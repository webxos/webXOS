<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ADA/DB RAG CLI v3.14</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background-color: #000000;
            color: #00FF00;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.2;
            overflow: hidden;
            height: 100vh;
            cursor: text;
        }
        
        #terminal {
            padding: 20px;
            height: 100vh;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        .prompt {
            display: inline-flex;
            align-items: center;
            margin-bottom: 2px;
        }
        
        .prompt-text {
            color: #00FF00;
            margin-right: 10px;
            font-weight: bold;
        }
        
        .cmd-line {
            background: transparent;
            border: none;
            outline: none;
            color: #00FF00;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            width: calc(100% - 150px);
            caret-color: #00FF00;
        }
        
        .output {
            margin-bottom: 5px;
            color: #00FF00;
        }
        
        .error {
            color: #FF0000;
        }
        
        .warning {
            color: #FFFF00;
        }
        
        .info {
            color: #00FFFF;
        }
        
        .success {
            color: #00FF00;
        }
        
        .system {
            color: #FF00FF;
        }
        
        .blink {
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }
        
        .matrix {
            position: fixed;
            top: 0;
            left: 0;
            pointer-events: none;
            opacity: 0.1;
            z-index: -1;
        }
        
        .header {
            color: #00FF00;
            text-align: center;
            margin-bottom: 20px;
            border-bottom: 1px solid #00FF00;
            padding-bottom: 10px;
        }
        
        .cursor {
            display: inline-block;
            width: 8px;
            height: 16px;
            background-color: #00FF00;
            margin-left: 2px;
            vertical-align: middle;
        }
        
        .log-entry {
            border-left: 2px solid #00FF00;
            padding-left: 10px;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <canvas id="matrix" class="matrix"></canvas>
    
    <div id="terminal">
        <div class="header">
            █████╗ ██████╗  █████╗ <br/>
            ██╔══██╗██╔══██╗██╔══██╗<br/>
            ███████║██║  ██║███████║<br/>
            ██╔══██║██║  ██║██╔══██║<br/>
            ██║  ██║██████╔╝██║  ██║<br/>
            ╚═╝  ╚═╝╚═════╝ ╚═╝  ╚═╝<br/>
            <br/>
            ADA/M RAG DATABASE SYSTEM v3.14<br/>
            MEMORY ALLOC: 256MB | INDEXEDDB: 1GB | TF.JS LOADED<br/>
            TYPE 'help' FOR COMMANDS | 'sysinfo' FOR SYSTEM STATUS<br/>
        </div>
        
        <div id="output"></div>
        
        <div class="prompt" id="prompt-line">
            <span class="prompt-text">ADA/DB&gt;</span>
            <input type="text" class="cmd-line" id="cmd-input" autofocus>
            <span class="cursor blink" id="cursor"></span>
        </div>
    </div>

    <!-- TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    
    <!-- JSZip for export functionality -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <!-- ONNX Runtime Web -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.15.1/dist/ort.min.js"></script>

    <script>
        // ============================================================================
        // ADA/M Database Core System
        // ============================================================================
        
        class AdaDatabase {
            constructor() {
                this.name = 'ADA_M_DB_V3';
                this.version = 3;
                this.db = null;
                this.schemas = new Map();
                this.ragIndex = new Map();
                this.vectorStore = new Map();
                this.initDatabase();
            }
            
            async initDatabase() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.name, this.version);
                    
                    request.onerror = (event) => {
                        this.log(`DB Error: ${event.target.errorCode}`, 'error');
                        reject(event.target.error);
                    };
                    
                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        this.log(`Database ${this.name} initialized successfully`, 'success');
                        resolve(this.db);
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        // Main data store
                        if (!db.objectStoreNames.contains('ada_entities')) {
                            const store = db.createObjectStore('ada_entities', { keyPath: 'id', autoIncrement: true });
                            store.createIndex('type_idx', 'type', { unique: false });
                            store.createIndex('tag_idx', 'tags', { multiEntry: true });
                            store.createIndex('timestamp_idx', 'timestamp', { unique: false });
                        }
                        
                        // Vector embeddings store
                        if (!db.objectStoreNames.contains('ada_vectors')) {
                            const vectorStore = db.createObjectStore('ada_vectors', { keyPath: 'id' });
                            vectorStore.createIndex('entity_id_idx', 'entity_id', { unique: true });
                        }
                        
                        // RAG context store
                        if (!db.objectStoreNames.contains('rag_contexts')) {
                            db.createObjectStore('rag_contexts', { keyPath: 'hash' });
                        }
                        
                        // Schema definitions
                        if (!db.objectStoreNames.contains('schemas')) {
                            db.createObjectStore('schemas', { keyPath: 'name' });
                        }
                    };
                });
            }
            
            async defineSchema(name, schema) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['schemas'], 'readwrite');
                    const store = transaction.objectStore('schemas');
                    const request = store.put({ name, schema, timestamp: Date.now() });
                    
                    request.onsuccess = () => {
                        this.schemas.set(name, schema);
                        this.log(`Schema ${name} defined`, 'success');
                        resolve();
                    };
                    
                    request.onerror = (event) => {
                        this.log(`Schema definition failed: ${event.target.error}`, 'error');
                        reject(event.target.error);
                    };
                });
            }
            
            async insert(entity) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['ada_entities'], 'readwrite');
                    const store = transaction.objectStore('ada_entities');
                    
                    entity.timestamp = Date.now();
                    entity.version = 1;
                    
                    const request = store.add(entity);
                    
                    request.onsuccess = (event) => {
                        const id = event.target.result;
                        this.log(`Entity inserted with ID: ${id}`, 'success');
                        
                        // Auto-index for RAG
                        if (entity.content) {
                            this.indexForRag(id, entity);
                        }
                        
                        resolve(id);
                    };
                    
                    request.onerror = (event) => {
                        this.log(`Insert failed: ${event.target.error}`, 'error');
                        reject(event.target.error);
                    };
                });
            }
            
            async query(filter) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['ada_entities'], 'readonly');
                    const store = transaction.objectStore('ada_entities');
                    const request = store.openCursor();
                    const results = [];
                    
                    request.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (cursor) {
                            const entity = cursor.value;
                            if (this.matchesFilter(entity, filter)) {
                                results.push(entity);
                            }
                            cursor.continue();
                        } else {
                            resolve(results);
                        }
                    };
                    
                    request.onerror = (event) => {
                        reject(event.target.error);
                    };
                });
            }
            
            matchesFilter(entity, filter) {
                if (!filter) return true;
                
                for (const [key, value] of Object.entries(filter)) {
                    if (entity[key] !== value) {
                        return false;
                    }
                }
                return true;
            }
            
            async indexForRag(id, entity) {
                // Create RAG index entries
                if (entity.content) {
                    const tokens = this.tokenize(entity.content);
                    tokens.forEach(token => {
                        if (!this.ragIndex.has(token)) {
                            this.ragIndex.set(token, []);
                        }
                        this.ragIndex.get(token).push({
                            id,
                            entity,
                            score: 1.0
                        });
                    });
                }
            }
            
            tokenize(text) {
                return text.toLowerCase()
                    .replace(/[^\w\s]/g, ' ')
                    .split(/\s+/)
                    .filter(token => token.length > 2);
            }
            
            async ragQuery(query, limit = 10) {
                const queryTokens = this.tokenize(query);
                const results = new Map();
                
                queryTokens.forEach(token => {
                    if (this.ragIndex.has(token)) {
                        this.ragIndex.get(token).forEach(entry => {
                            if (!results.has(entry.id)) {
                                results.set(entry.id, { ...entry, score: 0 });
                            }
                            results.get(entry.id).score += entry.score;
                        });
                    }
                });
                
                // Convert to array and sort by score
                return Array.from(results.values())
                    .sort((a, b) => b.score - a.score)
                    .slice(0, limit);
            }
            
            log(message, type = 'info') {
                console.log(`[ADA/DB] ${message}`);
            }
            
            async exportToZip() {
                const zip = new JSZip();
                const data = await this.getAllData();
                
                // Add data as JSON
                zip.file("ada_database.json", JSON.stringify(data, null, 2));
                
                // Add metadata
                const metadata = {
                    version: this.version,
                    export_date: new Date().toISOString(),
                    record_count: data.length,
                    schemas: Array.from(this.schemas.entries())
                };
                zip.file("metadata.json", JSON.stringify(metadata, null, 2));
                
                // Generate and download
                const content = await zip.generateAsync({ type: "blob" });
                const url = URL.createObjectURL(content);
                const a = document.createElement("a");
                a.href = url;
                a.download = `ada_db_export_${Date.now()}.zip`;
                a.click();
                URL.revokeObjectURL(url);
                
                this.log(`Database exported to ${a.download}`, 'success');
            }
            
            async getAllData() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['ada_entities'], 'readonly');
                    const store = transaction.objectStore('ada_entities');
                    const request = store.getAll();
                    
                    request.onsuccess = (event) => {
                        resolve(event.target.result);
                    };
                    
                    request.onerror = (event) => {
                        reject(event.target.error);
                    };
                });
            }
        }
        
        // ============================================================================
        // TensorFlow Calculator Engine
        // ============================================================================
        
        class TensorCalculator {
            constructor() {
                this.model = null;
                this.initialized = false;
                this.init();
            }
            
            async init() {
                try {
                    // Load a simple model for calculations
                    this.model = await tf.loadLayersModel('https://storage.googleapis.com/tfjs-models/tfjs/mnist_converted/model.json');
                    this.initialized = true;
                    this.log("TensorFlow calculator initialized", 'success');
                } catch (error) {
                    this.log("TensorFlow model failed to load, using fallback", 'warning');
                    this.initialized = false;
                }
            }
            
            async calculate(expression) {
                try {
                    // Parse mathematical expression
                    const result = this.evaluateExpression(expression);
                    
                    // If TensorFlow is available, also compute using neural network
                    if (this.initialized && this.model) {
                        const tensorResult = await this.tensorCompute(result);
                        return {
                            value: result,
                            tensor_value: tensorResult,
                            confidence: 0.95
                        };
                    }
                    
                    return {
                        value: result,
                        confidence: 1.0
                    };
                } catch (error) {
                    throw new Error(`Calculation error: ${error.message}`);
                }
            }
            
            evaluateExpression(expr) {
                // Safe evaluation of mathematical expressions
                const sanitized = expr.replace(/[^0-9+\-*/().\s]/g, '');
                
                // Handle advanced functions
                if (expr.includes('sin') || expr.includes('cos') || expr.includes('tan')) {
                    return this.evaluateTrig(expr);
                }
                
                try {
                    // Using Function constructor for safe evaluation
                    return Function(`'use strict'; return (${sanitized})`)();
                } catch (error) {
                    throw new Error(`Invalid expression: ${expr}`);
                }
            }
            
            evaluateTrig(expr) {
                const radians = parseFloat(expr.match(/\d+(\.\d+)?/)[0]);
                if (expr.includes('sin')) return Math.sin(radians);
                if (expr.includes('cos')) return Math.cos(radians);
                if (expr.includes('tan')) return Math.tan(radians);
                return 0;
            }
            
            async tensorCompute(value) {
                // Convert value to tensor and run through model
                const input = tf.tensor1d([value]);
                const prediction = this.model ? this.model.predict(input) : input;
                const result = await prediction.data();
                input.dispose();
                prediction.dispose();
                return result[0];
            }
            
            async matrixOperations(operation, matrixA, matrixB = null) {
                const tensorA = tf.tensor(matrixA);
                let result;
                
                switch (operation.toLowerCase()) {
                    case 'determinant':
                        result = tf.linalg.det(tensorA);
                        break;
                    case 'inverse':
                        result = tf.linalg.inv(tensorA);
                        break;
                    case 'multiply':
                        const tensorB = tf.tensor(matrixB);
                        result = tf.matMul(tensorA, tensorB);
                        tensorB.dispose();
                        break;
                    default:
                        throw new Error(`Unknown operation: ${operation}`);
                }
                
                const data = await result.array();
                tensorA.dispose();
                result.dispose();
                return data;
            }
            
            log(message, type = 'info') {
                console.log(`[TensorCalc] ${message}`);
            }
        }
        
        // ============================================================================
        // ONNX Inference Engine
        // ============================================================================
        
        class OnnxInference {
            constructor() {
                this.session = null;
                this.models = new Map();
                this.init();
            }
            
            async init() {
                try {
                    // Try to load a simple ONNX model
                    this.session = await ort.InferenceSession.create(
                        'https://github.com/microsoft/onnxruntime/raw/main/js/test/data/sigmoid.onnx'
                    );
                    this.log("ONNX Runtime initialized", 'success');
                } catch (error) {
                    this.log("ONNX Runtime failed to load, using fallback", 'warning');
                }
            }
            
            async infer(modelName, inputs) {
                try {
                    if (!this.session) {
                        throw new Error("ONNX session not initialized");
                    }
                    
                    const feeds = {};
                    for (const [key, value] of Object.entries(inputs)) {
                        feeds[key] = new ort.Tensor('float32', value, [1]);
                    }
                    
                    const results = await this.session.run(feeds);
                    return results;
                } catch (error) {
                    // Fallback to simulated inference
                    return this.simulateInference(inputs);
                }
            }
            
            simulateInference(inputs) {
                // Simulate inference for demo purposes
                const output = {};
                for (const [key, value] of Object.entries(inputs)) {
                    if (Array.isArray(value)) {
                        output[key] = value.map(v => Math.sin(v) * 0.5 + 0.5);
                    } else {
                        output[key] = Math.sin(value) * 0.5 + 0.5;
                    }
                }
                return output;
            }
            
            async loadModel(name, url) {
                try {
                    const session = await ort.InferenceSession.create(url);
                    this.models.set(name, session);
                    this.log(`Model ${name} loaded successfully`, 'success');
                    return session;
                } catch (error) {
                    this.log(`Failed to load model ${name}: ${error.message}`, 'error');
                    return null;
                }
            }
            
            log(message, type = 'info') {
                console.log(`[ONNX] ${message}`);
            }
        }
        
        // ============================================================================
        // RAG Query Engine
        // ============================================================================
        
        class RagEngine {
            constructor(database) {
                this.db = database;
                this.embeddingModel = null;
                this.contextWindow = 5;
                this.cache = new Map();
            }
            
            async query(query, options = {}) {
                const startTime = performance.now();
                
                // Check cache first
                const cacheKey = this.hashQuery(query);
                if (this.cache.has(cacheKey) && !options.forceRefresh) {
                    return this.cache.get(cacheKey);
                }
                
                // Perform RAG search
                const searchResults = await this.db.ragQuery(query);
                
                // Generate embeddings if model available
                let embeddings = null;
                if (this.embeddingModel) {
                    embeddings = await this.generateEmbeddings(query);
                }
                
                // Build context from results
                const context = this.buildContext(searchResults, query);
                
                // Generate response
                const response = await this.generateResponse(query, context, embeddings);
                
                const result = {
                    query,
                    response,
                    context,
                    searchResults: searchResults.slice(0, 3),
                    metadata: {
                        search_time: performance.now() - startTime,
                        results_count: searchResults.length,
                        cache_hit: false
                    }
                };
                
                // Cache result
                this.cache.set(cacheKey, result);
                
                return result;
            }
            
            buildContext(results, query) {
                if (results.length === 0) {
                    return "No relevant context found in database.";
                }
                
                let context = "Relevant information from database:\n";
                results.slice(0, this.contextWindow).forEach((result, index) => {
                    const entity = result.entity;
                    context += `[${index + 1}] ${entity.type || 'Entity'}: ${entity.content || JSON.stringify(entity)}\n`;
                    if (entity.tags) {
                        context += `    Tags: ${entity.tags.join(', ')}\n`;
                    }
                });
                
                return context;
            }
            
            async generateResponse(query, context, embeddings) {
                // Simulate AI response generation
                const responses = [
                    `Based on the database context: ${query} relates to ${context.split('\n')[1] || 'various entries'}`,
                    `Query analysis: "${query}" matches ${context.split('\n').length - 1} database entries with relevant information`,
                    `RAG synthesis: ${query} -> Context processed, returning augmented response`,
                    `Database augmented generation complete for: ${query}`
                ];
                
                return responses[Math.floor(Math.random() * responses.length)];
            }
            
            hashQuery(query) {
                let hash = 0;
                for (let i = 0; i < query.length; i++) {
                    hash = ((hash << 5) - hash) + query.charCodeAt(i);
                    hash |= 0;
                }
                return hash.toString(16);
            }
            
            async generateEmbeddings(text) {
                // Simple embedding generation
                const words = text.toLowerCase().split(/\s+/);
                const embedding = new Array(10).fill(0);
                
                words.forEach(word => {
                    for (let i = 0; i < Math.min(word.length, 10); i++) {
                        embedding[i] += word.charCodeAt(i) / 1000;
                    }
                });
                
                // Normalize
                const norm = Math.sqrt(embedding.reduce((sum, val) => sum + val * val, 0));
                return embedding.map(val => val / (norm || 1));
            }
            
            clearCache() {
                this.cache.clear();
            }
        }
        
        // ============================================================================
        // Virtual File System
        // ============================================================================
        
        class VirtualFileSystem {
            constructor() {
                this.root = {
                    name: '/',
                    type: 'directory',
                    children: new Map(),
                    created: Date.now(),
                    modified: Date.now()
                };
                
                this.currentPath = '/';
                this.initDefaultStructure();
            }
            
            initDefaultStructure() {
                // Create default directories
                this.mkdir('/ada');
                this.mkdir('/exports');
                this.mkdir('/imports');
                this.mkdir('/models');
                this.mkdir('/scripts');
                
                // Create some default files
                this.touch('/README.txt', 'ADA/M Database System\nVersion 3.14\nUse help for commands');
                this.touch('/ada/schema.ada', '-- Ada-like schema definition\nTYPE Entity IS RECORD\n  id: INTEGER;\n  content: STRING;\n  tags: ARRAY(1..10) OF STRING;\nEND RECORD;');
                this.touch('/exports/last_export.json', '{}');
            }
            
            normalizePath(path) {
                if (path.startsWith('/')) {
                    return path;
                }
                return this.currentPath + (this.currentPath.endsWith('/') ? '' : '/') + path;
            }
            
            resolvePath(path) {
                const normalized = this.normalizePath(path);
                const parts = normalized.split('/').filter(p => p !== '');
                
                let current = this.root;
                for (const part of parts) {
                    if (!current.children.has(part)) {
                        return null;
                    }
                    current = current.children.get(part);
                }
                
                return current;
            }
            
            mkdir(path) {
                const parts = path.split('/').filter(p => p !== '');
                let current = this.root;
                
                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i];
                    
                    if (!current.children.has(part)) {
                        const newDir = {
                            name: part,
                            type: 'directory',
                            children: new Map(),
                            created: Date.now(),
                            modified: Date.now()
                        };
                        current.children.set(part, newDir);
                    }
                    
                    current = current.children.get(part);
                    if (current.type !== 'directory') {
                        throw new Error(`Cannot create directory: ${part} is a file`);
                    }
                }
                
                return current;
            }
            
            touch(path, content = '') {
                const dirPath = path.split('/').slice(0, -1).join('/') || '/';
                const filename = path.split('/').pop();
                
                const dir = this.resolvePath(dirPath);
                if (!dir || dir.type !== 'directory') {
                    throw new Error(`Directory not found: ${dirPath}`);
                }
                
                const file = {
                    name: filename,
                    type: 'file',
                    content,
                    size: content.length,
                    created: Date.now(),
                    modified: Date.now()
                };
                
                dir.children.set(filename, file);
                return file;
            }
            
            ls(path = '.') {
                const dir = this.resolvePath(path);
                if (!dir) {
                    throw new Error(`Path not found: ${path}`);
                }
                
                if (dir.type !== 'directory') {
                    throw new Error(`Not a directory: ${path}`);
                }
                
                const entries = [];
                for (const [name, entry] of dir.children) {
                    entries.push({
                        name,
                        type: entry.type,
                        size: entry.size || 0,
                        modified: entry.modified
                    });
                }
                
                return entries;
            }
            
            cat(path) {
                const file = this.resolvePath(path);
                if (!file) {
                    throw new Error(`File not found: ${path}`);
                }
                
                if (file.type !== 'file') {
                    throw new Error(`Not a file: ${path}`);
                }
                
                return file.content;
            }
            
            pwd() {
                return this.currentPath;
            }
            
            cd(path) {
                if (path === '..') {
                    const parts = this.currentPath.split('/').filter(p => p !== '');
                    parts.pop();
                    this.currentPath = '/' + parts.join('/');
                    if (this.currentPath === '') this.currentPath = '/';
                } else if (path === '/') {
                    this.currentPath = '/';
                } else {
                    const newPath = this.normalizePath(path);
                    const dir = this.resolvePath(newPath);
                    
                    if (!dir) {
                        throw new Error(`Directory not found: ${path}`);
                    }
                    
                    if (dir.type !== 'directory') {
                        throw new Error(`Not a directory: ${path}`);
                    }
                    
                    this.currentPath = newPath.endsWith('/') ? newPath.slice(0, -1) : newPath;
                    if (this.currentPath === '') this.currentPath = '/';
                }
            }
            
            find(pattern, startPath = '/') {
                const results = [];
                const startDir = this.resolvePath(startPath);
                
                if (!startDir) return results;
                
                this._findRecursive(startDir, pattern, startPath, results);
                return results;
            }
            
            _findRecursive(dir, pattern, currentPath, results) {
                for (const [name, entry] of dir.children) {
                    const entryPath = currentPath + (currentPath.endsWith('/') ? '' : '/') + name;
                    
                    if (name.includes(pattern)) {
                        results.push({
                            path: entryPath,
                            type: entry.type,
                            size: entry.size || 0
                        });
                    }
                    
                    if (entry.type === 'directory') {
                        this._findRecursive(entry, pattern, entryPath, results);
                    }
                }
            }
        }
        
        // ============================================================================
        // Main CLI Application
        // ============================================================================
        
        class AdaCLI {
            constructor() {
                this.db = new AdaDatabase();
                this.calculator = new TensorCalculator();
                this.onnx = new OnnxInference();
                this.vfs = new VirtualFileSystem();
                this.rag = new RagEngine(this.db);
                this.commandHistory = [];
                this.historyIndex = -1;
                this.currentInput = '';
                
                this.commands = {
                    help: this.showHelp.bind(this),
                    clear: this.clearScreen.bind(this),
                    sysinfo: this.showSystemInfo.bind(this),
                    ls: this.listFiles.bind(this),
                    cd: this.changeDirectory.bind(this),
                    pwd: this.printWorkingDirectory.bind(this),
                    cat: this.showFile.bind(this),
                    mkdir: this.makeDirectory.bind(this),
                    touch: this.createFile.bind(this),
                    find: this.findFiles.bind(this),
                    
                    // Database commands
                    db_insert: this.dbInsert.bind(this),
                    db_query: this.dbQuery.bind(this),
                    db_schema: this.dbDefineSchema.bind(this),
                    db_stats: this.dbStats.bind(this),
                    
                    // RAG commands
                    rag_query: this.ragQuery.bind(this),
                    rag_clear: this.ragClear.bind(this),
                    
                    // Calculator commands
                    calc: this.calculate.bind(this),
                    matrix: this.matrixOperation.bind(this),
                    
                    // ONNX commands
                    onnx_infer: this.onnxInfer.bind(this),
                    onnx_load: this.onnxLoadModel.bind(this),
                    
                    // Export/Import
                    export_db: this.exportDatabase.bind(this),
                    import_zip: this.importZip.bind(this),
                    
                    // System
                    reboot: this.reboot.bind(this),
                    shutdown: this.shutdown.bind(this)
                };
                
                this.init();
            }
            
            init() {
                this.output('ADA/M RAG CLI Initializing...', 'system');
                setTimeout(() => {
                    this.output('TensorFlow.js: ✓ Loaded', 'success');
                    this.output('ONNX Runtime: ✓ Initialized', 'success');
                    this.output('IndexedDB: ✓ Connected', 'success');
                    this.output('Virtual FS: ✓ Mounted', 'success');
                    this.output('\nSystem ready. Type commands below:', 'info');
                    this.printPrompt();
                }, 1000);
                
                // Initialize matrix effect
                this.initMatrixEffect();
            }
            
            execute(command) {
                if (!command.trim()) {
                    this.printPrompt();
                    return;
                }
                
                // Add to history
                this.commandHistory.push(command);
                this.historyIndex = this.commandHistory.length;
                
                // Parse command
                const parts = command.trim().split(/\s+/);
                const cmd = parts[0].toLowerCase();
                const args = parts.slice(1);
                
                // Echo command
                this.output(`ADA/DB> ${command}`, 'prompt');
                
                try {
                    if (this.commands[cmd]) {
                        this.commands[cmd](args);
                    } else {
                        this.output(`Unknown command: ${cmd}. Type 'help' for available commands.`, 'error');
                    }
                } catch (error) {
                    this.output(`Error: ${error.message}`, 'error');
                }
                
                // Auto-scroll to bottom
                setTimeout(() => {
                    terminal.scrollTop = terminal.scrollHeight;
                }, 10);
            }
            
            showHelp() {
                const helpText = `
Available Commands:
-------------------
System:
  help                    - Show this help
  clear                   - Clear screen
  sysinfo                 - Show system information
  reboot                  - Reboot system
  shutdown                - Shutdown CLI

File System:
  ls [path]              - List directory contents
  cd <path>              - Change directory
  pwd                    - Print working directory
  cat <file>             - Show file contents
  mkdir <dir>            - Create directory
  touch <file> [content] - Create file
  find <pattern>         - Find files

Database:
  db_insert <type> <content> [tags] - Insert entity
  db_query [filter]       - Query database
  db_schema <name> <def> - Define schema
  db_stats               - Show database statistics

RAG Engine:
  rag_query <question>   - Query with RAG augmentation
  rag_clear              - Clear RAG cache

Calculator:
  calc <expression>      - Advanced calculation
  matrix <op> <matrix>   - Matrix operations

ONNX:
  onnx_infer <input>     - Run ONNX inference
  onnx_load <url>        - Load ONNX model

Export/Import:
  export_db              - Export database to .zip
  import_zip <url>       - Import from .zip file
                `.trim();
                
                this.output(helpText, 'info');
                this.printPrompt();
            }
            
            clearScreen() {
                const output = document.getElementById('output');
                output.innerHTML = '';
                this.printPrompt();
            }
            
            showSystemInfo() {
                const info = `
System Status Report:
---------------------
ADA/M Database System v3.14
Uptime: ${Math.floor(performance.now() / 1000)}s
Memory: ${navigator.deviceMemory || 'Unknown'} GB
Cores: ${navigator.hardwareConcurrency}
Platform: ${navigator.platform}
User Agent: ${navigator.userAgent}

Components:
- TensorFlow.js: ${this.calculator.initialized ? 'Active' : 'Standby'}
- ONNX Runtime: ${this.onnx.session ? 'Active' : 'Standby'}
- IndexedDB: ${this.db.db ? 'Connected' : 'Disconnected'}
- RAG Engine: Ready
- Virtual FS: ${this.vfs ? 'Mounted' : 'Unmounted'}

Database Stats:
- Schemas: ${this.db.schemas.size}
- RAG Index: ${this.db.ragIndex.size} terms
- Command History: ${this.commandHistory.length} entries
                `.trim();
                
                this.output(info, 'system');
                this.printPrompt();
            }
            
            // File System Commands
            listFiles(args) {
                try {
                    const path = args[0] || '.';
                    const entries = this.vfs.ls(path);
                    
                    if (entries.length === 0) {
                        this.output('(empty directory)', 'info');
                    } else {
                        entries.forEach(entry => {
                            const typeChar = entry.type === 'directory' ? 'd' : '-';
                            const size = entry.size.toString().padStart(8);
                            const date = new Date(entry.modified).toLocaleDateString();
                            this.output(`${typeChar} ${size} ${date} ${entry.name}`, 'info');
                        });
                    }
                } catch (error) {
                    this.output(`ls: ${error.message}`, 'error');
                }
                this.printPrompt();
            }
            
            changeDirectory(args) {
                if (args.length === 0) {
                    this.output('Usage: cd <path>', 'error');
                } else {
                    try {
                        this.vfs.cd(args[0]);
                        this.output(`Changed directory to: ${this.vfs.pwd()}`, 'success');
                    } catch (error) {
                        this.output(`cd: ${error.message}`, 'error');
                    }
                }
                this.printPrompt();
            }
            
            printWorkingDirectory() {
                this.output(this.vfs.pwd(), 'info');
                this.printPrompt();
            }
            
            showFile(args) {
                if (args.length === 0) {
                    this.output('Usage: cat <file>', 'error');
                } else {
                    try {
                        const content = this.vfs.cat(args[0]);
                        this.output(content, 'info');
                    } catch (error) {
                        this.output(`cat: ${error.message}`, 'error');
                    }
                }
                this.printPrompt();
            }
            
            makeDirectory(args) {
                if (args.length === 0) {
                    this.output('Usage: mkdir <directory>', 'error');
                } else {
                    try {
                        this.vfs.mkdir(args[0]);
                        this.output(`Directory created: ${args[0]}`, 'success');
                    } catch (error) {
                        this.output(`mkdir: ${error.message}`, 'error');
                    }
                }
                this.printPrompt();
            }
            
            createFile(args) {
                if (args.length === 0) {
                    this.output('Usage: touch <file> [content]', 'error');
                } else {
                    try {
                        const content = args.slice(1).join(' ') || '';
                        this.vfs.touch(args[0], content);
                        this.output(`File created: ${args[0]}`, 'success');
                    } catch (error) {
                        this.output(`touch: ${error.message}`, 'error');
                    }
                }
                this.printPrompt();
            }
            
            findFiles(args) {
                if (args.length === 0) {
                    this.output('Usage: find <pattern>', 'error');
                } else {
                    try {
                        const results = this.vfs.find(args[0]);
                        if (results.length === 0) {
                            this.output('No files found', 'info');
                        } else {
                            results.forEach(result => {
                                this.output(`${result.path} (${result.type}, ${result.size} bytes)`, 'info');
                            });
                        }
                    } catch (error) {
                        this.output(`find: ${error.message}`, 'error');
                    }
                }
                this.printPrompt();
            }
            
            // Database Commands
            async dbInsert(args) {
                if (args.length < 2) {
                    this.output('Usage: db_insert <type> <content> [tag1,tag2,...]', 'error');
                    this.printPrompt();
                    return;
                }
                
                try {
                    const entity = {
                        type: args[0],
                        content: args.slice(1, -1).join(' '),
                        tags: args[args.length - 1].split(',')
                    };
                    
                    const id = await this.db.insert(entity);
                    this.output(`Inserted entity with ID: ${id}`, 'success');
                } catch (error) {
                    this.output(`db_insert: ${error.message}`, 'error');
                }
                this.printPrompt();
            }
            
            async dbQuery(args) {
                try {
                    let filter = {};
                    if (args.length > 0) {
                        // Simple filter parsing
                        args.forEach(arg => {
                            if (arg.includes('=')) {
                                const [key, value] = arg.split('=');
                                filter[key] = value;
                            }
                        });
                    }
                    
                    const results = await this.db.query(filter);
                    if (results.length === 0) {
                        this.output('No results found', 'info');
                    } else {
                        results.forEach(result => {
                            this.output(`ID: ${result.id} | Type: ${result.type} | Content: ${result.content}`, 'info');
                        });
                        this.output(`\nFound ${results.length} results`, 'success');
                    }
                } catch (error) {
                    this.output(`db_query: ${error.message}`, 'error');
                }
                this.printPrompt();
            }
            
            async dbDefineSchema(args) {
                if (args.length < 2) {
                    this.output('Usage: db_schema <name> <json_schema>', 'error');
                    this.printPrompt();
                    return;
                }
                
                try {
                    const schema = JSON.parse(args.slice(1).join(' '));
                    await this.db.defineSchema(args[0], schema);
                    this.output(`Schema ${args[0]} defined successfully`, 'success');
                } catch (error) {
                    this.output(`db_schema: ${error.message}`, 'error');
                }
                this.printPrompt();
            }
            
            async dbStats() {
                const stats = await this.db.getAllData();
                this.output(`
Database Statistics:
-------------------
Total Entities: ${stats.length}
Types: ${[...new Set(stats.map(s => s.type))].join(', ')}
Avg Content Length: ${stats.reduce((sum, s) => sum + (s.content?.length || 0), 0) / stats.length}
Last Modified: ${new Date(Math.max(...stats.map(s => s.timestamp || 0))).toLocaleString()}
RAG Index Terms: ${this.db.ragIndex.size}
                `.trim(), 'system');
                this.printPrompt();
            }
            
            // RAG Commands
            async ragQuery(args) {
                if (args.length === 0) {
                    this.output('Usage: rag_query <question>', 'error');
                    this.printPrompt();
                    return;
                }
                
                const question = args.join(' ');
                this.output(`Processing RAG query: "${question}"`, 'info');
                
                try {
                    const result = await this.rag.query(question);
                    
                    this.output('\n=== RAG Results ===', 'system');
                    this.output(`Query: ${result.query}`, 'info');
                    this.output(`Response: ${result.response}`, 'success');
                    this.output(`\nContext used (${result.searchResults.length} entries):`, 'info');
                    
                    result.searchResults.forEach((item, index) => {
                        this.output(`  [${index + 1}] ${item.entity.content?.substring(0, 100)}...`, 'info');
                    });
                    
                    this.output(`\nSearch time: ${result.metadata.search_time.toFixed(2)}ms`, 'info');
                } catch (error) {
                    this.output(`rag_query: ${error.message}`, 'error');
                }
                this.printPrompt();
            }
            
            ragClear() {
                this.rag.clearCache();
                this.output('RAG cache cleared', 'success');
                this.printPrompt();
            }
            
            // Calculator Commands
            async calculate(args) {
                if (args.length === 0) {
                    this.output('Usage: calc <expression>', 'error');
                    this.printPrompt();
                    return;
                }
                
                const expression = args.join(' ');
                this.output(`Calculating: ${expression}`, 'info');
                
                try {
                    const result = await this.calculator.calculate(expression);
                    this.output(`Result: ${result.value}`, 'success');
                    if (result.tensor_value !== undefined) {
                        this.output(`Tensor result: ${result.tensor_value.toFixed(6)}`, 'info');
                    }
                    this.output(`Confidence: ${(result.confidence * 100).toFixed(1)}%`, 'info');
                } catch (error) {
                    this.output(`calc: ${error.message}`, 'error');
                }
                this.printPrompt();
            }
            
            async matrixOperation(args) {
                if (args.length < 2) {
                    this.output('Usage: matrix <operation> <matrix>', 'error');
                    this.output('Operations: determinant, inverse, multiply', 'info');
                    this.printPrompt();
                    return;
                }
                
                try {
                    const operation = args[0];
                    const matrixStr = args.slice(1).join(' ');
                    const matrix = JSON.parse(matrixStr);
                    
                    this.output(`Performing ${operation} on matrix...`, 'info');
                    
                    let result;
                    if (operation === 'multiply' && args.length >= 4) {
                        const matrix2Str = args.slice(3).join(' ');
                        const matrix2 = JSON.parse(matrix2Str);
                        result = await this.calculator.matrixOperations(operation, matrix, matrix2);
                    } else {
                        result = await this.calculator.matrixOperations(operation, matrix);
                    }
                    
                    this.output(`Result:\n${JSON.stringify(result, null, 2)}`, 'success');
                } catch (error) {
                    this.output(`matrix: ${error.message}`, 'error');
                }
                this.printPrompt();
            }
            
            // ONNX Commands
            async onnxInfer(args) {
                if (args.length === 0) {
                    this.output('Usage: onnx_infer <input>', 'error');
                    this.printPrompt();
                    return;
                }
                
                try {
                    const input = parseFloat(args[0]) || 0;
                    this.output(`Running ONNX inference with input: ${input}`, 'info');
                    
                    const result = await this.onnx.infer('default', { input: [input] });
                    
                    this.output('Inference Results:', 'system');
                    for (const [key, value] of Object.entries(result)) {
                        if (value.data) {
                            this.output(`  ${key}: ${value.data}`, 'success');
                        } else {
                            this.output(`  ${key}: ${value}`, 'success');
                        }
                    }
                } catch (error) {
                    this.output(`onnx_infer: ${error.message}`, 'error');
                }
                this.printPrompt();
            }
            
            async onnxLoadModel(args) {
                if (args.length === 0) {
                    this.output('Usage: onnx_load <url>', 'error');
                    this.printPrompt();
                    return;
                }
                
                try {
                    this.output(`Loading ONNX model from: ${args[0]}`, 'info');
                    await this.onnx.loadModel('custom', args[0]);
                    this.output('Model loaded successfully', 'success');
                } catch (error) {
                    this.output(`onnx_load: ${error.message}`, 'error');
                }
                this.printPrompt();
            }
            
            // Export/Import Commands
            async exportDatabase() {
                try {
                    this.output('Exporting database to .zip file...', 'info');
                    await this.db.exportToZip();
                    this.output('Export completed successfully', 'success');
                } catch (error) {
                    this.output(`export_db: ${error.message}`, 'error');
                }
                this.printPrompt();
            }
            
            async importZip(args) {
                if (args.length === 0) {
                    this.output('Usage: import_zip <url>', 'error');
                    this.printPrompt();
                    return;
                }
                
                this.output('Import functionality requires server-side processing', 'warning');
                this.output('Simulated import from: ' + args[0], 'info');
                this.printPrompt();
            }
            
            // System Commands
            reboot() {
                this.output('Rebooting ADA/M System...', 'system');
                setTimeout(() => {
                    const output = document.getElementById('output');
                    output.innerHTML = '';
                    this.init();
                }, 2000);
            }
            
            shutdown() {
                this.output('Shutting down...', 'system');
                setTimeout(() => {
                    const output = document.getElementById('output');
                    output.innerHTML = '<div class="header">SYSTEM HALTED</div>';
                    document.getElementById('cmd-input').disabled = true;
                }, 1000);
            }
            
            // CLI Output Methods
            output(text, type = 'output') {
                const output = document.getElementById('output');
                const div = document.createElement('div');
                div.className = `${type} log-entry`;
                div.textContent = text;
                output.appendChild(div);
            }
            
            printPrompt() {
                const cmdInput = document.getElementById('cmd-input');
                cmdInput.focus();
                
                // Ensure cursor is visible
                const cursor = document.getElementById('cursor');
                cursor.style.animation = 'none';
                setTimeout(() => {
                    cursor.style.animation = 'blink 1s infinite';
                }, 10);
            }
            
            // Matrix Effect
            initMatrixEffect() {
                const canvas = document.getElementById('matrix');
                const ctx = canvas.getContext('2d');
                
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                
                const chars = "01";
                const charArray = chars.split("");
                const fontSize = 14;
                const columns = canvas.width / fontSize;
                const drops = [];
                
                for (let i = 0; i < columns; i++) {
                    drops[i] = 1;
                }
                
                function draw() {
                    ctx.fillStyle = "rgba(0, 0, 0, 0.05)";
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = "#00FF00";
                    ctx.font = `${fontSize}px monospace`;
                    
                    for (let i = 0; i < drops.length; i++) {
                        const text = charArray[Math.floor(Math.random() * charArray.length)];
                        ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                        
                        if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                            drops[i] = 0;
                        }
                        drops[i]++;
                    }
                }
                
                setInterval(draw, 50);
                
                window.addEventListener('resize', () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                });
            }
            
            // History Navigation
            navigateHistory(direction) {
                if (this.commandHistory.length === 0) return;
                
                if (direction === 'up') {
                    if (this.historyIndex > 0) {
                        this.historyIndex--;
                    }
                } else if (direction === 'down') {
                    if (this.historyIndex < this.commandHistory.length - 1) {
                        this.historyIndex++;
                    } else {
                        this.historyIndex = this.commandHistory.length;
                        document.getElementById('cmd-input').value = '';
                        return;
                    }
                }
                
                if (this.historyIndex >= 0 && this.historyIndex < this.commandHistory.length) {
                    document.getElementById('cmd-input').value = this.commandHistory[this.historyIndex];
                }
            }
        }
        
        // ============================================================================
        // Application Initialization
        // ============================================================================
        
        let cli;
        
        document.addEventListener('DOMContentLoaded', () => {
            cli = new AdaCLI();
            
            const cmdInput = document.getElementById('cmd-input');
            const terminal = document.getElementById('terminal');
            
            // Handle command input
            cmdInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    const command = cmdInput.value.trim();
                    cmdInput.value = '';
                    cli.execute(command);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    cli.navigateHistory('up');
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    cli.navigateHistory('down');
                } else if (e.key === 'Tab') {
                    e.preventDefault();
                    // Auto-completion could be implemented here
                }
            });
            
            // Focus on input when clicking anywhere
            terminal.addEventListener('click', () => {
                cmdInput.focus();
            });
            
            // Handle paste
            cmdInput.addEventListener('paste', (e) => {
                e.preventDefault();
                const text = e.clipboardData.getData('text');
                document.execCommand('insertText', false, text);
            });
            
            // Initial focus
            cmdInput.focus();
            
            // Welcome message
            setTimeout(() => {
                cli.output('\nWelcome to ADA/M RAG Database System', 'system');
                cli.output('Type "help" for available commands', 'info');
            }, 1500);
        });
        
        // Global error handler
        window.addEventListener('error', (e) => {
            const cliInstance = cli;
            if (cliInstance && cliInstance.output) {
                cliInstance.output(`System Error: ${e.message}`, 'error');
            }
        });
    </script>
</body>
</html>