<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>edTV:3</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <style>
    * { box-sizing: border-box }
    html, body { margin:0; height:100%; background:#0a0a0a; color:#fff; font-family:Segoe UI, Tahoma, sans-serif }
    #app { position:relative; width:100%; height:100% }
    canvas#three { position:absolute; inset:0; width:100%; height:100% }
    .panel {
      position:absolute; left:50%; bottom:14px; transform:translateX(-50%);
      display:flex; flex-direction:column; gap:8px; width:95%; max-width:520px;
      background:rgba(0,0,0,.82); border:1px solid rgba(255,80,80,.5); border-radius:14px;
      padding:12px; backdrop-filter:blur(10px); box-shadow:0 0 18px rgba(255,0,0,.25);
      z-index:10;
    }
    .title { text-align:center; font-weight:600; color:#ff4444; text-shadow:0 0 10px rgba(255,50,50,.6) }
    .row { display:flex; gap:8px; flex-wrap:wrap }
    button, input[type="range"] {
      appearance:none; border-radius:999px; border:1px solid #ff4444; background:rgba(255,50,50,.25);
      color:#fff; padding:8px 12px; font-size:.85rem; cursor:pointer; transition:.2s; flex:1; min-width:120px;
    }
    button:hover { background:rgba(255,50,50,.45) }
    button:disabled { background:rgba(120,120,120,.25); border-color:#666; color:#999; cursor:not-allowed }
    .label { font-size:.75rem; color:#ccc; min-width:140px }
    .sliderRow { display:flex; align-items:center; gap:10px }
    .status { text-align:center; font-size:.75rem; color:#aaa }
    @media (max-width:768px) {
      .panel { width:98%; padding:10px }
      button { min-width:100px; font-size:.8rem; padding:7px 10px }
      .label { min-width:120px }
    }
  </style>
</head>
<body>
<div id="app">
  <canvas id="three"></canvas>

  <div class="panel">
    <div class="title">edTV:3</div>

    <div class="row">
      <button id="startBtn">Start</button>
      <button id="stopBtn" disabled>Stop</button>
      <button id="switchCamBtn">Switch cam</button>
      <button id="clearBtn">Clear map</button>
    </div>

    <div class="sliderRow">
      <div class="label">Frames:</div>
      <input id="cadence" type="range" min="1" max="15" step="1" value="5" />
    </div>

    <div class="sliderRow">
      <div class="label">Point size:</div>
      <input id="ptSize" type="range" min="0.2" max="2.5" step="0.1" value="0.9" />
    </div>

    <div class="sliderRow">
      <div class="label">Glow:</div>
      <input id="glow" type="range" min="1" max="20" step="1" value="8" />
    </div>

    <div class="status" id="status">Ready.</div>
  </div>
</div>

<script type="module">
  import * as THREE from "https://unpkg.com/three@0.158.0/build/three.module.js";
  import { OrbitControls } from "https://unpkg.com/three@0.158.0/examples/jsm/controls/OrbitControls.js";

  // DOM refs
  const canvas = document.getElementById("three");
  const statusEl = document.getElementById("status");
  const startBtn = document.getElementById("startBtn");
  const stopBtn = document.getElementById("stopBtn");
  const switchCamBtn = document.getElementById("switchCamBtn");
  const clearBtn = document.getElementById("clearBtn");
  const cadenceEl = document.getElementById("cadence");
  const ptSizeEl = document.getElementById("ptSize");
  const glowEl = document.getElementById("glow");

  // Status early
  const status = (msg) => { statusEl.textContent = msg; };

  // Three setup
  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.setSize(innerWidth, innerHeight);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x070707);

  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.05, 2000);
  camera.position.set(0, 2.5, 12);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.rotateSpeed = 0.8;
  controls.zoomSpeed = 0.7;
  controls.panSpeed = 0.7;

  const grid = new THREE.GridHelper(40, 40, 0x662222, 0x331111);
  grid.position.y = -4;
  scene.add(grid);

  const hemi = new THREE.HemisphereLight(0xddddff, 0x221111, 0.6);
  scene.add(hemi);

  // Central mono figure marker (user anchor)
  const centralMarkerGeom = new THREE.SphereGeometry(0.15, 16, 12);
  const centralMarkerMat  = new THREE.MeshBasicMaterial({ color: 0xffffff });
  const centralMarker     = new THREE.Mesh(centralMarkerGeom, centralMarkerMat);
  centralMarker.position.set(0, 0, 0);
  scene.add(centralMarker);

  // Points: chunked meshes to avoid massive buffer reallocations
  const pointChunks = [];
  const pointSizeRef = { value: parseFloat(ptSizeEl.value) };
  function makePointsChunk(positions, colors) {
    const geom = new THREE.BufferGeometry();
    geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));
    geom.setAttribute("color",    new THREE.BufferAttribute(colors, 3));
    geom.computeBoundingSphere();
    const mat = new THREE.PointsMaterial({
      size: pointSizeRef.value,
      vertexColors: true,
      transparent: true,
      opacity: 0.95,
      sizeAttenuation: true
    });
    const pts = new THREE.Points(geom, mat);
    pointChunks.push(pts);
    scene.add(pts);
  }
  function updateAllChunkSizes() {
    pointSizeRef.value = parseFloat(ptSizeEl.value);
    for (const chunk of pointChunks) chunk.material.size = pointSizeRef.value;
  }
  ptSizeEl.addEventListener("input", updateAllChunkSizes);

  // Capture pipeline
  const PROC_W = 500, PROC_H = 500;
  let stream = null;
  let video = null;
  let procCanvas = null, procCtx = null;
  let prevFrame = null;
  let frameCount = 0;
  let isRunning = false;
  let facingMode = "environment";

  // Pose & IMU
  let deviceQuat = new THREE.Quaternion();
  let worldPose  = new THREE.Object3D();
  scene.add(worldPose);
  let hasIMU = false;

  // Flow approximation
  const flow = { dx:0, dy:0 };
  const FLOW_SCALE = 0.02;

  // Device orientation: feature-detected; no deprecated requestPermission path
  window.addEventListener("deviceorientation", (e) => {
    if (e && e.alpha !== null && e.beta !== null && e.gamma !== null) {
      hasIMU = true;
      const alpha = (e.alpha||0) * Math.PI/180; // z
      const beta  = (e.beta ||0) * Math.PI/180; // x
      const gamma = (e.gamma||0) * Math.PI/180; // y
      const ea = new THREE.Euler(beta, alpha, -gamma, "ZXY");
      deviceQuat.setFromEuler(ea);
    }
  }, { passive:true });

  // Thermal color mapping
  function thermalColor(br) {
    let r, g, b;
    if (br < 0.2) { r = br*2.5; g = 0; b = 0; }
    else if (br < 0.5) { r = 0.5 + (br-0.2)*1.67; g = 0; b = 0; }
    else if (br < 0.8) { r = 1.0; g = (br-0.5)*3.33; b = 0; }
    else { r = 1.0; g = 1.0; b = (br-0.8)*5.0; }
    return [r,g,b];
  }

  // Full-res diff mask & flow (keyframe only). Lower threshold + true luminance
  function computeFlowAndMask(data, w, h) {
    if (!prevFrame) prevFrame = new Uint8ClampedArray(data.length);
    let sumX = 0, sumY = 0, sumW = 0;
    const mask = new Uint8Array(w*h);
    const stride = 4;
    const thr = 12;

    for (let y=0; y<h; y++) {
      for (let x=0; x<w; x++) {
        const i = (y*w + x) * stride;
        const L  = 0.299*data[i] + 0.587*data[i+1] + 0.114*data[i+2];
        const Lp = 0.299*prevFrame[i] + 0.587*prevFrame[i+1] + 0.114*prevFrame[i+2];
        const d  = Math.abs(L - Lp);
        if (d > thr) {
          mask[y*w + x] = 1;
          sumX += x; sumY += y; sumW += 1;
        }
      }
    }
    if (sumW > 0) {
      const cx = sumX / sumW, cy = sumY / sumW;
      flow.dx = (cx - w/2) * FLOW_SCALE;
      flow.dy = (h/2 - cy) * FLOW_SCALE;
    } else {
      flow.dx *= 0.95;
      flow.dy *= 0.95;
    }
    prevFrame.set(data);
    return mask;
  }

  // Build a chunk (no global reallocation). Transforms local points by current worldPose.
  function addThermalChunk(imageData, w, h, mask, depthScale) {
    const data = imageData.data;
    const stride = 4;
    const sampleStep = 2;

    const maxPts = Math.ceil((w*h)/(sampleStep*sampleStep));
    const positions = new Float32Array(maxPts*3);
    const colors    = new Float32Array(maxPts*3);

    let p = 0;
    const invW = 1/w, invH = 1/h;
    const tmp = new THREE.Vector3();
    const q = worldPose.quaternion.clone();
    const t = worldPose.position.clone();

    for (let y=0; y<h; y+=sampleStep) {
      for (let x=0; x<w; x+=sampleStep) {
        const idx = (y*w + x) * stride;
        const r = data[idx]   / 255;
        const g = data[idx+1] / 255;
        const b = data[idx+2] / 255;
        const br = (r+g+b)/3;

        if (mask[y*w + x] === 0 && br < 0.12) continue;

        const lx = (x*invW - 0.5) * 6.0;
        const ly = (0.5 - y*invH) * 6.0;
        const lz = (br - 0.5) * depthScale;

        tmp.set(lx, ly, lz).applyQuaternion(q).add(t);

        positions[p*3 + 0] = tmp.x;
        positions[p*3 + 1] = tmp.y;
        positions[p*3 + 2] = tmp.z;

        const [cr,cg,cb] = thermalColor(br);
        colors[p*3 + 0] = cr;
        colors[p*3 + 1] = cg;
        colors[p*3 + 2] = cb;

        p++;
      }
    }

    makePointsChunk(positions.subarray(0, p*3), colors.subarray(0, p*3));
  }

  // Webcam start/stop with robust error handling
  async function startWebcam() {
    try {
      status("Requesting camera...");
      stream = await navigator.mediaDevices.getUserMedia({
        video: { width: { ideal:1280 }, height: { ideal:720 }, facingMode },
        audio: false
      });
    } catch (err) {
      status("Camera blocked or unavailable. Enable access on HTTPS and tap Start again.");
      return;
    }

    video = document.createElement("video");
    video.srcObject = stream;
    try { await video.play(); }
    catch { status("Failed to play camera stream. Tap Start again after allowing permissions."); return; }

    procCanvas = document.createElement("canvas");
    procCanvas.width = PROC_W;
    procCanvas.height = PROC_H;
    procCtx = procCanvas.getContext("2d", { willReadFrequently:true });

    isRunning = true;
    startBtn.disabled = true;
    stopBtn.disabled = false;

    status(hasIMU
      ? "Thermal mapping: walk slowly; drag to orbit."
      : "Thermal mapping: orientation not available; using flat forward.");
  }

  function stopWebcam() {
    if (stream) {
      stream.getTracks().forEach(t => t.stop());
      stream = null;
    }
    isRunning = false;
    startBtn.disabled = false;
    stopBtn.disabled = true;
    status("Stopped. Map remains in scene.");
  }

  async function switchCam() {
    facingMode = (facingMode === "environment") ? "user" : "environment";
    if (isRunning) {
      stopWebcam();
      await startWebcam();
    }
  }

  // Clear map
  function clearMap() {
    for (const chunk of pointChunks) {
      chunk.geometry.dispose();
      chunk.material.dispose();
      scene.remove(chunk);
    }
    pointChunks.length = 0;
    prevFrame = null;
    worldPose.position.set(0,0,0);
    worldPose.quaternion.identity();
    status("Cleared. Ready to remap.");
  }

  // Frame loop — keyframe-only compute for mask & flow; update pose before chunk
  function tick() {
    requestAnimationFrame(tick);
    controls.update();

    if (isRunning && video && video.readyState >= 2) {
      const vw = video.videoWidth, vh = video.videoHeight;
      const size = Math.min(vw, vh);
      const sx = (vw - size)/2, sy = (vh - size)/2;

      procCtx.clearRect(0,0,PROC_W,PROC_H);
      procCtx.drawImage(video, sx, sy, size, size, 0, 0, PROC_W, PROC_H);

      const frame = procCtx.getImageData(0,0,PROC_W,PROC_H);

      const cadence = parseInt(cadenceEl.value, 10);
      const depthScale = parseFloat(glowEl.value);
      frameCount++;

      if (frameCount % cadence === 0) {
        const mask  = computeFlowAndMask(frame.data, PROC_W, PROC_H);

        // Orientation fallback for devices without motion
        if (!hasIMU) deviceQuat.set(0,0,0,1);

        // Update pose BEFORE adding points (keyframe only)
        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(deviceQuat);
        const right   = new THREE.Vector3(1, 0,  0).applyQuaternion(deviceQuat);
        const move = new THREE.Vector3()
          .addScaledVector(forward, flow.dy)
          .addScaledVector(right,   flow.dx);

        worldPose.position.add(move);
        worldPose.quaternion.copy(deviceQuat);

        addThermalChunk(frame, PROC_W, PROC_H, mask, depthScale);
        const totalPts = pointChunks.reduce((n,c)=>n+c.geometry.attributes.position.count,0);
        status(`Points: ${totalPts} | cadence ${cadence}`);
      }
    }

    renderer.render(scene, camera);
  }
  tick();

  // UI wiring
  startBtn.addEventListener("click", async () => { if (!isRunning) await startWebcam(); });
  stopBtn.addEventListener("click", () => stopWebcam());
  switchCamBtn.addEventListener("click", async () => { await switchCam(); });
  clearBtn.addEventListener("click", () => clearMap());
  glowEl.addEventListener("input", ()=> status(`Depth scale: ${glowEl.value}`));

  // Resize
  window.addEventListener("resize", () => {
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  status("Ready — HTTPS recommended for sensors/camera. Tap Start to begin.");
</script>
</body>
</html>

