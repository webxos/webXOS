<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>edTV: WEBXR MILITARY MASK TRY-ON</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
  *{margin:0;padding:0;box-sizing:border-box;font-family:'Press Start 2P',cursive;image-rendering:pixelated}
  body{background:#000;color:#0f0;overflow:hidden;height:100dvh;touch-action:manipulation;user-select:none}
  #app{position:relative;width:100%;height:100dvh;display:flex;flex-direction:column}
  .grid,.crt{position:absolute;inset:0;pointer-events:none}
  .grid{background:linear-gradient(rgba(0,255,0,0.06)1px,transparent 1px),linear-gradient(90deg,rgba(0,255,0,0.06)1px,transparent 1px);background-size:12px 12px}
  .crt{background:linear-gradient(transparent 50%,rgba(0,30,0,0.15)50%);background-size:100% 4px;animation:s 8s linear infinite}
  @keyframes s{0%{background-position:0 0}100%{background-position:0 100%}}
  .banner{background:rgba(0,40,0,0.98);border-bottom:2px solid #0f0;padding:12px 8px;font-size:10px;text-align:center;text-shadow:0 0 10px #0f0}
  .content{flex:1;display:flex;flex-direction:column;gap:8px;padding:8px;padding-bottom:max(env(safe-area-inset-bottom),20px)}
  .ar-view{flex:1;position:relative;border:2px solid #0f0;overflow:hidden;background:#000;border-radius:8px;box-shadow:0 0 20px rgba(0,255,0,0.6)}
  #video{width:100%;height:100%;object-fit:cover;transform:scaleX(-1);display:none}
  #canvas{position:absolute;inset:0;width:100%;height:100%}
  .controls{display:flex;flex-wrap:wrap;gap:8px;justify-content:center;padding:10px;background:rgba(0,30,0,0.9);border:2px solid #0f0}
  .btn,.dropdown{font-size:9px;padding:10px 14px;border:2px solid #0f0;background:#000;color:#0f0;cursor:pointer;transition:.2s;flex:1 1 100px;max-width:220px}
  .btn:hover,.btn:active{background:#0f0;color:#000;box-shadow:0 0 15px #0f0}
  .terminal{height:16dvh;background:rgba(0,0,0,0.9);border:2px solid #0f0;padding:8px;font-size:8px;overflow-y:auto;color:#0f0}
  .status{position:absolute;bottom:8px;left:8px;right:8px;display:flex;gap:8px;z-index:20;flex-wrap:wrap}
  .ind{padding:4px 8px;font-size:7px;background:rgba(0,60,0,0.9);border:1px solid #0f0;border-radius:4px}
  .locked{background:rgba(0,255,0,0.9);box-shadow:0 0 12px #0f0;animation:p 1.5s infinite}
  @keyframes p{0%,100%{opacity:1}50%{opacity:0.6}}
</style>
</head>
<body>
<div id="app">
  <div class="grid"></div><div class="crt"></div>
  <div class="banner">edTV: MILITARY MASK POINT CLOUD v3</div>
  <div class="content">
    <div class="controls">
      <button class="btn" id="start">START WEBCAM</button>
      <select class="dropdown" id="mask-select">
        <option value="oni">ONI DEMON</option>
        <option value="tactical">TACTICAL</option>
        <option value="gas">GAS MASK</option>
        <option value="respirator">RESPIRATOR</option>
        <option value="cyber">CYBER HELMET</option>
        <option value="skull">SKULL</option>
      </select>
    </div>
    <div class="terminal" id="log">> READY</div>
    <div class="ar-view">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="canvas"></canvas>
      <div class="status">
        <div class="ind" id="track">TRACKING: OFF</div>
        <div class="ind" id="mask">MASK: ONI</div>
      </div>
    </div>
  </div>
</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js';

const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const logEl = document.getElementById('log');
const trackEl = document.getElementById('track');
const maskEl = document.getElementById('mask');

let renderer, scene, camera;
let maskGroup = new THREE.Group();
let facePoints = new THREE.Points();
let currentMask = 'oni';
let isWebcamActive = false;
let canvas2D, ctx2D;

const configs = {
  oni:       {scale:1.7, y:0.02, z:-0.55, rx:-0.1, color:0x00ff00},
  tactical:  {scale:1.9, y:0.06, z:-0.52, rx:0.05, color:0x003300},
  gas:       {scale:2.1, y:0.04, z:-0.62, rx:0, color:0x00ff44},
  respirator:{scale:1.6, y:0.09, z:-0.50, rx:0.1, color:0x0088ff},
  cyber:     {scale:1.8, y:0.05, z:-0.50, rx:0, color:0x00ffff},
  skull:     {scale:1.7, y:0.00, z:-0.58, rx:-0.05, color:0xff0088}
};

function log(t){const d=document.createElement('div');d.textContent='> '+t;logEl.appendChild(d);logEl.scrollTop=logEl.scrollHeight;}

function createPointCloudMask(type) {
  maskGroup.clear();
  scene.remove(maskGroup);
  const cfg = configs[type];
  const pointMaterial = new THREE.PointsMaterial({
    color: cfg.color,
    size: 0.02,
    sizeAttenuation: true
  });

  // Create geometry for point cloud mask
  const geometry = new THREE.BufferGeometry();
  const positions = [];
  const colors = [];
  
  // Base helmet shape - front curve
  for(let i=0;i<=64;i++){
    const a = i/64*Math.PI*2;
    const r = 0.22 + Math.sin(i/10)*0.03;
    positions.push(Math.cos(a)*r, Math.sin(a)*r + 0.15, 0);
    positions.push(Math.cos(a)*r*0.88, Math.sin(a)*r*0.88 + 0.15, -0.09);
    
    // Add color data
    colors.push(cfg.color >> 16 & 0xff, cfg.color >> 8 & 0xff, cfg.color & 0xff);
    colors.push(cfg.color >> 16 & 0xff, cfg.color >> 8 & 0xff, cfg.color & 0xff);
  }

  // Visor area - dense point cloud
  if(type !== 'skull'){
    for(let x=-0.16;x<=0.16;x+=0.008)for(let y=-0.06;y<=0.10;y+=0.006){
      positions.push(x,y,-0.13);
      colors.push(cfg.color >> 16 & 0xff, cfg.color >> 8 & 0xff, cfg.color & 0xff);
    }
  }

  // Side components
  for(let side=-1;side<=1;side+=2){
    for(let i=0;i<32;i++){
      const a = i/32*Math.PI*2;
      const r = 0.07 + (i%3)*0.02;
      positions.push(side*(0.19 + Math.cos(a)*r), 0.08 + Math.sin(a)*r, -0.04);
      colors.push(cfg.color >> 16 & 0xff, cfg.color >> 8 & 0xff, cfg.color & 0xff);
    }
  }

  // Lower vents
  if(['gas','respirator','tactical'].includes(type)){
    for(let i=0;i<12;i++){
      for(let j=0;j<8;j++){
        positions.push(-0.065 + i*0.012, -0.09, -0.19 + j*0.003);
        colors.push(cfg.color >> 16 & 0xff, cfg.color >> 8 & 0xff, cfg.color & 0xff);
      }
    }
  }

  geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
  geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
  
  const pointCloud = new THREE.Points(geometry, pointMaterial);
  maskGroup.add(pointCloud);

  maskGroup.scale.setScalar(cfg.scale);
  maskGroup.position.y = cfg.y;
  maskGroup.position.z = cfg.z;
  maskGroup.rotation.x = cfg.rx || 0;
  scene.add(maskGroup);
  maskEl.textContent = `MASK: ${type.toUpperCase()}`;
}

function createFacePointCloud() {
  const geometry = new THREE.BufferGeometry();
  const positions = new Float32Array(720 * 720 * 3);
  const colors = new Float32Array(720 * 720 * 3);
  
  let index = 0;
  for (let i = 0; i < 720; i++) {
    for (let j = 0; j < 720; j++) {
      positions[index] = (i - 360) * 0.01;
      positions[index + 1] = (j - 360) * 0.01;
      positions[index + 2] = 0;
      
      // Set initial color to green
      colors[index] = 0.0;
      colors[index + 1] = 1.0;
      colors[index + 2] = 0.0;
      
      index += 3;
    }
  }
  
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  
  const material = new THREE.PointsMaterial({
    size: 0.008,
    vertexColors: true,
    sizeAttenuation: true
  });
  
  facePoints = new THREE.Points(geometry, material);
  scene.add(facePoints);
}

function updateFacePointCloud() {
  if (!isWebcamActive || !video || video.readyState !== video.HAVE_ENOUGH_DATA) return;
  
  // Get video dimensions
  const srcW = video.videoWidth;
  const srcH = video.videoHeight;
  
  // Calculate crop area to get center 720x720
  const sx = Math.max(0, (srcW - 720) / 2);
  const sy = Math.max(0, (srcH - 720) / 2);
  const cropSize = Math.min(720, srcW, srcH);
  
  // Draw cropped video to 2D canvas for processing
  ctx2D.clearRect(0, 0, canvas2D.width, canvas2D.height);
  ctx2D.drawImage(video, sx, sy, cropSize, cropSize, 0, 0, canvas2D.width, canvas2D.height);
  
  const imageData = ctx2D.getImageData(0, 0, canvas2D.width, canvas2D.height);
  const data = imageData.data;
  
  // Get point cloud geometry
  const positions = facePoints.geometry.attributes.position.array;
  const colors = facePoints.geometry.attributes.color.array;
  
  const depthIntensity = 8;
  const width = canvas2D.width;
  const height = canvas2D.height;
  
  // Update point positions based on video data (simplified depth from brightness)
  let pointIndex = 0;
  for (let i = 0; i < height; i += 1) {
    for (let j = 0; j < width; j += 1) {
      const pixelIndex = (i * width + j) * 4;
      const r = data[pixelIndex] / 255;
      const g = data[pixelIndex + 1] / 255;
      const b = data[pixelIndex + 2] / 255;
      
      // Calculate brightness and use it as depth
      const brightness = (r + g + b) / 3;
      
      // Map to 3D space (centered, scaled)
      const x = (j / width - 0.5) * 10;
      const y = (0.5 - i / height) * 10;
      const z = (brightness - 0.5) * depthIntensity;
      
      // Update position
      positions[pointIndex * 3] = x;
      positions[pointIndex * 3 + 1] = y;
      positions[pointIndex * 3 + 2] = z;
      
      // Use video colors for face point cloud
      colors[pointIndex * 3] = r;
      colors[pointIndex * 3 + 1] = g;
      colors[pointIndex * 3 + 2] = b;
      
      pointIndex++;
      
      // Safety check - don't exceed point cloud size
      if (pointIndex * 3 >= positions.length) break;
    }
    // Safety check - don't exceed point cloud size
    if (pointIndex * 3 >= positions.length) break;
  }
  
  // Mark attributes as needing update
  facePoints.geometry.attributes.position.needsUpdate = true;
  facePoints.geometry.attributes.color.needsUpdate = true;
}

async function startWebcam() {
  try {
    log('ACCESSING CAMERA...');
    
    const stream = await navigator.mediaDevices.getUserMedia({ 
      video: { 
        width: { ideal: 1280 },
        height: { ideal: 720 },
        facingMode: 'user'
      }, 
      audio: false 
    });
    
    video.srcObject = stream;
    video.play();
    
    // Create 2D canvas for processing video frames
    canvas2D = document.createElement('canvas');
    canvas2D.width = 720;
    canvas2D.height = 720;
    ctx2D = canvas2D.getContext('2d');
    
    // Wait for video to be ready
    video.addEventListener('loadeddata', function() {
      isWebcamActive = true;
      trackEl.textContent = 'TRACKING: LOCKED';
      trackEl.classList.add('locked');
      log('WEBCAM ACTIVE - FACE TRACKING ON');
    });
    
  } catch (error) {
    console.error('Error accessing webcam:', error);
    log('ERROR: COULD NOT ACCESS WEBCAM');
  }
}

async function initThreeJS() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.01, 20);
  renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
  renderer.setPixelRatio(devicePixelRatio);
  renderer.setSize(innerWidth, innerHeight);

  const light = new THREE.HemisphereLight(0xffffff, 0x00ff88, 1.4);
  scene.add(light);

  createFacePointCloud();
  createPointCloudMask(currentMask);

  // Start animation loop
  renderer.setAnimationLoop(() => {
    if (isWebcamActive) {
      updateFacePointCloud();
      
      // Auto-rotate slowly
      facePoints.rotation.y += 0.002;
      maskGroup.rotation.y += 0.002;
    }
    renderer.render(scene, camera);
  });
}

document.getElementById('start').onclick = async () => {
  await startWebcam();
  await initThreeJS();
};

document.getElementById('mask-select').onchange = e => {
  currentMask = e.target.value;
  createPointCloudMask(currentMask);
  log(`MASK: ${currentMask.toUpperCase()}`);
};

log('PRESS START WEBCAM');
</script>
</body>
</html>