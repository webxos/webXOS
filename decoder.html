<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WebXOS VIAL</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=VT323&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Press Start 2P', monospace; }
        html, body { 
            height: 100vh; 
            overflow: hidden; 
            background: #000; 
            color: #0f0; 
            display: flex; 
            flex-direction: column; 
            touch-action: manipulation; 
            position: relative;
        }
        
        /* Scanlines effect */
        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 100;
        }
        
        /* Grid background */
        body::after {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 0, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 0, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
            pointer-events: none;
            z-index: -1;
        }
        
        header {
            padding: 10px;
            text-align: center;
            border-bottom: 2px solid #0f0;
            background: rgba(0, 20, 0, 0.8);
            z-index: 10;
        }
        
        h1 {
            font-size: 1.6rem;
            text-shadow: 0 0 5px #0f0;
            margin-bottom: 5px;
        }
        
        .header-info {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            margin-top: 5px;
        }
        
        #terminal {
            flex: 1;
            margin: 10px;
            background: rgba(0, 20, 0, 0.7);
            border: 2px solid #0f0;
            border-radius: 5px;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        
        #terminal-log {
            flex: 1;
            overflow-y: auto;
            padding-right: 5px;
        }
        
        #terminal-log p {
            margin: 5px 0;
            font-size: 0.8rem;
            line-height: 1.3;
        }
        
        #terminal-input {
            display: flex;
            margin-top: 10px;
            border-top: 1px solid #0f0;
            padding-top: 10px;
        }
        
        #prompt-input {
            flex: 1;
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 8px;
            font-size: 0.8rem;
        }
        
        #send-button {
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 8px 15px;
            margin-left: 5px;
            cursor: pointer;
        }
        
        #vial-status {
            height: 120px;
            margin: 0 10px 10px;
            display: flex;
            gap: 10px;
        }
        
        .vial-container {
            flex: 1;
            background: rgba(0, 20, 0, 0.7);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 8px;
            display: flex;
            flex-direction: column;
        }
        
        .vial-header {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            margin-bottom: 5px;
        }
        
        .vial-name {
            font-weight: bold;
        }
        
        .vial-status {
            color: #0f0;
        }
        
        .vial-status.training {
            color: #ff0;
        }
        
        .vial-status.error {
            color: #f00;
        }
        
        .metric-bar {
            height: 8px;
            background: #333;
            border: 1px solid #0f0;
            border-radius: 2px;
            margin: 3px 0;
            overflow: hidden;
        }
        
        .metric-fill {
            height: 100%;
            transition: width 0.3s;
        }
        
        .fps-fill {
            background: #0f0;
        }
        
        .latency-fill {
            background: #f00;
        }
        
        .vial-metrics {
            font-size: 0.6rem;
            margin-top: 5px;
        }
        
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 0 10px 10px;
            justify-content: center;
        }
        
        button {
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 8px 12px;
            font-size: 0.7rem;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #0f0;
            color: #000;
        }
        
        button:disabled {
            background: #333;
            color: #666;
            border-color: #666;
            cursor: not-allowed;
        }
        
        button.active {
            background: #0f0;
            color: #000;
        }
        
        #error-notification {
            display: none;
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(255, 0, 0, 0.8);
            color: #fff;
            padding: 10px;
            border-radius: 3px;
            font-size: 0.8rem;
            max-width: 300px;
            z-index: 1000;
            box-shadow: 0 0 10px #ff0000;
            border: 1px solid #ff0000;
        }
        
        #error-notification.visible {
            display: block;
        }
        
        #donate-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000;
            border: 2px solid #0f0;
            padding: 20px;
            border-radius: 5px;
            z-index: 2000;
            box-shadow: 0 0 20px #0f0;
            text-align: center;
            max-width: 300px;
        }
        
        #donate-popup.visible {
            display: block;
        }
        
        #donate-popup h2 {
            margin-bottom: 15px;
            font-size: 1rem;
        }
        
        #donate-popup p {
            margin: 10px 0;
            font-size: 0.8rem;
        }
        
        #donate-close {
            margin-top: 15px;
            padding: 8px 15px;
        }
        
        .command {
            color: #0ff;
        }
        
        .error {
            color: #f00;
        }
        
        .success {
            color: #0f0;
        }
        
        .warning {
            color: #ff0;
        }
        
        .balance {
            color: #0af;
        }
        
        /* Scrollbar styling */
        #terminal-log::-webkit-scrollbar {
            width: 8px;
        }
        
        #terminal-log::-webkit-scrollbar-track {
            background: rgba(0, 30, 0, 0.5);
        }
        
        #terminal-log::-webkit-scrollbar-thumb {
            background: #0f0;
            border-radius: 4px;
        }
        
        /* Neurot particles */
        .neurot {
            position: fixed;
            width: 3px;
            height: 3px;
            background-color: #0f0;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1;
            box-shadow: 0 0 5px #0f0;
        }

        /* Decoder styles integrated */
        .certificate-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .certificate-container {
            min-width: 300px;
            min-height: 300px;
            background: #000000;
            border: 4px solid #00ff00;
            border-radius: 15px;
            box-shadow: 0 0 20px #00ff00, inset 0 0 10px #00ff00;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            perspective: 1000px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 20px #00ff00, inset 0 0 10px #00ff00; }
            50% { box-shadow: 0 0 30px #00ff00, inset 0 0 15px #00ff00; }
            100% { box-shadow: 0 0 20px #00ff00, inset 0 0 10px #00ff00; }
        }

        .certificate {
            min-width: 260px;
            min-height: 260px;
            padding: 15px;
            background: #001100;
            color: #00ff00;
            text-align: center;
            position: absolute;
            transform: perspective(1000px) translateZ(40px) rotateX(5deg) rotateY(5deg);
            z-index: 2;
            font-family: 'OCR-A', 'Orbitron', 'Courier New', monospace;
            font-weight: 700;
            background-image: linear-gradient(rgba(0, 255, 0, 0.3) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(0, 255, 0, 0.3) 1px, transparent 1px);
            background-size: 8px 8px;
            border: 1px dashed #00ff00;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.4), inset 0 0 10px rgba(0, 255, 0, 0.3);
            animation: flicker 3s infinite ease-in-out;
            cursor: pointer;
        }

        .certificate.spinning {
            animation: spinHologram 2s ease-in-out forwards;
        }

        .certificate-title {
            font-size: 28px;
            font-weight: 700;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
            margin-bottom: 8px;
            -webkit-text-stroke: 1px #004d00;
            animation: flicker 2s infinite ease-in-out;
            font-family: 'Orbitron', monospace;
            letter-spacing: 1px;
            line-height: 1.1;
            white-space: nowrap;
        }

        .certificate p {
            font-size: 12px;
            text-shadow: 0 0 8px #00ff00;
            margin: 8px 0;
            font-family: 'OCR-A', 'Courier New', monospace;
        }

        .certificate a {
            color: #00ffcc;
            text-decoration: none;
            font-size: 8px;
            text-shadow: 0 0 5px #00ffcc;
            font-family: 'OCR-A', 'Courier New', monospace;
        }

        .certificate a:hover {
            text-decoration: underline;
        }

        .score-display {
            font-size: 22px;
            color: #00ff00;
            text-shadow: 0 0 8px #00ff00;
            font-family: 'OCR-A', 'Courier New', monospace;
        }

        .emoji-reward {
            font-size: 40px;
            display: inline-block;
            text-shadow: 0 0 8px #00ff00, 0 0 12px #00ffcc;
            margin: 8px 0;
            line-height: 1;
        }

        .scramble-char {
            display: inline-block;
            position: relative;
            transition: all 0.2s ease;
        }

        .dissolving {
            animation: dissolve 1.6s ease-out forwards;
            color: #00ff00;
        }

        .rebuilding {
            animation: rebuild 1.4s ease-in forwards;
        }

        @keyframes dissolve {
            0% { transform: translate(0, 0); opacity: 1; }
            50% { transform: translate(0, -15px); opacity: 0.7; }
            100% { transform: translate(calc((50 - 100 * var(--rand-x)) * 1px), calc((50 - 100 * var(--rand-y)) * 1px)); opacity: 0; }
        }

        @keyframes rebuild {
            0% { transform: translate(calc((50 - 100 * var(--rand-x)) * 1px), calc((50 - 100 * var(--rand-y)) * 1px)); opacity: 0; }
            100% { transform: translate(0, 0); opacity: 1; }
        }

        @keyframes flicker {
            0% { opacity: 1; }
            50% { opacity: 0.85; }
            100% { opacity: 1; }
        }

        @keyframes spinHologram {
            0% { transform: perspective(1000px) translateZ(40px) rotateX(5deg) rotateY(5deg); }
            100% { transform: perspective(1000px) translateZ(40px) rotateX(5deg) rotateY(365deg); }
        }

        @media (max-width: 600px) {
            .certificate-container {
                min-width: 260px;
                min-height: 260px;
            }
            .certificate {
                min-width: 220px;
                min-height: 220px;
            }
            .certificate-title {
                font-size: 22px;
                -webkit-text-stroke: 0.8px #004d00;
                text-shadow: 0 0 2px #00ff00;
            }
            .certificate p {
                font-size: 10px;
            }
            .score-display {
                font-size: 18px;
            }
            .emoji-reward {
                font-size: 32px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>VIAL</h1>
        <div class="header-info">
            <span>NETWORK: <span id="network-status">OFFLINE</span></span>
            <span>BLOCKS: <span id="block-count">0</span></span>
            <span>REPUTATION: <span id="reputation">0</span></span>
        </div>
    </header>
    
    <div id="terminal">
        <div id="terminal-log">
            <p>> WebXOS VIAL initialized. Type /help for commands.</p>
            <p class="balance">$WEBXOS Balance: 0.0000</p>
        </div>
        <div id="terminal-input">
            <input type="text" id="prompt-input" placeholder="Enter command...">
            <button id="send-button">SEND</button>
        </div>
    </div>
    
    <div id="vial-status">
        <!-- Vial status bars will be generated here -->
    </div>
    
    <div class="button-group">
        <button id="authButton">AUTHENTICATE</button>
        <button id="voidButton">VOID</button>
        <button id="quantumLinkButton" disabled>QUANTUM LINK</button>
        <button id="exportButton" disabled>EXPORT</button>
        <button id="importButton" disabled>IMPORT</button>
        <button id="apiAccessButton" disabled>API ACCESS</button>
        <button id="donateButton">DONATE</button>
    </div>
    
    <div id="error-notification"></div>
    
    <div id="donate-popup">
        <h2>SUPPORT WEBXOS</h2>
        <p>PAYPAL DONATION LINK COMING SOON</p>
        <p>THANK YOU FOR YOUR SUPPORT!</p>
        <p>- webXOS 2025</p>
        <button id="donate-close">CLOSE</button>
    </div>
    
    <div class="certificate-modal" id="certificateModal">
        <div class="certificate-container">
            <div class="certificate" id="certificate">
                <h2 class="certificate-title" id="certificateTitle"></h2>
                <div id="certificateContent"></div>
            </div>
        </div>
    </div>
    
    <input type="file" id="file-input" accept=".md,.json" style="display: none;">

    <script>
        // Global state
        let isAuthenticated = false;
        let isOffline = true;
        let wallet = {
            address: null,
            balance: 0.0,
            hash: null,
            key: null
        };
        let agenticNetworkId = null;
        let reputation = 0;
        let blockchain = [];
        let apiCredentials = { key: null, secret: null };
        let vials = [];
        let logEntries = [];
        let fps = 60;
        let latency = 0;
        let lastUpdateTime = 0;
        let frameCount = 0;
        let fpsUpdateTime = 0;
        
        // PyTorch templates for vials
        const pytorchTemplates = [
            "nn.Sequential(nn.Linear(10, 1), nn.Sigmoid())",
            "nn.Sequential(nn.Linear(20, 2), nn.ReLU())",
            "nn.Sequential(nn.Linear(15, 3), nn.Tanh())",
            "nn.Sequential(nn.Linear(25, 4), nn.Softmax(dim=1))"
        ];

        // Initialize vials with empty state and PyTorch templates
        function initializeVials() {
            vials = [];
            for (let i = 0; i < 4; i++) {
                vials.push({
                    id: `vial${i+1}`,
                    status: 'stopped',
                    code: pytorchTemplates[i],
                    codeLength: pytorchTemplates[i].length,
                    webxosHash: generateUUID(),
                    wallet: {
                        balance: 0.0,
                        address: generateUUID(),
                        hash: generateUUID()
                    },
                    tasks: [],
                    quantumState: { qubits: [], entanglement: 'initialized' },
                    trainingData: [],
                    config: {},
                    isTraining: false,
                    fps: 60,
                    latency: 0,
                    template: pytorchTemplates[i]
                });
            }
            
            wallet.balance = 0.0;
            updateBalanceDisplay();
        }
        
        // Parse markdown wallet format (updated to handle templates/code)
        function parseMarkdownWallet(markdownText) {
            const lines = markdownText.split('\n');
            const result = {
                agenticNetwork: {},
                wallet: {},
                apiCredentials: {},
                blockchain: {},
                vials: []
            };
            
            let currentVial = null;
            let inCodeBlock = false;
            let codeBlock = [];
            let currentCodeLanguage = '';
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Agentic Network section
                if (line.startsWith('- Network ID:')) {
                    result.agenticNetwork.networkId = line.split(':')[1].trim();
                } else if (line.startsWith('- Reputation:')) {
                    result.agenticNetwork.reputation = parseInt(line.split(':')[1].trim()) || 0;
                }
                
                // Wallet section
                else if (line.startsWith('- Wallet Key:')) {
                    result.wallet.key = line.split(':')[1].trim();
                } else if (line.startsWith('- Session Balance:')) {
                    const balanceMatch = line.match(/- Session Balance: ([\d.]+) \$WEBXOS/);
                    if (balanceMatch) {
                        result.wallet.balance = parseFloat(balanceMatch[1]) || 0;
                    }
                } else if (line.startsWith('- Address:')) {
                    result.wallet.address = line.split(':')[1].trim();
                } else if (line.startsWith('- Hash:')) {
                    result.wallet.hash = line.split(':')[1].trim();
                }
                
                // API Credentials section
                else if (line.startsWith('- Key:')) {
                    result.apiCredentials.key = line.split(':')[1].trim();
                } else if (line.startsWith('- Secret:')) {
                    result.apiCredentials.secret = line.split(':')[1].trim();
                }
                
                // Blockchain section
                else if (line.startsWith('- Blocks:')) {
                    result.blockchain.blocks = parseInt(line.split(':')[1].trim()) || 0;
                } else if (line.startsWith('- Last Hash:')) {
                    result.blockchain.lastHash = line.split(':')[1].trim();
                }
                
                // Vial sections
                else if (line.startsWith('# Vial Agent:')) {
                    if (currentVial) {
                        // Save the previous vial
                        currentVial.code = codeBlock.join('\n');
                        currentVial.codeLength = currentVial.code.length;
                        currentVial.template = currentVial.code; // Use code as template
                        result.vials.push(currentVial);
                        codeBlock = [];
                    }
                    
                    const vialId = line.split(':')[1].trim();
                    currentVial = {
                        id: vialId,
                        status: 'stopped',
                        code: '',
                        codeLength: 0,
                        webxosHash: '',
                        wallet: {
                            balance: 0,
                            address: '',
                            hash: ''
                        },
                        tasks: [],
                        quantumState: { qubits: [], entanglement: 'initialized' },
                        trainingData: [],
                        config: {},
                        isTraining: false,
                        fps: 60,
                        latency: 0,
                        template: ''
                    };
                }
                
                // Vial properties
                else if (currentVial && line.startsWith('- Status:')) {
                    currentVial.status = line.split(':')[1].trim();
                } else if (currentVial && line.startsWith('- Language:')) {
                    currentCodeLanguage = line.split(':')[1].trim();
                } else if (currentVial && line.startsWith('- Code Length:')) {
                    const lengthMatch = line.match(/- Code Length: (\d+) bytes/);
                    if (lengthMatch) {
                        currentVial.codeLength = parseInt(lengthMatch[1]) || 0;
                    }
                } else if (currentVial && line.startsWith('- $WEBXOS Hash:')) {
                    currentVial.webxosHash = line.split(':')[1].trim();
                } else if (currentVial && line.startsWith('- Wallet Balance:')) {
                    const balanceMatch = line.match(/- Wallet Balance: ([\d.]+) \$WEBXOS/);
                    if (balanceMatch) {
                        currentVial.wallet.balance = parseFloat(balanceMatch[1]) || 0;
                    }
                } else if (currentVial && line.startsWith('- Wallet Address:')) {
                    currentVial.wallet.address = line.split(':')[1].trim();
                } else if (currentVial && line.startsWith('- Wallet Hash:')) {
                    currentVial.wallet.hash = line.split(':')[1].trim();
                } else if (currentVial && line.startsWith('```')) {
                    if (inCodeBlock) {
                        inCodeBlock = false;
                    } else {
                        inCodeBlock = true;
                    }
                } else if (inCodeBlock) {
                    codeBlock.push(line);
                }
            }
            
            if (currentVial) {
                currentVial.code = codeBlock.join('\n');
                currentVial.codeLength = currentVial.code.length;
                currentVial.template = currentVial.code; // Use code as template
                result.vials.push(currentVial);
            }
            
            return result;
        }
        
        // Log event to terminal
        function logEvent(message, type = '') {
            const log = document.getElementById('terminal-log');
            const p = document.createElement('p');
            p.textContent = message;
            if (type) p.classList.add(type);
            log.appendChild(p);
            log.scrollTop = log.scrollHeight;
        }
        
        // Show error notification
        function showErrorNotification(message) {
            const notif = document.getElementById('error-notification');
            notif.textContent = message;
            notif.classList.add('visible');
            setTimeout(() => notif.classList.remove('visible'), 3000);
        }
        
        // Update balance display
        function updateBalanceDisplay() {
            document.querySelector('.balance').textContent = `$WEBXOS Balance: ${wallet.balance.toFixed(4)}`;
        }
        
        // Update vial status bars
        function updateVialStatusBars() {
            const statusDiv = document.getElementById('vial-status');
            statusDiv.innerHTML = '';
            vials.forEach(vial => {
                const container = document.createElement('div');
                container.className = 'vial-container';
                
                const header = document.createElement('div');
                header.className = 'vial-header';
                header.innerHTML = `
                    <span class="vial-name">${vial.id.toUpperCase()}</span>
                    <span class="vial-status ${vial.isTraining ? 'training' : ''}">${vial.status.toUpperCase()}</span>
                `;
                container.appendChild(header);
                
                // FPS bar
                const fpsBar = document.createElement('div');
                fpsBar.className = 'metric-bar';
                const fpsFill = document.createElement('div');
                fpsFill.className = 'metric-fill fps-fill';
                fpsFill.style.width = `${(vial.fps / 120) * 100}%`;
                fpsBar.appendChild(fpsFill);
                container.appendChild(fpsBar);
                
                // Latency bar
                const latBar = document.createElement('div');
                latBar.className = 'metric-bar';
                const latFill = document.createElement('div');
                latFill.className = 'metric-fill latency-fill';
                latFill.style.width = `${(vial.latency / 200) * 100}%`;
                latBar.appendChild(latFill);
                container.appendChild(latBar);
                
                // Metrics
                const metrics = document.createElement('div');
                metrics.className = 'vial-metrics';
                metrics.innerHTML = `
                    FPS: ${Math.round(vial.fps)}<br>
                    LAT: ${Math.round(vial.latency)}ms<br>
                    BAL: ${vial.wallet.balance.toFixed(4)}
                `;
                container.appendChild(metrics);
                
                statusDiv.appendChild(container);
            });
            
            document.getElementById('block-count').textContent = blockchain.length;
            document.getElementById('reputation').textContent = reputation;
        }
        
        // Authenticate function
        function authenticate() {
            if (isAuthenticated) {
                showErrorNotification('Already authenticated.');
                return;
            }
            
            const fileInput = document.getElementById('file-input');
            fileInput.accept = '.md,.json';
            fileInput.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        try {
                            let walletData;
                            if (file.name.endsWith('.md')) {
                                walletData = parseMarkdownWallet(ev.target.result);
                                isOffline = false;
                            } else {
                                walletData = JSON.parse(ev.target.result);
                                isOffline = false;
                            }
                            
                            agenticNetworkId = walletData.agenticNetwork.networkId || generateUUID();
                            wallet.key = walletData.wallet.key || generateUUID();
                            wallet.address = walletData.wallet.address || generateUUID();
                            wallet.hash = walletData.wallet.hash || generateUUID();
                            wallet.balance = walletData.wallet.balance || 0;
                            apiCredentials = walletData.apiCredentials || { key: generateUUID(), secret: generateUUID() };
                            reputation = walletData.agenticNetwork.reputation || 0;
                            blockchain = Array(walletData.blockchain.blocks).fill().map((_, i) => ({
                                index: i,
                                hash: i === walletData.blockchain.blocks - 1 ? walletData.blockchain.lastHash : `prev_hash_${i}`,
                                timestamp: new Date().toISOString()
                            }));
                            
                            // Update vials with provided data
                            if (walletData.vials && walletData.vials.length > 0) {
                                vials = walletData.vials.map((v, i) => ({
                                    ...v,
                                    template: v.template || pytorchTemplates[i]
                                }));
                            }
                            
                            logEvent('Authenticated in ONLINE mode with provided wallet data', 'success');
                            logEvent(`Network ID: ${agenticNetworkId}`, 'command');
                            logEvent(`Wallet Balance: ${wallet.balance.toFixed(4)} $WEBXOS`, 'balance');
                            logEvent(`Reputation: ${reputation}`, 'balance');
                        } catch (error) {
                            showErrorNotification('Invalid wallet file.');
                            return;
                        }
                        
                        finalizeAuth();
                    };
                    reader.readAsText(file);
                } else {
                    // Offline auth
                    agenticNetworkId = generateUUID();
                    wallet.key = generateUUID();
                    wallet.address = generateUUID();
                    wallet.hash = generateUUID();
                    apiCredentials.key = generateUUID();
                    apiCredentials.secret = generateUUID();
                    reputation = 0;
                    blockchain = [];
                    
                    logEvent('Authenticated in OFFLINE mode with new wallet', 'success');
                    finalizeAuth();
                }
                fileInput.value = '';
                fileInput.onchange = null;
                fileInput.accept = '.md';
            };
            fileInput.click();
            
            function finalizeAuth() {
                isAuthenticated = true;
                document.getElementById('authButton').classList.add('active');
                document.getElementById('network-status').textContent = isOffline ? 'OFFLINE' : 'ONLINE';
                document.getElementById('network-status').style.color = isOffline ? '#f00' : '#0f0';
                
                // Enable buttons
                document.getElementById('quantumLinkButton').disabled = false;
                document.getElementById('exportButton').disabled = false;
                document.getElementById('importButton').disabled = false;
                document.getElementById('apiAccessButton').disabled = isOffline;
                
                updateBalanceDisplay();
                updateVialStatusBars();
            }
        }
        
        // Void function
        function voidVials() {
            isAuthenticated = false;
            isOffline = true;
            wallet = { address: null, balance: 0, hash: null, key: null };
            agenticNetworkId = null;
            reputation = 0;
            blockchain = [];
            apiCredentials = { key: null, secret: null };
            
            initializeVials();
            
            document.getElementById('authButton').classList.remove('active');
            document.getElementById('network-status').textContent = 'OFFLINE';
            document.getElementById('network-status').style.color = '#f00';
            
            // Disable buttons
            document.getElementById('quantumLinkButton').disabled = true;
            document.getElementById('exportButton').disabled = true;
            document.getElementById('importButton').disabled = true;
            document.getElementById('apiAccessButton').disabled = true;
            
            logEvent('All data voided. System reset.', 'warning');
            updateBalanceDisplay();
            updateVialStatusBars();
        }
        
        // Quantum Link function
        function quantumLink() {
            if (!isAuthenticated) {
                showErrorNotification('Not authenticated. Please authenticate first.');
                return;
            }
            
            logEvent('Activating Quantum Link for agent synchronization...', 'command');
            
            vials.forEach(vial => {
                vial.isTraining = true;
                vial.status = 'running';
                
                // Simulate training process
                setTimeout(() => {
                    vial.isTraining = false;
                    vial.status = 'running';
                    vial.wallet.balance += 100; // Simulated earnings
                    wallet.balance = vials.reduce((sum, v) => sum + v.wallet.balance, 0);
                    updateBalanceDisplay();
                    updateVialStatusBars();
                }, 2000);
            });
            
            updateVialStatusBars();
        }
        
        // Export function
        function exportVials() {
            if (!isAuthenticated) {
                showErrorNotification('Not authenticated. Please authenticate first.');
                return;
            }
            
            const exportData = {
                agenticNetwork: {
                    networkId: agenticNetworkId,
                    sessionStart: new Date().toISOString(),
                    reputation: reputation
                },
                wallet: {
                    key: wallet.key,
                    balance: wallet.balance,
                    address: wallet.address,
                    hash: wallet.hash
                },
                apiCredentials: apiCredentials,
                blockchain: {
                    blocks: blockchain.length,
                    lastHash: blockchain.length > 0 ? blockchain[blockchain.length-1].hash : 'none'
                },
                vials: vials.map(v => ({
                    ...v,
                    template: v.template // Include PyTorch template
                }))
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `decoder_wallet_export_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            logEvent('Wallet and vial data exported successfully', 'success');
        }
        
        // Import function (modified to combine/add balances)
        function importFile() {
            if (!isAuthenticated) {
                showErrorNotification('Not authenticated. Please authenticate first.');
                return;
            }
            
            document.getElementById('file-input').click();
        }
        
        // Handle file import (combine mode)
        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const fileContent = e.target.result;
                    let importData;
                    
                    if (file.name.endsWith('.md')) {
                        importData = parseMarkdownWallet(fileContent);
                    } else {
                        importData = JSON.parse(fileContent);
                    }
                    
                    // Combine wallet data (add balances)
                    if (importData.wallet) {
                        wallet.balance += importData.wallet.balance || 0;
                    }
                    
                    // Combine vials (add balances to matching vials)
                    if (importData.vials && Array.isArray(importData.vials)) {
                        importData.vials.forEach(impVial => {
                            const localVial = vials.find(v => v.id === impVial.id);
                            if (localVial) {
                                localVial.wallet.balance += impVial.wallet.balance || 0;
                                // Optionally merge other fields if needed
                            }
                        });
                    }
                    
                    // Add reputation
                    if (importData.agenticNetwork) {
                        reputation += importData.agenticNetwork.reputation || 0;
                    }
                    
                    // Add blockchain blocks (simulated)
                    if (importData.blockchain) {
                        const newBlocks = importData.blockchain.blocks || 0;
                        for (let i = 0; i < newBlocks; i++) {
                            blockchain.push({
                                index: blockchain.length,
                                hash: `combined_hash_${blockchain.length}`,
                                timestamp: new Date().toISOString()
                            });
                        }
                    }
                    
                    logEvent('Wallet data combined successfully', 'success');
                    updateBalanceDisplay();
                    updateVialStatusBars();
                } catch (error) {
                    showErrorNotification('Failed to import file: Invalid format');
                    logEvent(`Import error: ${error.message}`, 'error');
                }
            };
            reader.readAsText(file);
            
            // Reset file input
            event.target.value = '';
        }
        
        // API Access function
        function apiAccess() {
            if (!isAuthenticated) {
                showErrorNotification('Not authenticated. Please authenticate first.');
                return;
            }
            
            if (isOffline) {
                showErrorNotification('API access is disabled in offline mode.');
                return;
            }
            
            logEvent(`API Key: ${apiCredentials.key}`, 'command');
            logEvent(`API Secret: ${apiCredentials.secret}`, 'command');
            logEvent('Use these credentials with LangChain to train vials', 'command');
        }
        
        // Donate function
        function donate() {
            document.getElementById('donate-popup').classList.add('visible');
        }
        
        // Close donate popup
        function closeDonatePopup() {
            document.getElementById('donate-popup').classList.remove('visible');
        }
        
        // Handle command input (integrated decoder)
        function handleCommand() {
            const input = document.getElementById('prompt-input');
            const command = input.value.trim();
            input.value = '';
            
            if (!command) return;
            
            logEvent(`> ${command}`, 'command');
            
            if (command === '/help') {
                logEvent('Available commands:');
                logEvent('/status - Show vial status');
                logEvent('/balance - Show wallet balance');
                logEvent('/train <vial> - Train a specific vial');
                logEvent('/stop <vial> - Stop training a vial');
                logEvent('/blockchain - Show blockchain info');
                logEvent('/decode <code> - Decode game serial and reward $WEBXOS');
                return;
            }
            
            if (command === '/status') {
                vials.forEach(vial => {
                    logEvent(`${vial.id}: ${vial.status} | FPS: ${Math.round(vial.fps)} | Latency: ${Math.round(vial.latency)}ms`);
                });
                return;
            }
            
            if (command === '/balance') {
                logEvent(`Wallet Balance: ${wallet.balance.toFixed(4)} $WEBXOS`, 'balance');
                logEvent(`Reputation: ${reputation}`, 'balance');
                return;
            }
            
            if (command.startsWith('/train ')) {
                const vialId = command.split(' ')[1];
                const vial = vials.find(v => v.id === vialId);
                if (vial) {
                    vial.isTraining = true;
                    vial.status = 'running';
                    logEvent(`Training started for ${vialId}`, 'success');
                    
                    // Simulate training
                    setTimeout(() => {
                        vial.isTraining = false;
                        vial.wallet.balance += 50;
                        wallet.balance = vials.reduce((sum, v) => sum + v.wallet.balance, 0);
                        updateBalanceDisplay();
                        logEvent(`Training completed for ${vialId}. Earned 50 $WEBXOS`, 'success');
                        updateVialStatusBars();
                    }, 3000);
                    
                    updateVialStatusBars();
                } else {
                    logEvent(`Vial ${vialId} not found`, 'error');
                }
                return;
            }
            
            if (command.startsWith('/stop ')) {
                const vialId = command.split(' ')[1];
                const vial = vials.find(v => v.id === vialId);
                if (vial) {
                    vial.isTraining = false;
                    logEvent(`Training stopped for ${vialId}`, 'warning');
                    updateVialStatusBars();
                } else {
                    logEvent(`Vial ${vialId} not found`, 'error');
                }
                return;
            }
            
            if (command === '/blockchain') {
                logEvent(`Blockchain height: ${blockchain.length}`, 'command');
                if (blockchain.length > 0) {
                    logEvent(`Last block hash: ${blockchain[blockchain.length-1].hash.substring(0, 16)}...`, 'command');
                }
                return;
            }
            
            if (command.startsWith('/decode ')) {
                if (!isAuthenticated) {
                    logEvent('Not authenticated. Please authenticate first.', 'error');
                    return;
                }
                const code = command.substring(8).trim();
                const result = decodeWebXOS(code);
                if (result.success && result.decoded) {
                    const data = parseGameData(result.decoded);
                    const reward = calculateReward(data);
                    distributeReward(reward);
                    logEvent(`Decoded successfully. Rewarded ${reward.toFixed(4)} $WEBXOS to vials.`, 'success');
                    showCertificate(data, result);
                } else {
                    logEvent(result.message, 'error');
                }
                return;
            }
            
            logEvent(`Unknown command: ${command}. Type /help for available commands.`, 'error');
        }
        
        // Decoder functions
        function hexToString(hex) {
            let str = '';
            for (let i = 0; i < hex.length; i += 2) {
                str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
            }
            return str;
        }

        function decodeWebXOS(code) {
            if (!code || typeof code !== 'string' || !code.startsWith('WEBXOS-')) {
                return {
                    success: false,
                    message: "ERROR: Invalid WebXOS code format. Must start with 'WEBXOS-'",
                    decoded: null
                };
            }

            const parts = code.split('-');
            if (parts.length !== 6) {
                return {
                    success: false,
                    message: `ERROR: Invalid code structure. Expected 6 parts, got ${parts.length}`,
                    decoded: null
                };
            }

            const [prefix, timestamp, encodedMessage, random1, random2, checksum] = parts;
            try {
                const decoded = hexToString(encodedMessage);
                const expectedChecksum = (decoded.length * 17).toString(36).toUpperCase().padStart(4, '0');
                if (checksum !== expectedChecksum) {
                    return {
                        success: false,
                        message: `ERROR: Checksum mismatch. Expected ${expectedChecksum}, got ${checksum}`,
                        decoded: null
                    };
                }
                return {
                    success: true,
                    message: `DECODED MESSAGE: ${decoded}`,
                    decoded: decoded,
                    timestamp: parseInt(timestamp, 36)
                };
            } catch (e) {
                return {
                    success: false,
                    message: `ERROR: Decoding failed. ${e.message}`,
                    decoded: null
                };
            }
        }

        function parseGameData(decoded) {
            const data = {};
            const pairs = decoded.split(';');
            pairs.forEach(pair => {
                const [key, value] = pair.split(':');
                if (key && value) {
                    data[key.trim()] = value.trim();
                }
            });
            if (Object.keys(data).length === 0 && !isNaN(parseFloat(decoded))) {
                data.Time = decoded;
                data.WPM = 'N/A';
                data.Lang = 'Unknown';
            }
            return data;
        }

        // Calculate reward from game data
        function calculateReward(data) {
            let reward = 0;
            const game = data.Game || 'Code Crunch';
            if (game === 'Code Crunch') {
                reward = parseFloat(data.WPM || 0) * 0.001 * parseFloat(data.Time || 1);
            } else if (game === 'Arachnid') {
                reward = parseFloat(data.Score || 0) * 0.0001;
            } else if (game === 'Emoji Quest') {
                reward = parseFloat(data.Gold || 0) * 0.001 + parseFloat(data.TotalXP || 0) * 0.0001;
            } else if (game === 'WebX Universe') {
                reward = parseFloat(data.XP || 0) * 0.0001 + parseFloat(data.Resources || 0) * 0.001;
            }
            return Math.max(0, reward);
        }

        // Distribute reward to 4 vials
        function distributeReward(reward) {
            const perVial = reward / 4;
            vials.forEach(vial => {
                vial.wallet.balance += perVial;
            });
            wallet.balance += reward;
            reputation += 1;
            blockchain.push({
                index: blockchain.length,
                hash: generateUUID(),
                timestamp: new Date().toISOString()
            });
            updateBalanceDisplay();
            updateVialStatusBars();
        }

        // Certificate display functions
        function getRandomDigit() {
            return String.fromCharCode(48 + Math.floor(Math.random() * 10));
        }

        function getRandomDirection() {
            return Math.random();
        }

        function wrapScrambleChars(text, isScore = false, isEmoji = false) {
            if (isEmoji) {
                return `<span class="emoji-reward" style="font-size: 40px; text-shadow: 0 0 8px #00ff00, 0 0 12px #00ffcc; margin: 8px 0; display: inline-block;">${text}</span>`;
            }
            const chars = text.split('');
            return chars
                .map((char, index) => `<span class="scramble-char" style="${isScore ? 'font-size: 22px; text-shadow: 0 0 8px #00ff00;' : ''}">${char}</span>`)
                .join('');
        }

        function displayWithScramble(element, text, isScore = false, isEmoji = false) {
            if (isEmoji) {
                element.innerHTML = `<span class="emoji-reward" style="font-size: 40px; text-shadow: 0 0 8px #00ff00, 0 0 12px #00ffcc; margin: 8px 0; display: inline-block;">${text}</span>`;
                return;
            }
            element.innerHTML = wrapScrambleChars(text, isScore, isEmoji);
            const spans = element.querySelectorAll('.scramble-char');
            const chars = text.split('');
            spans.forEach((span, index) => {
                span.textContent = getRandomDigit();
                span.classList.add('dissolving');
                span.style.setProperty('--rand-x', getRandomDirection());
                span.style.setProperty('--rand-y', getRandomDirection());
            });
            let rebuildIndex = 0;
            const rebuildInterval = setInterval(() => {
                if (rebuildIndex >= spans.length) {
                    clearInterval(rebuildInterval);
                    return;
                }
                const span = spans[rebuildIndex];
                span.textContent = chars[rebuildIndex] || ' ';
                span.classList.remove('dissolving');
                span.classList.add('rebuilding');
                span.style.setProperty('--rand-x', getRandomDirection());
                span.style.setProperty('--rand-y', getRandomDirection());
                setTimeout(() => {
                    span.classList.remove('rebuilding');
                }, 1400);
                rebuildIndex++;
            }, 25);
        }

        function showCertificate(data, result) {
            const game = data.Game || 'Code Crunch';
            const certificateTitle = document.getElementById('certificateTitle');
            const certificateContent = document.getElementById('certificateContent');
            const certificate = document.getElementById('certificate');
            const certificateModal = document.getElementById('certificateModal');
            certificateTitle.textContent = '';
            certificateContent.innerHTML = '';
            certificate.classList.remove('spinning');

            displayWithScramble(certificateTitle, game === 'Code Crunch' ? 'Code Crunch Certificate' : game);

            let content = '';
            if (game === 'WebX Universe') {
                content = `
                    <p>Name: ${data.Name || 'Unknown'}</p>
                    <p>Level: ${data.Level || '0'}</p>
                    <p>XP: ${data.XP || '0'}</p>
                    <p>Resources: ${data.Resources || '0'}</p>
                `;
            } else if (game === 'Arachnid') {
                content = `
                    <p class="score-display">Score: ${data.Score || '0'}</p>
                    <p>Time: ${data.TimeElapsed || '0s'}</p>
                    <p><a href="https://arachnid-leaderboard.com">Leaderboard - Coming Soon</a></p>
                `;
            } else if (game === 'Emoji Quest') {
                const emojis = ['', '', '', '', ''];
                const rewardEmoji = emojis[Math.floor(Math.random() * emojis.length)];
                content = `
                    <p class="emoji-reward">${rewardEmoji}</p>
                    <p>Level: ${data.Level || '0'}</p>
                    <p>Gold: ${data.Gold || '0'}</p>
                    <p>Total XP: ${data.TotalXP || '0'}</p>
                    <p>Time: ${data.TimeElapsed || '0s'}</p>
                `;
            } else if (game === 'Code Crunch') {
                const wpm = data.WPM || 'N/A';
                const lang = data.Lang || 'Unknown';
                const time = data.Time || result.decoded;
                content = `
                    <p>Average WPM: ${wpm}</p>
                    <p>Language: ${lang}</p>
                    <p>Total Time: ${time} seconds</p>
                `;
            }

            certificateContent.innerHTML = content;

            // Apply scramble to content
            const paragraphs = certificateContent.querySelectorAll('p');
            paragraphs.forEach(p => {
                const text = p.textContent;
                const isScore = p.classList.contains('score-display');
                const isEmoji = p.classList.contains('emoji-reward');
                if (text) {
                    p.innerHTML = '';
                    displayWithScramble(p, text, isScore, isEmoji);
                }
            });

            // Adjust size
            setTimeout(() => {
                const titleRect = certificateTitle.getBoundingClientRect();
                const contentRect = certificateContent.getBoundingClientRect();
                const padding = 30;
                const newWidth = Math.max(260, titleRect.width + padding * 2);
                const newHeight = Math.max(260, titleRect.height + contentRect.height + padding * 2);
                const maxWidth = 600;
                const maxHeight = 600;

                certificate.style.width = `${Math.min(newWidth, maxWidth)}px`;
                certificate.style.height = `${Math.min(newHeight, maxHeight)}px`;
                document.querySelector('.certificate-container').style.width = `${Math.min(newWidth + 40, maxWidth + 40)}px`;
                document.querySelector('.certificate-container').style.height = `${Math.min(newHeight + 40, maxHeight + 40)}px`;
            }, 100);

            certificateModal.style.display = 'flex';
        }

        // Certificate event listeners
        document.getElementById('certificate').addEventListener('click', () => {
            const certificate = document.getElementById('certificate');
            const certificateTitle = document.getElementById('certificateTitle');
            const certificateContent = document.getElementById('certificateContent');
            certificate.classList.remove('spinning');
            void certificate.offsetWidth;
            certificate.classList.add('spinning');

            const titleText = certificateTitle.textContent;
            displayWithScramble(certificateTitle, titleText);
            const paragraphs = certificateContent.querySelectorAll('p');
            paragraphs.forEach(p => {
                const text = p.textContent;
                p.innerHTML = '';
                const isScore = p.classList.contains('score-display');
                const isEmoji = p.classList.contains('emoji-reward');
                displayWithScramble(p, text, isScore, isEmoji);
            });
        });

        document.getElementById('certificateModal').addEventListener('click', (e) => {
            if (e.target === document.getElementById('certificateModal')) {
                document.getElementById('certificateModal').style.display = 'none';
                document.getElementById('certificate').classList.remove('spinning');
            }
        });
        
        // FPS and performance monitoring
        function updatePerformanceMetrics() {
            const now = performance.now();
            frameCount++;
            
            if (now >= fpsUpdateTime + 1000) {
                fps = frameCount;
                frameCount = 0;
                fpsUpdateTime = now;
                
                // Update global latency (simulated)
                latency = Math.max(5, Math.min(200, latency + (Math.random() - 0.5) * 5));
                
                // Update vial metrics
                vials.forEach(vial => {
                    vial.fps = Math.max(30, Math.min(120, vial.fps + (Math.random() - 0.5) * 2));
                    vial.latency = Math.max(5, Math.min(200, vial.latency + (Math.random() - 0.5) * 5));
                });
                
                updateVialStatusBars();
            }
            
            lastUpdateTime = now;
            requestAnimationFrame(updatePerformanceMetrics);
        }
        
        // Neurot particle system
        function createNeurotParticles() {
            const neurotCount = 30;
            const neurotContainer = document.createElement('div');
            neurotContainer.id = 'neurot-container';
            document.body.appendChild(neurotContainer);
            
            for (let i = 0; i < neurotCount; i++) {
                createNeurot();
            }
            
            function createNeurot() {
                const neurot = document.createElement('div');
                neurot.className = 'neurot';
                
                const x = Math.random() * window.innerWidth;
                const y = Math.random() * window.innerHeight;
                const size = Math.random() * 3 + 1;
                const opacity = Math.random() * 0.5 + 0.3;
                
                neurot.style.left = `${x}px`;
                neurot.style.top = `${y}px`;
                neurot.style.width = `${size}px`;
                neurot.style.height = `${size}px`;
                neurot.style.opacity = opacity;
                
                neurotContainer.appendChild(neurot);
                animateNeurot(neurot);
            }
            
            function animateNeurot(neurot) {
                let x = parseFloat(neurot.style.left);
                let y = parseFloat(neurot.style.top);
                
                const xSpeed = (Math.random() - 0.5) * 0.3;
                const ySpeed = (Math.random() - 0.5) * 0.3;
                
                function move() {
                    x += xSpeed;
                    y += ySpeed;
                    
                    if (x > window.innerWidth) x = 0;
                    if (x < 0) x = window.innerWidth;
                    if (y > window.innerHeight) y = 0;
                    if (y < 0) y = window.innerHeight;
                    
                    neurot.style.left = `${x}px`;
                    neurot.style.top = `${y}px`;
                    
                    requestAnimationFrame(move);
                }
                
                move();
            }
        }
        
        // UUID generator
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
                const r = Math.random() * 16 | 0;
                return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
            });
        }
        
        // Initialize the application
        function initialize() {
            createNeurotParticles();
            initializeVials();
            updateVialStatusBars();
            updatePerformanceMetrics();
            
            // Set up event listeners
            document.getElementById('authButton').addEventListener('click', authenticate);
            document.getElementById('voidButton').addEventListener('click', voidVials);
            document.getElementById('quantumLinkButton').addEventListener('click', quantumLink);
            document.getElementById('exportButton').addEventListener('click', exportVials);
            document.getElementById('importButton').addEventListener('click', importFile);
            document.getElementById('apiAccessButton').addEventListener('click', apiAccess);
            document.getElementById('donateButton').addEventListener('click', donate);
            document.getElementById('donate-close').addEventListener('click', closeDonatePopup);
            document.getElementById('file-input').addEventListener('change', handleFileImport);
            document.getElementById('send-button').addEventListener('click', handleCommand);
            document.getElementById('prompt-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleCommand();
                }
            });
            
            logEvent('WebXOS DECODER initialized successfully', 'success');
            logEvent('Type /help for available commands', 'command');
        }
        
        // Start the application when the page loads
        window.addEventListener('load', initialize);
    </script>
</body>
</html>
