<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IONICSPHERE - by webXOS</title>
    
    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gpu.js@latest/dist/gpu-browser.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #000000;
            color: #00ff00;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        /* Header */
        #header {
            background: rgba(0, 20, 0, 0.95);
            border-bottom: 2px solid #00ff00;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            height: 60px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }
        
        .logo {
            font-size: 24px;
            font-weight: bold;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
            letter-spacing: 2px;
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .live-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff0000;
            box-shadow: 0 0 10px #ff0000;
            animation: pulse 1s infinite;
        }
        
        .live-dot.active {
            background: #00ff00;
            box-shadow: 0 0 15px #00ff00;
        }
        
        .header-buttons {
            display: flex;
            gap: 10px;
        }
        
        .header-btn {
            background: transparent;
            border: 1px solid #00ff00;
            color: #00ff00;
            padding: 8px 15px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .header-btn:hover {
            background: rgba(0, 255, 0, 0.1);
            box-shadow: 0 0 10px #00ff00;
        }
        
        .header-btn.active {
            background: rgba(0, 255, 0, 0.2);
            box-shadow: 0 0 15px #00ff00;
            animation: neonPulse 1.5s infinite alternate;
        }
        
        /* Main Content */
        #main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        /* Terminal */
        #terminal-container {
            flex: 0 0 500px;
            background: rgba(0, 10, 0, 0.95);
            border-right: 2px solid #00ff00;
            display: flex;
            flex-direction: column;
            z-index: 10;
            box-shadow: 5px 0 15px rgba(0, 255, 0, 0.2);
        }
        
        #terminal {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .terminal-line {
            margin-bottom: 5px;
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        .terminal-line.prompt {
            color: #00ff00;
        }
        
        .terminal-line.output {
            color: #00cc00;
        }
        
        .terminal-line.system {
            color: #00ffff;
        }
        
        .terminal-line.error {
            color: #ff0000;
        }
        
        .terminal-line.warning {
            color: #ffff00;
        }
        
        .terminal-line.success {
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
        }
        
        .terminal-input {
            background: rgba(0, 20, 0, 0.8);
            border: 1px solid #00ff00;
            border-left: none;
            border-right: none;
            border-bottom: none;
            padding: 15px 20px;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            width: 100%;
            outline: none;
        }
        
        .terminal-input:focus {
            background: rgba(0, 30, 0, 0.9);
            box-shadow: inset 0 0 10px rgba(0, 255, 0, 0.3);
        }
        
        /* Visualization */
        #visualization {
            flex: 1;
            position: relative;
            background: #000;
        }
        
        #threeCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }
        
        /* Stats Panel */
        #stats-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 20, 0, 0.9);
            border: 2px solid #00ff00;
            padding: 15px;
            font-size: 12px;
            width: 300px;
            z-index: 5;
            backdrop-filter: blur(5px);
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 6px 0;
            padding: 3px 0;
            border-bottom: 1px solid rgba(0, 255, 0, 0.1);
        }
        
        .stat-label {
            color: #00cc00;
        }
        
        .stat-value {
            color: #00ff00;
            font-weight: bold;
        }
        
        /* Training Panel */
        #training-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 20, 0, 0.9);
            border: 2px solid #00ff00;
            padding: 15px;
            font-size: 12px;
            width: 350px;
            z-index: 5;
            backdrop-filter: blur(5px);
        }
        
        .training-progress {
            width: 100%;
            height: 10px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ff00;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .training-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00cc00);
            width: 0%;
            transition: width 0.5s ease-out;
        }
        
        /* Animations */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @keyframes neonPulse {
            0% { box-shadow: 0 0 10px #00ff00; }
            100% { box-shadow: 0 0 20px #00ff00, 0 0 30px #00ff00; }
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }
        
        .cursor {
            animation: blink 1s infinite;
        }
        
        /* Scrollbar */
        #terminal::-webkit-scrollbar {
            width: 10px;
        }
        
        #terminal::-webkit-scrollbar-track {
            background: rgba(0, 20, 0, 0.5);
        }
        
        #terminal::-webkit-scrollbar-thumb {
            background: #00ff00;
            border-radius: 5px;
        }
        
        /* Model Status */
        .model-status {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 11px;
            margin-left: 5px;
        }
        
        .status-training {
            background: rgba(255, 255, 0, 0.2);
            color: #ffff00;
        }
        
        .status-ready {
            background: rgba(0, 255, 0, 0.2);
            color: #00ff00;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div id="header">
        <div class="logo">IONICSPHERE</div>
        
        <div class="status-indicator">
            <div class="live-dot" id="liveDot"></div>
            <span id="statusText">INITIALIZING</span>
        </div>
        
        <div class="header-buttons">
            <button class="header-btn" onclick="runSimulation()" id="runBtn">â–¶ RUN SIM</button>
            <button class="header-btn" onclick="toggleTraining()" id="trainBtn">ðŸ§  TRAIN</button>
            <button class="header-btn" onclick="exportEverything()">ðŸ“¦ EXPORT ALL</button>
        </div>
    </div>
    
    <!-- Main Content -->
    <div id="main-content">
        <!-- Terminal -->
        <div id="terminal-container">
            <div id="terminal">
                <div class="terminal-line system">========================================</div>
                <div class="terminal-line system">  IONICSPHERE by webXOS v7.0</div>
                <div class="terminal-line system">  Three Js Ionic Ocean Simulator</div>
                <div class="terminal-line system">========================================</div>
                <div class="terminal-line output">Initializing quantum simulation matrix...</div>
                <div class="terminal-line output">Loading TensorFlow.js neural kernel...</div>
                <div class="terminal-line output">Generating 10,240 synthetic ions...</div>
                <div class="terminal-line output">Type 'help' for available commands</div>
                <div class="terminal-line prompt">$ <span id="currentLine"></span><span class="cursor">â–ˆ</span></div>
            </div>
            <input type="text" id="commandInput" class="terminal-input" placeholder="Type command (help, train, export, clear, status, reset)...">
        </div>
        
        <!-- Visualization -->
        <div id="visualization">
            <canvas id="threeCanvas"></canvas>
            
            <!-- Training Panel -->
            <div id="training-panel">
                <div class="stat-row">
                    <span class="stat-label">TRAINING:</span>
                    <span class="stat-value" id="trainingStatus">IDLE</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">EPOCH:</span>
                    <span class="stat-value" id="epochDisplay">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">LOSS:</span>
                    <span class="stat-value" id="lossDisplay">0.0000</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">ACCURACY:</span>
                    <span class="stat-value" id="accuracyDisplay">0.0%</span>
                </div>
                <div class="training-progress">
                    <div id="trainingProgress" class="training-progress-fill"></div>
                </div>
                <div class="stat-row">
                    <span class="stat-label">BATCH SIZE:</span>
                    <span class="stat-value" id="batchDisplay">32</span>
                </div>
            </div>
            
            <!-- Stats Panel -->
            <div id="stats-panel">
                <div class="stat-row">
                    <span class="stat-label">SIMULATION:</span>
                    <span class="stat-value" id="simStatus">PAUSED</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">FPS:</span>
                    <span class="stat-value" id="fpsCounter">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">IONS:</span>
                    <span class="stat-value" id="ionCount">10,240</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">SIM TIME:</span>
                    <span class="stat-value" id="simTime">0.0s</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">CAPTURED DATA:</span>
                    <span class="stat-value" id="dataCount">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">GPU ACCEL:</span>
                    <span class="stat-value" id="gpuStatus">ACTIVE</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==================== GLOBAL STATE ====================
        let simulationRunning = false;
        let trainingActive = false;
        let animationId = null;
        let trainingAnimationId = null;
        let simulationTime = 0;
        let lastFrameTime = performance.now();
        let frameCount = 0;
        let fps = 0;
        let epochCount = 0;
        let trainingLoss = 0;
        let trainingAccuracy = 0;
        let currentBatch = 0;
        
        // Real-time data collection
        let capturedData = {
            positions: [],
            velocities: [],
            trainingLog: [],
            frames: [],
            modelStates: [],
            timestamps: []
        };
        
        // TensorFlow.js Model
        let tfModel = null;
        let trainingData = [];
        let validationData = [];
        
        // Three.js components
        let scene, camera, renderer, controls, particles, ocean;
        let particleCount = 10240;
        
        // Command history
        let commandHistory = [];
        let historyIndex = -1;
        
        // GPU.js kernel for physics
        let gpu = new GPU();
        let physicsKernel = null;
        
        // ==================== TENSORFLOW.JS MODEL ====================
        async function createNeuralModel() {
            printLine('[TENSORFLOW] Creating neural network...', 'system');
            
            try {
                // Create a model for predicting ion stability
                tfModel = tf.sequential();
                
                // Input: 5 features (position xyz + velocity xy)
                tfModel.add(tf.layers.dense({
                    units: 32,
                    inputShape: [5],
                    activation: 'relu',
                    kernelInitializer: 'heNormal'
                }));
                
                tfModel.add(tf.layers.dropout({rate: 0.2}));
                
                tfModel.add(tf.layers.dense({
                    units: 16,
                    activation: 'relu'
                }));
                
                tfModel.add(tf.layers.dense({
                    units: 8,
                    activation: 'relu'
                }));
                
                // Output: stability prediction (0-1)
                tfModel.add(tf.layers.dense({
                    units: 1,
                    activation: 'sigmoid'
                }));
                
                // Compile model
                tfModel.compile({
                    optimizer: tf.train.adam(0.001),
                    loss: 'binaryCrossentropy',
                    metrics: ['accuracy']
                });
                
                printLine('[TENSORFLOW] Model created successfully', 'success');
                printLine('[TENSORFLOW] Architecture: 5â†’32â†’16â†’8â†’1', 'output');
                printLine('[TENSORFLOW] Optimizer: Adam (0.001)', 'output');
                
                return true;
            } catch (error) {
                printLine(`[TENSORFLOW] Error: ${error.message}`, 'error');
                return false;
            }
        }
        
        async function generateTrainingData() {
            printLine('[DATA] Generating synthetic training data...', 'system');
            
            trainingData = [];
            validationData = [];
            
            // Generate 1000 synthetic samples
            for (let i = 0; i < 1000; i++) {
                const features = [
                    Math.random(), // position x
                    Math.random(), // position y
                    Math.random(), // position z
                    (Math.random() - 0.5) * 2, // velocity x
                    (Math.random() - 0.5) * 2  // velocity y
                ];
                
                // Label: 1 if stable (based on position and velocity), 0 if unstable
                const stability = (features[1] > 0.3 && Math.abs(features[3]) < 0.5) ? 1 : 0;
                
                if (i < 800) {
                    trainingData.push({features, label: stability});
                } else {
                    validationData.push({features, label: stability});
                }
            }
            
            printLine(`[DATA] Generated ${trainingData.length} training samples`, 'success');
            printLine(`[DATA] Generated ${validationData.length} validation samples`, 'success');
        }
        
        async function trainModelStep() {
            if (!tfModel || !trainingActive || trainingData.length === 0) return;
            
            try {
                // Prepare batch data
                const batchSize = 32;
                const batchStart = currentBatch * batchSize;
                const batchEnd = Math.min(batchStart + batchSize, trainingData.length);
                
                if (batchStart >= trainingData.length) {
                    currentBatch = 0;
                    epochCount++;
                    printLine(`[TRAINING] Epoch ${epochCount} completed`, 'system');
                    updateTrainingUI();
                    return;
                }
                
                const batchData = trainingData.slice(batchStart, batchEnd);
                
                // Convert to tensors
                const features = batchData.map(d => d.features);
                const labels = batchData.map(d => d.label);
                
                const xs = tf.tensor2d(features);
                const ys = tf.tensor2d(labels, [labels.length, 1]);
                
                // Train for one step
                const history = await tfModel.fit(xs, ys, {
                    batchSize: batchSize,
                    epochs: 1,
                    shuffle: true,
                    verbose: 0
                });
                
                // Update metrics
                const loss = history.history.loss[0];
                const accuracy = history.history.acc ? history.history.acc[0] : 0;
                
                trainingLoss = loss;
                trainingAccuracy = accuracy;
                
                // Store training log
                capturedData.trainingLog.push({
                    epoch: epochCount,
                    batch: currentBatch,
                    loss: loss,
                    accuracy: accuracy,
                    timestamp: Date.now()
                });
                
                // Update UI
                updateTrainingUI();
                
                // Cleanup
                xs.dispose();
                ys.dispose();
                
                currentBatch++;
                
            } catch (error) {
                printLine(`[TRAINING] Error: ${error.message}`, 'error');
            }
        }
        
        function updateTrainingUI() {
            document.getElementById('trainingStatus').textContent = trainingActive ? 'TRAINING' : 'IDLE';
            document.getElementById('epochDisplay').textContent = epochCount;
            document.getElementById('lossDisplay').textContent = trainingLoss.toFixed(4);
            document.getElementById('accuracyDisplay').textContent = (trainingAccuracy * 100).toFixed(1) + '%';
            document.getElementById('batchDisplay').textContent = currentBatch;
            
            const progress = ((currentBatch * 32) / trainingData.length) * 100;
            document.getElementById('trainingProgress').style.width = progress + '%';
        }
        
        // ==================== REAL-TIME DATA CAPTURE ====================
        function captureFrameData() {
            if (!particles || !simulationRunning) return;
            
            const positions = particles.geometry.attributes.position.array;
            const velocities = particles.userData.velocities;
            
            // Capture every 60 frames (~1 second at 60fps)
            if (frameCount % 60 === 0) {
                capturedData.positions.push(Float32Array.from(positions));
                capturedData.velocities.push(Float32Array.from(velocities));
                capturedData.timestamps.push(Date.now());
                capturedData.modelStates.push({
                    epoch: epochCount,
                    loss: trainingLoss,
                    accuracy: trainingAccuracy
                });
                
                document.getElementById('dataCount').textContent = capturedData.positions.length;
                
                if (capturedData.positions.length % 10 === 0) {
                    printLine(`[CAPTURE] Stored ${capturedData.positions.length} data frames`, 'system');
                }
            }
        }
        
        function captureThreeJSFrame() {
            if (!renderer) return;
            
            const canvas = document.getElementById('threeCanvas');
            const dataURL = canvas.toDataURL('image/png');
            
            capturedData.frames.push({
                timestamp: Date.now(),
                epoch: epochCount,
                dataURL: dataURL,
                metrics: {
                    loss: trainingLoss,
                    accuracy: trainingAccuracy,
                    fps: fps
                }
            });
            
            printLine(`[CAPTURE] Screenshot captured (epoch ${epochCount})`, 'system');
        }
        
        // ==================== THREE.JS SIMULATION ====================
        async function initThreeJS() {
            printLine('[THREE.JS] Initializing 3D visualization...', 'system');
            
            try {
                // Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000022);
                
                // Camera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 50, 100);
                
                // Renderer
                const canvas = document.getElementById('threeCanvas');
                renderer = new THREE.WebGLRenderer({ 
                    canvas, 
                    antialias: true,
                    powerPreference: "high-performance"
                });
                renderer.setSize(canvas.clientWidth, canvas.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                
                // Controls
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0x0044aa, 0.5);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0x00ffff, 0.8);
                directionalLight.position.set(10, 20, 15);
                scene.add(directionalLight);
                
                // Create ocean
                createOcean();
                
                // Create particles
                createIons();
                
                // Initialize GPU.js kernel for physics
                initPhysicsKernel();
                
                printLine('[THREE.JS] Visualization ready', 'success');
                return true;
                
            } catch (error) {
                printLine(`[THREE.JS] Error: ${error.message}`, 'error');
                return false;
            }
        }
        
        function createOcean() {
            const geometry = new THREE.PlaneGeometry(200, 200, 64, 64);
            const material = new THREE.MeshPhongMaterial({
                color: 0x0066ff,
                transparent: true,
                opacity: 0.7,
                wireframe: false
            });
            
            ocean = new THREE.Mesh(geometry, material);
            ocean.rotation.x = -Math.PI / 2;
            scene.add(ocean);
        }
        
        function createIons() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // Distribute in a sphere
                const radius = 50 + Math.random() * 30;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = radius * Math.cos(phi);
                
                // Color coding based on position
                colors[i3] = 0.2 + positions[i3] / 100;
                colors[i3 + 1] = 0.4 + positions[i3 + 1] / 100;
                colors[i3 + 2] = 0.8 + positions[i3 + 2] / 100;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 2.0,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            
            particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            // Store velocities
            particles.userData.velocities = new Float32Array(particleCount * 3);
            particles.userData.originalPositions = positions.slice();
            
            for (let i = 0; i < particleCount * 3; i++) {
                particles.userData.velocities[i] = (Math.random() - 0.5) * 0.2;
            }
            
            printLine(`[IONS] Created ${particleCount.toLocaleString()} particles`, 'success');
        }
        
        function initPhysicsKernel() {
            try {
                physicsKernel = gpu.createKernel(function(positions, velocities, time) {
                    const i = this.thread.x * 3;
                    
                    // Brownian motion with time-based variation
                    const noise = Math.sin(time + positions[i]) * 0.05;
                    
                    return [
                        positions[i] + velocities[i] + noise,
                        positions[i + 1] + velocities[i + 1] + noise,
                        positions[i + 2] + velocities[i + 2] + noise
                    ];
                }).setOutput([particleCount]);
                
                printLine('[GPU.JS] Physics kernel initialized', 'success');
            } catch (error) {
                printLine('[GPU.JS] Using CPU fallback for physics', 'warning');
                physicsKernel = null;
            }
        }
        
        function updateSimulation(deltaTime) {
            if (!simulationRunning || !particles || !ocean) return;
            
            simulationTime += deltaTime;
            
            // Update FPS counter
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastFrameTime >= 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastFrameTime));
                frameCount = 0;
                lastFrameTime = currentTime;
                
                document.getElementById('fpsCounter').textContent = fps;
                document.getElementById('simTime').textContent = simulationTime.toFixed(1) + 's';
            }
            
            // Update ocean waves
            updateOcean(deltaTime);
            
            // Update ions using GPU.js if available
            updateIons(deltaTime);
            
            // Capture real-time data
            captureFrameData();
            
            // Update controls
            controls.update();
        }
        
        function updateOcean(deltaTime) {
            const positionAttribute = ocean.geometry.attributes.position;
            const time = simulationTime;
            
            for (let i = 0; i < positionAttribute.count; i++) {
                const i3 = i * 3;
                const x = positionAttribute.array[i3];
                const z = positionAttribute.array[i3 + 2];
                
                const wave = Math.sin(x * 0.05 + time) * 2 +
                            Math.cos(z * 0.03 + time * 0.7) * 1.5;
                
                positionAttribute.array[i3 + 1] = wave;
            }
            
            positionAttribute.needsUpdate = true;
        }
        
        function updateIons(deltaTime) {
            const positions = particles.geometry.attributes.position.array;
            const velocities = particles.userData.velocities;
            
            if (physicsKernel) {
                // Use GPU.js for physics
                try {
                    const result = physicsKernel(positions, velocities, simulationTime);
                    
                    for (let i = 0; i < particleCount; i++) {
                        const i3 = i * 3;
                        const newPos = result[i];
                        
                        positions[i3] = newPos[0];
                        positions[i3 + 1] = newPos[1];
                        positions[i3 + 2] = newPos[2];
                        
                        // Add restoring force toward center
                        const dx = positions[i3];
                        const dy = positions[i3 + 1];
                        const dz = positions[i3 + 2];
                        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        
                        if (distance > 80) {
                            const force = 0.01;
                            velocities[i3] -= dx * force;
                            velocities[i3 + 1] -= dy * force;
                            velocities[i3 + 2] -= dz * force;
                        }
                    }
                } catch (error) {
                    // Fallback to CPU
                    updateIonsCPU(deltaTime);
                }
            } else {
                updateIonsCPU(deltaTime);
            }
            
            particles.geometry.attributes.position.needsUpdate = true;
        }
        
        function updateIonsCPU(deltaTime) {
            const positions = particles.geometry.attributes.position.array;
            const velocities = particles.userData.velocities;
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // Brownian motion
                velocities[i3] += (Math.random() - 0.5) * 0.1 * deltaTime;
                velocities[i3 + 1] += (Math.random() - 0.5) * 0.1 * deltaTime;
                velocities[i3 + 2] += (Math.random() - 0.5) * 0.1 * deltaTime;
                
                // Damping
                velocities[i3] *= 0.99;
                velocities[i3 + 1] *= 0.99;
                velocities[i3 + 2] *= 0.99;
                
                // Update positions
                positions[i3] += velocities[i3] * deltaTime * 30;
                positions[i3 + 1] += velocities[i3 + 1] * deltaTime * 30;
                positions[i3 + 2] += velocities[i3 + 2] * deltaTime * 30;
                
                // Keep within bounds
                const radius = Math.sqrt(
                    positions[i3] * positions[i3] +
                    positions[i3 + 1] * positions[i3 + 1] +
                    positions[i3 + 2] * positions[i3 + 2]
                );
                
                if (radius > 80) {
                    velocities[i3] *= -0.5;
                    velocities[i3 + 1] *= -0.5;
                    velocities[i3 + 2] *= -0.5;
                }
            }
        }
        
        // ==================== ANIMATION LOOP ====================
        function animationLoop() {
            const currentTime = performance.now();
            const deltaTime = (currentTime - (scene.userData.lastTime || currentTime)) / 1000;
            scene.userData.lastTime = currentTime;
            
            updateSimulation(deltaTime);
            
            if (trainingActive) {
                trainModelStep();
            }
            
            renderer.render(scene, camera);
            animationId = requestAnimationFrame(animationLoop);
        }
        
        // ==================== COMMAND LINE INTERFACE ====================
        function printLine(text, type = 'output') {
            const line = document.createElement('div');
            line.className = `terminal-line ${type}`;
            line.textContent = text;
            document.getElementById('terminal').appendChild(line);
            scrollTerminal();
        }
        
        function printPrompt() {
            const prompt = document.createElement('div');
            prompt.className = 'terminal-line prompt';
            prompt.innerHTML = '$ <span id="currentLine"></span><span class="cursor">â–ˆ</span>';
            document.getElementById('terminal').appendChild(prompt);
            scrollTerminal();
        }
        
        function scrollTerminal() {
            const terminal = document.getElementById('terminal');
            terminal.scrollTop = terminal.scrollHeight;
        }
        
        function clearTerminal() {
            document.getElementById('terminal').innerHTML = '';
            printLine('[SYSTEM] Terminal cleared', 'system');
            printPrompt();
        }
        
        function showHelp() {
            printLine('Available commands:', 'system');
            printLine('  help          - Show this help message');
            printLine('  run           - Start simulation');
            printLine('  pause         - Pause simulation');
            printLine('  train [epochs]- Toggle/start training (optional epochs)');
            printLine('  stop          - Stop training');
            printLine('  capture       - Capture screenshot');
            printLine('  status        - Show system status');
            printLine('  export        - Export all data as ZIP');
            printLine('  clear         - Clear terminal');
            printLine('  reset         - Reset simulation');
        }
        
        function handleCommand(command) {
            const parts = command.trim().split(' ');
            const cmd = parts[0].toLowerCase();
            const args = parts.slice(1);
            
            switch(cmd) {
                case 'help':
                    showHelp();
                    break;
                    
                case 'run':
                    runSimulation();
                    break;
                    
                case 'pause':
                    pauseSimulation();
                    break;
                    
                case 'train':
                    if (args[0]) {
                        printLine(`[TRAINING] Training for ${args[0]} epochs...`, 'system');
                    }
                    toggleTraining();
                    break;
                    
                case 'stop':
                    toggleTraining(false);
                    break;
                    
                case 'capture':
                    captureThreeJSFrame();
                    break;
                    
                case 'status':
                    showStatus();
                    break;
                    
                case 'export':
                    exportEverything();
                    break;
                    
                case 'clear':
                    clearTerminal();
                    break;
                    
                case 'reset':
                    resetSimulation();
                    break;
                    
                case 'model':
                    printLine(`[MODEL] Architecture: 5â†’32â†’16â†’8â†’1`, 'system');
                    printLine(`[MODEL] Epochs: ${epochCount}`, 'output');
                    printLine(`[MODEL] Loss: ${trainingLoss.toFixed(4)}`, 'output');
                    printLine(`[MODEL] Accuracy: ${(trainingAccuracy * 100).toFixed(1)}%`, 'output');
                    break;
                    
                case 'data':
                    printLine(`[DATA] Captured frames: ${capturedData.positions.length}`, 'system');
                    printLine(`[DATA] Training samples: ${trainingData.length}`, 'output');
                    printLine(`[DATA] Validation samples: ${validationData.length}`, 'output');
                    break;
                    
                case '':
                    // Empty command
                    break;
                    
                default:
                    printLine(`Command not found: ${cmd}. Type 'help' for available commands.`, 'error');
                    break;
            }
        }
        
        function showStatus() {
            printLine('=== SYSTEM STATUS ===', 'system');
            printLine(`Simulation: ${simulationRunning ? 'RUNNING' : 'PAUSED'}`);
            printLine(`Training: ${trainingActive ? 'ACTIVE' : 'INACTIVE'}`);
            printLine(`Epochs: ${epochCount}`);
            printLine(`Loss: ${trainingLoss.toFixed(4)}`);
            printLine(`Accuracy: ${(trainingAccuracy * 100).toFixed(1)}%`);
            printLine(`FPS: ${fps}`);
            printLine(`Sim Time: ${simulationTime.toFixed(1)}s`);
            printLine(`Ions: ${particleCount.toLocaleString()}`);
            printLine(`Captured Data: ${capturedData.positions.length} frames`);
        }
        
        // ==================== SIMULATION CONTROL ====================
        function runSimulation() {
            if (!simulationRunning) {
                simulationRunning = true;
                document.getElementById('runBtn').classList.add('active');
                document.getElementById('liveDot').classList.add('active');
                document.getElementById('statusText').textContent = 'RUNNING';
                document.getElementById('simStatus').textContent = 'RUNNING';
                
                if (!animationId) {
                    scene.userData.lastTime = performance.now();
                    animationId = requestAnimationFrame(animationLoop);
                }
                
                printLine('[SIMULATION] Started real-time quantum simulation', 'success');
            }
        }
        
        function pauseSimulation() {
            simulationRunning = false;
            document.getElementById('runBtn').classList.remove('active');
            document.getElementById('liveDot').classList.remove('active');
            document.getElementById('statusText').textContent = 'PAUSED';
            document.getElementById('simStatus').textContent = 'PAUSED';
            
            printLine('[SIMULATION] Paused', 'system');
        }
        
        function toggleTraining(start = true) {
            if (start && !trainingActive) {
                trainingActive = true;
                document.getElementById('trainBtn').classList.add('active');
                printLine('[TRAINING] Started real-time neural training', 'success');
                printLine('[TRAINING] Using live particle data as input', 'output');
            } else if (!start && trainingActive) {
                trainingActive = false;
                document.getElementById('trainBtn').classList.remove('active');
                printLine('[TRAINING] Stopped', 'system');
            } else {
                trainingActive = !trainingActive;
                document.getElementById('trainBtn').classList.toggle('active');
                printLine(`[TRAINING] ${trainingActive ? 'Started' : 'Stopped'}`, 'system');
            }
            
            updateTrainingUI();
        }
        
        function resetSimulation() {
            simulationRunning = false;
            trainingActive = false;
            simulationTime = 0;
            epochCount = 0;
            trainingLoss = 0;
            trainingAccuracy = 0;
            currentBatch = 0;
            
            document.getElementById('runBtn').classList.remove('active');
            document.getElementById('trainBtn').classList.remove('active');
            document.getElementById('liveDot').classList.remove('active');
            document.getElementById('statusText').textContent = 'STANDBY';
            document.getElementById('simStatus').textContent = 'STANDBY';
            
            // Reset particles
            if (particles && particles.userData.originalPositions) {
                const positions = particles.geometry.attributes.position.array;
                const original = particles.userData.originalPositions;
                for (let i = 0; i < positions.length; i++) {
                    positions[i] = original[i];
                }
                particles.geometry.attributes.position.needsUpdate = true;
            }
            
            capturedData = {
                positions: [],
                velocities: [],
                trainingLog: [],
                frames: [],
                modelStates: [],
                timestamps: []
            };
            
            updateTrainingUI();
            document.getElementById('dataCount').textContent = '0';
            
            printLine('[SYSTEM] Full reset complete', 'system');
        }
        
        // ==================== EXPORT SYSTEM ====================
        async function exportEverything() {
            printLine('[EXPORT] Creating unified package...', 'system');
            
            try {
                const zip = new JSZip();
                
                // 1. Model metadata
                const modelMetadata = {
                    name: "IonicQuantumSimulator_v7.0",
                    version: "7.0",
                    export_date: new Date().toISOString(),
                    epochs_trained: epochCount,
                    final_loss: trainingLoss,
                    final_accuracy: trainingAccuracy,
                    particle_count: particleCount,
                    simulation_time: simulationTime,
                    features: ["position_x", "position_y", "position_z", "velocity_x", "velocity_y"],
                    architecture: "5â†’32â†’16â†’8â†’1",
                    optimizer: "adam",
                    learning_rate: 0.001,
                    batch_size: 32
                };
                zip.file("model_metadata.json", JSON.stringify(modelMetadata, null, 2));
                
                // 2. Training log
                zip.file("training_log.json", JSON.stringify(capturedData.trainingLog, null, 2));
                
                // 3. Captured particle data (compressed)
                const particleData = {
                    metadata: {
                        frames: capturedData.positions.length,
                        particles_per_frame: particleCount,
                        total_positions: capturedData.positions.length * particleCount * 3,
                        timestamps: capturedData.timestamps
                    },
                    positions: capturedData.positions.map(arr => Array.from(arr)),
                    velocities: capturedData.velocities.map(arr => Array.from(arr)),
                    model_states: capturedData.modelStates
                };
                zip.file("particle_data.json", JSON.stringify(particleData, null, 2));
                
                // 4. Screenshots
                if (capturedData.frames.length > 0) {
                    const framesFolder = zip.folder("screenshots");
                    capturedData.frames.forEach((frame, index) => {
                        const base64Data = frame.dataURL.split(',')[1];
                        framesFolder.file(`frame_${index}_epoch_${frame.epoch}.png`, base64Data, {base64: true});
                    });
                }
                
                // 5. TensorFlow.js model weights
                if (tfModel) {
                    const weights = await tfModel.save(tf.io.withSaveHandler(async (artifacts) => {
                        const weightData = {
                            modelTopology: artifacts.modelTopology,
                            weightSpecs: artifacts.weightSpecs,
                            weightData: Array.from(new Uint8Array(artifacts.weightData))
                        };
                        return weightData;
                    }));
                    
                    zip.file("tfjs_model/model.json", JSON.stringify(weights.modelTopology, null, 2));
                    zip.file("tfjs_model/weights.bin", new Blob([new Uint8Array(weights.weightData)]));
                }
                
                // 6. README with model card
                const readme = generateReadme();
                zip.file("README.md", readme);
                
                // 7. Terminal log
                const terminalContent = document.getElementById('terminal').innerText;
                zip.file("terminal_log.txt", terminalContent);
                
                // 8. Configuration file
                const config = {
                    simulation: {
                        ion_count: particleCount,
                        ocean_size: 200,
                        time_step: 0.016,
                        physics_engine: physicsKernel ? "GPU.js" : "CPU"
                    },
                    neural_network: {
                        input_shape: [5],
                        output_shape: [1],
                        layers: [32, 16, 8],
                        activation: "relu",
                        output_activation: "sigmoid"
                    },
                    export_info: {
                        version: "7.0",
                        format: "JSON/ZIP",
                        total_size: "varies",
                        compatible_with: "TensorFlow.js, Three.js"
                    }
                };
                zip.file("config.json", JSON.stringify(config, null, 2));
                
                // Generate and download
                const content = await zip.generateAsync({type: "blob"});
                const filename = `ionicsphere_export_v7.0_${Date.now()}.zip`;
                saveAs(content, filename);
                
                printLine(`[EXPORT] Package created: ${filename}`, 'success');
                printLine(`[EXPORT] Files: 8, Size: ${Math.round(content.size / 1024 / 1024 * 10) / 10}MB`, 'output');
                printLine('[EXPORT] Includes: model, data, screenshots, logs', 'output');
                
            } catch (error) {
                printLine(`[EXPORT] Error: ${error.message}`, 'error');
            }
        }
        
        function generateReadme() {
            return `# Ionic Sphere Quantum Simulator v7.0
## Real-Time Neural Training System

**Model Name:** IonicQuantumSimulator_v7.0
**Version:** 7.0
**Export Date:** ${new Date().toISOString()}

### Training Summary
- **Total Epochs:** ${epochCount}
- **Final Loss:** ${trainingLoss.toFixed(4)}
- **Final Accuracy:** ${(trainingAccuracy * 100).toFixed(1)}%
- **Training Samples:** ${trainingData.length}
- **Simulation Time:** ${simulationTime.toFixed(1)}s

### Dataset Information
This package contains real-time captured data from the quantum ionic simulation:

**Particle Data:**
- Frames captured: ${capturedData.positions.length}
- Particles per frame: ${particleCount}
- Total position samples: ${capturedData.positions.length * particleCount * 3}
- Time range: ${capturedData.timestamps.length > 0 ? `${Math.round((capturedData.timestamps[capturedData.timestamps.length-1] - capturedData.timestamps[0])/1000)}s` : 'N/A'}

**Features Captured:**
1. Position (x, y, z) - normalized coordinates
2. Velocity (x, y) - movement vectors
3. Timestamp - simulation time
4. Model state - neural network parameters at capture time

### Model Architecture
\`\`\`
Input(5) â†’ Dense(32, relu) â†’ Dropout(0.2)
         â†’ Dense(16, relu)
         â†’ Dense(8, relu)
         â†’ Output(1, sigmoid)
\`\`\`

### Training Configuration
- **Optimizer:** Adam (learning_rate=0.001)
- **Loss Function:** Binary Crossentropy
- **Batch Size:** 32
- **Validation Split:** 20%
- **Shuffle:** True

### Simulation Parameters
- **Ion Count:** ${particleCount.toLocaleString()}
- **Ocean Size:** 200x200 units
- **Physics Engine:** ${physicsKernel ? 'GPU.js accelerated' : 'CPU based'}
- **Render Engine:** Three.js r128
- **Target FPS:** 60

### File Structure
\`\`\`
ionicsphere_export_v7.0_*.zip/
â”œâ”€â”€ model_metadata.json     # Model configuration and stats
â”œâ”€â”€ training_log.json       # Loss/accuracy per epoch
â”œâ”€â”€ particle_data.json      # Captured particle positions/velocities
â”œâ”€â”€ screenshots/            # PNG frames from simulation
â”‚   â”œâ”€â”€ frame_0_*.png
â”‚   â””â”€â”€ ...
â”œâ”€â”€ tfjs_model/            # TensorFlow.js model files
â”‚   â”œâ”€â”€ model.json
â”‚   â””â”€â”€ weights.bin
â”œâ”€â”€ README.md              # This file
â”œâ”€â”€ terminal_log.txt       # CLI interaction history
â””â”€â”€ config.json           # System configuration
\`\`\`

### Usage Instructions

**1. Load Model in TensorFlow.js:**
\`\`\`javascript
async function loadModel() {
    const model = await tf.loadLayersModel('tfjs_model/model.json');
    const weights = await fetch('tfjs_model/weights.bin');
    // Load weights and make predictions
}
\`\`\`

**2. Analyze Particle Data:**
\`\`\`javascript
const data = JSON.parse(particleDataJson);
const positions = data.positions;  // Array of position frames
const velocities = data.velocities; // Array of velocity frames
\`\`\`

**3. Reproduce Simulation:**
- Use Three.js with provided particle data
- Apply same physics parameters
- Feed data into neural network for stability predictions

### Citation
If you use this data in research, please cite:
\`\`\`bibtex
@dataset{ionic_sphere_2024,
  title={Real-Time Quantum Ionic Simulation Dataset},
  author={IONICSPHERE Research Team},
  year={2024},
  publisher={IONICSPHERE v7.0},
  url={https://github.com/ionicsphere/simulator}
}
\`\`\`

### License
Research Use Only - Attribution Required

### Contact
For questions or access to newer versions, visit the project repository.`;
        }
        
        // ==================== COMMAND INPUT HANDLING ====================
        function setupCommandInput() {
            const input = document.getElementById('commandInput');
            const currentLine = document.getElementById('currentLine');
            
            input.focus();
            
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    const command = input.value.trim();
                    
                    if (command) {
                        // Remove old prompt
                        const prompts = document.querySelectorAll('.terminal-line.prompt');
                        if (prompts.length > 0) {
                            prompts[prompts.length - 1].remove();
                        }
                        
                        // Show command
                        printLine(`$ ${command}`, 'prompt');
                        
                        // Execute command
                        handleCommand(command);
                        
                        // Add to history
                        commandHistory.push(command);
                        historyIndex = commandHistory.length;
                        
                        // Clear input and show new prompt
                        input.value = '';
                        currentLine.textContent = '';
                        printPrompt();
                    }
                } else if (e.key === 'ArrowUp') {
                    if (commandHistory.length > 0) {
                        historyIndex = Math.max(0, historyIndex - 1);
                        input.value = commandHistory[historyIndex] || '';
                        currentLine.textContent = input.value;
                    }
                    e.preventDefault();
                } else if (e.key === 'ArrowDown') {
                    if (commandHistory.length > 0) {
                        historyIndex = Math.min(commandHistory.length, historyIndex + 1);
                        input.value = commandHistory[historyIndex] || '';
                        currentLine.textContent = input.value;
                    }
                    e.preventDefault();
                } else if (e.key === 'Tab') {
                    e.preventDefault();
                    // Tab completion
                    const commands = ['help', 'run', 'pause', 'train', 'stop', 'capture', 'status', 'export', 'clear', 'reset', 'model', 'data'];
                    const current = input.value.trim();
                    
                    for (const cmd of commands) {
                        if (cmd.startsWith(current)) {
                            input.value = cmd;
                            currentLine.textContent = cmd;
                            break;
                        }
                    }
                }
            });
            
            input.addEventListener('input', () => {
                currentLine.textContent = input.value;
            });
        }
        
        // ==================== INITIALIZATION ====================
        async function initialize() {
            printLine('[SYSTEM] Booting IONICSPHERE v7.0...', 'system');
            
            try {
                // Initialize TensorFlow.js
                printLine('[TENSORFLOW] Initializing...', 'system');
                await tf.ready();
                printLine('[TENSORFLOW] Backend: ' + tf.getBackend(), 'success');
                
                // Create neural model
                await createNeuralModel();
                
                // Generate training data
                await generateTrainingData();
                
                // Initialize Three.js
                await initThreeJS();
                
                // Set up command input
                setupCommandInput();
                
                // Start animation loop
                scene.userData.lastTime = performance.now();
                animationId = requestAnimationFrame(animationLoop);
                
                // Update status
                document.getElementById('statusText').textContent = 'READY';
                document.getElementById('gpuStatus').textContent = physicsKernel ? 'ACTIVE' : 'CPU';
                
                printLine('[SYSTEM] Ready. Type "help" for commands.', 'success');
                printLine('[SYSTEM] Real-time training: train/stop', 'output');
                printLine('[SYSTEM] Data export: export', 'output');
                
            } catch (error) {
                printLine(`[ERROR] Initialization failed: ${error.message}`, 'error');
            }
        }
        
        function handleResize() {
            if (camera && renderer) {
                const canvas = document.getElementById('threeCanvas');
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            }
        }
        
        // Start everything
        window.addEventListener('load', initialize);
        window.addEventListener('resize', handleResize);
        
        // Auto-start simulation after 2 seconds
        setTimeout(() => {
            if (!simulationRunning) {
                runSimulation();
            }
        }, 2000);
    </script>
</body>
</html>
