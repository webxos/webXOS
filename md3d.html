<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta http-equiv="Permissions-Policy" content="clipboard-write=(self)">
  <title>MD3D Engine</title>
  <style>
    body { font-family: monospace; margin: 0; padding: 10px; background: #000; color: #0f0; }
    #console, #error-console, #input, #md-input, canvas { border: 1px solid #0f0; background: #000; color: #0f0; }
    #console { width: 100%; height: 200px; overflow-y: auto; padding: 10px; font-size: 14px; }
    #error-console { width: 100%; height: 150px; overflow-y: auto; padding: 10px; font-size: 14px; margin-top: 10px; }
    #input-area { margin-top: 10px; display: flex; flex-direction: column; gap: 10px; }
    #input { padding: 10px; font-size: 16px; width: 100%; box-sizing: border-box; }
    #md-popup, #md3d-popup { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); border: 2px solid #0f0; padding: 15px; z-index: 1000; background: #000; }
    #md-input { width: 100%; height: 250px; font-family: monospace; font-size: 14px; }
    button { padding: 12px; font-size: 16px; cursor: pointer; width: 100%; box-sizing: border-box; background: #4a0; color: #000; }
    button:hover:not(:disabled) { background: #2c0; }
    button:disabled { background: #222; opacity: 0.5; cursor: not-allowed; }
    #close3d-popup { position: absolute; top: 10px; right: 10px; padding: 8px; width: auto; }
    #md3d-popup { width: calc(100% - 40px); max-width: 800px; height: calc(100vh - 40px); max-height: 600px; }
    #status-area { margin: 10px 0; font-size: 12px; }
    .log-info { color: #0f0; }
    .log-error { color: #f00; }
    .log-warning { color: #ff0; }
    #log-output { display: none; margin-top: 10px; width: 100%; height: 100px; }
    #line-count { margin-top: 5px; font-size: 12px; color: #ff0; }
    .controls { position: absolute; bottom: 10px; width: calc(100% - 60px); background: rgba(20, 20, 50, 0.9); padding: 10px; display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; backdrop-filter: blur(5px); z-index: 10; }
    .control-item { flex: 1; min-width: 80px; text-align: center; }
    .prompt { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.8); padding: 10px; border-radius: 10px; font-size: 14px; max-width: 90%; text-align: center; opacity: 0; transition: opacity 0.5s; z-index: 5; color: #fff; }
    .prompt.active { opacity: 1; }
    .throttle-indicator { position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%); color: #4a90e2; font-size: 12px; opacity: 0; transition: opacity 0.3s; z-index: 5; }
    .throttle-indicator.active { opacity: 1; }
    @media (min-width: 768px) {
      #input-area { flex-direction: row; }
      button { width: 100px; }
      #input { width: calc(100% - 420px); }
    }
  </style>
</head>
<body>
  <div id="console" role="log"></div>
  <div id="error-console"></div>
  <button id="copy-log-btn" disabled aria-label="Copy error log to clipboard">Copy to Clipboard</button>
  <div id="status-area">
    <span id="webgl-status">Loading...</span> | 
    <span id="fps">0.00</span> FPS | 
    <span id="memory">0.00</span> MB | 
    <span id="time">0.00</span> ms | 
    <span id="entities">0</span> Entities
  </div>
  <div id="input-area">
    <input id="input" placeholder="Enter command (/help for commands)" aria-label="Command input" />
    <button id="execute" disabled aria-label="Execute command">Run</button>
    <button id="markdown-btn" disabled aria-label="Open markdown popup">MD3D</button>
    <button id="clear-btn" disabled aria-label="Clear app">Clear</button>
    <button id="debug-btn" disabled aria-label="Run diagnostics">Debug</button>
  </div>
  <div id="md-popup">
    <select id="code-type" aria-label="Code type">
      <option value="text/markdown">Markdown (.md)</option>
      <option value="javascript">JavaScript (.js)</option>
    </select>
    <textarea id="md-input" placeholder="Paste Markdown with commands (add_shape, add_light, set_camera, animate, add_control) or JavaScript." aria-label="Markdown input"></textarea>
    <div id="line-count">Lines: 0</div>
    <div style="margin-top: 10px;">
      <button onclick="injectMD()" aria-label="Inject markdown">Inject</button>
      <button onclick="closePopup()" aria-label="Close markdown popup">Close</button>
    </div>
  </div>
  <div id="md3d-popup">
    <button id="close3d-popup" onclick="close3D()" aria-label="Close 3D canvas">X</button>
    <canvas id="md3d-canvas" aria-labelledby="canvas-desc"></canvas>
    <div id="canvas-desc" hidden>3D rendering canvas for MD3D applications.</div>
    <div class="controls" id="controls"></div>
    <div id="prompt" class="prompt"></div>
    <div id="throttleIndicator" class="throttle-indicator"></div>
  </div>
  <textarea id="log-output" readonly placeholder="Error log for manual copy" aria-label="Error log"></textarea>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
    // Cosmic Engine for WebGL
    class CosmicEngine {
      constructor(canvas) {
        this.canvas = canvas;
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(80, canvas.clientWidth / canvas.clientHeight, 0.1, 10000);
        this.renderer = null;
        this.objects = [];
        this.animations = [];
        this.entityCount = 0;
        this.frustum = new THREE.Frustum();
        this.cameraMatrix = new THREE.Matrix4();
        this.keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, w: false, s: false, a: false, d: false };
        this.isDragging = false;
        this.previousMousePosition = { x: 0, y: 0 };
        this.lastTime = performance.now();
        this.sharedMaterials = {
          glow: new THREE.MeshBasicMaterial({ color: 0xffffff }),
          cube: new THREE.MeshBasicMaterial({ color: 0xff0000 })
        };
        this.sharedGeometries = {
          cube: new THREE.BoxGeometry(1, 1, 1)
        };
        this.controls = {};
      }

      init() {
        try {
          this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: false, powerPreference: 'high-performance' });
          this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
          this.renderer.setClearColor(0x000000, 1);
          document.getElementById('webgl-status').textContent = 'WebGL Active';
          logInfo('WebGL renderer initialized');
          this.camera.position.set(0, 0, 10);
          logInfo('CosmicEngine initialized');
        } catch (e) {
          logError(`Engine initialization failed: ${e.message}`, e.stack);
          throw e;
        }
      }

      setSize(w, h) {
        this.camera.aspect = w / h;
        this.camera.updateProjectionMatrix();
        if (this.renderer) this.renderer.setSize(w, h);
      }

      addObject(obj) {
        this.scene.add(obj);
        this.objects.push(obj);
        this.entityCount++;
        updateStatus();
      }

      addCube(name, position, size, color) {
        const cube = new THREE.Mesh(this.sharedGeometries.cube, new THREE.MeshBasicMaterial({ color: new THREE.Color(...color.map(Number)) }));
        cube.position.set(...position.map(Number));
        cube.scale.setScalar(Number(size));
        cube.userData = { type: 'cube', name };
        this.addObject(cube);
        logInfo(`Cube ${name} added`);
      }

      addLight(name, type, position, color, intensity) {
        if (type !== 'point') throw new Error('Only point lights supported');
        const light = new THREE.PointLight(new THREE.Color(...color.map(Number)), Number(intensity), 1000);
        light.position.set(...position.map(Number));
        light.userData = { name, type: 'light' };
        this.addObject(light);
        logInfo(`Light ${name} added`);
      }

      setCamera(position, rotation) {
        this.camera.position.set(...position.map(Number));
        this.camera.rotation.set(...rotation.map(Number));
        logInfo(`Camera set: pos=[${position}], rot=[${rotation}]`);
      }

      animate(name, position, duration) {
        const obj = this.objects.find(o => o.userData.name === name);
        if (!obj) throw new Error(`Object ${name} not found`);
        this.animations.push({ name, target: position.map(Number), duration: Number(duration), t0: performance.now() / 1000 });
        logInfo(`Animation for ${name} added`);
      }

      addControl(id, label, callback) {
        this.controls[id] = { label, callback };
        updateControls();
      }

      clear() {
        this.objects.forEach(obj => this.scene.remove(obj));
        this.objects = [];
        this.animations = [];
        this.entityCount = 0;
        this.controls = {};
        updateControls();
        logInfo('Scene cleared');
        updateStatus();
      }

      render() {
        const now = performance.now();
        const deltaTime = Math.min((now - this.lastTime) / 1000, 0.1);
        this.lastTime = now;

        this.cameraMatrix.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse);
        this.frustum.setFromProjectionMatrix(this.cameraMatrix);

        this.animations.forEach((a, i) => {
          const t = Math.min((performance.now() / 1000 - a.t0) / a.duration, 1);
          const et = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
          const obj = this.objects.find(o => o.userData.name === a.name);
          if (obj) {
            const p0 = obj.position;
            obj.position.set(
              p0.x + (a.target[0] - p0.x) * et,
              p0.y + (a.target[1] - p0.y) * et,
              p0.z + (a.target[2] - p0.z) * et
            );
            if (t >= 1) {
              logInfo(`Animation ${a.name} done`);
              this.animations.splice(i, 1);
            }
          }
        });

        if (this.renderer) {
          this.renderer.render(this.scene, this.camera);
          logInfo('WebGL render pass completed', 'info');
        }
      }
    }

    // MD3D Manager
    class MD3D {
      constructor(engine) {
        this.engine = engine;
      }

      add_shape(type, name, position, size, color) {
        if (type !== 'cube') throw new Error('Only cube shapes supported');
        if (!name || !Array.isArray(position) || position.length !== 3 || isNaN(size) || size <= 0 || !Array.isArray(color) || color.length !== 3) {
          throw new Error('Invalid shape parameters');
        }
        this.engine.addCube(name, position, size, color);
      }

      add_light(name, type, position, color, intensity) {
        if (!name || !type || !Array.isArray(position) || position.length !== 3 || !Array.isArray(color) || color.length !== 3 || isNaN(intensity) || intensity < 0) {
          throw new Error('Invalid light parameters');
        }
        this.engine.addLight(name, type, position, color, intensity);
      }

      set_camera(position, rotation) {
        if (!Array.isArray(position) || position.length !== 3 || !Array.isArray(rotation) || rotation.length !== 3) {
          throw new Error('Invalid camera parameters');
        }
        this.engine.setCamera(position, rotation);
      }

      animate(name, position, duration) {
        if (!name || !Array.isArray(position) || position.length !== 3 || isNaN(duration) || duration <= 0) {
          throw new Error('Invalid animation parameters');
        }
        this.engine.animate(name, position, duration);
      }

      add_control(id, label, callback) {
        this.engine.addControl(id, label, callback);
      }

      clear() {
        this.engine.clear();
        updateFn = null;
        logInfo('Scene cleared');
      }

      test() {
        logInfo('Testing...');
        logInfo(`Entities: ${this.engine.entityCount}, Animations: ${this.engine.animations.length}`);
        logInfo(`Engine: ${this.engine ? 'OK' : 'Failed'}`);
        logInfo('Test passed');
      }
    }

    let log = [], engine = null, md3d = null, rendering = false, renderId, perfId, isInitialized = false;
    let updateFn = null;

    function logInfo(msg, level = 'info') {
      const c = document.getElementById('console');
      c.innerHTML += `<div class="log-${level}">[MD3D] ${msg}</div>`;
      c.lastElementChild?.scrollIntoView();
      log.push({ time: new Date().toISOString(), level: level.toUpperCase(), msg });
      if (log.length > 100) log.shift();
      document.getElementById('log-output').value = log.map(e => `[${e.time}] [${e.level}] ${e.msg}`).join('\n');
      document.getElementById('copy-log-btn').disabled = false;
    }

    function logError(msg, traceback = '') {
      logInfo(msg, 'error');
      const ec = document.getElementById('error-console');
      ec.innerHTML += `<div class="log-error">[ERROR] ${msg}${traceback ? '<br>Traceback: ' + traceback : ''}</div>`;
      if (ec.children.length > 100) ec.removeChild(ec.firstChild);
      ec.lastElementChild?.scrollIntoView();
    }

    function updateStatus() {
      document.getElementById('entities').textContent = engine ? engine.entityCount : 0;
    }

    function updateControls() {
      const controlsDiv = document.getElementById('controls');
      controlsDiv.innerHTML = '';
      Object.entries(engine.controls).forEach(([id, { label, callback }]) => {
        const div = document.createElement('div');
        div.className = 'control-item';
        const btn = document.createElement('button');
        btn.id = id;
        btn.textContent = label;
        btn.onclick = callback;
        div.appendChild(btn);
        controlsDiv.appendChild(div);
      });
    }

    async function init() {
      if (isInitialized) {
        logInfo('Already initialized, skipping');
        return;
      }
      try {
        logInfo('Initializing...');
        await init3D();
        md3d = new MD3D(engine);
        initControls();
        logInfo('Initialized');
        ['execute', 'markdown-btn', 'clear-btn', 'debug-btn', 'copy-log-btn'].forEach(id => {
          const el = document.getElementById(id);
          el.disabled = false;
          el.setAttribute('aria-disabled', 'false');
        });
        isInitialized = true;
      } catch (e) {
        logError(`Init failed: ${e.message}`, e.stack);
        document.getElementById('webgl-status').textContent = 'Failed';
        disableUI();
      }
    }

    function disableUI() {
      ['execute', 'markdown-btn', 'clear-btn', 'debug-btn', 'copy-log-btn'].forEach(id => {
        const el = document.getElementById(id);
        el.disabled = true;
        el.setAttribute('aria-disabled', 'true');
      });
    }

    async function init3D() {
      try {
        const canvas = document.getElementById('md3d-canvas');
        engine = new CosmicEngine(canvas);
        engine.init();
        resize();
        logInfo('3D initialized');
      } catch (e) {
        logError(`3D init failed: ${e.message}`, e.stack);
        document.getElementById('webgl-status').textContent = 'Failed';
        throw e;
      }
    }

    function render() {
      if (rendering) return;
      rendering = true;
      const loop = () => {
        try {
          if (!engine) {
            logError('Render stopped: Engine invalid');
            stopRender();
            return;
          }
          if (document.getElementById('md3d-popup').style.display === 'none') {
            logInfo('Render stopped: 3D canvas closed');
            stopRender();
            return;
          }
          const t0 = performance.now();
          if (updateFn) {
            try {
              updateFn(md3d, engine.scene, engine.camera, engine, engine.objects, engine.animations, engine.keys, { dragging: engine.isDragging, dx: 0, dy: 0 });
            } catch (e) {
              logError(`Update failed: ${e.message}`, e.stack);
            }
          }
          engine.render();
          document.getElementById('time').textContent = (performance.now() - t0).toFixed(2);
          renderId = requestAnimationFrame(loop);
        } catch (e) {
          logError(`Render loop failed: ${e.message}`, e.stack);
          stopRender();
        }
      };
      renderId = requestAnimationFrame(loop);
    }

    function stopRender() {
      if (renderId) {
        cancelAnimationFrame(renderId);
        renderId = null;
        rendering = false;
        logInfo('Render stopped');
      }
    }

    function updatePerf() {
      let t0 = performance.now(), frames = 0;
      const loop = t => {
        frames++;
        if (t - t0 >= 1000) {
          document.getElementById('fps').textContent = (frames * 1000 / (t - t0)).toFixed(2);
          if (performance.memory) {
            document.getElementById('memory').textContent = (performance.memory.usedJSHeapSize / 1e6).toFixed(2);
          }
          frames = 0;
          t0 = t;
        }
        perfId = requestAnimationFrame(loop);
      };
      perfId = requestAnimationFrame(loop);
    }

    function initControls() {
      const canvas = document.getElementById('md3d-canvas');
      canvas.addEventListener('mousedown', e => {
        engine.isDragging = true;
        engine.previousMousePosition = { x: e.clientX, y: e.clientY };
      });
      canvas.addEventListener('mousemove', e => {
        if (engine.isDragging) {
          const deltaX = e.clientX - engine.previousMousePosition.x;
          const deltaY = e.clientY - engine.previousMousePosition.y;
          engine.previousMousePosition = { x: e.clientX, y: e.clientY };
          if (updateFn) {
            updateFn(md3d, engine.scene, engine.camera, engine, engine.objects, engine.animations, engine.keys, { dragging: true, dx: deltaX, dy: deltaY });
          }
        }
      });
      canvas.addEventListener('mouseup', () => {
        engine.isDragging = false;
      });
      canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        engine.previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      });
      canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        const deltaX = e.touches[0].clientX - engine.previousMousePosition.x;
        const deltaY = e.touches[0].clientY - engine.previousMousePosition.y;
        engine.previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        if (updateFn) {
          updateFn(md3d, engine.scene, engine.camera, engine, engine.objects, engine.animations, engine.keys, { dragging: true, dx: deltaX, dy: deltaY });
        }
      });
      window.addEventListener('keydown', e => {
        if (e.key in engine.keys) {
          engine.keys[e.key] = true;
          e.preventDefault();
        }
      });
      window.addEventListener('keyup', e => {
        if (e.key in engine.keys) engine.keys[e.key] = false;
      });
    }

    async function parseMD(code) {
      const normalizedCode = code.replace(/\r\n/g, '\n').trim();
      const lines = normalizedCode.split('\n').filter(l => l.trim() !== '');
      logInfo(`Parsing ${lines.length} lines`);
      const cmds = [];
      let inCode = false, codeBlock = '', codeType = '', validCount = 0;
      for (let i = 0; i < lines.length; i++) {
        const l = lines[i].trim();
        try {
          if (l.match(/^```(javascript|glsl|wgsl|text)$/)) {
            inCode = true;
            codeType = l.match(/^```(\w+)/)[1];
            codeBlock = '';
            logInfo(`Code block (${codeType}) started at line ${i + 1}`);
            continue;
          }
          if (l.startsWith('```') && inCode) {
            inCode = false;
            if (codeBlock.trim()) {
              if (codeType === 'javascript') {
                try {
                  new Function(codeBlock);
                  cmds.push({ type: 'js', content: codeBlock, line: i + 1 });
                  logInfo(`JS block parsed at line ${i + 1}: ${codeBlock.slice(0, 20)}...`);
                  validCount++;
                } catch (e) {
                  logError(`Invalid JS block at line ${i + 1}: ${e.message}`, e.stack);
                  return null;
                }
              }
            }
            continue;
          }
          if (inCode) {
            codeBlock += l + '\n';
            continue;
          }
          if (l.startsWith('#') || l.startsWith('//') || l.startsWith('<!--')) continue;
          const shape = l.match(/^add_shape\s*\(\s*cube\s*,\s*"?([^",]+)"?\s*,\s*position\s*=\s*\(\s*([^)]+)\s*\)\s*,\s*size\s*=\s*([^,]+)\s*,\s*color\s*=\s*\(\s*([^)]+)\s*\)\s*\)$/);
          if (shape) {
            const [, name, pos, size, col] = shape;
            const p = pos.split(/\s*,\s*/).map(Number), c = col.split(/\s*,\s*/).map(Number);
            if (p.length !== 3 || p.some(isNaN) || isNaN(size) || size <= 0 || c.length !== 3 || c.some(isNaN)) {
              throw new Error(`Invalid shape parameters at line ${i + 1}`);
            }
            cmds.push({ type: 'command', content: `md3d.add_shape("cube", "${name.trim()}", [${p.join(',')}], ${size}, [${c.join(',')}]);`, line: i + 1 });
            logInfo(`Generated: add_shape(${name.trim()}) at line ${i + 1}`);
            validCount++;
            continue;
          }
          const light = l.match(/^add_light\s*\(\s*"?([^",]+)"?\s*,\s*point\s*,\s*position\s*=\s*\(\s*([^)]+)\s*\)\s*,\s*color\s*=\s*\(\s*([^)]+)\s*\)\s*,\s*intensity\s*=\s*([^)]+)\s*\)$/);
          if (light) {
            const [, name, pos, col, intensity] = light;
            const p = pos.split(/\s*,\s*/).map(Number), c = col.split(/\s*,\s*/).map(Number);
            if (p.length !== 3 || p.some(isNaN) || c.length !== 3 || c.some(isNaN) || isNaN(intensity) || intensity < 0) {
              throw new Error(`Invalid light parameters at line ${i + 1}`);
            }
            cmds.push({ type: 'command', content: `md3d.add_light("${name.trim()}", "point", [${p.join(',')}], [${c.join(',')}], ${intensity});`, line: i + 1 });
            logInfo(`Generated: add_light(${name.trim()}) at line ${i + 1}`);
            validCount++;
            continue;
          }
          const cam = l.match(/^set_camera\s*\(\s*position\s*=\s*\(\s*([^)]+)\s*\)\s*,\s*rotation\s*=\s*\(\s*([^)]+)\s*\)\s*\)$/);
          if (cam) {
            const [, pos, rot] = cam;
            const p = pos.split(/\s*,\s*/).map(Number), r = rot.split(/\s*,\s*/).map(Number);
            if (p.length !== 3 || p.some(isNaN) || r.length !== 3 || r.some(isNaN)) {
              throw new Error(`Invalid camera parameters at line ${i + 1}`);
            }
            cmds.push({ type: 'command', content: `md3d.set_camera([${p.join(',')}], [${r.join(',')}]);`, line: i + 1 });
            logInfo(`Generated: set_camera at line ${i + 1}`);
            validCount++;
            continue;
          }
          const anim = l.match(/^animate\s*\(\s*"?([^",]+)"?\s*,\s*position\s*=\s*\(\s*([^)]+)\s*\)\s*,\s*duration\s*=\s*([^)]+)\s*\)$/);
          if (anim) {
            const [, name, pos, duration] = anim;
            const p = pos.split(/\s*,\s*/).map(Number);
            if (p.length !== 3 || p.some(isNaN) || isNaN(duration) || duration <= 0) {
              throw new Error(`Invalid animation parameters at line ${i + 1}`);
            }
            cmds.push({ type: 'command', content: `md3d.animate("${name.trim()}", [${p.join(',')}], ${duration});`, line: i + 1 });
            logInfo(`Generated: animate(${name.trim()}) at line ${i + 1}`);
            validCount++;
            continue;
          }
          const control = l.match(/^add_control\s*\(\s*"?([^",]+)"?\s*,\s*"([^"]+)"\s*,\s*([^)]+)\s*\)$/);
          if (control) {
            const [, id, label, callback] = control;
            cmds.push({ type: 'command', content: `md3d.add_control("${id.trim()}", "${label.trim()}", ${callback.trim()});`, line: i + 1 });
            logInfo(`Generated: add_control(${id.trim()}) at line ${i + 1}`);
            validCount++;
            continue;
          }
          logInfo(`Skipped line ${i + 1}: ${l.slice(0, 20)}... (invalid)`, 'warning');
        } catch (e) {
          logError(`Line ${i + 1}: ${e.message}`, e.stack);
        }
      }
      if (inCode) {
        logError(`Unclosed ${codeType} block at line ${lines.length}`);
        return null;
      }
      if (!validCount) {
        logError('No valid commands found');
        return null;
      }
      return cmds;
    }

    async function injectMD(code = null) {
      try {
        if (!md3d || !engine) {
          logError('Cannot inject MD: Engine or MD3D not initialized');
          return;
        }
        const mdInput = document.getElementById('md-input').value.trim();
        const finalCode = code ? code.replace(/\r\n/g, '\n').trim() : mdInput.replace(/\r\n/g, '\n').trim();
        if (!finalCode) {
          logInfo('No MD to inject', 'warning');
          return;
        }
        if (code && mdInput) {
          logInfo(`Ignoring manual input (${mdInput.split('\n').length} lines); using provided code`, 'warning');
          document.getElementById('md-input').value = '';
          document.getElementById('line-count').textContent = 'Lines: 0';
        }
        const cmds = await parseMD(finalCode);
        if (!cmds) {
          logError('No valid content to execute');
          return;
        }
        for (const cmd of cmds) {
          if (cmd.type === 'js') {
            try {
              updateFn = new Function('md3d', 'scene', 'camera', 'renderer', 'sceneObjects', 'animations', 'keyboardState', 'touchState', cmd.content);
              logInfo(`JS update function loaded at line ${cmd.line}`);
              updateFn(md3d, engine.scene, engine.camera, engine, engine.objects, engine.animations, engine.keys, { dragging: engine.isDragging, dx: 0, dy: 0 });
              logInfo(`JS update function executed at line ${cmd.line}`);
            } catch (e) {
              logError(`JS execution failed at line ${cmd.line}: ${e.message}`, e.stack);
            }
          } else if (cmd.type === 'command') {
            try {
              eval(cmd.content);
              logInfo(`Command executed at line ${cmd.line}: ${cmd.content.slice(0, 20)}...`);
            } catch (e) {
              logError(`Command execution failed at line ${cmd.line}: ${e.message}`, e.stack);
            }
          }
        }
        logInfo(`MD ran: entities=${engine.entityCount}, animations=${engine.animations.length}`);
        show3D();
        if (!rendering) render();
        if (document.getElementById('md-popup').style.display === 'block') closePopup();
      } catch (e) {
        logError(`MD injection failed: ${e.message}`, e.stack);
      }
    }

    function showPopup() {
      document.getElementById('md-popup').style.display = 'block';
      updateLineCount();
      logInfo('MD popup opened');
    }

    function closePopup() {
      document.getElementById('md-popup').style.display = 'none';
      document.getElementById('md-input').value = '';
      document.getElementById('line-count').textContent = 'Lines: 0';
      logInfo('MD popup closed');
    }

    function updateLineCount() {
      const input = document.getElementById('md-input').value;
      const lineCount = input.split('\n').length;
      document.getElementById('line-count').textContent = `Lines: ${lineCount}`;
    }

    function show3D() {
      if (!engine) {
        logError('Cannot show 3D canvas: Engine not initialized');
        return;
      }
      document.getElementById('md3d-popup').style.display = 'block';
      resize();
      if (!rendering) render();
      const canvas = document.getElementById('md3d-canvas');
      canvas.setAttribute('aria-label', `3D canvas with ${engine.entityCount} entities`);
      logInfo('3D canvas opened');
    }

    function close3D() {
      document.getElementById('md3d-popup').style.display = 'none';
      stopRender();
      logInfo('3D canvas closed');
    }

    function showPrompt(text) {
      const prompt = document.getElementById('prompt');
      prompt.textContent = text;
      prompt.classList.add('active');
      setTimeout(() => prompt.classList.remove('active'), 2000);
    }

    async function debug() {
      if (!md3d || !engine) {
        logError('Cannot debug: Engine or MD3D not initialized');
        return;
      }
      logInfo('Debugging with test3d.md...');
      md3d.clear();
      const test3d = `
# Test3D Video Test
add_shape(cube, cube1, position=(-4, 2, 0), size=1, color=(1, 0, 0))
add_shape(cube, cube2, position=(-2, 2, 0), size=0.8, color=(0, 1, 0))
add_shape(cube, cube3, position=(0, 2, 0), size=0.6, color=(0, 0, 1))
add_shape(cube, cube4, position=(2, 2, 0), size=0.7, color=(1, 1, 0))
add_shape(cube, cube5, position=(4, 2, 0), size=0.9, color=(1, 0, 1))
add_shape(cube, cube6, position=(-4, -2, 0), size=1.2, color=(0, 1, 1))
add_shape(cube, cube7, position=(-2, -2, 0), size=0.5, color=(1, 0.5, 0))
add_shape(cube, cube8, position=(0, -2, 0), size=0.8, color=(0.5, 0, 1))
add_shape(cube, cube9, position=(2, -2, 0), size=1, color=(0, 1, 0.5))
add_shape(cube, cube10, position=(4, -2, 0), size=0.6, color=(0.5, 0.5, 1))
add_light(main_light, point, position=(5, 5, 5), color=(1, 1, 1), intensity=1)
set_camera(position=(0, 0, 12), rotation=(0, 0, 0))
animate(cube1, position=(-4, 4, 0), duration=6)
animate(cube2, position=(-2, -4, 0), duration=6)
animate(cube3, position=(0, 4, 0), duration=6)
animate(cube4, position=(2, -4, 0), duration=6)
animate(cube5, position=(4, 4, 0), duration=6)
animate(cube6, position=(-4, -4, 0), duration=6)
animate(cube7, position=(-2, 4, 0), duration=6)
animate(cube8, position=(0, -4, 0), duration=6)
animate(cube9, position=(2, 4, 0), duration=6)
animate(cube10, position=(4, -4, 0), duration=6)

\`\`\`javascript
function updateFn(md3d, scene, camera, renderer, sceneObjects, animations, keyboardState, touchState) {
  const t = performance.now() / 1000;
  const cubes = sceneObjects.filter(o => o.userData.name.startsWith('cube'));
  cubes.forEach((cube, i) => {
    const phase = i * Math.PI / 5;
    cube.rotation.x = Math.sin(t + phase) * Math.PI;
    cube.rotation.y = Math.cos(t + phase) * Math.PI;
    cube.scale.setScalar(0.5 + Math.sin(t * 2 + phase) * 0.2);
    const r = Math.sin(t + phase) * 0.5 + 0.5;
    const g = Math.sin(t + phase + Math.PI / 2) * 0.5 + 0.5;
    const b = Math.sin(t + phase + Math.PI) * 0.5 + 0.5;
    cube.material.color.setRGB(r, g, b);
  });
}
\`\`\`
`;
      let fpsSamples = [], renderTimes = [], peakMemory = 0;
      const t0 = performance.now();
      const sampleFPS = () => {
        const fps = Number(document.getElementById('fps').textContent);
        const rt = Number(document.getElementById('time').textContent);
        if (performance.memory) {
          const mem = performance.memory.usedJSHeapSize / 1e6;
          peakMemory = Math.max(peakMemory, mem);
        }
        fpsSamples.push(fps);
        renderTimes.push(rt);
      };
      await injectMD(test3d);
      const initialAnimations = engine.animations.length;
      const checks = [
        { id: 1, test: '3D init', fn: () => engine ? 'OK' : 'Failed' },
        { id: 2, test: 'Scene', fn: () => engine.scene ? 'OK' : 'Failed' },
        { id: 3, test: 'Camera', fn: () => engine.camera ? 'OK' : 'Failed' },
        { id: 4, test: 'Engine', fn: () => engine ? 'OK' : 'Failed' },
        { id: 5, test: 'Rendering', fn: () => engine.entityCount >= 11 ? 'OK' : `Failed (${engine.entityCount} entities)` },
        { id: 6, test: 'Animations', fn: () => initialAnimations >= 10 ? 'OK' : `Failed (${initialAnimations} animations)` },
        { id: 7, test: 'MD3D', fn: () => md3d ? 'OK' : 'Failed' },
        { id: 8, test: 'Entities', fn: () => engine.entityCount >= 11 ? 'OK' : `Failed (${engine.entityCount} entities)` },
        { id: 9, test: 'WebGL Context', fn: () => engine.renderer ? 'OK' : 'Failed' },
        { id: 10, test: 'Test MD Execution', fn: () => engine.objects.filter(o => o.userData.name.startsWith('cube')).length === 10 && 
                                                   engine.objects.find(l => l.userData.name === 'main_light') ? 'OK' : 'Failed' }
      ];
      let failedChecks = 0;
      for (let c of checks) {
        const r = c.fn();
        if (r === 'OK') {
          logInfo(`[CHECK ${c.id}] ${c.test}: ${r}`);
        } else {
          logError(`[CHECK ${c.id}] ${c.test}: ${r}`);
          failedChecks++;
        }
      }
      const interval = setInterval(sampleFPS, 100);
      setTimeout(() => {
        clearInterval(interval);
        const avgFPS = fpsSamples.length ? (fpsSamples.reduce((a, b) => a + b, 0) / fpsSamples.length).toFixed(2) : 0;
        const avgRenderTime = renderTimes.length ? (renderTimes.reduce((a, b) => a + b, 0) / renderTimes.length).toFixed(2) : 0;
        const summary = `Debug Summary: ${failedChecks === 0 ? 'PASSED' : 'FAILED'}, ` +
                        `Renderer: WebGL, Entities: ${engine.entityCount}, Initial Animations: ${initialAnimations}, ` +
                        `Avg FPS: ${avgFPS}, Avg Render Time: ${avgRenderTime}ms, Peak Memory: ${peakMemory.toFixed(2)}MB, ` +
                        `Checks Failed: ${failedChecks}`;
        if (failedChecks === 0) {
          logInfo(summary);
        } else {
          logError(summary);
        }
        logInfo('Debug done');
        if (engine.entityCount >= 11 && failedChecks === 0) {
          logInfo('Debug test passed, closing 3D canvas');
          close3D();
        } else {
          logError('Debug test failed, keeping 3D canvas open for inspection');
        }
      }, 3000);
    }

    function copyLog() {
      if (!log.length) {
        logInfo('No logs to copy');
        return;
      }
      try {
        navigator.clipboard.writeText(document.getElementById('log-output').value);
        logInfo('Logs copied');
      } catch (e) {
        const out = document.getElementById('log-output');
        out.style.display = 'block';
        out.focus();
        out.select();
        logError('Clipboard failed; copy manually', e.stack);
      }
    }

    function resize() {
      if (!engine) {
        logError('Cannot resize: Engine not initialized');
        return;
      }
      const popup = document.getElementById('md3d-popup');
      const rect = popup.getBoundingClientRect();
      const w = Math.min(rect.width - 30, 3840), h = Math.min(rect.height - 30, 2160);
      engine.setSize(w, h);
    }

    // Initialize
    addEventListener('resize', resize);
    addEventListener('beforeunload', () => {
      stopRender();
      if (perfId) cancelAnimationFrame(perfId);
    });
    document.getElementById('execute').onclick = execCmd;
    document.getElementById('markdown-btn').onclick = showPopup;
    document.getElementById('clear-btn').onclick = () => md3d.clear();
    document.getElementById('copy-log-btn').onclick = copyLog;
    document.getElementById('debug-btn').onclick = debug;
    document.getElementById('md-input').addEventListener('input', updateLineCount);
    init();
    updatePerf();

    const commands = {
      '/help': () => {
        logInfo('Commands: /test, /show3d, /clear');
      },
      '/test': () => md3d.test(),
      '/show3d': () => show3D(),
      '/clear': () => md3d.clear()
    };

    function execCmd() {
      const cmd = document.getElementById('input').value.trim().split(' ');
      const action = cmd[0];
      const args = cmd.slice(1);
      if (commands[action]) commands[action](...args);
      else logError(`Unknown command: ${action}`);
      document.getElementById('input').value = '';
    }
  </script>
</body>
</html>
