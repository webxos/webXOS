<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta http-equiv="Permissions-Policy" content="clipboard-write=(self)">
  <title>MD3D Engine</title>
  <style>
    body { font-family: monospace; margin: 0; padding: 10px; background: #000; color: #0f0; }
    #console, #error-console, #input, #md-input, canvas { border: 1px solid #0f0; background: #000; color: #0f0; }
    #console { width: 100%; height: 200px; overflow-y: auto; padding: 10px; font-size: 14px; }
    #error-console { width: 100%; height: 150px; overflow-y: auto; padding: 10px; font-size: 14px; margin-top: 10px; }
    #input-area { margin-top: 10px; display: flex; flex-direction: column; gap: 10px; }
    #input { padding: 10px; font-size: 16px; width: 100%; box-sizing: border-box; }
    #md-popup, #md3d-popup { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); border: 2px solid #0f0; padding: 15px; z-index: 1000; background: #000; }
    #md-input { width: 100%; height: 250px; font-family: monospace; font-size: 14px; }
    button { padding: 12px; font-size: 16px; cursor: pointer; width: 100%; box-sizing: border-box; background: #4a0; color: #000; }
    button:hover:not(:disabled) { background: #2c0; }
    button:disabled { background: #222; opacity: 0.5; cursor: not-allowed; }
    #close3d-popup { position: absolute; top: 10px; right: 10px; padding: 8px; width: auto; }
    #md3d-popup { width: calc(100% - 40px); max-width: 800px; height: calc(100vh - 40px); max-height: 600px; }
    #status-area { margin: 10px 0; font-size: 12px; }
    .log-info { color: #0f0; }
    .log-error { color: #f00; }
    .log-warning { color: #ff0; }
    #log-output { display: none; margin-top: 10px; width: 100%; height: 100px; }
    #line-count { margin-top: 5px; font-size: 12px; color: #ff0; }
    .controls { position: absolute; bottom: 10px; width: calc(100% - 60px); background: rgba(20, 20, 50, 0.9); padding: 10px; display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; backdrop-filter: blur(5px); z-index: 10; }
    .control-item { flex: 1; min-width: 80px; text-align: center; }
    .prompt { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.8); padding: 10px; border: 2px solid #0f0; border-radius: 10px; font-size: 14px; max-width: 90%; text-align: center; opacity: 0; transition: opacity 0.5s; z-index: 20; color: #fff; }
    .prompt.active { opacity: 1; }
    .throttle-indicator { position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%); color: #4a90e2; font-size: 12px; opacity: 0; transition: opacity 0.3s; z-index: 5; }
    .throttle-indicator.active { opacity: 1; }
    @media (min-width: 768px) {
      #input-area { flex-direction: row; }
      button { width: 100px; }
      #input { width: calc(100% - 420px); }
    }
  </style>
</head>
<body>
  <div id="console" role="log"></div>
  <div id="error-console"></div>
  <button id="copy-log-btn" disabled aria-label="Copy error log to clipboard">Copy to Clipboard</button>
  <div id="status-area">
    <span id="webgl-status">Loading...</span> | 
    <span id="fps">0.00</span> FPS | 
    <span id="memory">0.00</span> MB | 
    <span id="time">0.00</span> ms | 
    <span id="entities">0</span> Entities
  </div>
  <div id="input-area">
    <input id="input" placeholder="Enter command (/help for commands)" aria-label="Command input" />
    <button id="execute" disabled aria-label="Execute command">Execute</button>
    <button id="markdown-btn" disabled aria-label="Open markdown popup">MD3D</button>
    <button id="clear-btn" disabled aria-label="Clear app">Clear</button>
    <button id="debug-btn" disabled aria-label="Run diagnostics">Debug</button>
  </div>
  <div id="md-popup">
    <select id="code-type" aria-label="Code type">
      <option value="text/markdown">Markdown (.md)</option>
      <option value="javascript">JavaScript (.js)</option>
    </select>
    <textarea id="md-input" placeholder="Paste Markdown with commands (add_shape, add_instanced_shape, update_instance, set_instance_count, add_light, set_camera, animate, add_control) or JavaScript." aria-label="Markdown input"></textarea>
    <div id="line-count">Lines: 0</div>
    <div style="margin-top: 10px;">
      <button onclick="injectMD()" aria-label="Inject markdown">Inject</button>
      <button onclick="closePopup()" aria-label="Close markdown popup">Close</button>
    </div>
  </div>
  <div id="md3d-popup">
    <button id="close3d-popup" onclick="close3D()" aria-label="Close 3D canvas">X</button>
    <canvas id="md3d-canvas" aria-labelledby="canvas-desc"></canvas>
    <div id="canvas-desc" hidden>3D rendering canvas for MD3D applications.</div>
    <div class="controls" id="controls"></div>
    <div id="prompt" class="prompt"></div>
    <div id="throttleIndicator" class="throttle-indicator"></div>
  </div>
  <textarea id="log-output" readonly placeholder="Error log for manual copy" aria-label="Error log"></textarea>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
    // Cosmic Engine for WebGL
    class CosmicEngine {
      constructor(canvas) {
        this.canvas = canvas;
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 5000);
        this.renderer = null;
        this.objects = [];
        this.instancedObjects = [];
        this.animations = [];
        this.entityCount = 0;
        this.frustum = new THREE.Frustum();
        this.cameraMatrix = new THREE.Matrix4();
        this.keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, w: false, s: false, a: false, d: false };
        this.isDragging = false;
        this.previousMousePosition = { x: 0, y: 0 };
        this.lastTime = performance.now();
        this.sharedMaterials = {
          basic: new THREE.MeshBasicMaterial({ color: 0xffffff }),
          instanced: new THREE.MeshBasicMaterial({ color: 0x00ff00 })
        };
        this.sharedGeometries = {
          cube: new THREE.BoxGeometry(1, 1, 1),
          tetrahedron: new THREE.TetrahedronGeometry(1, 0),
          sphere: new THREE.SphereGeometry(1, 8, 8)
        };
        this.controls = {};
        this.webglContextLost = false;
      }

      init() {
        try {
          if (!this.canvas.getContext('webgl2') && !this.canvas.getContext('webgl')) {
            throw new Error('WebGL not supported');
          }
          this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: false, powerPreference: 'high-performance', alpha: true });
          this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
          this.renderer.setClearColor(0x000000, 1);
          this.renderer.domElement.tabIndex = 0;
          document.getElementById('webgl-status').textContent = 'WebGL Active';
          logInfo('WebGL renderer initialized');
          this.camera.position.set(0, 0, 10);
          logInfo('CosmicEngine initialized');
          this.setupWebGLEventListeners();
        } catch (e) {
          logError(`Engine initialization failed: ${e.message}`, e.stack);
          document.getElementById('webgl-status').textContent = 'WebGL Failed';
          throw e;
        }
      }

      setupWebGLEventListeners() {
        this.canvas.addEventListener('webglcontextlost', (e) => {
          e.preventDefault();
          this.webglContextLost = true;
          logError('WebGL context lost');
          stopRender();
        });
        this.canvas.addEventListener('webglcontextrestored', () => {
          this.webglContextLost = false;
          logInfo('WebGL context restored');
          this.init();
          render();
        });
      }

      setSize(w, h) {
        try {
          this.camera.aspect = w / h;
          this.camera.updateProjectionMatrix();
          if (this.renderer && !this.webglContextLost) {
            this.renderer.setSize(w, h, false);
          }
        } catch (e) {
          logError(`Resize failed: ${e.message}`, e.stack);
        }
      }

      addObject(obj) {
        try {
          this.scene.add(obj);
          this.objects.push(obj);
          this.entityCount++;
          updateStatus();
        } catch (e) {
          logError(`Add object failed: ${e.message}`, e.stack);
        }
      }

      addInstancedObject(obj) {
        try {
          this.scene.add(obj);
          this.instancedObjects.push(obj);
          this.entityCount += obj.count;
          updateStatus();
        } catch (e) {
          logError(`Add instanced object failed: ${e.message}`, e.stack);
        }
      }

      addCube(name, position, size, color) {
        try {
          if (!name || !Array.isArray(position) || position.length !== 3 || isNaN(size) || size <= 0 || !Array.isArray(color) || color.length !== 3) {
            throw new Error('Invalid cube parameters');
          }
          const cube = new THREE.Mesh(this.sharedGeometries.cube, new THREE.MeshBasicMaterial({ color: new THREE.Color(...color.map(Number)) }));
          cube.position.set(...position.map(Number));
          cube.scale.setScalar(Number(size));
          cube.userData = { type: 'cube', name };
          this.addObject(cube);
          logInfo(`Cube ${name} added`);
        } catch (e) {
          logError(`Add cube failed: ${e.message}`, e.stack);
        }
      }

      addInstancedShape(name, type, count, position, size, color) {
        try {
          if (!name || !['cube', 'tetrahedron', 'sphere'].includes(type) || isNaN(count) || count < 1 || !Array.isArray(position) || position.length !== 3 || isNaN(size) || size <= 0 || !Array.isArray(color) || color.length !== 3) {
            throw new Error('Invalid instanced shape parameters');
          }
          const geometry = this.sharedGeometries[type];
          const material = new THREE.MeshBasicMaterial({ color: new THREE.Color(...color.map(Number)) });
          const instancedMesh = new THREE.InstancedMesh(geometry, material, count);
          const matrix = new THREE.Matrix4();
          for (let i = 0; i < count; i++) {
            matrix.setPosition(...position.map(Number));
            matrix.scale(new THREE.Vector3(size, size, size));
            instancedMesh.setMatrixAt(i, matrix);
          }
          instancedMesh.instanceMatrix.needsUpdate = true;
          instancedMesh.userData = { type: 'instanced', name, instanceCount: count };
          this.addInstancedObject(instancedMesh);
          logInfo(`Instanced ${type} ${name} added with ${count} instances`);
        } catch (e) {
          logError(`Add instanced shape failed: ${e.message}`, e.stack);
        }
      }

      updateInstance(name, index, position, rotation, scale, color) {
        try {
          const instancedMesh = this.instancedObjects.find(o => o.userData.name === name);
          if (!instancedMesh) throw new Error(`Instanced mesh ${name} not found`);
          if (index < 0 || index >= instancedMesh.count) throw new Error(`Invalid instance index ${index}`);
          const matrix = new THREE.Matrix4();
          if (position && position.length === 3) {
            matrix.setPosition(...position.map(Number));
          }
          if (rotation && rotation.length === 3) {
            matrix.makeRotationFromEuler(new THREE.Euler(...rotation.map(Number)));
          }
          if (scale && !isNaN(scale)) {
            matrix.scale(new THREE.Vector3(scale, scale, scale));
          }
          instancedMesh.setMatrixAt(index, matrix);
          if (color && color.length === 3) {
            instancedMesh.setColorAt(index, new THREE.Color(...color.map(Number)));
            instancedMesh.instanceColor.needsUpdate = true;
          }
          instancedMesh.instanceMatrix.needsUpdate = true;
          logInfo(`Instance ${index} of ${name} updated`);
        } catch (e) {
          logError(`Update instance failed: ${e.message}`, e.stack);
        }
      }

      setInstanceCount(name, count) {
        try {
          const instancedMesh = this.instancedObjects.find(o => o.userData.name === name);
          if (!instancedMesh) throw new Error(`Instanced mesh ${name} not found`);
          if (isNaN(count) || count < 1) throw new Error('Invalid instance count');
          this.entityCount -= instancedMesh.count;
          instancedMesh.count = count;
          instancedMesh.userData.instanceCount = count;
          instancedMesh.instanceMatrix.needsUpdate = true;
          this.entityCount += count;
          updateStatus();
          logInfo(`Instance count for ${name} set to ${count}`);
        } catch (e) {
          logError(`Set instance count failed: ${e.message}`, e.stack);
        }
      }

      addLight(name, type, position, color, intensity) {
        try {
          if (type !== 'point') throw new Error('Only point lights supported');
          if (!name || !Array.isArray(position) || position.length !== 3 || !Array.isArray(color) || color.length !== 3 || isNaN(intensity)) {
            throw new Error('Invalid light parameters');
          }
          const light = new THREE.PointLight(new THREE.Color(...color.map(Number)), Number(intensity), 1000);
          light.position.set(...position.map(Number));
          light.userData = { name, type: 'light' };
          this.addObject(light);
          logInfo(`Light ${name} added`);
        } catch (e) {
          logError(`Add light failed: ${e.message}`, e.stack);
        }
      }

      setCamera(position, rotation) {
        try {
          if (!Array.isArray(position) || position.length !== 3 || !Array.isArray(rotation) || rotation.length !== 3) {
            throw new Error('Invalid camera parameters');
          }
          this.camera.position.set(...position.map(Number));
          this.camera.rotation.set(...rotation.map(Number));
          logInfo(`Camera set: pos=[${position}], rot=[${rotation}]`);
        } catch (e) {
          logError(`Set camera failed: ${e.message}`, e.stack);
        }
      }

      animate(name, position, duration) {
        try {
          const obj = this.objects.find(o => o.userData.name === name);
          if (!obj) throw new Error(`Object ${name} not found`);
          this.animations.push({ name, target: position.map(Number), duration: Number(duration), t0: performance.now() / 1000 });
          logInfo(`Animation for ${name} added`);
        } catch (e) {
          logError(`Add animation failed: ${e.message}`, e.stack);
        }
      }

      addControl(id, label, callback) {
        try {
          if (!id || !label || typeof callback !== 'function') throw new Error('Invalid control parameters');
          this.controls[id] = { label, callback };
          updateControls();
        } catch (e) {
          logError(`Add control failed: ${e.message}`, e.stack);
        }
      }

      clear() {
        try {
          this.objects.forEach(obj => this.scene.remove(obj));
          this.instancedObjects.forEach(obj => {
            this.scene.remove(obj);
            obj.geometry.dispose();
            obj.material.dispose();
          });
          this.objects = [];
          this.instancedObjects = [];
          this.animations = [];
          this.entityCount = 0;
          this.controls = {};
          updateControls();
          logInfo('Scene cleared');
          updateStatus();
        } catch (e) {
          logError(`Clear scene failed: ${e.message}`, e.stack);
        }
      }

      render() {
        try {
          if (this.webglContextLost) return;
          const now = performance.now();
          const deltaTime = Math.min((now - this.lastTime) / 1000, 0.1);
          this.lastTime = now;

          this.cameraMatrix.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse);
          this.frustum.setFromProjectionMatrix(this.cameraMatrix);

          this.animations.forEach((a, i) => {
            const t = Math.min((performance.now() / 1000 - a.t0) / a.duration, 1);
            const et = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
            const obj = this.objects.find(o => o.userData.name === a.name);
            if (obj) {
              const p0 = obj.position;
              obj.position.set(
                p0.x + (a.target[0] - p0.x) * et,
                p0.y + (a.target[1] - p0.y) * et,
                p0.z + (a.target[2] - p0.z) * et
              );
              if (t >= 1) {
                logInfo(`Animation ${a.name} done`);
                this.animations.splice(i, 1);
              }
            }
          });

          if (this.renderer) {
            this.renderer.render(this.scene, this.camera);
            logInfo('WebGL render pass completed', 'info');
          }
        } catch (e) {
          logError(`Render failed: ${e.message}`, e.stack);
          stopRender();
        }
      }

      dispose() {
        try {
          this.objects.forEach(obj => {
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) obj.material.dispose();
          });
          this.instancedObjects.forEach(obj => {
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) obj.material.dispose();
          });
          this.renderer?.dispose();
          logInfo('Engine resources disposed');
        } catch (e) {
          logError(`Dispose failed: ${e.message}`, e.stack);
        }
      }
    }

    // MD3D Manager
    class MD3D {
      constructor(engine) {
        this.engine = engine;
      }

      add_shape(type, name, position, size, color) {
        try {
          if (type !== 'cube') throw new Error('Only cube shapes supported');
          this.engine.addCube(name, position, size, color);
        } catch (e) {
          logError(`Add shape failed: ${e.message}`, e.stack);
        }
      }

      add_instanced_shape(name, type, count, position, size, color) {
        this.engine.addInstancedShape(name, type, count, position, size, color);
      }

      update_instance(name, index, position, rotation, scale, color) {
        this.engine.updateInstance(name, index, position, rotation, scale, color);
      }

      set_instance_count(name, count) {
        this.engine.setInstanceCount(name, count);
      }

      add_light(name, type, position, color, intensity) {
        this.engine.addLight(name, type, position, color, intensity);
      }

      set_camera(position, rotation) {
        this.engine.setCamera(position, rotation);
      }

      animate(name, position, duration) {
        this.engine.animate(name, position, duration);
      }

      add_control(id, label, callback) {
        this.engine.addControl(id, label, callback);
      }

      clear() {
        try {
          this.engine.clear();
          updateFn = null;
          logInfo('MD3D cleared');
        } catch (e) {
          logError(`MD3D clear failed: ${e.message}`, e.stack);
        }
      }

      test() {
        try {
          logInfo('Testing...');
          logInfo(`Entities: ${this.engine.entityCount}, Animations: ${this.engine.animations.length}`);
          logInfo(`Engine: ${this.engine ? 'OK' : 'Failed'}`);
          logInfo('Test passed');
        } catch (e) {
          logError(`Test failed: ${e.message}`, e.stack);
        }
      }
    }

    let log = [], engine = null, md3d = null, rendering = false, renderId, perfId, isInitialized = false;
    let updateFn = null;

    function logInfo(msg, level = 'info') {
      try {
        const c = document.getElementById('console');
        c.innerHTML += `<div class="log-${level}">[MD3D] ${msg}</div>`;
        c.lastElementChild?.scrollIntoView();
        log.push({ time: new Date().toISOString(), level: level.toUpperCase(), msg });
        if (log.length > 100) log.shift();
        document.getElementById('log-output').value = log.map(e => `[${e.time}] [${e.level}] ${e.msg}`).join('\n');
        document.getElementById('copy-log-btn').disabled = false;
      } catch (e) {
        console.error(`Log info failed: ${e.message}`);
      }
    }

    function logError(msg, traceback = '') {
      try {
        const ec = document.getElementById('error-console');
        ec.innerHTML += `<div class="log-error">[ERROR] ${msg}${traceback ? '<br>Traceback: ' + traceback : ''}</div>`;
        if (ec.children.length > 100) ec.removeChild(ec.firstChild);
        ec.lastElementChild?.scrollIntoView();
        log.push({ time: new Date().toISOString(), level: 'ERROR', msg });
        if (log.length > 100) log.shift();
        document.getElementById('log-output').value = log.map(e => `[${e.time}] [${e.level}] ${e.msg}`).join('\n');
        document.getElementById('copy-log-btn').disabled = false;
      } catch (e) {
        console.error(`Log error failed: ${e.message}`);
      }
    }

    function updateStatus() {
      try {
        document.getElementById('entities').textContent = engine ? engine.entityCount : 0;
      } catch (e) {
        logError(`Update status failed: ${e.message}`, e.stack);
      }
    }

    function updateControls() {
      try {
        const controlsDiv = document.getElementById('controls');
        controlsDiv.innerHTML = '';
        Object.entries(engine.controls).forEach(([id, { label, callback }]) => {
          const div = document.createElement('div');
          div.className = 'control-item';
          const btn = document.createElement('button');
          btn.id = id;
          btn.textContent = label;
          btn.onclick = callback;
          div.appendChild(btn);
          controlsDiv.appendChild(div);
        });
      } catch (e) {
        logError(`Update controls failed: ${e.message}`, e.stack);
      }
    }

    async function init() {
      if (isInitialized) {
        logInfo('Already initialized, skipping');
        return;
      }
      try {
        logInfo('Initializing...');
        await init3D();
        md3d = new MD3D(engine);
        initControls();
        logInfo('Initialized');
        ['execute', 'markdown-btn', 'clear-btn', 'debug-btn', 'copy-log-btn'].forEach(id => {
          const el = document.getElementById(id);
          el.disabled = false;
          el.setAttribute('aria-disabled', 'false');
        });
        isInitialized = true;
      } catch (e) {
        logError(`Init failed: ${e.message}`, e.stack);
        document.getElementById('webgl-status').textContent = 'Failed';
        disableUI();
      }
    }

    function disableUI() {
      try {
        ['execute', 'markdown-btn', 'clear-btn', 'debug-btn', 'copy-log-btn'].forEach(id => {
          const el = document.getElementById(id);
          el.disabled = true;
          el.setAttribute('aria-disabled', 'true');
        });
      } catch (e) {
        logError(`Disable UI failed: ${e.message}`, e.stack);
      }
    }

    async function init3D() {
      try {
        const canvas = document.getElementById('md3d-canvas');
        engine = new CosmicEngine(canvas);
        engine.init();
        resize();
        logInfo('3D initialized');
      } catch (e) {
        logError(`3D init failed: ${e.message}`, e.stack);
        document.getElementById('webgl-status').textContent = 'Failed';
        throw e;
      }
    }

    function render() {
      if (rendering || engine?.webglContextLost) return;
      rendering = true;
      const loop = () => {
        try {
          if (!engine || engine.webglContextLost) {
            logError('Render stopped: Engine invalid or context lost');
            stopRender();
            return;
          }
          if (document.getElementById('md3d-popup').style.display === 'none') {
            logInfo('Render stopped: 3D canvas closed');
            stopRender();
            return;
          }
          const t0 = performance.now();
          if (updateFn) {
            try {
              updateFn(md3d, engine.scene, engine.camera, engine, engine.objects, engine.animations, engine.keys, { dragging: engine.isDragging, dx: 0, dy: 0 });
            } catch (e) {
              logError(`Update failed: ${e.message}`, e.stack);
            }
          }
          engine.render();
          document.getElementById('time').textContent = (performance.now() - t0).toFixed(2);
          renderId = requestAnimationFrame(loop);
        } catch (e) {
          logError(`Render loop failed: ${e.message}`, e.stack);
          stopRender();
        }
      };
      renderId = requestAnimationFrame(loop);
    }

    function stopRender() {
      try {
        if (renderId) {
          cancelAnimationFrame(renderId);
          renderId = null;
          rendering = false;
          logInfo('Render stopped');
        }
      } catch (e) {
        logError(`Stop render failed: ${e.message}`, e.stack);
      }
    }

    function updatePerf() {
      try {
        let t0 = performance.now(), frames = 0;
        const loop = t => {
          frames++;
          if (t - t0 >= 1000) {
            document.getElementById('fps').textContent = (frames * 1000 / (t - t0)).toFixed(2);
            if (performance.memory) {
              document.getElementById('memory').textContent = (performance.memory.usedJSHeapSize / 1e6).toFixed(2);
            }
            frames = 0;
            t0 = t;
          }
          perfId = requestAnimationFrame(loop);
        };
        perfId = requestAnimationFrame(loop);
      } catch (e) {
        logError(`Update perf failed: ${e.message}`, e.stack);
      }
    }

    function initControls() {
      try {
        const canvas = document.getElementById('md3d-canvas');
        canvas.addEventListener('mousedown', e => {
          engine.isDragging = true;
          engine.previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        canvas.addEventListener('mousemove', e => {
          if (engine.isDragging) {
            const deltaX = e.clientX - engine.previousMousePosition.x;
            const deltaY = e.clientY - engine.previousMousePosition.y;
            engine.previousMousePosition = { x: e.clientX, y: e.clientY };
            if (updateFn) {
              updateFn(md3d, engine.scene, engine.camera, engine, engine.objects, engine.animations, engine.keys, { dragging: true, dx: deltaX, dy: deltaY });
            }
          }
        });
        canvas.addEventListener('mouseup', () => {
          engine.isDragging = false;
        });
        canvas.addEventListener('touchstart', e => {
          e.preventDefault();
          engine.previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });
        canvas.addEventListener('touchmove', e => {
          e.preventDefault();
          const deltaX = e.touches[0].clientX - engine.previousMousePosition.x;
          const deltaY = e.touches[0].clientY - engine.previousMousePosition.y;
          engine.previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
          if (updateFn) {
            updateFn(md3d, engine.scene, engine.camera, engine, engine.objects, engine.animations, engine.keys, { dragging: true, dx: deltaX, dy: deltaY });
          }
        });
        document.addEventListener('keydown', e => {
          if (document.activeElement === document.getElementById('input') && e.key === 'Enter') {
            execCmd();
          } else if (['w', 's', 'a', 'd', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key) && document.activeElement !== document.getElementById('input')) {
            engine.keys[e.key] = true;
            e.preventDefault();
          }
        });
        document.addEventListener('keyup', e => {
          if (['w', 's', 'a', 'd', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
            engine.keys[e.key] = false;
          }
        });
      } catch (e) {
        logError(`Init controls failed: ${e.message}`, e.stack);
      }
    }

    async function parseMD(code) {
      try {
        const normalizedCode = code.replace(/\r\n/g, '\n').trim();
        const lines = normalizedCode.split('\n').filter(l => l.trim() !== '');
        logInfo(`Parsing ${lines.length} lines`);
        const cmds = [];
        let inCode = false, codeBlock = '', codeType = '', validCount = 0;
        for (let i = 0; i < lines.length; i++) {
          const l = lines[i].trim();
          try {
            if (l.match(/^```(javascript|glsl|wgsl|text)$/)) {
              inCode = true;
              codeType = l.match(/^```(\w+)/)[1];
              codeBlock = '';
              logInfo(`Code block (${codeType}) started at line ${i + 1}`);
              continue;
            }
            if (l.startsWith('```') && inCode) {
              inCode = false;
              if (codeBlock.trim()) {
                if (codeType === 'javascript') {
                  try {
                    new Function(codeBlock);
                    cmds.push({ type: 'js', content: codeBlock, line: i + 1 });
                    logInfo(`JS block parsed at line ${i + 1}: ${codeBlock.slice(0, 20)}...`);
                    validCount++;
                  } catch (e) {
                    logError(`Invalid JS block at line ${i + 1}: ${e.message}`, e.stack);
                    return null;
                  }
                }
              }
              continue;
            }
            if (inCode) {
              codeBlock += l + '\n';
              continue;
            }
            if (l.startsWith('#') || l.startsWith('//') || l.startsWith('<!--')) continue;
            const shape = l.match(/^add_shape\s*\(\s*cube\s*,\s*"?([^",]+)"?\s*,\s*position\s*=\s*\(\s*([^)]+)\s*\)\s*,\s*size\s*=\s*([^,]+)\s*,\s*color\s*=\s*\(\s*([^)]+)\s*\)\s*\)$/);
            if (shape) {
              const [, name, pos, size, col] = shape;
              const p = pos.split(/\s*,\s*/).map(Number), c = col.split(/\s*,\s*/).map(Number);
              if (p.length !== 3 || p.some(isNaN) || isNaN(size) || size <= 0 || c.length !== 3 || c.some(isNaN)) {
                throw new Error(`Invalid shape parameters at line ${i + 1}`);
              }
              cmds.push({ type: 'command', content: `md3d.add_shape("cube", "${name.trim()}", [${p.join(',')}], ${size}, [${c.join(',')}]);`, line: i + 1 });
              logInfo(`Generated: add_shape(${name.trim()}) at line ${i + 1}`);
              validCount++;
              continue;
            }
            const instancedShape = l.match(/^add_instanced_shape\s*\(\s*"?([^",]+)"?\s*,\s*(cube|tetrahedron|sphere)\s*,\s*count\s*=\s*([^,]+)\s*,\s*position\s*=\s*\(\s*([^)]+)\s*\)\s*,\s*size\s*=\s*([^,]+)\s*,\s*color\s*=\s*\(\s*([^)]+)\s*\)\s*\)$/);
            if (instancedShape) {
              const [, name, type, count, pos, size, col] = instancedShape;
              const p = pos.split(/\s*,\s*/).map(Number), c = col.split(/\s*,\s*/).map(Number);
              if (p.length !== 3 || p.some(isNaN) || isNaN(count) || count < 1 || isNaN(size) || size <= 0 || c.length !== 3 || c.some(isNaN)) {
                throw new Error(`Invalid instanced shape parameters at line ${i + 1}`);
              }
              cmds.push({ type: 'command', content: `md3d.add_instanced_shape("${name.trim()}", "${type}", ${count}, [${p.join(',')}], ${size}, [${c.join(',')}]);`, line: i + 1 });
              logInfo(`Generated: add_instanced_shape(${name.trim()}) at line ${i + 1}`);
              validCount++;
              continue;
            }
            const updateInstance = l.match(/^update_instance\s*\(\s*"?([^",]+)"?\s*,\s*index\s*=\s*([^,]+)\s*,\s*position\s*=\s*\(\s*([^)]+)\s*\)\s*(?:,\s*rotation\s*=\s*\(\s*([^)]+)\s*\))?\s*(?:,\s*scale\s*=\s*([^,]+))?\s*(?:,\s*color\s*=\s*\(\s*([^)]+)\s*\))?\s*\)$/);
            if (updateInstance) {
              const [, name, index, pos, rot, scale, col] = updateInstance;
              const p = pos.split(/\s*,\s*/).map(Number);
              const r = rot ? rot.split(/\s*,\s*/).map(Number) : null;
              const c = col ? col.split(/\s*,\s*/).map(Number) : null;
              if (p.length !== 3 || p.some(isNaN) || isNaN(index) || (r && (r.length !== 3 || r.some(isNaN))) || (scale && isNaN(scale)) || (c && (c.length !== 3 || c.some(isNaN)))) {
                throw new Error(`Invalid update instance parameters at line ${i + 1}`);
              }
              let content = `md3d.update_instance("${name.trim()}", ${index}, [${p.join(',')}]`;
              if (r) content += `, [${r.join(',')}]`;
              else content += `, null`;
              if (scale) content += `, ${scale}`;
              else content += `, null`;
              if (c) content += `, [${c.join(',')}]`;
              else content += `, null`;
              content += `);`;
              cmds.push({ type: 'command', content, line: i + 1 });
              logInfo(`Generated: update_instance(${name.trim()}, ${index}) at line ${i + 1}`);
              validCount++;
              continue;
            }
            const setInstanceCount = l.match(/^set_instance_count\s*\(\s*"?([^",]+)"?\s*,\s*count\s*=\s*([^)]+)\s*\)$/);
            if (setInstanceCount) {
              const [, name, count] = setInstanceCount;
              if (isNaN(count) || count < 1) {
                throw new Error(`Invalid instance count at line ${i + 1}`);
              }
              cmds.push({ type: 'command', content: `md3d.set_instance_count("${name.trim()}", ${count});`, line: i + 1 });
              logInfo(`Generated: set_instance_count(${name.trim()}) at line ${i + 1}`);
              validCount++;
              continue;
            }
            const light = l.match(/^add_light\s*\(\s*"?([^",]+)"?\s*,\s*point\s*,\s*position\s*=\s*\(\s*([^)]+)\s*\)\s*,\s*color\s*=\s*\(\s*([^)]+)\s*\)\s*,\s*intensity\s*=\s*([^)]+)\s*\)$/);
            if (light) {
              const [, name, pos, col, intensity] = light;
              const p = pos.split(/\s*,\s*/).map(Number), c = col.split(/\s*,\s*/).map(Number);
              if (p.length !== 3 || p.some(isNaN) || c.length !== 3 || c.some(isNaN) || isNaN(intensity) || intensity < 0) {
                throw new Error(`Invalid light parameters at line ${i + 1}`);
              }
              cmds.push({ type: 'command', content: `md3d.add_light("${name.trim()}", "point", [${p.join(',')}], [${c.join(',')}], ${intensity});`, line: i + 1 });
              logInfo(`Generated: add_light(${name.trim()}) at line ${i + 1}`);
              validCount++;
              continue;
            }
            const cam = l.match(/^set_camera\s*\(\s*position\s*=\s*\(\s*([^)]+)\s*\)\s*,\s*rotation\s*=\s*\(\s*([^)]+)\s*\)\s*\)$/);
            if (cam) {
              const [, pos, rot] = cam;
              const p = pos.split(/\s*,\s*/).map(Number), r = rot.split(/\s*,\s*/).map(Number);
              if (p.length !== 3 || p.some(isNaN) || r.length !== 3 || r.some(isNaN)) {
                throw new Error(`Invalid camera parameters at line ${i + 1}`);
              }
              cmds.push({ type: 'command', content: `md3d.set_camera([${p.join(',')}], [${r.join(',')}]);`, line: i + 1 });
              logInfo(`Generated: set_camera at line ${i + 1}`);
              validCount++;
              continue;
            }
            const anim = l.match(/^animate\s*\(\s*"?([^",]+)"?\s*,\s*position\s*=\s*\(\s*([^)]+)\s*\)\s*,\s*duration\s*=\s*([^)]+)\s*\)$/);
            if (anim) {
              const [, name, pos, duration] = anim;
              const p = pos.split(/\s*,\s*/).map(Number);
              if (p.length !== 3 || p.some(isNaN) || isNaN(duration) || duration <= 0) {
                throw new Error(`Invalid animation parameters at line ${i + 1}`);
              }
              cmds.push({ type: 'command', content: `md3d.animate("${name.trim()}", [${p.join(',')}], ${duration});`, line: i + 1 });
              logInfo(`Generated: animate(${name.trim()}) at line ${i + 1}`);
              validCount++;
              continue;
            }
            const control = l.match(/^add_control\s*\(\s*"?([^",]+)"?\s*,\s*"([^"]+)"\s*,\s*([^)]+)\s*\)$/);
            if (control) {
              const [, id, label, callback] = control;
              cmds.push({ type: 'command', content: `md3d.add_control("${id.trim()}", "${label.trim()}", ${callback.trim()});`, line: i + 1 });
              logInfo(`Generated: add_control(${id.trim()}) at line ${i + 1}`);
              validCount++;
              continue;
            }
            logInfo(`Skipped line ${i + 1}: ${l.slice(0, 20)}... (invalid)`, 'warning');
          } catch (e) {
            logError(`Line ${i + 1}: ${e.message}`, e.stack);
          }
        }
        if (inCode) {
          logError(`Unclosed ${codeType} block at line ${lines.length}`);
          return null;
        }
        if (!validCount) {
          logError('No valid commands found');
          return null;
        }
        return cmds;
      } catch (e) {
        logError(`Parse MD failed: ${e.message}`, e.stack);
        return null;
      }
    }

    async function injectMD(code = null) {
      try {
        if (!md3d || !engine) {
          logError('Cannot inject MD: Engine or MD3D not initialized');
          return;
        }
        const mdInput = document.getElementById('md-input').value.trim();
        const finalCode = code ? code.replace(/\r\n/g, '\n').trim() : mdInput.replace(/\r\n/g, '\n').trim();
        if (!finalCode) {
          logInfo('No MD to inject', 'warning');
          return;
        }
        if (code && mdInput) {
          logInfo(`Ignoring manual input (${mdInput.split('\n').length} lines); using provided code`, 'warning');
          document.getElementById('md-input').value = '';
          document.getElementById('line-count').textContent = 'Lines: 0';
        }
        const cmds = await parseMD(finalCode);
        if (!cmds) {
          logError('No valid content to execute');
          return;
        }
        for (const cmd of cmds) {
          if (cmd.type === 'js') {
            try {
              updateFn = new Function('md3d', 'scene', 'camera', 'renderer', 'sceneObjects', 'animations', 'keyboardState', 'touchState', cmd.content);
              logInfo(`JS update function loaded at line ${cmd.line}`);
              updateFn(md3d, engine.scene, engine.camera, engine, engine.objects, engine.animations, engine.keys, { dragging: engine.isDragging, dx: 0, dy: 0 });
              logInfo(`JS update function executed at line ${cmd.line}`);
            } catch (e) {
              logError(`JS execution failed at line ${cmd.line}: ${e.message}`, e.stack);
            }
          } else if (cmd.type === 'command') {
            try {
              eval(cmd.content);
              logInfo(`Command executed at line ${cmd.line}: ${cmd.content.slice(0, 20)}...`);
            } catch (e) {
              logError(`Command execution failed at line ${cmd.line}: ${e.message}`, e.stack);
            }
          }
        }
        logInfo(`MD ran: entities=${engine.entityCount}, animations=${engine.animations.length}`);
        show3D();
        if (!rendering) render();
        if (document.getElementById('md-popup').style.display === 'block') closePopup();
      } catch (e) {
        logError(`MD injection failed: ${e.message}`, e.stack);
      }
    }

    function showPopup() {
      try {
        document.getElementById('md-popup').style.display = 'block';
        updateLineCount();
        logInfo('MD popup opened');
      } catch (e) {
        logError(`Show popup failed: ${e.message}`, e.stack);
      }
    }

    function closePopup() {
      try {
        document.getElementById('md-popup').style.display = 'none';
        document.getElementById('md-input').value = '';
        document.getElementById('line-count').textContent = 'Lines: 0';
        logInfo('MD popup closed');
      } catch (e) {
        logError(`Close popup failed: ${e.message}`, e.stack);
      }
    }

    function updateLineCount() {
      try {
        const input = document.getElementById('md-input').value;
        const lineCount = input.split('\n').length;
        document.getElementById('line-count').textContent = `Lines: ${lineCount}`;
      } catch (e) {
        logError(`Update line count failed: ${e.message}`, e.stack);
      }
    }

    function show3D() {
      try {
        if (!engine) {
          logError('Cannot show 3D canvas: Engine not initialized');
          return;
        }
        document.getElementById('md3d-popup').style.display = 'block';
        resize();
        if (!rendering) render();
        const canvas = document.getElementById('md3d-canvas');
        canvas.setAttribute('aria-label', `3D canvas with ${engine.entityCount} entities`);
        logInfo('3D canvas opened');
      } catch (e) {
        logError(`Show 3D failed: ${e.message}`, e.stack);
      }
    }

    function close3D() {
      try {
        document.getElementById('md3d-popup').style.display = 'none';
        stopRender();
        logInfo('3D canvas closed');
      } catch (e) {
        logError(`Close 3D failed: ${e.message}`, e.stack);
      }
    }

    function showPrompt(text) {
      try {
        const prompt = document.getElementById('prompt');
        prompt.textContent = text;
        prompt.classList.add('active');
        setTimeout(() => prompt.classList.remove('active'), 2000);
      } catch (e) {
        logError(`Show prompt failed: ${e.message}`, e.stack);
      }
    }

    async function debug() {
      try {
        if (!md3d || !engine) {
          logError('Cannot debug: Engine or MD3D not initialized');
          return;
        }
        logInfo('Debugging with test3d.md...');
        md3d.clear();
        const test3d = `
# Test3D Instanced Mesh Test
add_instanced_shape(drones, tetrahedron, count=100, position=(0, 0, -50), size=2, color=(0, 1, 0))
add_light(main_light, point, position=(5, 5, 5), color=(1, 1, 1), intensity=1)
set_camera(position=(0, 0, 12), rotation=(0, 0, 0))

\`\`\`javascript
function updateFn(md3d, scene, camera, renderer, sceneObjects, animations, keyboardState, touchState) {
  const t = performance.now() / 1000;
  const instancedMesh = renderer.instancedObjects.find(o => o.userData.name === 'drones');
  if (instancedMesh) {
    const matrix = new THREE.Matrix4();
    for (let i = 0; i < instancedMesh.count; i++) {
      const phi = Math.acos(-1 + (2 * i) / instancedMesh.count);
      const theta = Math.sqrt(instancedMesh.count * Math.PI) * phi;
      matrix.setPosition(
        10 * Math.cos(theta) * Math.sin(phi),
        10 * Math.sin(theta) * Math.sin(phi),
        10 * Math.cos(phi) - 50
      );
      instancedMesh.setMatrixAt(i, matrix);
      instancedMesh.setColorAt(i, new THREE.Color(
        Math.sin(t + i * 0.1) * 0.5 + 0.5,
        0,
        Math.cos(t + i * 0.1) * 0.5 + 0.5
      ));
    }
    instancedMesh.instanceMatrix.needsUpdate = true;
    instancedMesh.instanceColor.needsUpdate = true;
  }
}
\`\`\`
`;
        let fpsSamples = [], renderTimes = [], peakMemory = 0;
        const t0 = performance.now();
        const sampleFPS = () => {
          const fps = Number(document.getElementById('fps').textContent);
          const rt = Number(document.getElementById('time').textContent);
          if (performance.memory) {
            const mem = performance.memory.usedJSHeapSize / 1e6;
            peakMemory = Math.max(peakMemory, mem);
          }
          fpsSamples.push(fps);
          renderTimes.push(rt);
        };
        await injectMD(test3d);
        const initialAnimations = engine.animations.length;
        const checks = [
          { id: 1, test: '3D init', fn: () => engine ? 'OK' : 'Failed' },
          { id: 2, test: 'Scene', fn: () => engine.scene ? 'OK' : 'Failed' },
          { id: 3, test: 'Camera', fn: () => engine.camera ? 'OK' : 'Failed' },
          { id: 4, test: 'Engine', fn: () => engine ? 'OK' : 'Failed' },
          { id: 5, test: 'Rendering', fn: () => engine.entityCount >= 100 ? 'OK' : `Failed (${engine.entityCount} entities)` },
          { id: 6, test: 'Animations', fn: () => initialAnimations === 0 ? 'OK' : `Failed (${initialAnimations} animations)` },
          { id: 7, test: 'MD3D', fn: () => md3d ? 'OK' : 'Failed' },
          { id: 8, test: 'Entities', fn: () => engine.entityCount >= 100 ? 'OK' : `Failed (${engine.entityCount} entities)` },
          { id: 9, test: 'WebGL Context', fn: () => engine.renderer ? 'OK' : 'Failed' },
          { id: 10, test: 'Test MD Execution', fn: () => engine.instancedObjects.find(o => o.userData.name === 'drones') ? 'OK' : 'Failed' }
        ];
        let failedChecks = 0;
        for (let c of checks) {
          const r = c.fn();
          if (r === 'OK') {
            logInfo(`[CHECK ${c.id}] ${c.test}: ${r}`);
          } else {
            logError(`[CHECK ${c.id}] ${c.test}: ${r}`);
            failedChecks++;
          }
        }
        const interval = setInterval(sampleFPS, 100);
        setTimeout(() => {
          clearInterval(interval);
          const avgFPS = fpsSamples.length ? (fpsSamples.reduce((a, b) => a + b, 0) / fpsSamples.length).toFixed(2) : 0;
          const avgRenderTime = renderTimes.length ? (renderTimes.reduce((a, b) => a + b, 0) / renderTimes.length).toFixed(2) : 0;
          const summary = `Debug Summary: ${failedChecks === 0 ? 'PASSED' : 'FAILED'}, ` +
                          `Renderer: WebGL, Entities: ${engine.entityCount}, Initial Animations: ${initialAnimations}, ` +
                          `Avg FPS: ${avgFPS}, Avg Render Time: ${avgRenderTime}ms, Peak Memory: ${peakMemory.toFixed(2)}MB, ` +
                          `Checks Failed: ${failedChecks}`;
          if (failedChecks === 0) {
            logInfo(summary);
          } else {
            logError(summary);
          }
          logInfo('Debug done');
          if (engine.entityCount >= 100 && failedChecks === 0) {
            logInfo('Debug test passed, closing 3D canvas');
            close3D();
          } else {
            logError('Debug test failed, keeping 3D canvas open for inspection');
          }
        }, 3000);
      } catch (e) {
        logError(`Debug failed: ${e.message}`, e.stack);
      }
    }

    function copyLog() {
      try {
        if (!log.length) {
          logInfo('No logs to copy');
          return;
        }
        navigator.clipboard.writeText(document.getElementById('log-output').value)
          .then(() => logInfo('Logs copied'))
          .catch(e => {
            const out = document.getElementById('log-output');
            out.style.display = 'block';
            out.focus();
            out.select();
            logError('Clipboard failed; copy manually', e.stack);
          });
      } catch (e) {
        logError(`Copy log failed: ${e.message}`, e.stack);
      }
    }

    function resize() {
      try {
        if (!engine) {
          logError('Cannot resize: Engine not initialized');
          return;
        }
        const popup = document.getElementById('md3d-popup');
        const rect = popup.getBoundingClientRect();
        const w = Math.min(rect.width - 30, 3840), h = Math.min(rect.height - 30, 2160);
        engine.setSize(w, h);
      } catch (e) {
        logError(`Resize failed: ${e.message}`, e.stack);
      }
    }

    function clearApp() {
      try {
        if (md3d) md3d.clear();
        document.getElementById('console').innerHTML = '';
        document.getElementById('error-console').innerHTML = '';
        document.getElementById('log-output').value = '';
        log = [];
        document.getElementById('copy-log-btn').disabled = true;
        logInfo('Application cleared');
      } catch (e) {
        logError(`Clear app failed: ${e.message}`, e.stack);
      }
    }

    // Initialize
    try {
      addEventListener('resize', resize);
      addEventListener('beforeunload', () => {
        stopRender();
        if (perfId) cancelAnimationFrame(perfId);
        engine?.dispose();
      });
      document.getElementById('execute').onclick = execCmd;
      document.getElementById('markdown-btn').onclick = showPopup;
      document.getElementById('clear-btn').onclick = clearApp;
      document.getElementById('copy-log-btn').onclick = copyLog;
      document.getElementById('debug-btn').onclick = debug;
      document.getElementById('md-input').addEventListener('input', updateLineCount);
      init();
      updatePerf();
    } catch (e) {
      logError(`Initialization failed: ${e.message}`, e.stack);
    }

    const commands = {
      '/help': () => {
        logInfo('Commands: /test, /show3d, /clear');
      },
      '/test': () => md3d.test(),
      '/show3d': () => show3D(),
      '/clear': () => clearApp()
    };

    function execCmd() {
      try {
        const cmd = document.getElementById('input').value.trim().split(' ');
        const action = cmd[0];
        const args = cmd.slice(1);
        if (commands[action]) commands[action](...args);
        else logError(`Unknown command: ${action}`);
        document.getElementById('input').value = '';
      } catch (e) {
        logError(`Execute command failed: ${e.message}`, e.stack);
      }
    }
  </script>
</body>
</html>
