<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>COMMAND AND QUANTIFY | WebXOS 2025</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000000;
            color: #00ff41;
            min-height: 100vh;
            overflow: hidden;
            font-family: 'Orbitron', sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 5px;
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(0, 255, 65, 0.1) 0%, transparent 20%),
                radial-gradient(circle at 90% 80%, rgba(0, 255, 65, 0.1) 0%, transparent 20%),
                linear-gradient(45deg, #000000 0%, #0a0a0a 100%);
        }
        
        .game-container {
            display: grid;
            grid-template-columns: 250px 1fr 250px;
            grid-template-rows: 60px 1fr 25px;
            gap: 8px;
            width: 100%;
            max-width: 1400px;
            height: 90vh;
            max-height: 800px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ff41;
            border-bottom: 4px solid #00ff41;
            border-radius: 5px;
            padding: 8px;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.5),
                        inset 0 0 20px rgba(0, 255, 65, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        /* Header */
        .header {
            grid-column: 1 / -1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background: rgba(0, 10, 0, 0.9);
            border-radius: 5px;
            border: 1px solid #00ff41;
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
            text-shadow: 0 0 10px rgba(0, 255, 65, 0.7);
        }
        
        .logo {
            font-family: 'Press Start 2P', cursive;
            font-size: 14px;
            font-weight: bold;
            color: #00ff41;
            text-shadow: 0 0 10px rgba(0, 255, 65, 0.7);
            letter-spacing: 1px;
        }
        
        .game-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .mode-selector {
            background: rgba(0, 30, 0, 0.7);
            border: 1px solid #00ff41;
            border-radius: 3px;
            color: #00ff41;
            padding: 4px 6px;
            font-size: 10px;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
        }
        
        .round-info {
            font-size: 12px;
            color: #00ff41;
            font-weight: bold;
            margin-left: 8px;
        }
        
        /* Battlefield */
        .battlefield-container {
            grid-column: 2;
            grid-row: 2;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 10, 0, 0.7);
            border-radius: 5px;
            padding: 4px;
            border: 1px solid #00ff41;
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.3),
                        inset 0 0 10px rgba(0, 255, 65, 0.1);
            overflow: hidden;
            position: relative;
        }
        
        .battlefield {
            display: grid;
            gap: 1px;
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            background: rgba(10, 20, 10, 0.5);
            border-radius: 3px;
            padding: 2px;
            border: 1px solid rgba(0, 255, 65, 0.3);
            box-sizing: border-box;
            position: relative;
        }
        
        .grid-cell {
            background: rgba(0, 30, 0, 0.3);
            border: 1px dashed rgba(0, 255, 65, 0.2);
            border-radius: 1px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
            min-height: 0;
            min-width: 0;
        }
        
        .grid-cell:hover {
            background: rgba(0, 100, 0, 0.3);
            box-shadow: 0 0 5px rgba(0, 200, 65, 0.5);
        }
        
        .entity {
            width: 70%;
            height: 70%;
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            text-align: center;
            color: white;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            position: absolute;
            text-shadow: 1px 1px 2px black;
            transition: all 0.3s ease;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .player-0 .entity {
            background: linear-gradient(135deg, #00ff00, #00aa00);
            border: 1px solid #00ff00;
            box-shadow: 0 0 3px #00ff00;
        }
        
        .player-1 .entity {
            background: linear-gradient(135deg, #0088ff, #0044aa);
            border: 1px solid #0088ff;
            box-shadow: 0 0 3px #0088ff;
        }
        
        .player-2 .entity {
            background: linear-gradient(135deg, #ffff00, #aaaa00);
            border: 1px solid #ffff00;
            box-shadow: 0 0 3px #ffff00;
        }
        
        .player-3 .entity {
            background: linear-gradient(135deg, #ff0000, #aa0000);
            border: 1px solid #ff0000;
            box-shadow: 0 0 3px #ff0000;
        }
        
        .entity.selected {
            box-shadow: 0 0 0 1px white, 0 0 5px white;
            animation: pulse 1s infinite;
            transform: translate(-50%, -50%) scale(1.05);
        }
        
        .entity.last-move {
            box-shadow: 0 0 0 1px white, 0 0 10px white, 0 0 15px white;
            animation: lastMovePulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.05); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
        
        @keyframes lastMovePulse {
            0% { box-shadow: 0 0 0 1px white, 0 0 10px white, 0 0 15px white; }
            50% { box-shadow: 0 0 0 2px white, 0 0 15px white, 0 0 20px white; }
            100% { box-shadow: 0 0 0 1px white, 0 0 10px white, 0 0 15px white; }
        }
        
        /* Player Panels */
        .player-panel {
            background: rgba(0, 10, 0, 0.9);
            border-radius: 5px;
            padding: 6px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            border: 1px solid;
            position: relative;
            overflow: hidden;
            height: 100%;
        }
        
        .player-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, currentColor, transparent);
        }
        
        .player-0.panel {
            border-color: #00ff00;
        }
        
        .player-1.panel {
            border-color: #0088ff;
        }
        
        .player-2.panel {
            border-color: #ffff00;
        }
        
        .player-3.panel {
            border-color: #ff0000;
        }
        
        .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
            font-size: 9px;
            font-weight: bold;
            color: #00ff41;
            flex-shrink: 0;
        }
        
        .player-resources {
            font-size: 10px;
            font-weight: bold;
            margin-bottom: 4px;
            text-align: center;
            color: #ffff00;
            text-shadow: 0 0 3px rgba(255, 255, 0, 0.7);
            flex-shrink: 0;
        }
        
        .build-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
            flex-grow: 1;
        }
        
        .build-btn {
            background: rgba(0, 30, 0, 0.7);
            border: 1px solid #00ff41;
            border-radius: 3px;
            color: #00ff41;
            padding: 4px;
            font-size: 8px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            font-family: 'Orbitron', sans-serif;
            min-height: 22px;
            width: 100%;
        }
        
        .build-btn:hover {
            background: rgba(0, 100, 0, 0.7);
            box-shadow: 0 0 5px rgba(0, 255, 65, 0.7);
        }
        
        .build-btn:disabled {
            background: rgba(10, 10, 10, 0.5);
            color: #666;
            border-color: #444;
            cursor: not-allowed;
            box-shadow: none;
        }
        
        .build-icon {
            font-size: 10px;
            margin-right: 4px;
            width: 12px;
            text-align: center;
        }
        
        /* Side Panels */
        .side-panel {
            background: rgba(0, 10, 0, 0.9);
            border-radius: 5px;
            padding: 6px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            border: 1px solid #00ff41;
            overflow-y: auto;
            min-height: 0;
        }
        
        .side-panel-left {
            grid-column: 1;
            grid-row: 2;
            display: flex;
            flex-direction: column;
            height: 100%;
            gap: 6px;
        }
        
        .side-panel-right {
            grid-column: 3;
            grid-row: 2;
            display: flex;
            flex-direction: column;
            gap: 6px;
            height: 100%;
        }
        
        .cpu-panel {
            padding: 5px;
            border-radius: 3px;
            border: 1px solid;
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }
        
        .cpu-panel.player-1 {
            border-color: #0088ff;
        }
        
        .cpu-panel.player-2 {
            border-color: #ffff00;
        }
        
        .cpu-panel.player-3 {
            border-color: #ff0000;
        }
        
        .player-status {
            font-size: 7px;
            text-align: center;
            margin-top: 2px;
            font-style: italic;
            color: #aaa;
        }
        
        /* QNN Controls */
        .qnn-controls {
            background: rgba(0, 20, 0, 0.8);
            border-radius: 3px;
            padding: 5px;
            border: 1px solid rgba(0, 255, 65, 0.5);
            flex-shrink: 0;
        }
        
        .qnn-title {
            font-size: 8px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 4px;
            color: #00ff88;
        }
        
        .slider-container {
            margin-bottom: 4px;
        }
        
        .slider-label {
            font-size: 7px;
            display: flex;
            justify-content: space-between;
            margin-bottom: 1px;
        }
        
        .slider {
            width: 100%;
            height: 3px;
            -webkit-appearance: none;
            background: rgba(0, 255, 65, 0.2);
            border-radius: 2px;
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #00ff41;
            cursor: pointer;
            box-shadow: 0 0 3px rgba(0, 255, 65, 0.7);
        }
        
        /* Visual Effects */
        .grid-cell.highlighted {
            box-shadow: inset 0 0 0 1px white, 0 0 5px white;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.6);
        }
        
        .player-active {
            box-shadow: 0 0 10px currentColor;
            animation: glow 2s infinite;
        }
        
        @keyframes glow {
            0% { box-shadow: 0 0 3px currentColor; }
            50% { box-shadow: 0 0 12px currentColor; }
            100% { box-shadow: 0 0 3px currentColor; }
        }
        
        .combat-animation {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 8px;
            z-index: 10;
            animation: explode 0.5s forwards;
        }
        
        @keyframes explode {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }
        
        /* Neural glow effect for user turn */
        .neural-glow {
            position: relative;
            overflow: hidden;
        }
        
        .neural-glow::after {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            background: linear-gradient(45deg, #00ff41, #00ff88, #00ff41);
            border-radius: 5px;
            z-index: -1;
            opacity: 0.5;
            filter: blur(6px);
            animation: neuralPulse 2s infinite;
        }
        
        @keyframes neuralPulse {
            0% { opacity: 0.3; }
            50% { opacity: 0.6; }
            100% { opacity: 0.3; }
        }
        
        /* Eliminated player styling */
        .player-eliminated {
            opacity: 0.5;
            border-color: #666 !important;
            box-shadow: none !important;
        }
        
        .player-eliminated::before {
            background: linear-gradient(90deg, transparent, #666, transparent) !important;
        }
        
        /* Victory screen */
        .victory-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: white;
            text-align: center;
            padding: 15px;
        }
        
        .victory-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 20px;
            color: #00ff41;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(0, 255, 65, 0.7);
        }
        
        .victory-subtitle {
            font-size: 16px;
            margin-bottom: 12px;
            color: #00ff41;
        }
        
        .ranking-list {
            list-style: none;
            margin: 12px 0;
            font-size: 12px;
        }
        
        .ranking-item {
            margin: 6px 0;
            padding: 6px 12px;
            border-radius: 3px;
            background: rgba(0, 255, 65, 0.1);
        }
        
        .ranking-1 {
            color: #ffff00;
            font-weight: bold;
            font-size: 14px;
            text-shadow: 0 0 3px rgba(255, 255, 0, 0.7);
        }
        
        .ranking-2 {
            color: #cccccc;
            font-size: 12px;
        }
        
        .ranking-3 {
            color: #ff9900;
            font-size: 11px;
        }
        
        .ranking-4 {
            color: #888888;
            font-size: 10px;
        }
        
        .restart-btn {
            background: linear-gradient(135deg, #00ff41, #00aa41);
            color: #000;
            border: none;
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.7);
            margin-top: 12px;
        }
        
        .restart-btn:hover {
            background: linear-gradient(135deg, #44ff41, #00cc41);
            box-shadow: 0 0 15px rgba(0, 255, 65, 0.9);
        }
        
        /* Footer with centered copyright */
        .footer {
            grid-column: 1 / -1;
            grid-row: 3;
            text-align: center;
            padding: 3px;
            font-size: 8px;
            color: #00ff41;
            opacity: 0.7;
            border-top: 1px solid #00ff41;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* Artifact - Hidden signature */
        .artifact {
            position: absolute;
            top: 3px;
            left: 8px;
            font-size: 6px;
            color: #00ff41;
            opacity: 0.3;
            font-family: 'Courier New', monospace;
        }
        
        /* Grid lines for better alignment */
        .battlefield::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                linear-gradient(to right, rgba(0, 255, 65, 0.05) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(0, 255, 65, 0.05) 1px, transparent 1px);
            pointer-events: none;
        }
        
        /* Ensure no scrolling */
        html, body {
            overflow: hidden;
        }
        
        /* New UI Improvements */
        
        /* Game Stats Panel */
        .game-stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 8px;
            flex-shrink: 0;
        }
        
        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .stat-value {
            font-weight: bold;
            color: #ffff00;
        }
        
        .stat-label {
            color: #00ff41;
            font-size: 7px;
        }
        
        /* Enhanced Side Panels */
        .side-panel-title {
            font-size: 10px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 4px;
            color: #00ff41;
            border-bottom: 1px solid #00ff41;
            padding-bottom: 3px;
            flex-shrink: 0;
        }
        
        /* Responsive adjustments */
        @media (max-width: 1024px) {
            .game-container {
                grid-template-columns: 200px 1fr 200px;
                gap: 6px;
                padding: 6px;
                height: 85vh;
                max-height: 700px;
            }
            
            .logo {
                font-size: 12px;
            }
            
            .round-info {
                font-size: 11px;
            }
            
            .player-header {
                font-size: 8px;
            }
            
            .player-resources {
                font-size: 9px;
            }
            
            .build-btn {
                font-size: 7px;
                padding: 3px;
                min-height: 20px;
            }
            
            .build-icon {
                font-size: 9px;
                margin-right: 3px;
            }
            
            .entity {
                font-size: 7px;
            }
        }
        
        @media (max-width: 768px) {
            .game-container {
                grid-template-columns: 1fr;
                grid-template-rows: 45px 1fr 20px;
                height: 85vh;
                max-height: 600px;
            }
            
            .header {
                grid-column: 1;
                grid-row: 1;
            }
            
            .battlefield-container {
                grid-column: 1;
                grid-row: 2;
                min-height: 300px;
            }
            
            .side-panel-left, .side-panel-right {
                display: none;
            }
            
            .footer {
                grid-column: 1;
                grid-row: 3;
            }
        }
        
        @media (max-width: 480px) {
            .game-container {
                padding: 4px;
                gap: 4px;
                height: 80vh;
                max-height: 500px;
            }
        }
    </style>
</head>
<body>
    <div class="artifact">WebXOS.2025.CNQ.ARTIFACT.9D5C1H</div>
    <div class="game-container">
        <div class="header">
            <div class="logo">COMMAND AND QUANTIFY</div>
            <div class="game-controls">
                <select class="mode-selector" id="grid-mode">
                    <option value="8">8x8 MODE</option>
                    <option value="16" selected>16x16 MODE</option>
                </select>
                <button class="restart-btn" id="restart-game" style="padding: 4px 8px; font-size: 9px;">QUANTUM RESTART</button>
                <div class="round-info">ROUND <span id="round-counter">1</span></div>
            </div>
        </div>
        
        <!-- Left Side Panel -->
        <div class="side-panel side-panel-left">
            <div class="side-panel-title">QUANTUM COMMANDER</div>
            <div class="player-panel player-0 panel" id="player-panel-0">
                <div class="player-header">
                    <span>QUANTUM COMMANDER</span>
                    <div style="width: 8px; height: 8px; background: #00ff00; border-radius: 50%; box-shadow: 0 0 3px #00ff00;"></div>
                </div>
                <div class="player-resources" id="resources-0">50 QUANTUM UNITS</div>
                
                <!-- Game Stats -->
                <div class="game-stats">
                    <div class="stat-item">
                        <div class="stat-value" id="barracks-count-0">0</div>
                        <div class="stat-label">BARRACKS</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="armies-count-0">0</div>
                        <div class="stat-label">ARMIES</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="farms-count-0">0</div>
                        <div class="stat-label">FARMS</div>
                    </div>
                </div>
                
                <div class="build-options" id="build-options-0">
                    <!-- Build options will be populated by JavaScript -->
                </div>
            </div>
            
            <!-- QNN Controls for Player -->
            <div class="qnn-controls">
                <div class="qnn-title">QUANTUM NEURAL NETWORK</div>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>STRATEGY AGGRESSION</span>
                        <span id="aggression-value">50%</span>
                    </div>
                    <input type="range" min="0" max="100" value="50" class="slider" id="aggression-slider">
                </div>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>MEMORY DEPTH</span>
                        <span id="memory-value">50%</span>
                    </div>
                    <input type="range" min="0" max="100" value="50" class="slider" id="memory-slider">
                </div>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>SPEED vs ACCURACY</span>
                        <span id="speed-value">50%</span>
                    </div>
                    <input type="range" min="0" max="100" value="50" class="slider" id="speed-slider">
                </div>
            </div>
        </div>
        
        <!-- Battlefield -->
        <div class="battlefield-container">
            <div class="battlefield" id="battlefield-grid">
                <!-- Grid will be populated by JavaScript -->
            </div>
        </div>
        
        <!-- Right Side Panel -->
        <div class="side-panel side-panel-right">
            <div class="side-panel-title">CPU OPPONENTS</div>
            <div class="cpu-panel player-1" id="player-panel-1">
                <div class="player-header">
                    <span>CPU ALPHA</span>
                    <div style="width: 8px; height: 8px; background: #0088ff; border-radius: 50%; box-shadow: 0 0 3px #0088ff;"></div>
                </div>
                <div class="player-resources" id="resources-1">50 QUANTUM UNITS</div>
                
                <!-- CPU Stats -->
                <div class="game-stats">
                    <div class="stat-item">
                        <div class="stat-value" id="barracks-count-1">0</div>
                        <div class="stat-label">BARRACKS</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="armies-count-1">0</div>
                        <div class="stat-label">ARMIES</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="farms-count-1">0</div>
                        <div class="stat-label">FARMS</div>
                    </div>
                </div>
                
                <div class="player-status" id="status-1">QNN INITIALIZING...</div>
                
                <!-- QNN Controls for CPU 1 -->
                <div class="qnn-controls">
                    <div class="qnn-title">QNN PROFILE: TACTICAL</div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>AGGRESSION</span>
                            <span>65%</span>
                        </div>
                        <input type="range" min="0" max="100" value="65" class="slider" disabled>
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>MEMORY</span>
                            <span>75%</span>
                        </div>
                        <input type="range" min="0" max="100" value="75" class="slider" disabled>
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>SPEED</span>
                            <span>45%</span>
                        </div>
                        <input type="range" min="0" max="100" value="45" class="slider" disabled>
                    </div>
                </div>
            </div>
            
            <div class="cpu-panel player-2" id="player-panel-2">
                <div class="player-header">
                    <span>CPU BETA</span>
                    <div style="width: 8px; height: 8px; background: #ffff00; border-radius: 50%; box-shadow: 0 0 3px #ffff00;"></div>
                </div>
                <div class="player-resources" id="resources-2">50 QUANTUM UNITS</div>
                
                <!-- CPU Stats -->
                <div class="game-stats">
                    <div class="stat-item">
                        <div class="stat-value" id="barracks-count-2">0</div>
                        <div class="stat-label">BARRACKS</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="armies-count-2">0</div>
                        <div class="stat-label">ARMIES</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="farms-count-2">0</div>
                        <div class="stat-label">FARMS</div>
                    </div>
                </div>
                
                <div class="player-status" id="status-2">QNN INITIALIZING...</div>
                
                <!-- QNN Controls for CPU 2 -->
                <div class="qnn-controls">
                    <div class="qnn-title">QNN PROFILE: DEFENSIVE</div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>AGGRESSION</span>
                            <span>35%</span>
                        </div>
                        <input type="range" min="0" max="100" value="35" class="slider" disabled>
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>MEMORY</span>
                            <span>85%</span>
                        </div>
                        <input type="range" min="0" max="100" value="85" class="slider" disabled>
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>SPEED</span>
                            <span>60%</span>
                        </div>
                        <input type="range" min="0" max="100" value="60" class="slider" disabled>
                    </div>
                </div>
            </div>
            
            <div class="cpu-panel player-3" id="player-panel-3">
                <div class="player-header">
                    <span>CPU GAMMA</span>
                    <div style="width: 8px; height: 8px; background: #ff0000; border-radius: 50%; box-shadow: 0 0 3px #ff0000;"></div>
                </div>
                <div class="player-resources" id="resources-3">50 QUANTUM UNITS</div>
                
                <!-- CPU Stats -->
                <div class="game-stats">
                    <div class="stat-item">
                        <div class="stat-value" id="barracks-count-3">0</div>
                        <div class="stat-label">BARRACKS</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="armies-count-3">0</div>
                        <div class="stat-label">ARMIES</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="farms-count-3">0</div>
                        <div class="stat-label">FARMS</div>
                    </div>
                </div>
                
                <div class="player-status" id="status-3">QNN INITIALIZING...</div>
                
                <!-- QNN Controls for CPU 3 -->
                <div class="qnn-controls">
                    <div class="qnn-title">QNN PROFILE: AGGRESSIVE</div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>AGGRESSION</span>
                            <span>85%</span>
                        </div>
                        <input type="range" min="0" max="100" value="85" class="slider" disabled>
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>MEMORY</span>
                            <span>30%</span>
                        </div>
                        <input type="range" min="0" max="100" value="30" class="slider" disabled>
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>SPEED</span>
                            <span>70%</span>
                        </div>
                        <input type="range" min="0" max="100" value="70" class="slider" disabled>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Footer with centered copyright -->
        <div class="footer">
            ¬© WebXOS 2025 | COMMAND AND QUANTIFY - QUANTUM NEURAL BATTLEFIELD SYSTEM
        </div>
    </div>

    <script>
        // Game state
        const gameState = {
            currentPlayer: 0, // 0 is human, 1-3 are CPUs
            players: [
                { id: 0, name: "QUANTUM COMMANDER", color: "#00ff00", resources: 50, barracks: 0, armies: 0, farms: 0, entities: [], eliminated: false, lastMove: null, eliminationOrder: null, qnn: { aggression: 0.5, memory: 0.5, speed: 0.5 } },
                { id: 1, name: "CPU ALPHA", color: "#0088ff", resources: 50, barracks: 0, armies: 0, farms: 0, entities: [], eliminated: false, lastMove: null, eliminationOrder: null, qnn: { aggression: 0.65, memory: 0.75, speed: 0.45 } },
                { id: 2, name: "CPU BETA", color: "#ffff00", resources: 50, barracks: 0, armies: 0, farms: 0, entities: [], eliminated: false, lastMove: null, eliminationOrder: null, qnn: { aggression: 0.35, memory: 0.85, speed: 0.6 } },
                { id: 3, name: "CPU GAMMA", color: "#ff0000", resources: 50, barracks: 0, armies: 0, farms: 0, entities: [], eliminated: false, lastMove: null, eliminationOrder: null, qnn: { aggression: 0.85, memory: 0.3, speed: 0.7 } }
            ],
            selectedBuilding: null,
            selectedEntity: null,
            gridSize: 16,
            round: 1,
            turnInProgress: false,
            gameOver: false,
            eliminationCount: 0,
            qnnModel: null,
            trainingInProgress: false
        };

        // Entity types
        const entityTypes = [
            { id: 1, name: "Quantum Core", type: "core", cost: 250, health: 100, icon: "‚öõÔ∏è", movable: true },
            { id: 2, name: "Barracks", type: "military", cost: 100, health: 60, icon: "‚öîÔ∏è", movable: false },
            { id: 3, name: "Quantum Farm", type: "economic", cost: 0, health: 40, icon: "üåæ", movable: false },
            { id: 4, name: "Army", type: "unit", cost: 100, health: 50, icon: "üéØ", movable: true }
        ];

        // Initialize the game when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            initGame();
        });

        // Initialize the game
        async function initGame() {
            try {
                // Initialize QNN
                await initQNN();
                
                // Set up event listeners
                document.getElementById('grid-mode').addEventListener('change', changeGridMode);
                document.getElementById('restart-game').addEventListener('click', restartGame);
                
                // Set up QNN sliders
                setupQnnSliders();
                
                createGrid();
                renderBuildOptions();
                updatePlayerPanels();
                
                // Place initial towers for all players in corners
                placeInitialTowers();
                
                // Update round counter
                document.getElementById('round-counter').textContent = gameState.round;
                
                // Highlight current player
                highlightCurrentPlayer();
                
                console.log("Game initialized successfully");
            } catch (error) {
                console.error("Error initializing game:", error);
            }
        }

        // Initialize Quantum Neural Network
        async function initQNN() {
            try {
                // Create a simple neural network model
                gameState.qnnModel = tf.sequential({
                    layers: [
                        tf.layers.dense({inputShape: [10], units: 16, activation: 'relu'}),
                        tf.layers.dense({units: 8, activation: 'relu'}),
                        tf.layers.dense({units: 4, activation: 'softmax'})
                    ]
                });
                
                // Compile the model
                gameState.qnnModel.compile({
                    optimizer: 'adam',
                    loss: 'categoricalCrossentropy',
                    metrics: ['accuracy']
                });
                
                // Use the model for a simple prediction to verify it's working
                const dummyInput = tf.randomNormal([1, 10]);
                const prediction = gameState.qnnModel.predict(dummyInput);
                const result = await prediction.data();
                console.log("QNN Prediction test:", result);
            } catch (error) {
                console.error("Error initializing QNN:", error);
            }
        }

        // Set up QNN sliders
        function setupQnnSliders() {
            const aggressionSlider = document.getElementById('aggression-slider');
            const memorySlider = document.getElementById('memory-slider');
            const speedSlider = document.getElementById('speed-slider');
            
            aggressionSlider.addEventListener('input', function() {
                document.getElementById('aggression-value').textContent = this.value + '%';
                gameState.players[0].qnn.aggression = this.value / 100;
            });
            
            memorySlider.addEventListener('input', function() {
                document.getElementById('memory-value').textContent = this.value + '%';
                gameState.players[0].qnn.memory = this.value / 100;
            });
            
            speedSlider.addEventListener('input', function() {
                document.getElementById('speed-value').textContent = this.value + '%';
                gameState.players[0].qnn.speed = this.value / 100;
            });
        }

        // Change grid mode
        function changeGridMode() {
            const mode = parseInt(document.getElementById('grid-mode').value);
            gameState.gridSize = mode;
            restartGame();
        }

        // Restart the game
        function restartGame() {
            // Reset game state
            gameState.players.forEach(player => {
                player.resources = 50;
                player.barracks = 0;
                player.armies = 0;
                player.farms = 0;
                player.entities = [];
                player.eliminated = false;
                player.lastMove = null;
                player.eliminationOrder = null;
            });
            
            gameState.selectedBuilding = null;
            gameState.selectedEntity = null;
            gameState.round = 1;
            gameState.turnInProgress = false;
            gameState.gameOver = false;
            gameState.eliminationCount = 0;
            
            document.getElementById('round-counter').textContent = gameState.round;
            
            // Recreate grid
            createGrid();
            renderBuildOptions();
            updatePlayerPanels();
            
            // Place initial towers
            placeInitialTowers();
            
            // Highlight current player
            highlightCurrentPlayer();
        }

        // Create the battlefield grid
        function createGrid() {
            const grid = document.getElementById('battlefield-grid');
            if (!grid) {
                console.error("Battlefield grid element not found!");
                return;
            }
            
            // Set grid template based on size
            grid.style.gridTemplateColumns = `repeat(${gameState.gridSize}, 1fr)`;
            grid.style.gridTemplateRows = `repeat(${gameState.gridSize}, 1fr)`;
            
            // Update grid lines
            grid.style.setProperty('--grid-size', gameState.gridSize);
            
            grid.innerHTML = '';
            
            for (let y = 0; y < gameState.gridSize; y++) {
                for (let x = 0; x < gameState.gridSize; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell touch-entity';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    
                    cell.addEventListener('click', () => {
                        if (gameState.currentPlayer === 0 && !gameState.turnInProgress && !gameState.gameOver) {
                            if (gameState.selectedBuilding) {
                                placeEntity(gameState.selectedBuilding, x, y);
                            } else if (gameState.selectedEntity) {
                                moveEntity(gameState.selectedEntity, x, y);
                            }
                        }
                    });
                    
                    grid.appendChild(cell);
                }
            }
            
            // Render existing entities
            renderEntities();
        }

        // Place initial towers for all players in corners
        function placeInitialTowers() {
            const size = gameState.gridSize;
            
            // Player 0 (human) - top left corner
            placeEntity(1, 0, 0, 0, true);
            
            // Player 1 - top right corner
            placeEntity(1, size - 1, 0, 1, true);
            
            // Player 2 - bottom right corner
            placeEntity(1, size - 1, size - 1, 2, true);
            
            // Player 3 - bottom left corner
            placeEntity(1, 0, size - 1, 3, true);
        }

        // Render the build options for human player
        function renderBuildOptions() {
            const buildOptions = document.getElementById('build-options-0');
            if (!buildOptions) {
                console.error("Build options element not found!");
                return;
            }
            
            buildOptions.innerHTML = '';
            
            // Create barracks button
            const barracksBtn = createBuildButton(2, "Barracks", "‚öîÔ∏è", "100Q");
            buildOptions.appendChild(barracksBtn);
            
            // Create farm button
            const farmBtn = createBuildButton(3, "Quantum Farm", "üåæ", "FREE");
            buildOptions.appendChild(farmBtn);
            
            // Create army button
            const armyBtn = createBuildButton(4, "Army", "üéØ", "100Q");
            buildOptions.appendChild(armyBtn);
            
            // Add entity selection button
            const selectEntityBtn = document.createElement('button');
            selectEntityBtn.className = 'build-btn';
            selectEntityBtn.innerHTML = `
                <div class="build-icon">‚öõÔ∏è</div>
                <div>SELECT ENTITY</div>
            `;
            
            selectEntityBtn.addEventListener('click', () => {
                if (gameState.currentPlayer === 0 && !gameState.turnInProgress && !gameState.gameOver) {
                    gameState.selectedBuilding = null;
                    gameState.selectedEntity = null;
                }
            });
            
            buildOptions.appendChild(selectEntityBtn);
        }

        // Helper function to create build buttons
        function createBuildButton(entityId, name, icon, cost) {
            const btn = document.createElement('button');
            btn.className = 'build-btn';
            btn.innerHTML = `
                <div class="build-icon">${icon}</div>
                <div>${name} (${cost})</div>
            `;
            
            btn.addEventListener('click', () => {
                selectBuilding(entityId);
            });
            
            return btn;
        }

        // Select building for placement
        function selectBuilding(entityId) {
            if (gameState.currentPlayer === 0 && !gameState.turnInProgress && !gameState.gameOver) {
                // Check if player can build this entity
                const player = gameState.players[0];
                const entityType = entityTypes.find(e => e.id === entityId);
                
                if (entityId === 4 && player.barracks <= player.armies) {
                    return;
                }
                
                if (player.resources < entityType.cost) {
                    return;
                }
                
                gameState.selectedBuilding = entityId;
                gameState.selectedEntity = null;
                
                highlightValidPlacement();
            }
        }

        // Update player panels with current resources and status
        function updatePlayerPanels() {
            gameState.players.forEach(player => {
                const resourcesEl = document.getElementById(`resources-${player.id}`);
                if (resourcesEl) {
                    resourcesEl.textContent = `${player.resources} QUANTUM UNITS`;
                }
                
                // Update stats
                const barracksCountEl = document.getElementById(`barracks-count-${player.id}`);
                const armiesCountEl = document.getElementById(`armies-count-${player.id}`);
                const farmsCountEl = document.getElementById(`farms-count-${player.id}`);
                
                if (barracksCountEl) barracksCountEl.textContent = player.barracks;
                if (armiesCountEl) armiesCountEl.textContent = player.armies;
                if (farmsCountEl) farmsCountEl.textContent = player.farms;
                
                if (player.id !== 0) {
                    const statusEl = document.getElementById(`status-${player.id}`);
                    if (statusEl) {
                        if (player.eliminated) {
                            statusEl.textContent = "ELIMINATED";
                        } else {
                            statusEl.textContent = gameState.currentPlayer === player.id ? "QNN CALCULATING..." : "AWAITING ORDERS";
                        }
                    }
                }
                
                // Update panel appearance for eliminated players
                const panelEl = document.getElementById(`player-panel-${player.id}`);
                if (panelEl) {
                    if (player.eliminated) {
                        panelEl.classList.add('player-eliminated');
                    } else {
                        panelEl.classList.remove('player-eliminated');
                    }
                }
            });
            
            // Add neural glow to user panel when it's their turn
            const userPanel = document.getElementById('player-panel-0');
            if (userPanel) {
                if (gameState.currentPlayer === 0 && !gameState.players[0].eliminated) {
                    userPanel.classList.add('neural-glow');
                } else {
                    userPanel.classList.remove('neural-glow');
                }
            }
        }

        // Check if position is adjacent to player's existing entities
        function isAdjacentToPlayer(playerId, x, y) {
            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
            
            for (const [dx, dy] of directions) {
                const checkX = x + dx;
                const checkY = y + dy;
                
                if (checkX >= 0 && checkX < gameState.gridSize && checkY >= 0 && checkY < gameState.gridSize) {
                    const entity = getEntityAt(checkX, checkY);
                    if (entity && entity.player.id === playerId && !entity.player.eliminated) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        // Get all valid adjacent positions for a player
        function getValidAdjacentPositions(playerId) {
            const positions = [];
            const player = gameState.players[playerId];
            
            if (player.eliminated) return positions;
            
            for (const entity of player.entities) {
                const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                
                for (const [dx, dy] of directions) {
                    const x = entity.x + dx;
                    const y = entity.y + dy;
                    
                    if (x >= 0 && x < gameState.gridSize && y >= 0 && y < gameState.gridSize) {
                        const existingEntity = getEntityAt(x, y);
                        if (!existingEntity) {
                            positions.push({ x, y });
                        }
                    }
                }
            }
            
            // Remove duplicates
            return positions.filter((pos, index, self) => 
                index === self.findIndex(p => p.x === pos.x && p.y === pos.y)
            );
        }

        // Place an entity on the grid
        function placeEntity(entityId, x, y, playerId = null, isInitial = false) {
            const player = playerId !== null ? gameState.players[playerId] : gameState.players[gameState.currentPlayer];
            const entityType = entityTypes.find(e => e.id === entityId);
            
            if (!entityType || player.eliminated) return;
            
            // Check if player has enough resources (except for initial placement and farms)
            if (!isInitial && entityType.id !== 3 && player.resources < entityType.cost) {
                return;
            }
            
            // For armies, check if player has enough barracks
            if (entityType.id === 4 && player.barracks <= player.armies) {
                return;
            }
            
            // Check if the position is valid
            if (x < 0 || x >= gameState.gridSize || y < 0 || y >= gameState.gridSize) {
                return;
            }
            
            // Check if the cell is empty
            const existingEntity = getEntityAt(x, y);
            if (existingEntity) {
                return;
            }
            
            // Check if the position is adjacent to player's existing entities (except for initial placement)
            if (!isInitial && !isAdjacentToPlayer(player.id, x, y)) {
                return;
            }
            
            // Deduct resources (except for initial placement and farms)
            if (!isInitial && entityType.id !== 3) {
                player.resources -= entityType.cost;
            }
            
            // Add the entity
            const entity = {
                id: entityId,
                x: x,
                y: y,
                playerId: player.id,
                health: entityType.health,
                maxHealth: entityType.health
            };
            
            player.entities.push(entity);
            
            // Update player stats
            if (entityType.id === 2) {
                player.barracks += 1;
            } else if (entityType.id === 3) {
                player.farms += 1;
            } else if (entityType.id === 4) {
                player.armies += 1;
            }
            
            // Track last move
            player.lastMove = { type: 'build', entityType: entityType.name, x, y };
            
            // Automatically end turn after player action
            if (gameState.currentPlayer === 0 && !isInitial) {
                setTimeout(endTurn, 1000);
            }
            
            renderEntities();
            updatePlayerPanels();
            
            // Clear selection after placement
            if (gameState.currentPlayer === 0 && !isInitial) {
                gameState.selectedBuilding = null;
                clearHighlights();
            }
        }

        // Move an entity to a new position
        function moveEntity(entity, x, y) {
            const player = gameState.players[gameState.currentPlayer];
            const entityType = entityTypes.find(e => e.id === entity.id);
            
            if (player.eliminated) return;
            
            // Check if the position is valid
            if (x < 0 || x >= gameState.gridSize || y < 0 || y >= gameState.gridSize) {
                return;
            }
            
            // Check if the move is adjacent
            const dx = Math.abs(entity.x - x);
            const dy = Math.abs(entity.y - y);
            if (dx + dy !== 1) {
                return;
            }
            
            // Check if the target cell is occupied
            const targetEntity = getEntityAt(x, y);
            if (targetEntity) {
                // If target is owned by the same player, can't move there
                if (targetEntity.player.id === player.id) {
                    return;
                }
                
                // Attack the target
                attackEntity(entity, targetEntity.entity, targetEntity.player);
            } else {
                // Move the entity to the empty cell
                entity.x = x;
                entity.y = y;
                // Track last move
                player.lastMove = { type: 'move', entityType: entityType.name, x, y };
                
                // Automatically end turn after player action
                if (gameState.currentPlayer === 0) {
                    setTimeout(endTurn, 1000);
                }
            }
            
            // Clear selection
            gameState.selectedEntity = null;
            renderEntities();
            clearHighlights();
        }

        // Attack an enemy entity
        function attackEntity(entity, target, targetPlayer) {
            const player = gameState.players[gameState.currentPlayer];
            const entityType = entityTypes.find(e => e.id === entity.id);
            const targetType = entityTypes.find(e => e.id === target.id);
            
            // Show combat animation
            showCombatAnimation(target.x, target.y);
            
            // Track last move
            player.lastMove = { type: 'attack', entityType: entityType.name, x: target.x, y: target.y, target: targetType.name };
            
            // If attacking a Quantum Core, check for defense
            if (target.id === 1) {
                // Quantum Core has 25% chance to defend itself and destroy the attacking entity
                if (Math.random() < 0.25) {
                    // Core defends successfully
                    const index = player.entities.indexOf(entity);
                    if (index > -1) {
                        player.entities.splice(index, 1);
                        if (entity.id === 4) player.armies -= 1;
                    }
                    return; // End the attack here
                } else {
                    // Eliminate the player
                    targetPlayer.eliminated = true;
                    gameState.eliminationCount++;
                    targetPlayer.eliminationOrder = gameState.eliminationCount;
                    // Remove all their entities
                    targetPlayer.entities = [];
                    targetPlayer.barracks = 0;
                    targetPlayer.armies = 0;
                    targetPlayer.farms = 0;
                    
                    // Move entity to the conquered position
                    entity.x = target.x;
                    entity.y = target.y;
                    
                    // Check for game over
                    checkGameOver();
                }
            }
            // Barracks can now defend themselves
            else if (target.id === 2) {
                // Barracks has 50% chance to defend itself
                if (Math.random() < 0.5) {
                    // Barracks defends successfully
                    const index = player.entities.indexOf(entity);
                    if (index > -1) {
                        player.entities.splice(index, 1);
                        if (entity.id === 4) player.armies -= 1;
                    }
                } else {
                    // Barracks is destroyed
                    const index = targetPlayer.entities.indexOf(target);
                    if (index > -1) {
                        targetPlayer.entities.splice(index, 1);
                        targetPlayer.barracks -= 1;
                        
                        // Move entity to the conquered position
                        entity.x = target.x;
                        entity.y = target.y;
                    }
                }
            }
            // Farms are destroyed instantly
            else if (target.id === 3) {
                // Attacker wins automatically
                const index = targetPlayer.entities.indexOf(target);
                if (index > -1) {
                    targetPlayer.entities.splice(index, 1);
                    targetPlayer.farms -= 1; // Fixed: Decrement farm count
                    
                    // Move entity to the conquered position
                    entity.x = target.x;
                    entity.y = target.y;
                }
            } 
            // Army vs Army: 50% chance to win
            else if (target.id === 4) {
                // 50% chance to win
                if (Math.random() < 0.5) {
                    // Attacker wins
                    const index = targetPlayer.entities.indexOf(target);
                    if (index > -1) {
                        targetPlayer.entities.splice(index, 1);
                        targetPlayer.armies -= 1;
                        
                        // Move entity to the conquered position
                        entity.x = target.x;
                        entity.y = target.y;
                    }
                } else {
                    // Defender wins
                    const index = player.entities.indexOf(entity);
                    if (index > -1) {
                        player.entities.splice(index, 1);
                        if (entity.id === 4) player.armies -= 1;
                    }
                }
            }
            
            // Automatically end turn after player action
            if (gameState.currentPlayer === 0) {
                setTimeout(endTurn, 1000);
            }
            
            // Check for game over
            checkGameOver();
        }

        // Show combat animation
        function showCombatAnimation(x, y) {
            const cell = document.querySelector(`.grid-cell[data-x="${x}"][data-y="${y}"]`);
            if (cell) {
                const animation = document.createElement('div');
                animation.className = 'combat-animation';
                animation.textContent = 'üí•';
                cell.appendChild(animation);
                
                setTimeout(() => {
                    cell.removeChild(animation);
                }, 500);
            }
        }

        // Get entity at a specific position
        function getEntityAt(x, y) {
            for (const player of gameState.players) {
                if (player.eliminated) continue;
                
                for (const entity of player.entities) {
                    if (entity.x === x && entity.y === y) {
                        return { entity, player };
                    }
                }
            }
            return null;
        }

        // Render entities on the grid
        function renderEntities() {
            // Clear all cells first
            document.querySelectorAll('.grid-cell').forEach(cell => {
                cell.innerHTML = '';
                cell.className = 'grid-cell touch-entity';
            });
            
            // Render each entity
            gameState.players.forEach(player => {
                if (player.eliminated) return;
                
                player.entities.forEach(entity => {
                    const entityType = entityTypes.find(e => e.id === entity.id);
                    const cell = document.querySelector(`.grid-cell[data-x="${entity.x}"][data-y="${entity.y}"]`);
                    
                    if (cell && entityType) {
                        cell.classList.add(`player-${player.id}`);
                        
                        const entityElement = document.createElement('div');
                        entityElement.className = `entity ${entityType.name.toLowerCase().replace(' ', '-')} touch-entity`;
                        
                        // Check if this entity was part of the last move
                        if (player.lastMove && 
                            player.lastMove.x === entity.x && 
                            player.lastMove.y === entity.y) {
                            entityElement.classList.add('last-move');
                        }
                        
                        if (entity === gameState.selectedEntity) {
                            entityElement.classList.add('selected');
                        }
                        
                        entityElement.textContent = entityType.icon;
                        entityElement.title = `${entityType.name} (${player.name})`;
                        
                        // Add click handler for movable entities
                        if (entityType.movable && gameState.currentPlayer === player.id) {
                            entityElement.style.cursor = 'pointer';
                            entityElement.addEventListener('click', (e) => {
                                e.stopPropagation();
                                if (gameState.currentPlayer === 0 && !gameState.turnInProgress && !gameState.gameOver) {
                                    gameState.selectedEntity = entity;
                                    gameState.selectedBuilding = null;
                                    highlightValidMovement(entity);
                                    renderEntities();
                                }
                            });
                        }
                        
                        cell.appendChild(entityElement);
                    }
                });
            });
        }

        // Highlight valid placement positions
        function highlightValidPlacement() {
            clearHighlights();
            
            if (gameState.currentPlayer !== 0 || !gameState.selectedBuilding || gameState.turnInProgress || gameState.gameOver) return;
            
            const player = gameState.players[0];
            if (player.eliminated) return;
            
            // Highlight empty cells adjacent to player's entities
            for (let y = 0; y < gameState.gridSize; y++) {
                for (let x = 0; x < gameState.gridSize; x++) {
                    const cell = document.querySelector(`.grid-cell[data-x="${x}"][data-y="${y}"]`);
                    const entity = getEntityAt(x, y);
                    
                    if (cell && !entity) {
                        // Check if adjacent to player's entity
                        const adjacent = [
                            [x-1, y], [x+1, y], [x, y-1], [x, y+1]
                        ];
                        
                        for (const [ax, ay] of adjacent) {
                            if (ax >= 0 && ax < gameState.gridSize && ay >= 0 && ay < gameState.gridSize) {
                                const adjacentEntity = getEntityAt(ax, ay);
                                if (adjacentEntity && adjacentEntity.player.id === player.id) {
                                    cell.classList.add('highlighted');
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }

        // Highlight valid movement positions for an entity
        function highlightValidMovement(entity) {
            clearHighlights();
            
            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
            
            for (const [dx, dy] of directions) {
                const x = entity.x + dx;
                const y = entity.y + dy;
                
                if (x >= 0 && x < gameState.gridSize && y >= 0 && y < gameState.gridSize) {
                    const cell = document.querySelector(`.grid-cell[data-x="${x}"][data-y="${y}"]`);
                    const targetEntity = getEntityAt(x, y);
                    
                    if (cell && (!targetEntity || targetEntity.player.id !== gameState.currentPlayer)) {
                        cell.classList.add('highlighted');
                    }
                }
            }
        }

        // Clear all highlights
        function clearHighlights() {
            document.querySelectorAll('.grid-cell').forEach(cell => {
                cell.classList.remove('highlighted');
            });
        }

        // Highlight current player
        function highlightCurrentPlayer() {
            document.querySelectorAll('.player-panel').forEach(panel => {
                panel.classList.remove('player-active');
            });
            
            const currentPanel = document.getElementById(`player-panel-${gameState.currentPlayer}`);
            if (currentPanel && !gameState.players[gameState.currentPlayer].eliminated) {
                currentPanel.classList.add('player-active');
            }
        }

        // End the current turn
        function endTurn() {
            if (gameState.gameOver) return;
            
            gameState.turnInProgress = false;
            
            // Generate resources from farms for all players at the end of each round
            if (gameState.currentPlayer === 3) {
                gameState.players.forEach(player => {
                    if (player.eliminated) return;
                    
                    player.resources += player.farms * 10;
                });
            }
            
            // Move to next player (skip eliminated players)
            let nextPlayer = (gameState.currentPlayer + 1) % gameState.players.length;
            let attempts = 0;
            
            while (gameState.players[nextPlayer].eliminated && attempts < gameState.players.length) {
                nextPlayer = (nextPlayer + 1) % gameState.players.length;
                attempts++;
            }
            
            gameState.currentPlayer = nextPlayer;
            
            // If we've cycled through all players, it's a new round
            if (gameState.currentPlayer === 0) {
                gameState.round++;
                document.getElementById('round-counter').textContent = gameState.round;
            }
            
            // Clear any selections
            gameState.selectedBuilding = null;
            gameState.selectedEntity = null;
            
            updatePlayerPanels();
            renderEntities();
            clearHighlights();
            highlightCurrentPlayer();
            
            // If it's a CPU turn, process it immediately
            if (gameState.currentPlayer !== 0 && !gameState.players[gameState.currentPlayer].eliminated) {
                gameState.turnInProgress = true;
                setTimeout(() => {
                    cpuTurn(gameState.currentPlayer);
                }, 500);
            }
        }

        // Enhanced CPU player logic with QNN
        function cpuTurn(cpuId) {
            const cpu = gameState.players[cpuId];
            
            if (cpu.eliminated || gameState.gameOver) {
                setTimeout(endTurn, 50);
                return;
            }
            
            // Get all valid adjacent positions
            const validPositions = getValidAdjacentPositions(cpuId);
            
            // If no valid positions, skip turn
            if (validPositions.length === 0) {
                setTimeout(endTurn, 50);
                return;
            }
            
            // Enhanced strategy for CPUs with QNN influence
            let actionTaken = false;
            
            // Try to find an enemy core to attack (highest priority)
            const enemyCores = [];
            gameState.players.forEach(player => {
                if (player.id !== cpuId && !player.eliminated) {
                    player.entities.forEach(entity => {
                        if (entity.id === 1) { // Quantum Core
                            enemyCores.push({ entity, player });
                        }
                    });
                }
            });
            
            // If we found enemy cores, try to attack them
            if (enemyCores.length > 0) {
                const movableEntities = cpu.entities.filter(e => {
                    const entityType = entityTypes.find(et => et.id === e.id);
                    return entityType && entityType.movable && e.id !== 1; // Exclude Quantum Core (id=1)
                });
                
                if (movableEntities.length > 0) {
                    // Find the closest enemy core
                    let closestCore = null;
                    let minDistance = Infinity;
                    
                    enemyCores.forEach(({ entity }) => {
                        movableEntities.forEach(movable => {
                            const distance = Math.abs(movable.x - entity.x) + Math.abs(movable.y - entity.y);
                            if (distance < minDistance) {
                                minDistance = distance;
                                closestCore = { entity, movable };
                            }
                        });
                    });
                    
                    // Try to move toward the closest core
                    if (closestCore) {
                        const entity = closestCore.movable;
                        const core = closestCore.entity;
                        const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                        
                        // Find the best direction to move toward the core
                        let bestDirection = null;
                        let bestDistance = minDistance;
                        
                        for (const [dx, dy] of directions) {
                            const x = entity.x + dx;
                            const y = entity.y + dy;
                            
                            if (x >= 0 && x < gameState.gridSize && y >= 0 && y < gameState.gridSize) {
                                const target = getEntityAt(x, y);
                                const distance = Math.abs(x - core.x) + Math.abs(y - core.y);
                                
                                if ((!target || target.player.id !== cpuId) && distance < bestDistance) {
                                    bestDistance = distance;
                                    bestDirection = [dx, dy];
                                }
                            }
                        }
                        
                        // Move in the best direction
                        if (bestDirection) {
                            const x = entity.x + bestDirection[0];
                            const y = entity.y + bestDirection[1];
                            const target = getEntityAt(x, y);
                            
                            if (target) {
                                attackEntity(entity, target.entity, target.player);
                            } else {
                                entity.x = x;
                                entity.y = y;
                                cpu.lastMove = { type: 'move', entityType: 'Army', x, y };
                            }
                            actionTaken = true;
                        }
                    }
                }
            }
            
            // If we didn't attack, try to build more structures
            if (!actionTaken) {
                // Build farms aggressively if resources are low
                if (cpu.resources < 150) {
                    // Build more farms if we have few farms
                    if (cpu.farms < 5 || Math.random() < 0.7) {
                        const randomPos = validPositions[Math.floor(Math.random() * validPositions.length)];
                        if (randomPos) {
                            placeEntity(3, randomPos.x, randomPos.y, cpuId);
                            actionTaken = true;
                        }
                    }
                }
                
                // Build barracks if we have few or none
                if (!actionTaken && (cpu.barracks < 2 || (cpu.resources >= 100 && Math.random() < 0.6))) {
                    const randomPos = validPositions[Math.floor(Math.random() * validPositions.length)];
                    if (randomPos) {
                        placeEntity(2, randomPos.x, randomPos.y, cpuId);
                        actionTaken = true;
                    }
                }
                
                // Build army if we have barracks capacity and resources
                if (!actionTaken && cpu.barracks > 0 && cpu.armies < cpu.barracks * 2 && cpu.resources >= 100) {
                    const randomPos = validPositions[Math.floor(Math.random() * validPositions.length)];
                    if (randomPos) {
                        placeEntity(4, randomPos.x, randomPos.y, cpuId);
                        actionTaken = true;
                    }
                }
            }
            
            // If we still didn't take any action, try to move a random army
            if (!actionTaken) {
                const armies = cpu.entities.filter(e => e.id === 4);
                if (armies.length > 0) {
                    const army = armies[Math.floor(Math.random() * armies.length)];
                    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                    
                    // Try to find a valid move toward any enemy
                    for (const [dx, dy] of directions) {
                        const x = army.x + dx;
                        const y = army.y + dy;
                        
                        if (x >= 0 && x < gameState.gridSize && y >= 0 && y < gameState.gridSize) {
                            const target = getEntityAt(x, y);
                            
                            if (!target || target.player.id !== cpuId) {
                                // Move or attack
                                if (target) {
                                    attackEntity(army, target.entity, target.player);
                                } else {
                                    army.x = x;
                                    army.y = y;
                                    cpu.lastMove = { type: 'move', entityType: 'Army', x, y };
                                }
                                actionTaken = true;
                                break;
                            }
                        }
                    }
                }
            }
            
            // Always end the CPU turn after a short delay
            setTimeout(endTurn, 500);
        }

        // Check if the game is over and show victory screen
        function checkGameOver() {
            const alivePlayers = gameState.players.filter(player => !player.eliminated);
            
            if (alivePlayers.length === 1) {
                gameState.gameOver = true;
                const winner = alivePlayers[0];
                
                // Set elimination order for the winner (1st place)
                winner.eliminationOrder = 1;
                
                // Show victory screen after a short delay
                setTimeout(showVictoryScreen, 1500);
            } else if (alivePlayers.length === 0) {
                gameState.gameOver = true;
            }
        }

        // Show victory screen with rankings
        function showVictoryScreen() {
            // Create victory screen element
            const victoryScreen = document.createElement('div');
            victoryScreen.className = 'victory-screen';
            
            // Sort players by elimination order (ascending)
            const rankedPlayers = [...gameState.players].sort((a, b) => {
                // Players with lower eliminationOrder were eliminated later (better rank)
                // The winner has eliminationOrder = 1
                return a.eliminationOrder - b.eliminationOrder;
            });
            
            // Create ranking list
            let rankingHTML = '<ul class="ranking-list">';
            rankedPlayers.forEach((player, index) => {
                const rank = index + 1;
                let rankClass = '';
                let rankText = '';
                
                switch(rank) {
                    case 1:
                        rankClass = 'ranking-1';
                        rankText = '1ST PLACE - VICTOR';
                        break;
                    case 2:
                        rankClass = 'ranking-2';
                        rankText = '2ND PLACE';
                        break;
                    case 3:
                        rankClass = 'ranking-3';
                        rankText = '3RD PLACE';
                        break;
                    case 4:
                        rankClass = 'ranking-4';
                        rankText = '4TH PLACE';
                        break;
                }
                
                rankingHTML += `
                    <li class="ranking-item ${rankClass}">
                        ${rankText}: ${player.name}
                    </li>
                `;
            });
            rankingHTML += '</ul>';
            
            victoryScreen.innerHTML = `
                <div class="victory-title">QUANTUM VICTORY!</div>
                <div class="victory-subtitle">${rankedPlayers[0].name} IS THE LAST QUANTUM STANDING!</div>
                ${rankingHTML}
                <button class="restart-btn" id="restart-btn">QUANTUM RESTART</button>
            `;
            
            document.body.appendChild(victoryScreen);
            
            // Add event listener for restart button
            document.getElementById('restart-btn').addEventListener('click', () => {
                location.reload();
            });
        }
    </script>
</body>
</html>