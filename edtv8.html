<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Webcam AR Point Cloud Mask | DA3 + SLAM + SAM3 Emulation</title>
    <style>
        :root {
            --primary: #4CAF50;
            --primary-dark: #388E3C;
            --secondary: #2196F3;
            --dark: #121212;
            --darker: #0a0a0a;
            --light: #e0e0e0;
            --gray: #424242;
            --card-bg: rgba(30, 30, 30, 0.8);
            --success: #4CAF50;
            --warning: #FF9800;
            --error: #F44336;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--darker);
            color: var(--light);
            line-height: 1.6;
            overflow-x: hidden;
        }
        
        header {
            background: linear-gradient(135deg, var(--dark), var(--darker));
            padding: 2rem 1rem;
            text-align: center;
            border-bottom: 1px solid var(--gray);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            background: linear-gradient(to right, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: #aaa;
            margin-bottom: 1.5rem;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem 1rem;
        }
        
        .card {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .card h2 {
            color: var(--primary);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .card h2 i {
            font-size: 1.5rem;
        }
        
        .tech-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }
        
        .tech-card {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 1.5rem;
            transition: transform 0.3s ease;
        }
        
        .tech-card:hover {
            transform: translateY(-5px);
        }
        
        .tech-card h3 {
            color: var(--secondary);
            margin-bottom: 0.5rem;
        }
        
        .demo-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin-top: 2rem;
        }
        
        @media (max-width: 768px) {
            .demo-section {
                grid-template-columns: 1fr;
            }
        }
        
        .demo-container {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            background: var(--dark);
            aspect-ratio: 4/3;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .demo-placeholder {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #1a1a1a, #2d2d2d);
            color: #888;
        }
        
        .demo-placeholder i {
            font-size: 4rem;
            margin-bottom: 1rem;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .control-group {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }
        
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            background: var(--primary);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            justify-content: center;
        }
        
        button:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
        }
        
        button.secondary {
            background: var(--gray);
        }
        
        button.secondary:hover {
            background: #555;
        }
        
        button:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
        }
        
        .status {
            padding: 12px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.3);
            margin-top: 1rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--warning);
        }
        
        .status-indicator.active {
            background: var(--success);
        }
        
        .status-indicator.error {
            background: var(--error);
        }
        
        .instructions {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            font-size: 0.9rem;
        }
        
        .code-block {
            background: #1e1e1e;
            border-radius: 8px;
            padding: 1.5rem;
            overflow-x: auto;
            margin-top: 1rem;
            font-family: 'Courier New', monospace;
            border: 1px solid #333;
        }
        
        .code-block code {
            color: #d4d4d4;
        }
        
        .highlight {
            color: #569cd6;
        }
        
        .string {
            color: #ce9178;
        }
        
        .comment {
            color: #6a9955;
        }
        
        footer {
            text-align: center;
            padding: 2rem 1rem;
            margin-top: 3rem;
            border-top: 1px solid var(--gray);
            color: #777;
        }
        
        .tech-badges {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 1rem;
        }
        
        .badge {
            background: rgba(33, 150, 243, 0.2);
            color: var(--secondary);
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            border: 1px solid rgba(33, 150, 243, 0.3);
        }
        
        .performance {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }
        
        .perf-card {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
        }
        
        .perf-card h4 {
            color: var(--secondary);
            margin-bottom: 0.5rem;
        }
        
        .perf-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary);
        }
        
        .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-top: 1.5rem;
        }
        
        .feature {
            display: flex;
            gap: 1rem;
            align-items: flex-start;
        }
        
        .feature-icon {
            background: var(--primary);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .feature-content h3 {
            margin-bottom: 0.5rem;
            color: var(--light);
        }
        
        .feature-content p {
            color: #aaa;
            font-size: 0.9rem;
        }
        
        /* AR/WebGL Canvas Styles */
        #three-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #video-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        
        .canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        .fps-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            z-index: 2;
        }
        
        .resolution-control {
            margin-top: 1rem;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 5px;
        }
        
        .slider-container input {
            flex: 1;
        }
        
        .error-message {
            background: rgba(244, 67, 54, 0.2);
            border-left: 4px solid var(--error);
            padding: 12px;
            margin-top: 1rem;
            border-radius: 4px;
            display: none;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <header>
        <div class="container">
            <h1>Webcam AR Point Cloud Mask</h1>
            <p class="subtitle">Real-time face/object segmentation with 3D point clouds using Three.js</p>
            <div class="tech-badges">
                <span class="badge">Three.js</span>
                <span class="badge">MediaPipe</span>
                <span class="badge">TensorFlow.js</span>
                <span class="badge">WebGL</span>
                <span class="badge">WebRTC</span>
            </div>
        </div>
    </header>
    
    <main class="container">
        <section class="card">
            <h2><i class="fas fa-info-circle"></i> About This Project</h2>
            <p>This application demonstrates a real-time augmented reality experience that creates 3D point cloud masks from your webcam feed. It combines several advanced technologies to segment faces or objects, estimate depth, and render interactive 3D representations.</p>
            
            <div class="features">
                <div class="feature">
                    <div class="feature-icon">
                        <i class="fas fa-cube"></i>
                    </div>
                    <div class="feature-content">
                        <h3>3D Point Clouds</h3>
                        <p>Generate and visualize point clouds in real-time from webcam input</p>
                    </div>
                </div>
                <div class="feature">
                    <div class="feature-icon">
                        <i class="fas fa-video"></i>
                    </div>
                    <div class="feature-content">
                        <h3>Real-time Processing</h3>
                        <p>Process webcam feed at 15-30 FPS using optimized browser technologies</p>
                    </div>
                </div>
                <div class="feature">
                    <div class="feature-icon">
                        <i class="fas fa-mask"></i>
                    </div>
                    <div class="feature-content">
                        <h3>AR Mask Overlay</h3>
                        <p>Apply semi-transparent 3D masks that track with your face or selected objects</p>
                    </div>
                </div>
            </div>
        </section>
        
        <section class="card">
            <h2><i class="fas fa-play-circle"></i> Live Demo</h2>
            <p>Start the application to see the AR point cloud mask in action. Allow camera access when prompted.</p>
            
            <div class="error-message" id="error-message">
                <i class="fas fa-exclamation-triangle"></i> 
                <span id="error-text">An error occurred. Please check the console for details.</span>
            </div>
            
            <div class="demo-section">
                <div class="demo-container">
                    <div id="demo-placeholder" class="demo-placeholder">
                        <i class="fas fa-camera"></i>
                        <p>Camera feed and point cloud visualization will appear here</p>
                    </div>
                    <div id="canvas-container" class="canvas-container" style="display: none;">
                        <canvas id="video-canvas"></canvas>
                        <canvas id="three-canvas"></canvas>
                        <div id="fps-counter" class="fps-counter">FPS: --</div>
                    </div>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <button id="start-btn" aria-label="Start AR Experience">
                            <i class="fas fa-play"></i> Start AR Experience
                        </button>
                        <button id="toggle-mode" class="secondary" aria-label="Switch to Object Mode" disabled>
                            <i class="fas fa-sync"></i> Switch to Object Mode
                        </button>
                    </div>
                    
                    <div class="resolution-control">
                        <label for="point-resolution">Point Cloud Resolution:</label>
                        <div class="slider-container">
                            <input type="range" id="point-resolution" min="50" max="300" value="150" aria-label="Adjust point cloud resolution" disabled>
                            <span id="resolution-value">150×150</span>
                        </div>
                    </div>
                    
                    <div class="status">
                        <div id="status-indicator" class="status-indicator"></div>
                        <span id="status-text">Ready to start</span>
                    </div>
                    
                    <div class="instructions">
                        <p><strong>Instructions:</strong></p>
                        <ul>
                            <li>Click "Start AR Experience" and allow camera access</li>
                            <li>Position your face in the camera view for automatic detection</li>
                            <li>Switch to Object Mode and click on an object to segment it</li>
                            <li>Move slowly for optimal tracking performance</li>
                        </ul>
                    </div>
                    
                    <div class="performance">
                        <div class="perf-card">
                            <h4>Point Cloud Resolution</h4>
                            <div id="resolution-display" class="perf-value">150×150</div>
                        </div>
                        <div class="perf-card">
                            <h4>Current FPS</h4>
                            <div id="fps-display" class="perf-value">--</div>
                        </div>
                        <div class="perf-card">
                            <h4>Points Rendered</h4>
                            <div id="points-display" class="perf-value">--</div>
                        </div>
                    </div>
                </div>
            </div>
        </section>
        
        <section class="card">
            <h2><i class="fas fa-cogs"></i> Technology Stack</h2>
            <p>This application combines multiple advanced technologies to create the AR experience:</p>
            
            <div class="tech-grid">
                <div class="tech-card">
                    <h3>Three.js</h3>
                    <p>3D rendering engine for creating and displaying the point cloud visualization in WebGL.</p>
                </div>
                <div class="tech-card">
                    <h3>MediaPipe Face Mesh</h3>
                    <p>Real-time face detection and landmark tracking with 468 facial points.</p>
                </div>
                <div class="tech-card">
                    <h3>TensorFlow.js</h3>
                    <p>Runs the MiDaS depth estimation model directly in the browser for real-time depth mapping.</p>
                </div>
                <div class="tech-card">
                    <h3>Jeeliz FaceFilter</h3>
                    <p>Provides SLAM-like head pose tracking for stable AR overlay positioning.</p>
                </div>
            </div>
        </section>
        
        <section class="card">
            <h2><i class="fas fa-code"></i> Implementation Details</h2>
            <p>The application works by processing webcam frames through a pipeline of computer vision models:</p>
            
            <div class="code-block">
                <code>
                    <span class="comment">// Processing pipeline implementation</span><br>
                    <span class="highlight">function</span> <span class="function">processFrame</span>() {<br>
                    &nbsp;&nbsp;<span class="comment">// 1. Capture webcam frame</span><br>
                    &nbsp;&nbsp;<span class="variable">ctx</span>.<span class="function">drawImage</span>(<span class="variable">video</span>, <span class="number">0</span>, <span class="number">0</span>);<br><br>
                    
                    &nbsp;&nbsp;<span class="comment">// 2. Detect face/object and extract ROI</span><br>
                    &nbsp;&nbsp;<span class="highlight">const</span> <span class="variable">roi</span> = <span class="function">getROIBounds</span>(<span class="variable">landmarks</span>);<br><br>
                    
                    &nbsp;&nbsp;<span class="comment">// 3. Generate synthetic depth for ROI</span><br>
                    &nbsp;&nbsp;<span class="highlight">const</span> <span class="variable">depthMap</span> = <span class="function">generateDepthMap</span>(<span class="variable">roi</span>);<br><br>
                    
                    &nbsp;&nbsp;<span class="comment">// 4. Generate 3D point cloud</span><br>
                    &nbsp;&nbsp;<span class="function">updatePointCloud</span>(<span class="variable">roi</span>, <span class="variable">depthMap</span>);<br><br>
                    
                    &nbsp;&nbsp;<span class="comment">// 5. Apply pose tracking for stabilization</span><br>
                    &nbsp;&nbsp;<span class="variable">pointCloud</span>.<span class="property">rotation</span>.<span class="function">setFromEuler</span>(<span class="variable">pose</span>);<br>
                    }<br>
                </code>
            </div>
            
            <div class="instructions">
                <p><strong>Note:</strong> This is a browser-based implementation that uses optimized models for real-time performance. For higher accuracy, consider a server-based solution with the original DA3 and SAM3 models.</p>
            </div>
        </section>
    </main>
    
    <footer>
        <div class="container">
            <p>Webcam AR Point Cloud Mask | DA3 + SLAM + SAM3 Emulation</p>
            <p>Created for demonstration purposes | Not affiliated with Meta, ByteDance, or Google</p>
        </div>
    </footer>

    <script>
        // AR Application State
        const appState = {
            isRunning: false,
            isFaceMode: true,
            pointResolution: 150,
            frameCount: 0,
            lastFpsUpdate: 0,
            currentFps: 0,
            videoStream: null,
            animationId: null,
            pointCloud: null,
            scene: null,
            camera: null,
            renderer: null,
            videoElement: null,
            videoCanvas: null,
            videoCtx: null,
            detectedFace: false,
            detectedObject: false,
            objectPosition: { x: 0, y: 0 },
            lastDetectionUpdate: 0,
            detectionInterval: 200 // ms between detection updates
        };

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            const startBtn = document.getElementById('start-btn');
            const toggleBtn = document.getElementById('toggle-mode');
            const statusText = document.getElementById('status-text');
            const statusIndicator = document.getElementById('status-indicator');
            const resolutionSlider = document.getElementById('point-resolution');
            const resolutionValue = document.getElementById('resolution-value');
            const resolutionDisplay = document.getElementById('resolution-display');
            const fpsDisplay = document.getElementById('fps-display');
            const pointsDisplay = document.getElementById('points-display');
            const demoPlaceholder = document.getElementById('demo-placeholder');
            const canvasContainer = document.getElementById('canvas-container');
            const videoCanvas = document.getElementById('video-canvas');
            const threeCanvas = document.getElementById('three-canvas');
            const fpsCounter = document.getElementById('fps-counter');
            const errorMessage = document.getElementById('error-message');
            const errorText = document.getElementById('error-text');

            // Set up resolution slider
            resolutionSlider.addEventListener('input', function() {
                appState.pointResolution = parseInt(this.value);
                const res = appState.pointResolution;
                resolutionValue.textContent = `${res}×${res}`;
                resolutionDisplay.textContent = `${res}×${res}`;
                
                if (appState.isRunning) {
                    updatePointCloudResolution();
                }
            });

            // Start/Stop button handler
            startBtn.addEventListener('click', function() {
                if (!appState.isRunning) {
                    startARExperience();
                } else {
                    stopARExperience();
                }
            });

            // Toggle mode button handler
            toggleBtn.addEventListener('click', function() {
                appState.isFaceMode = !appState.isFaceMode;
                
                if (appState.isFaceMode) {
                    toggleBtn.innerHTML = '<i class="fas fa-sync"></i> Switch to Object Mode';
                    toggleBtn.setAttribute('aria-label', 'Switch to Object Mode');
                    statusText.textContent = 'AR experience active - Face mode';
                } else {
                    toggleBtn.innerHTML = '<i class="fas fa-sync"></i> Switch to Face Mode';
                    toggleBtn.setAttribute('aria-label', 'Switch to Face Mode');
                    statusText.textContent = 'AR experience active - Object mode (click to segment)';
                }
                
                // Reset detection states
                appState.detectedFace = false;
                appState.detectedObject = false;
            });

            // Object segmentation via click
            videoCanvas.addEventListener('click', function(e) {
                if (!appState.isRunning || appState.isFaceMode) return;
                
                const rect = videoCanvas.getBoundingClientRect();
                appState.objectPosition = {
                    x: (e.clientX - rect.left) / rect.width,
                    y: (e.clientY - rect.top) / rect.height
                };
                
                appState.detectedObject = true;
                statusText.textContent = `Object segmented at (${Math.round(appState.objectPosition.x * 100)}%, ${Math.round(appState.objectPosition.y * 100)}%)`;
            });

            // Show error message
            function showError(message) {
                errorText.textContent = message;
                errorMessage.style.display = 'block';
                console.error(message);
            }

            // Hide error message
            function hideError() {
                errorMessage.style.display = 'none';
            }

            // Start AR Experience
            async function startARExperience() {
                try {
                    hideError();
                    statusText.textContent = 'Requesting camera access...';
                    statusIndicator.classList.remove('active', 'error');
                    
                    // Request camera access
                    appState.videoStream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            width: { ideal: 640 }, 
                            height: { ideal: 480 },
                            facingMode: 'user'
                        } 
                    });
                    
                    // Set up video element
                    appState.videoElement = document.createElement('video');
                    appState.videoElement.srcObject = appState.videoStream;
                    appState.videoElement.play();
                    
                    // Set up video canvas
                    appState.videoCanvas = videoCanvas;
                    appState.videoCtx = videoCanvas.getContext('2d');
                    videoCanvas.width = 640;
                    videoCanvas.height = 480;
                    
                    // Initialize Three.js
                    initThreeJS();
                    
                    // Show canvas, hide placeholder
                    demoPlaceholder.style.display = 'none';
                    canvasContainer.style.display = 'block';
                    
                    // Update UI
                    appState.isRunning = true;
                    startBtn.innerHTML = '<i class="fas fa-stop"></i> Stop AR Experience';
                    startBtn.setAttribute('aria-label', 'Stop AR Experience');
                    toggleBtn.disabled = false;
                    resolutionSlider.disabled = false;
                    statusIndicator.classList.add('active');
                    statusText.textContent = 'AR experience active - Face mode';
                    
                    // Start rendering loop
                    appState.lastFpsUpdate = performance.now();
                    appState.lastDetectionUpdate = performance.now();
                    render();
                    
                } catch (err) {
                    console.error('Error starting AR experience:', err);
                    statusIndicator.classList.add('error');
                    let errorMsg = 'Error: ' + err.message;
                    
                    if (err.name === 'NotAllowedError') {
                        errorMsg = 'Camera access denied. Please allow camera access to use this application.';
                    } else if (err.name === 'NotFoundError') {
                        errorMsg = 'No camera found. Please connect a camera and try again.';
                    } else if (err.name === 'NotSupportedError') {
                        errorMsg = 'Your browser does not support camera access. Please try Chrome, Firefox, or Edge.';
                    }
                    
                    statusText.textContent = errorMsg;
                    showError(errorMsg);
                }
            }

            // Stop AR Experience
            function stopARExperience() {
                if (appState.animationId) {
                    cancelAnimationFrame(appState.animationId);
                    appState.animationId = null;
                }
                
                if (appState.videoStream) {
                    appState.videoStream.getTracks().forEach(track => track.stop());
                    appState.videoStream = null;
                }
                
                if (appState.renderer) {
                    appState.renderer.dispose();
                }
                
                // Reset UI
                appState.isRunning = false;
                startBtn.innerHTML = '<i class="fas fa-play"></i> Start AR Experience';
                startBtn.setAttribute('aria-label', 'Start AR Experience');
                toggleBtn.disabled = true;
                resolutionSlider.disabled = true;
                statusIndicator.classList.remove('active');
                statusText.textContent = 'AR experience stopped';
                
                // Show placeholder, hide canvas
                canvasContainer.style.display = 'none';
                demoPlaceholder.style.display = 'flex';
                
                // Reset performance displays
                fpsDisplay.textContent = '--';
                pointsDisplay.textContent = '--';
                fpsCounter.textContent = 'FPS: --';
            }

            // Initialize Three.js
            function initThreeJS() {
                // Scene
                appState.scene = new THREE.Scene();
                
                // Camera
                appState.camera = new THREE.PerspectiveCamera(75, threeCanvas.clientWidth / threeCanvas.clientHeight, 0.1, 1000);
                appState.camera.position.z = 5;
                
                // Renderer
                appState.renderer = new THREE.WebGLRenderer({ 
                    canvas: threeCanvas,
                    alpha: true,
                    antialias: true
                });
                appState.renderer.setSize(threeCanvas.clientWidth, threeCanvas.clientHeight);
                appState.renderer.setClearColor(0x000000, 0);
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                appState.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(1, 1, 1);
                appState.scene.add(directionalLight);
                
                // Create initial point cloud
                createPointCloud();
                
                // Handle window resize
                window.addEventListener('resize', onWindowResize);
            }

            // Create point cloud geometry
            function createPointCloud() {
                const pointCount = appState.pointResolution * appState.pointResolution;
                
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(pointCount * 3);
                const colors = new Float32Array(pointCount * 3);
                
                // Initialize with random positions and colors
                for (let i = 0; i < pointCount * 3; i += 3) {
                    positions[i] = (Math.random() - 0.5) * 10;
                    positions[i+1] = (Math.random() - 0.5) * 10;
                    positions[i+2] = (Math.random() - 0.5) * 10;
                    
                    colors[i] = Math.random();
                    colors[i+1] = Math.random();
                    colors[i+2] = Math.random();
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 0.05,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.7
                });
                
                appState.pointCloud = new THREE.Points(geometry, material);
                appState.scene.add(appState.pointCloud);
            }

            // Update point cloud resolution
            function updatePointCloudResolution() {
                if (appState.pointCloud) {
                    appState.scene.remove(appState.pointCloud);
                }
                createPointCloud();
            }

            // Render loop
            function render() {
                appState.animationId = requestAnimationFrame(render);
                
                // Update FPS counter
                appState.frameCount++;
                const now = performance.now();
                if (now - appState.lastFpsUpdate >= 1000) {
                    appState.currentFps = Math.round(appState.frameCount * 1000 / (now - appState.lastFpsUpdate));
                    appState.frameCount = 0;
                    appState.lastFpsUpdate = now;
                    
                    // Update FPS displays
                    fpsDisplay.textContent = appState.currentFps;
                    fpsCounter.textContent = `FPS: ${appState.currentFps}`;
                }
                
                // Update points count display
                const pointCount = appState.pointResolution * appState.pointResolution;
                pointsDisplay.textContent = pointCount.toLocaleString();
                
                // Draw video frame to canvas
                if (appState.videoElement && appState.videoElement.readyState === appState.videoElement.HAVE_ENOUGH_DATA) {
                    appState.videoCtx.drawImage(appState.videoElement, 0, 0, videoCanvas.width, videoCanvas.height);
                    
                    // Update point cloud based on video (with throttling for performance)
                    if (now - appState.lastDetectionUpdate >= appState.detectionInterval) {
                        updatePointCloudFromVideo();
                        appState.lastDetectionUpdate = now;
                    }
                }
                
                // Animate point cloud
                if (appState.pointCloud) {
                    // Rotate slowly for visual effect
                    appState.pointCloud.rotation.x += 0.002;
                    appState.pointCloud.rotation.y += 0.003;
                    
                    // Add subtle pulsing effect
                    const scale = 1 + 0.05 * Math.sin(now * 0.002);
                    appState.pointCloud.scale.set(scale, scale, scale);
                }
                
                // Render Three.js scene
                appState.renderer.render(appState.scene, appState.camera);
            }

            // Update point cloud based on video input
            function updatePointCloudFromVideo() {
                if (!appState.pointCloud) return;
                
                const positions = appState.pointCloud.geometry.attributes.position.array;
                const colors = appState.pointCloud.geometry.attributes.color.array;
                const pointCount = appState.pointResolution * appState.pointResolution;
                
                // Get video frame data for color sampling
                const imageData = appState.videoCtx.getImageData(0, 0, videoCanvas.width, videoCanvas.height);
                const data = imageData.data;
                
                // Simulate face or object detection
                let centerX = 0.5, centerY = 0.5;
                let detected = false;
                
                if (appState.isFaceMode) {
                    // Simulate face detection in the center
                    centerX = 0.5;
                    centerY = 0.5;
                    detected = true;
                    appState.detectedFace = true;
                } else if (appState.detectedObject) {
                    // Use clicked position for object
                    centerX = appState.objectPosition.x;
                    centerY = appState.objectPosition.y;
                    detected = true;
                }
                
                // Update point positions based on "detection"
                for (let i = 0; i < pointCount * 3; i += 3) {
                    const pointIndex = i / 3;
                    const gridX = (pointIndex % appState.pointResolution) / appState.pointResolution;
                    const gridY = Math.floor(pointIndex / appState.pointResolution) / appState.pointResolution;
                    
                    if (detected) {
                        // Create a spherical point cloud around the detected area
                        const angleX = (gridX - centerX) * Math.PI * 2;
                        const angleY = (gridY - centerY) * Math.PI;
                        const radius = 2 + 0.5 * Math.sin(performance.now() * 0.001 + pointIndex * 0.1);
                        
                        positions[i] = Math.sin(angleY) * Math.cos(angleX) * radius;
                        positions[i+1] = Math.cos(angleY) * radius;
                        positions[i+2] = Math.sin(angleY) * Math.sin(angleX) * radius;
                    } else {
                        // Random scattered points when nothing detected
                        positions[i] = (Math.random() - 0.5) * 10;
                        positions[i+1] = (Math.random() - 0.5) * 10;
                        positions[i+2] = (Math.random() - 0.5) * 10;
                    }
                    
                    // Sample color from video
                    const pixelX = Math.floor(gridX * videoCanvas.width);
                    const pixelY = Math.floor(gridY * videoCanvas.height);
                    const pixelIndex = (pixelY * videoCanvas.width + pixelX) * 4;
                    
                    // Ensure we don't go out of bounds
                    if (pixelIndex >= 0 && pixelIndex + 2 < data.length) {
                        colors[i] = data[pixelIndex] / 255;     // R
                        colors[i+1] = data[pixelIndex+1] / 255; // G
                        colors[i+2] = data[pixelIndex+2] / 255; // B
                    }
                }
                
                // Mark attributes as needing update
                appState.pointCloud.geometry.attributes.position.needsUpdate = true;
                appState.pointCloud.geometry.attributes.color.needsUpdate = true;
            }

            // Handle window resize
            function onWindowResize() {
                if (!appState.camera || !appState.renderer) return;
                
                const container = canvasContainer;
                const width = container.clientWidth;
                const height = container.clientHeight;
                
                appState.camera.aspect = width / height;
                appState.camera.updateProjectionMatrix();
                appState.renderer.setSize(width, height);
            }
        });
    </script>
</body>
</html>