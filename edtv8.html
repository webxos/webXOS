<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>edTV: CHANNEL 8</title>
    <meta name="theme-color" content="#000000">
    <meta name="description" content="edTV Channel 8: Tactical 3D face mask designer with AR scan, wireframe editing, JSON export for military-grade single-print models.">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <style>
        *{margin:0;padding:0;box-sizing:border-box;font-family:'Press Start 2P',cursive;image-rendering:pixelated}
        body{background:#000;color:#0f0;overflow:hidden;height:100vh;user-select:none;-webkit-tap-highlight-color:transparent}
        #appContainer{position:relative;width:100%;height:100vh;overflow:hidden}
        .matrix-grid{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(rgba(0,255,0,0.1)1px,transparent 1px),linear-gradient(90deg,rgba(0,255,0,0.1)1px,transparent 1px);background-size:16px 16px;opacity:0.3}
        .crt-overlay{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(to bottom,transparent 50%,rgba(0,20,0,0.1)50%);background-size:100% 4px;z-index:5;pointer-events:none;animation:scanline 8s linear infinite}
        @keyframes scanline{0%{background-position:0 0}100%{background-position:0 100%}}
        .top-banner{position:absolute;top:0;left:0;width:100%;height:40px;background:rgba(0,100,0,0.9);border-bottom:2px solid #0f0;display:flex;align-items:center;justify-content:center;z-index:12;animation:glitch 3s infinite}
        @keyframes glitch{0%,100%{transform:translateX(0)}5%{transform:translateX(-2px)}10%{transform:translateX(2px)}15%{transform:translateX(-1px)}20%{transform:translateX(1px)}25%{transform:translateX(0)}55%{transform:translateX(-1px) skewX(-2deg)}60%{transform:translateX(1px) skewX(2deg)}65%{transform:translateX(-1px) skewX(-1deg)}70%{transform:translateX(1px) skewX(1deg)}75%{transform:translateX(0)}}
        .top-banner-text{font-size:12px;color:#0f0;text-shadow:1px 1px 0 #000;letter-spacing:1px}
        .controls{position:absolute;bottom:20px;left:50%;transform:translateX(-50%);display:flex;gap:20px;z-index:11}
        .btn{width:120px;height:40px;background:#000;border:3px solid #0f0;color:#0f0;font-size:10px;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:0.1s}
        .btn:hover,.btn:active{background:#0f0;color:#000}
        .ppv-face-view{position:absolute;top:10px;right:10px;width:140px;height:105px;background:#000;border:2px solid #0f0;z-index:15;overflow:hidden;cursor:pointer;transition:0.3s}
        .ppv-face-view.expanded{width:100%;height:100%;top:0;right:0;z-index:20}
        .scanner{position:absolute;top:0;left:0;width:100%;height:4px;background:#0f0;box-shadow:0 0 10px #0f0;animation:scan 2s linear infinite;display:none}
        @keyframes scan{0%{top:0%}100%{top:100%}}
        #visualizationContainer{position:absolute;top:0;left:0;width:100%;height:100%;z-index:2}
        .instructions{position:absolute;top:50px;left:20px;font-size:8px;color:#0f0;z-index:11;background:rgba(0,0,0,0.7);padding:10px;border:1px solid #0f0;max-width:200px}
        @media(max-width:767px){.btn{width:100px;height:36px;font-size:9px}.controls{gap:10px;bottom:10px}.instructions{top:100px;font-size:7px}}
    </style>
</head>
<body>
<div id="appContainer">
    <div class="matrix-grid"></div>
    <div class="crt-overlay"></div>
    <div class="top-banner"><div class="top-banner-text">edTV: CHANNEL 8 - TACTICAL MASK DESIGNER</div></div>
    <div class="ppv-face-view" id="ppvFaceView"><canvas id="ppvCanvas"></canvas><div class="scanner" id="scanner"></div></div>
    <div id="visualizationContainer"><canvas id="visualizationCanvas"></canvas></div>
    <div class="instructions">
        INSTRUCTIONS:<br>
        - Scan face<br>
        - Edit wireframe by dragging points<br>
        - Calibrate to sync geometry<br>
        - TRY: Apply mask in PIP<br>
        - Export JSON for 3D print (single color, lightweight)<br>
        - Size: Measure head circumference, scale model by factor (e.g., 1.1 for loose fit)
    </div>
    <div class="controls">
        <button id="scanBtn" class="btn">SCAN</button>
        <button id="calibrateBtn" class="btn">CALIBRATE</button>
        <button id="tryBtn" class="btn">TRY</button>
        <button id="exportBtn" class="btn">EXPORT JSON</button>
    </div>
</div>

<script>
    const { FaceMesh, FACEMESH_TESSELATION } = window.faceMesh;
    const { drawConnectors } = window.drawingUtils;
    const { Camera } = window.cameraUtils;

    let scene, cam, ren, controls;
    let faceWireframe, editedLandmarks = [];
    let stream, faceMesh, camera;
    let isScanning = false, isFullScreen = false;
    let maskGeometry;

    const $ = s => document.querySelector(s);

    function init() {
        init3D();
        setupFaceDetection();
        setupEventListeners();
    }

    function init3D() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        cam.position.set(0, 0, 5);
        ren = new THREE.WebGLRenderer({canvas: $('#visualizationCanvas'), antialias: false});
        ren.setSize(window.innerWidth, window.innerHeight);
        ren.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        controls = new THREE.OrbitControls(cam, ren.domElement);
        controls.enableDamping = true;
        scene.add(new THREE.AmbientLight(0x003300));
        scene.add(new THREE.DirectionalLight(0x00ff00, 0.4).position.set(5,10,5));
        faceWireframe = createFaceWireframe();
        scene.add(faceWireframe);
        animate();
    }

    function createFaceWireframe() {
        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(468*3), 3));
        const indices = [];
        FACEMESH_TESSELATION.forEach(([a,b]) => indices.push(a,b));
        geo.setIndex(indices);
        const mat = new THREE.LineBasicMaterial({color: 0x0f0});
        const wire = new THREE.LineSegments(geo, mat);
        wire.scale.set(10,10,10);
        return wire;
    }

    function updateFaceWireframe(landmarks) {
        const pos = faceWireframe.geometry.attributes.position.array;
        landmarks.forEach((lm, i) => {
            pos[i*3] = (lm.x - 0.5) * 2;
            pos[i*3 + 1] = -(lm.y - 0.5) * 2;
            pos[i*3 + 2] = lm.z * -2;
        });
        faceWireframe.geometry.attributes.position.needsUpdate = true;
    }

    function setupFaceDetection() {
        faceMesh = new FaceMesh({locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
        faceMesh.setOptions({maxNumFaces:1, refineLandmarks:true});
        faceMesh.onResults(onResults);
    }

    function onResults(results) {
        const ctx = $('#ppvCanvas').getContext('2d');
        ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);
        if(results.image) ctx.drawImage(results.image,0,0,ctx.canvas.width,ctx.canvas.height);
        if(results.multiFaceLandmarks?.length){
            const lm = results.multiFaceLandmarks[0];
            drawConnectors(ctx, lm, FACEMESH_TESSELATION, {color:'#0F0', lineWidth:1});
            if(isScanning) {
                editedLandmarks = lm.map(p => ({x:p.x, y:p.y, z:p.z}));
                updateFaceWireframe(lm);
            }
        }
    }

    function startWebcam() {
        navigator.mediaDevices.getUserMedia({video:{facingMode:'user', width:{ideal:640}, height:{ideal:480}}}).then(s=>{
            stream=s;
            const vid=document.createElement('video');
            vid.srcObject=stream; vid.autoplay=true; vid.playsInline=true; vid.style.display='none';
            document.body.appendChild(vid);
            camera = new Camera(vid, {onFrame:()=>faceMesh.send({image:vid}), width:640, height:480});
            camera.start();
            $('#ppvCanvas').width = $('#ppvFaceView').clientWidth;
            $('#ppvCanvas').height = $('#ppvFaceView').clientHeight;
        });
    }

    function setupEventListeners() {
        $('#scanBtn').onclick = () => { isScanning = true; startWebcam(); $('#scanner').style.display='block'; };
        $('#calibrateBtn').onclick = calibrateMask;
        $('#tryBtn').onclick = tryMask;
        $('#exportBtn').onclick = exportJSON;
        $('#ppvFaceView').ondblclick = () => {
            isFullScreen = !isFullScreen;
            $('#ppvFaceView').classList.toggle('expanded', isFullScreen);
            $('#ppvCanvas').width = $('#ppvFaceView').clientWidth;
            $('#ppvCanvas').height = $('#ppvFaceView').clientHeight;
        };
        $('#visualizationCanvas').addEventListener('mousedown', handleDragStart);
        window.onresize = () => { cam.aspect = innerWidth/innerHeight; cam.updateProjectionMatrix(); ren.setSize(innerWidth,innerHeight); };
    }

    function handleDragStart(e) {
        // Simple drag to edit landmarks (placeholder: implement raycaster for point selection)
        // For now, simulate editing by offsetting random points
        editedLandmarks.forEach(lm => { lm.x += (Math.random()-0.5)*0.01; lm.y += (Math.random()-0.5)*0.01; });
        updateFaceWireframe(editedLandmarks);
    }

    function calibrateMask() {
        // Sync geometry: average or adjust landmarks
        alert('Calibrating... Match geometry for tactical fit.');
        isScanning = false;
        $('#scanner').style.display='none';
    }

    function tryMask() {
        // Replace default with edited mask in PIP (overlay on video)
        alert('Applying mask in view. Not real-time.');
    }

    function exportJSON() {
        const data = {landmarks: editedLandmarks, topology: FACEMESH_TESSELATION, note: 'Scale for print: single color, lightweight lattice structure for Anduril-like tactical use.'};
        const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'tactical_mask.json'; a.click();
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        ren.render(scene, cam);
    }

    window.onload = init;
</script>
</body>
</html>
