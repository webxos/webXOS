<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>NeuroTS AR Mirror</title>
    <meta name="theme-color" content="#000000">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <style>
        *{margin:0;padding:0;box-sizing:border-box;font-family:'Press Start 2P',cursive;image-rendering:pixelated}
        body{background:#000;color:#0f0;overflow:hidden;height:100vh;user-select:none;-webkit-tap-highlight-color:transparent}
        #appContainer{position:relative;width:100%;height:100vh;overflow:hidden}
        .matrix-grid{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(rgba(0,255,0,0.1)1px,transparent 1px),linear-gradient(90deg,rgba(0,255,0,0.1)1px,transparent 1px);background-size:16px 16px;opacity:0.3}
        .crt-overlay{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(to bottom,transparent 50%,rgba(0,20,0,0.1)50%);background-size:100% 4px;z-index:5;pointer-events:none;animation:scanline 8s linear infinite}
        @keyframes scanline{0%{background-position:0 0}100%{background-position:0 100%}}
        #visualizationContainer{position:absolute;top:0;left:0;width:100%;height:100%;z-index:2}
        #ideInterface{position:absolute;top:0;left:0;width:100%;height:100%;z-index:10}
        
        /* Top Banner with Glitch Effect */
        .top-banner {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 40px;
            background: rgba(255, 0, 255, 0.9);
            border-bottom: 2px solid #f0f;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 12;
            overflow: hidden;
            animation: glitch 3s infinite;
        }
        
        @keyframes glitch {
            0%, 100% { transform: translateX(0); }
            5% { transform: translateX(-2px); }
            10% { transform: translateX(2px); }
            15% { transform: translateX(-1px); }
            20% { transform: translateX(1px); }
            25% { transform: translateX(0); }
            50% { transform: translateX(0); }
            55% { transform: translateX(-1px) skewX(-2deg); }
            60% { transform: translateX(1px) skewX(2deg); }
            65% { transform: translateX(-1px) skewX(-1deg); }
            70% { transform: translateX(1px) skewX(1deg); }
            75% { transform: translateX(0); }
        }
        
        .top-banner::before {
            content: '';
            position: absolute;
            top: 0;
            left: -10%;
            width: 120%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            animation: shimmer 2s infinite;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .top-banner-text {
            font-size: 12px;
            color: #000;
            text-shadow: 1px 1px 0 #fff;
            letter-spacing: 1px;
        }
        
        /* Left Side Mirror Button */
        .mirror-btn{
            width:180px;height:52px;background:#000;border:3px solid #0ff;color:#0ff;
            font-size:10px;display:flex;align-items:center;justify-content:center;cursor:pointer;
            box-shadow:3px 3px 0 #000;transform:skew(-2deg);transition:background 0.1s,color 0.1s;
            touch-action:none;
            position:absolute;top:60px;left:20px;z-index:11
        }
        .mirror-btn:hover,.mirror-btn:active{background:#0ff;color:#000}
        .mirror-btn.active{background:#0ff;color:#000}
        
        /* Right Side Controls */
        .right-controls {
            position: absolute;
            top: 60px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 11;
        }
        
        .zoom-in-btn {
            width: 120px;
            height: 40px;
            background: #000;
            border: 3px solid #0f0;
            color: #0f0;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
        }
        
        .zoom-out-btn {
            width: 120px;
            height: 40px;
            background: #000;
            border: 3px solid #f00;
            color: #f00;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
        }
        
        .reset-btn {
            width: 120px;
            height: 40px;
            background: #000;
            border: 3px solid #ff0;
            color: #ff0;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
        }
        
        .zoom-in-btn:hover,.zoom-in-btn:active{background:#0f0;color:#000}
        .zoom-out-btn:hover,.zoom-out-btn:active{background:#f00;color:#000}
        .reset-btn:hover,.reset-btn:active{background:#ff0;color:#000}
        
        /* PPV Face View */
        .ppv-face-view {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 140px;
            height: 105px;
            background: #000;
            border: 2px solid #0ff;
            z-index: 15;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .ppv-face-view.expanded {
            width: 300px;
            height: 225px;
            z-index: 20;
        }
        
        .ppv-canvas {
            width: 100%;
            height: 100%;
        }
        
        /* Radar Display */
        .radar-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 200px;
            border-radius: 50%;
            border: 2px solid rgba(0, 255, 0, 0.5);
            background: rgba(0, 0, 0, 0.3);
            z-index: 10;
        }
        
        .radar-sweep {
            position: absolute;
            top: 0;
            left: 50%;
            width: 2px;
            height: 100%;
            background: linear-gradient(to bottom, transparent, #0f0, transparent);
            transform-origin: center;
            z-index: 1;
        }
        
        .radar-dot {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
        }
        
        .green-dot {
            background-color: #0f0;
            box-shadow: 0 0 8px #0f0;
        }
        
        .red-dot {
            background-color: #f00;
            box-shadow: 0 0 8px #f00;
        }
        
        /* HUD Warning */
        #hudWarning{position:absolute;top:20%;left:50%;transform:translate(-50%,-50%);color:#f00;font-size:12px;text-shadow:1px 1px 0 #000;z-index:11;display:none}
        
        /* NeuroTS Status */
        .neurots-status {
            position: absolute;
            top: 50px;
            left: 10px;
            font-size: 8px;
            color: #0ff;
            z-index: 11;
            background: rgba(0,0,0,0.7);
            padding: 5px;
            border: 1px solid #0ff;
        }
        
        /* Status Panel */
        .status-panel {
            position: absolute;
            top: 50px;
            right: 160px;
            font-size: 8px;
            color: #0ff;
            z-index: 11;
            background: rgba(0,0,0,0.7);
            padding: 5px;
            border: 1px solid #0ff;
        }
        
        /* Desktop Override */
        @media (min-width:768px){
            .mirror-btn{width:200px;height:56px;font-size:12px}
        }
        
        /* Mobile Optimization */
        @media (max-width:767px){
            .ppv-face-view{width:100px;height:75px}
            .ppv-face-view.expanded{width:280px;height:210px}
            .status-panel{right:120px}
            .mirror-btn{left:10px;width:160px;height:48px;font-size:9px}
            .right-controls{right:10px}
            .zoom-in-btn, .zoom-out-btn, .reset-btn{width:100px;height:36px;font-size:9px}
        }
        
        /* Focus styles for accessibility */
        .mirror-btn:focus, .zoom-in-btn:focus, .zoom-out-btn:focus, .reset-btn:focus {
            outline: 2px solid #0ff;
            outline-offset: 2px;
        }
        
        /* Scene Click Area */
        #sceneClickArea {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            cursor: pointer;
        }
        
        /* Mobile Touch Controls */
        .touch-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            z-index: 10;
            display: none;
        }
        
        .touch-control-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
        }
        
        @media (max-width: 767px) {
            .touch-controls {
                display: block;
            }
        }
    </style>
</head>
<body>
<div id="appContainer">
    <div class="matrix-grid"></div>
    <div class="crt-overlay"></div>
    
    <!-- Top Banner with Glitch Effect -->
    <div class="top-banner">
        <div class="top-banner-text">MIRROR PERSONAL IDE v1.0</div>
    </div>
    
    <!-- PPV Face View -->
    <div class="ppv-face-view" id="ppvFaceView">
        <canvas class="ppv-canvas" id="ppvCanvas"></canvas>
    </div>
    
    <!-- NeuroTS Status -->
    <div class="neurots-status" id="neurotsStatus">
        NEUROTS: CALIBRATING...
    </div>
    
    <!-- Status Panel -->
    <div class="status-panel">
        OBJECTS: <span id="objectCount">0</span><br>
        FPS: <span id="fpsCounter">60</span><br>
        ZOOM: <span id="zoomLevel">1.0</span>x
    </div>
    
    <!-- 3D SCENE -->
    <div id="visualizationContainer">
        <canvas id="visualizationCanvas"></canvas>
        <div id="sceneClickArea" title="Touch and drag to rotate view"></div>
    </div>
    
    <!-- Radar Display -->
    <div class="radar-container" id="radarContainer">
        <div class="radar-sweep" id="radarSweep"></div>
    </div>
    
    <!-- Mobile Touch Controls -->
    <div class="touch-controls" id="touchControls">
        <div class="touch-control-center"></div>
    </div>
    
    <div id="ideInterface">
        <!-- LEFT SIDE MIRROR BUTTON -->
        <button id="mirrorBtn" class="mirror-btn" aria-label="Open AR Mirror">MIRROR PERSONAL IDE v1.0</button>
        
        <!-- RIGHT SIDE CONTROLS -->
        <div class="right-controls">
            <button id="zoomInBtn" class="zoom-in-btn" aria-label="Zoom In">ZOOM IN</button>
            <button id="zoomOutBtn" class="zoom-out-btn" aria-label="Zoom Out">ZOOM OUT</button>
            <button id="resetViewBtn" class="reset-btn" aria-label="Reset View">RESET VIEW</button>
        </div>
        
        <!-- HUD -->
        <div id="hudWarning">USER MISSING</div>
    </div>
</div>

<script>
    // Main Application Variables
    let scene, cam, ren, clock;
    let userObj, neurotsObjects = [];
    let faceDirection = 0, userDetected = false;
    let stream, faceMesh, camera;
    let isFrontCam = true;
    const user = new THREE.Vector3(0, 1, 0);
    let animationId = null;
    let neurotsReconstructionActive = false;
    let sceneScale = 1.0;
    let isZooming = false;
    let objectCount = 0;
    let frameCount = 0;
    let lastFpsUpdate = 0;
    const fpsUpdateInterval = 1000;
    
    // Camera control variables
    let cameraDistance = 5;
    let cameraAngleX = 0;
    let cameraAngleY = 0;
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let lastTouchX = 0;
    let lastTouchY = 0;
    let isPinching = false;
    let initialPinchDistance = 0;

    // DOM utility functions
    const $ = s => document.querySelector(s);
    const $$ = s => document.querySelectorAll(s);

    function init() {
        try {
            init3D();
            setupFaceDetection();
            setupObjectDetection();
            setupEventListeners();
            animate();
            
            console.log("NeuroTS AR Mirror initialized successfully");
        } catch (error) {
            console.error('Initialization error:', error);
        }
    }

    function init3D() {
        try {
            // Initialize Three.js scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            updateCameraPosition();
            
            const canvas = $('#visualizationCanvas');
            ren = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                antialias: false, 
                powerPreference: "high-performance" 
            });
            ren.setSize(window.innerWidth, window.innerHeight);
            ren.setPixelRatio(1); // Force 1x for performance
            
            clock = new THREE.Clock();

            // Lighting
            scene.add(new THREE.AmbientLight(0x003300));
            const dir = new THREE.DirectionalLight(0x00ff00, 0.4);
            dir.position.set(5, 10, 5);
            scene.add(dir);

            // Grid
            const gridHelper = new THREE.GridHelper(20, 20, 0x004400, 0x002200);
            scene.add(gridHelper);

            // User object (simple representation)
            userObj = createNeurotsUser();
            userObj.position.copy(user);
            scene.add(userObj);

            cam.lookAt(user);
            ren.render(scene, cam);
            
        } catch (error) {
            console.error('3D initialization error:', error);
        }
    }
    
    function updateCameraPosition() {
        // Calculate camera position based on angles and distance
        const x = cameraDistance * Math.sin(cameraAngleY) * Math.cos(cameraAngleX);
        const y = cameraDistance * Math.sin(cameraAngleX) + 2;
        const z = cameraDistance * Math.cos(cameraAngleY) * Math.cos(cameraAngleX);
        
        cam.position.set(x, y, z);
        cam.lookAt(user);
        
        // Update zoom level display
        $('#zoomLevel').textContent = (1 / cameraDistance * 5).toFixed(1);
    }

    function createNeurotsUser() {
        // Create simple user representation
        const group = new THREE.Group();
        
        // Head (simple sphere)
        const headGeometry = new THREE.SphereGeometry(0.2, 6, 4);
        const headMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x00ffff, 
            wireframe: true 
        });
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.y = 0.2;
        group.add(head);
        
        // Body (simple cylinder)
        const bodyGeometry = new THREE.CylinderGeometry(0.1, 0.08, 0.4, 6);
        const bodyMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x00aaff, 
            wireframe: true 
        });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.y = -0.2;
        group.add(body);
        
        return group;
    }

    function setupFaceDetection() {
        try {
            faceMesh = new FaceMesh({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
                }
            });
            
            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            faceMesh.onResults(onFaceMeshResults);
            
            console.log("Face Mesh detection initialized");
        } catch (error) {
            console.error('Face detection setup error:', error);
        }
    }

    function onFaceMeshResults(results) {
        userDetected = results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0;
        $('#hudWarning').style.display = userDetected ? 'none' : 'block';
        
        const ppvCanvas = $('#ppvCanvas');
        const ppvCtx = ppvCanvas.getContext('2d');
        
        // Clear and draw the video frame
        ppvCtx.clearRect(0, 0, ppvCanvas.width, ppvCanvas.height);
        
        if (results.image) {
            ppvCtx.drawImage(results.image, 0, 0, ppvCanvas.width, ppvCanvas.height);
        }

        if (userDetected) {
            const landmarks = results.multiFaceLandmarks[0];
            
            // Draw face mesh wireframe
            drawConnectors(ppvCtx, landmarks, FACEMESH_TESSELATION, { color: '#C0C0C070', lineWidth: 1 });
            drawConnectors(ppvCtx, landmarks, FACEMESH_RIGHT_EYE, { color: '#FF3030', lineWidth: 1 });
            drawConnectors(ppvCtx, landmarks, FACEMESH_LEFT_EYE, { color: '#30FF30', lineWidth: 1 });
            drawConnectors(ppvCtx, landmarks, FACEMESH_FACE_OVAL, { color: '#E0E0E0', lineWidth: 2 });
            
            // Calculate face direction (yaw) using cheek landmarks
            const leftCheek = landmarks[234];
            const rightCheek = landmarks[454];
            const yaw = Math.atan2(
                (rightCheek.x - leftCheek.x) * ppvCanvas.width,
                (rightCheek.z - leftCheek.z) * 1000 // Approximate depth
            ) * 180 / Math.PI;
            
            faceDirection = yaw;
            $('#neurotsStatus').textContent = `NEUROTS: TRACKING (${yaw.toFixed(0)}Â°)`;
            
            // Enable neurots reconstruction when face is detected
            neurotsReconstructionActive = true;
        } else {
            $('#neurotsStatus').textContent = 'NEUROTS: CALIBRATING...';
            neurotsReconstructionActive = false;
        }
    }

    function setupObjectDetection() {
        // Simulate object detection - in real app this would use AR object detection
        setInterval(() => {
            if (neurotsReconstructionActive && objectCount < 100) { // Limit objects for performance
                // Randomly decide if we should add an object
                if (Math.random() < 0.1) {
                    addDetectedObject();
                }
            }
        }, 500);
    }

    function addDetectedObject() {
        // Determine object type and position
        const isLargeObject = Math.random() > 0.5; // Green for large, red for small
        const distance = 2 + Math.random() * 8;
        const angle = (Math.random() * 120 - 60 + faceDirection) * Math.PI / 180;
        
        const x = Math.cos(angle) * distance;
        const z = Math.sin(angle) * distance;
        const y = Math.random() * 3; // Random height
        
        // Create ultra-lightweight 3D dot
        const dotGeometry = new THREE.SphereGeometry(0.05, 4, 4); // Ultra low poly
        const dotMaterial = new THREE.MeshBasicMaterial({ 
            color: isLargeObject ? 0x00ff00 : 0xff0000 
        });
        const dot = new THREE.Mesh(dotGeometry, dotMaterial);
        dot.position.set(x, y, z);
        
        // Store object data
        dot.userData = {
            type: isLargeObject ? 'surface' : 'object',
            id: objectCount,
            static: true
        };
        
        scene.add(dot);
        neurotsObjects.push(dot);
        objectCount++;
        
        // Update UI
        $('#objectCount').textContent = objectCount;
        
        // Add to radar display
        addRadarDot(x, z, isLargeObject);
        
        console.log(`Added ${isLargeObject ? 'green' : 'red'} object at (${x.toFixed(1)}, ${y.toFixed(1)}, ${z.toFixed(1)})`);
    }
    
    function addRadarDot(x, z, isLarge) {
        const radar = $('#radarContainer');
        const dot = document.createElement('div');
        dot.className = `radar-dot ${isLarge ? 'green-dot' : 'red-dot'}`;
        
        // Convert 3D coordinates to radar coordinates
        const radarX = (x / 10) * 100 + 50;
        const radarY = (z / 10) * 100 + 50;
        
        dot.style.left = `${radarX}%`;
        dot.style.top = `${radarY}%`;
        
        radar.appendChild(dot);
        
        // Limit radar dots for performance
        const radarDots = radar.querySelectorAll('.radar-dot');
        if (radarDots.length > 50) {
            radar.removeChild(radarDots[0]);
        }
    }

    function startWebcam() {
        if (stream) {
            return; // Webcam already running
        }
        
        try {
            // Auto-detect camera direction based on device
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            isFrontCam = isMobile; // Use front camera on mobile, back on desktop
            
            // Request camera access
            navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: isFrontCam ? 'user' : 'environment',
                    width: { ideal: 640 },
                    height: { ideal: 480 }
                } 
            })
            .then(s => {
                stream = s;
                
                // Create video element for face detection
                const video = document.createElement('video');
                video.id = 'webcamVideo';
                video.srcObject = stream;
                video.autoplay = true;
                video.playsInline = true;
                video.style.display = 'none';
                document.body.appendChild(video);
                
                // Setup camera for face detection
                camera = new Camera(video, {
                    onFrame: async () => {
                        await faceMesh.send({ image: video });
                    },
                    width: 640,
                    height: 480
                });
                
                camera.start();
                
                // Setup PPV canvas
                const ppvCanvas = $('#ppvCanvas');
                ppvCanvas.width = $('#ppvFaceView').clientWidth;
                ppvCanvas.height = $('#ppvFaceView').clientHeight;
                
                $('#neurotsStatus').textContent = 'NEUROTS: FACE DETECTION ACTIVE';
                
                console.log("Webcam started successfully");
            })
            .catch(error => {
                console.error('Webcam error:', error);
                
                let errorMessage = 'CAMERA ACCESS DENIED';
                if (error.name === 'NotAllowedError') {
                    errorMessage = 'CAMERA ACCESS DENIED BY USER';
                } else if (error.name === 'NotFoundError') {
                    errorMessage = 'NO CAMERA FOUND';
                } else if (error.name === 'NotSupportedError') {
                    errorMessage = 'CAMERA NOT SUPPORTED';
                }
                
                $('#neurotsStatus').textContent = errorMessage;
                stream = null;
            });
            
        } catch (error) {
            console.error('Webcam setup error:', error);
            $('#neurotsStatus').textContent = 'WEBCAM SETUP FAILED';
        }
    }

    function stopWebcam() {
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            stream = null;
            
            if (camera) {
                camera.stop();
            }
            
            // Remove hidden video element
            const video = $('#webcamVideo');
            if (video) video.remove();
            
            $('#neurotsStatus').textContent = 'WEBCAM STOPPED';
            
            console.log("Webcam stopped");
        }
    }

    function zoomIn() {
        if (isZooming) return;
        
        isZooming = true;
        cameraDistance = Math.max(cameraDistance * 0.8, 1.5);
        updateCameraPosition();
        
        setTimeout(() => { isZooming = false; }, 300);
        console.log("Zoomed in");
    }

    function zoomOut() {
        if (isZooming) return;
        
        isZooming = true;
        cameraDistance = Math.min(cameraDistance * 1.2, 15);
        updateCameraPosition();
        
        setTimeout(() => { isZooming = false; }, 300);
        console.log("Zoomed out");
    }

    function resetView() {
        cameraDistance = 5;
        cameraAngleX = 0;
        cameraAngleY = 0;
        updateCameraPosition();
        
        console.log("View reset");
    }

    function setupEventListeners() {
        // Mirror button event listener
        $('#mirrorBtn').addEventListener('click', () => {
            if ($('#mirrorBtn').classList.contains('active')) {
                stopWebcam();
                $('#mirrorBtn').classList.remove('active');
                $('#mirrorBtn').textContent = 'MIRROR PERSONAL IDE v1.0';
            } else {
                startWebcam();
                $('#mirrorBtn').classList.add('active');
                $('#mirrorBtn').textContent = 'MIRROR ACTIVE';
            }
        });
        
        // Zoom controls
        $('#zoomInBtn').addEventListener('click', zoomIn);
        $('#zoomOutBtn').addEventListener('click', zoomOut);
        $('#resetViewBtn').addEventListener('click', resetView);
        
        // PPV face view toggle
        $('#ppvFaceView').addEventListener('click', () => {
            $('#ppvFaceView').classList.toggle('expanded');
            // Update canvas size
            const ppvCanvas = $('#ppvCanvas');
            ppvCanvas.width = $('#ppvFaceView').clientWidth;
            ppvCanvas.height = $('#ppvFaceView').clientHeight;
        });
        
        // Mouse controls for desktop
        const sceneClickArea = $('#sceneClickArea');
        
        sceneClickArea.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;
            
            cameraAngleY += deltaX * 0.01;
            cameraAngleX = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraAngleX - deltaY * 0.01));
            
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            
            updateCameraPosition();
        });
        
        document.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        // Touch controls for mobile
        sceneClickArea.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                // Single touch for rotation
                isDragging = true;
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                // Two touches for pinch-to-zoom
                isPinching = true;
                initialPinchDistance = getTouchDistance(e.touches[0], e.touches[1]);
            }
            e.preventDefault();
        });
        
        sceneClickArea.addEventListener('touchmove', (e) => {
            if (isDragging && e.touches.length === 1) {
                // Single touch rotation
                const deltaX = e.touches[0].clientX - lastTouchX;
                const deltaY = e.touches[0].clientY - lastTouchY;
                
                cameraAngleY += deltaX * 0.01;
                cameraAngleX = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraAngleX - deltaY * 0.01));
                
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
                
                updateCameraPosition();
            } else if (isPinching && e.touches.length === 2) {
                // Two touch pinch-to-zoom
                const currentDistance = getTouchDistance(e.touches[0], e.touches[1]);
                const zoomFactor = initialPinchDistance / currentDistance;
                
                cameraDistance = Math.max(1.5, Math.min(15, cameraDistance * zoomFactor));
                initialPinchDistance = currentDistance;
                
                updateCameraPosition();
            }
            e.preventDefault();
        });
        
        sceneClickArea.addEventListener('touchend', (e) => {
            isDragging = false;
            isPinching = false;
        });
        
        // Helper function to calculate distance between two touches
        function getTouchDistance(touch1, touch2) {
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        // Window resize handler
        window.addEventListener('resize', () => {
            cam.aspect = window.innerWidth / window.innerHeight;
            cam.updateProjectionMatrix();
            ren.setSize(window.innerWidth, window.innerHeight);
            
            // Update PPV canvas size
            const ppvCanvas = $('#ppvCanvas');
            const ppvView = $('#ppvFaceView');
            ppvCanvas.width = ppvView.clientWidth;
            ppvCanvas.height = ppvView.clientHeight;
        }, { passive: true });
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', cleanup);
        
        console.log("Event listeners setup complete");
    }

    function cleanup() {
        // Stop animation loop
        if (animationId) {
            cancelAnimationFrame(animationId);
        }
        
        // Stop webcam
        if (stream) {
            stopWebcam();
        }
        
        // Clean up Three.js resources
        if (scene) {
            scene.traverse(object => {
                if (object.geometry) object.geometry.dispose();
                if (object.material) {
                    if (Array.isArray(object.material)) {
                        object.material.forEach(material => material.dispose());
                    } else {
                        object.material.dispose();
                    }
                }
            });
        }
        
        console.log("Cleanup completed");
    }

    function animate() {
        animationId = requestAnimationFrame(animate);
        const deltaTime = clock.getDelta();
        
        // Update user rotation based on face direction
        if (userObj) {
            userObj.rotation.y = -faceDirection * Math.PI / 180;
        }
        
        // Update radar sweep
        const radarSweep = $('#radarSweep');
        const sweepRotation = (Date.now() * 0.002) % 360;
        radarSweep.style.transform = `translateX(-50%) rotate(${sweepRotation}deg)`;
        
        // Render scene
        ren.render(scene, cam);
        
        // Update FPS counter
        const now = performance.now();
        if (now - lastFpsUpdate > fpsUpdateInterval) {
            const fps = Math.round((frameCount * 1000) / (now - lastFpsUpdate));
            $('#fpsCounter').textContent = fps;
            frameCount = 0;
            lastFpsUpdate = now;
        }
        
        frameCount++;
    }

    // Initialize the application when the window loads
    window.addEventListener('load', init);
</script>
</body>
</html>