<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRIOS - BETA TEST</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Press Start 2P', 'Courier New', monospace;
            image-rendering: pixelated;
        }
        
        body {
            background: #000;
            color: #0f0;
            overflow: hidden;
            height: 100vh;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }
        
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        .hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }
        
        /* Enhanced FPS Counter */
        .fps-counter {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 10px;
            color: #0f0;
            text-shadow: 0 0 5px #0f0, 0 0 10px #0f0;
            background: rgba(0, 0, 0, 0.8);
            padding: 3px 6px;
            border: 1px solid #0f0;
            box-shadow: 0 0 5px #0f0;
        }
        
        /* Enhanced Dragon Health Bar */
        .dragon-health-container {
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #f00;
            padding: 3px;
            display: none;
            image-rendering: pixelated;
            box-shadow: 0 0 10px #f00;
        }
        
        .dragon-health-label {
            font-size: 8px;
            text-align: center;
            color: #f00;
            margin-bottom: 2px;
            text-shadow: 0 0 5px #f00;
        }
        
        .dragon-health-bar {
            width: 100%;
            height: 10px;
            background: rgba(20, 0, 0, 0.7);
            border: 1px solid #f00;
            position: relative;
            overflow: hidden;
        }
        
        .dragon-health-fill {
            height: 100%;
            background: #f00;
            width: 100%;
            box-shadow: 0 0 5px #f00;
        }
        
        .dragon-health-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 6px;
            color: #fff;
            text-shadow: 0 0 3px #000;
        }
        
        /* Enhanced HUD Elements */
        .health-container {
            position: absolute;
            top: 5px;
            left: 5px;
            width: 150px;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px;
            border: 1px solid #0f0;
            box-shadow: 0 0 5px #0f0;
        }
        
        .health-label {
            font-size: 7px;
            margin-bottom: 3px;
            color: #0f0;
            text-shadow: 0 0 3px #0f0;
        }
        
        .health-bar {
            width: 100%;
            height: 10px;
            background: rgba(0, 20, 0, 0.7);
            border: 1px solid #0f0;
            position: relative;
            overflow: hidden;
        }
        
        .health-fill {
            height: 100%;
            background: #0f0;
            width: 100%;
            box-shadow: 0 0 5px #0f0;
        }
        
        .health-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 6px;
            color: #000;
            font-weight: bold;
        }
        
        .ammo-container {
            position: absolute;
            bottom: 5px;
            right: 5px;
            text-align: right;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px;
            border: 1px solid #0f0;
            box-shadow: 0 0 5px #0f0;
        }
        
        .ammo-count {
            font-size: 14px;
            margin-bottom: 2px;
            text-shadow: 0 0 5px #0f0;
            color: #0f0;
        }
        
        .weapon-name {
            font-size: 7px;
            opacity: 0.9;
            color: #0f0;
        }
        
        .dragon-counter {
            position: absolute;
            top: 40px;
            right: 5px;
            font-size: 9px;
            color: #0f0;
            text-shadow: 0 0 5px #0f0;
            background: rgba(0, 0, 0, 0.8);
            padding: 3px 6px;
            border: 1px solid #0f0;
            box-shadow: 0 0 5px #0f0;
        }
        
        /* Enhanced Heat Bar */
        .heat-container {
            position: absolute;
            bottom: 40px;
            left: 5px;
            width: 150px;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px;
            border: 1px solid #0f0;
            box-shadow: 0 0 5px #0f0;
        }
        
        .heat-label {
            font-size: 7px;
            margin-bottom: 3px;
            color: #0f0;
            text-shadow: 0 0 3px #0f0;
        }
        
        .heat-bar {
            width: 100%;
            height: 10px;
            background: rgba(20, 0, 0, 0.7);
            border: 1px solid #0f0;
            position: relative;
            overflow: hidden;
        }
        
        .heat-fill {
            height: 100%;
            background: #ff0;
            width: 0%;
            transition: width 0.3s;
            box-shadow: 0 0 5px #ff0;
        }
        
        .heat-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 6px;
            color: #000;
            font-weight: bold;
        }
        
        /* Enhanced Boost Bar */
        .boost-container {
            position: absolute;
            bottom: 25px;
            left: 5px;
            width: 150px;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px;
            border: 1px solid #ff0;
            box-shadow: 0 0 5px #ff0;
        }
        
        .boost-label {
            font-size: 7px;
            margin-bottom: 3px;
            color: #ff0;
            text-shadow: 0 0 3px #ff0;
        }
        
        .boost-bar {
            width: 100%;
            height: 10px;
            background: rgba(20, 20, 0, 0.7);
            border: 1px solid #ff0;
            position: relative;
            overflow: hidden;
        }
        
        .boost-fill {
            height: 100%;
            background: #ff0;
            width: 100%;
            box-shadow: 0 0 5px #ff0;
        }
        
        .boost-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 6px;
            color: #000;
            font-weight: bold;
        }
        
        /* Enhanced Crosshair */
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 5;
        }
        
        .crosshair::before, .crosshair::after {
            content: '';
            position: absolute;
            background: #0f0;
            box-shadow: 0 0 5px #0f0;
        }
        
        .crosshair::before {
            top: 50%;
            left: 0;
            width: 100%;
            height: 1px;
            transform: translateY(-50%);
        }
        
        .crosshair::after {
            left: 50%;
            top: 0;
            height: 100%;
            width: 1px;
            transform: translateX(-50%);
        }
        
        .crosshair-dot {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 3px;
            height: 3px;
            background: #0f0;
            border-radius: 50%;
            box-shadow: 0 0 5px #0f0;
        }
        
        /* Sword Drone Crosshair */
        .sword-target-crosshair {
            position: absolute;
            width: 30px;
            height: 30px;
            pointer-events: none;
            z-index: 4;
            display: none;
        }
        
        .sword-target-crosshair::before, .sword-target-crosshair::after {
            content: '';
            position: absolute;
            background: #f00;
            box-shadow: 0 0 10px #f00;
        }
        
        .sword-target-crosshair::before {
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            transform: translateY(-50%);
        }
        
        .sword-target-crosshair::after {
            left: 50%;
            top: 0;
            height: 100%;
            width: 2px;
            transform: translateX(-50%);
        }
        
        /* Sword Drone UI */
        .sword-drone-container {
            position: absolute;
            bottom: 80px;
            left: 5px;
            width: 150px;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px;
            border: 1px solid #0f0;
            box-shadow: 0 0 5px #0f0;
        }
        
        .sword-drone-label {
            font-size: 7px;
            margin-bottom: 3px;
            color: #0f0;
            text-shadow: 0 0 3px #0f0;
        }
        
        .sword-drone-bar {
            width: 100%;
            height: 10px;
            background: rgba(0, 20, 0, 0.7);
            border: 1px solid #0f0;
            position: relative;
            overflow: hidden;
        }
        
        .sword-drone-fill {
            height: 100%;
            background: #0f0;
            width: 100%;
            box-shadow: 0 0 5px #0f0;
        }
        
        .sword-drone-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 6px;
            color: #000;
            font-weight: bold;
        }
        
        .sword-drone-status {
            font-size: 7px;
            margin-top: 3px;
            color: #0f0;
            text-align: center;
            text-shadow: 0 0 3px #0f0;
        }
        
        /* Enhanced Menu Styles */
        .menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 10, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }
        
        .title {
            font-size: 24px;
            margin-bottom: 10px;
            text-align: center;
            color: #0f0;
            text-shadow: 0 0 10px #0f0, 0 0 20px #0f0;
            letter-spacing: 1px;
        }
        
        .subtitle {
            font-size: 10px;
            margin-bottom: 8px;
            color: #f00;
            text-align: center;
            text-shadow: 0 0 5px #f00;
        }
        
        .menu-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }
        
        .menu-btn {
            padding: 8px 16px;
            background: #000;
            border: 2px solid #0f0;
            color: #0f0;
            font-size: 10px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s;
            pointer-events: auto;
            text-transform: uppercase;
            letter-spacing: 1px;
            image-rendering: pixelated;
            box-shadow: 0 0 5px #0f0;
        }
        
        .menu-btn:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 10px #0f0, 0 0 20px #0f0;
        }
        
        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            display: none;
        }
        
        .loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 30;
        }
        
        .loading-bar {
            width: 200px;
            height: 12px;
            background: #000;
            border: 2px solid #0f0;
            overflow: hidden;
            margin-top: 10px;
            box-shadow: 0 0 5px #0f0;
        }
        
        .loading-fill {
            height: 100%;
            background: #0f0;
            width: 0%;
            transition: width 0.3s;
            box-shadow: 0 0 5px #0f0;
        }
        
        .fullscreen-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            padding: 3px 6px;
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            font-size: 6px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s;
            pointer-events: auto;
            z-index: 100;
            box-shadow: 0 0 5px #0f0;
        }
        
        .fullscreen-btn:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 10px #0f0;
        }
        
        /* Damage Indicator */
        .damage-indicator {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 5;
        }
        
        .damage-flash {
            width: 100%;
            height: 100%;
            background: rgba(255, 0, 0, 0.3);
        }
        
        /* Enhanced Wave Indicator */
        .wave-indicator {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: #0f0;
            text-shadow: 0 0 5px #0f0;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px 10px;
            border: 2px solid #0f0;
            display: none;
            box-shadow: 0 0 10px #0f0;
        }
        
        /* Enhanced Save/Load UI */
        .save-load-container {
            position: absolute;
            bottom: 5px;
            left: 5px;
            display: flex;
            gap: 5px;
            z-index: 100;
        }
        
        .save-btn, .load-btn {
            padding: 3px 6px;
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            font-size: 6px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s;
            pointer-events: auto;
            text-transform: uppercase;
            box-shadow: 0 0 5px #0f0;
        }
        
        .save-btn:hover, .load-btn:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 10px #0f0;
        }
        
        .file-input {
            display: none;
        }
        
        /* Enhanced Stats Display */
        .stats-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 15px;
            background: rgba(0, 10, 0, 0.8);
            padding: 10px;
            border: 2px solid #0f0;
            box-shadow: 0 0 10px #0f0;
        }
        
        .stat-item {
            font-size: 8px;
            color: #0f0;
            display: flex;
            justify-content: space-between;
            text-shadow: 0 0 3px #0f0;
        }
        
        .stat-value {
            font-weight: bold;
        }
        
        .cinematic-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 25;
            display: none;
        }
        
        .cinematic-text {
            font-size: 18px;
            color: #f00;
            text-shadow: 0 0 5px #f00, 0 0 10px #f00;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .cinematic-subtext {
            font-size: 10px;
            color: #0f0;
            text-shadow: 0 0 3px #0f0;
            text-align: center;
        }
        
        .countdown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 25;
            display: none;
        }
        
        .countdown-text {
            font-size: 60px;
            color: #f00;
            text-shadow: 0 0 10px #f00, 0 0 20px #f00;
            margin-bottom: 15px;
        }
        
        .countdown-subtext {
            font-size: 14px;
            color: #0f0;
            text-shadow: 0 0 5px #0f0;
        }
        
        .run-time {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 14px;
            color: #0f0;
            text-shadow: 0 0 5px #0f0;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px 10px;
            border: 2px solid #0f0;
            display: none;
            box-shadow: 0 0 10px #0f0;
        }
        
        .skill-tree-btn {
            position: absolute;
            top: 5px;
            left: 5px;
            padding: 3px 6px;
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            font-size: 6px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s;
            pointer-events: auto;
            z-index: 100;
            box-shadow: 0 0 5px #0f0;
        }
        
        .skill-tree-btn:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 10px #0f0;
        }
        
        .gun-heat-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
            opacity: 0;
            transition: opacity 0.3s;
            background: radial-gradient(circle at center, rgba(0, 255, 0, 0.3) 0%, transparent 70%);
        }
        
        /* Enhanced Chat Terminal */
        .chat-terminal {
            position: absolute;
            bottom: 60px;
            left: 5px;
            width: 300px;
            height: 120px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #0f0;
            padding: 5px;
            display: flex;
            flex-direction: column;
            z-index: 50;
            pointer-events: auto;
            box-shadow: 0 0 10px #0f0;
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            font-size: 8px;
            color: #0f0;
            margin-bottom: 5px;
            border-bottom: 1px solid #0f0;
            padding-bottom: 3px;
        }
        
        .chat-input {
            background: transparent;
            border: 1px solid #0f0;
            color: #0f0;
            font-size: 8px;
            padding: 2px;
            font-family: 'Press Start 2P', monospace;
        }
        
        .chat-input:focus {
            outline: none;
            background: rgba(0, 20, 0, 0.5);
            box-shadow: 0 0 5px #0f0;
        }
        
        /* Enhanced Level Display */
        .level-container {
            position: absolute;
            top: 20px;
            left: 5px;
            font-size: 8px;
            color: #0f0;
            text-shadow: 0 0 5px #0f0;
            background: rgba(0, 0, 0, 0.8);
            padding: 3px 6px;
            border: 1px solid #0f0;
            box-shadow: 0 0 5px #0f0;
        }
        
        /* Enhanced Instructions Overlay */
        .instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 500px;
            background: rgba(0, 10, 0, 0.95);
            border: 3px solid #0f0;
            padding: 15px;
            z-index: 100;
            display: none;
            color: #0f0;
            font-size: 8px;
            line-height: 1.4;
            box-shadow: 0 0 20px #0f0;
        }
        
        .instructions h2 {
            text-align: center;
            margin-bottom: 10px;
            color: #f00;
            text-shadow: 0 0 5px #f00;
        }
        
        .instructions-btn {
            position: absolute;
            top: 5px;
            left: 60px;
            padding: 3px 6px;
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            font-size: 6px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s;
            pointer-events: auto;
            z-index: 100;
            box-shadow: 0 0 5px #0f0;
        }
        
        .instructions-btn:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 10px #0f0;
        }
        
        .close-instructions {
            position: absolute;
            top: 5px;
            right: 5px;
            padding: 2px 5px;
            background: #000;
            border: 1px solid #f00;
            color: #f00;
            font-size: 6px;
            cursor: pointer;
            box-shadow: 0 0 5px #f00;
        }
        
        .immortal-indicator {
            position: absolute;
            top: 40px;
            left: 5px;
            font-size: 8px;
            color: #0f0;
            text-shadow: 0 0 5px #0f0;
            background: rgba(0, 0, 0, 0.7);
            padding: 3px 6px;
            border: 1px solid #0f0;
            display: none;
            box-shadow: 0 0 5px #0f0;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
    <div id="gameContainer">
        <div class="loading-screen" id="loadingScreen">
            <h1 class="title">TRIOS</h1>
            <div class="subtitle">GLADIATOR DRONE SIMULATOR LOADED: YOU MAY BEGIN THE BETA TEST</div>
            <div class="subtitle">LOADING XFORC3D VR HUD CONTROL ENGINE...</div>
            <div class="loading-bar">
                <div class="loading-fill" id="loadingFill"></div>
            </div>
        </div>
        
        <canvas id="gameCanvas"></canvas>
        
        <div class="gun-heat-overlay" id="gunHeatOverlay"></div>
        
        <div class="hud">
            <div class="fps-counter" id="fpsCounter">FPS: 60</div>
            <div class="immortal-indicator" id="immortalIndicator">IMMORTAL MODE ENGAGED</div>
            
            <div class="dragon-health-container" id="dragonHealthContainer">
                <div class="dragon-health-label" id="dragonHealthLabel">DRAGON HEALTH</div>
                <div class="dragon-health-bar">
                    <div class="dragon-health-fill" id="dragonHealthFill"></div>
                    <div class="dragon-health-text">HEALTH: <span id="dragonHealthPercent">100%</span></div>
                </div>
            </div>
            
            <div class="wave-indicator" id="waveIndicator">WAVE 1: YELLOW DRAGON</div>
            
            <div class="run-time" id="runTime">RUN TIME: 00:00</div>
            
            <div class="damage-indicator" id="damageIndicator">
                <div class="damage-flash"></div>
            </div>
            
            <div class="health-container">
                <div class="health-label">PLAYER INTEGRITY</div>
                <div class="health-bar">
                    <div class="health-fill" id="healthFill"></div>
                    <div class="health-text">HEALTH: <span id="healthPercent">100%</span></div>
                </div>
            </div>
            
            <div class="level-container">
                LEVEL: <span id="playerLevel">1</span> | EXP: <span id="playerExp">0</span>
            </div>
            
            <div class="ammo-container">
                <div class="ammo-count" id="ammoCount">UNLIMITED</div>
                <div class="weapon-name">NEUROT GATLING</div>
            </div>
            
            <div class="dragon-counter">
                WAVE: <span id="waveCount">1</span>/3
            </div>
            
            <div class="heat-container">
                <div class="heat-label">GATLING HEAT</div>
                <div class="heat-bar">
                    <div class="heat-fill" id="heatFill"></div>
                    <div class="heat-text">HEAT: <span id="heatPercent">0%</span></div>
                </div>
            </div>
            
            <div class="boost-container">
                <div class="boost-label">BOOST FUEL</div>
                <div class="boost-bar">
                    <div class="boost-fill" id="boostFill"></div>
                    <div class="boost-text">BOOST: <span id="boostPercent">100%</span></div>
                </div>
            </div>
            
            <!-- Sword Drone UI -->
            <div class="sword-drone-container">
                <div class="sword-drone-label">DRONE</div>
                <div class="sword-drone-bar">
                    <div class="sword-drone-fill" id="swordDroneFill"></div>
                    <div class="sword-drone-text">COOLDOWN: <span id="swordDronePercent">100%</span></div>
                </div>
                <div class="sword-drone-status" id="swordDroneStatus">READY [R]</div>
            </div>
            
            <!-- Clean Crosshair -->
            <div class="crosshair">
                <div class="crosshair-dot"></div>
            </div>
            
            <!-- Sword Drone Target Crosshair -->
            <div class="sword-target-crosshair" id="swordTargetCrosshair"></div>
            
            <!-- Chat Terminal -->
            <div class="chat-terminal" id="chatTerminal">
                <div class="chat-messages" id="chatMessages">
                    <div>> SYSTEM: Welcome to TRIOS: DRAGON SLAYER BETA TEST</div>
                    <div>> SYSTEM: Type /help for commands</div>
                </div>
                <input type="text" class="chat-input" id="chatInput" placeholder="Type /help for commands...">
            </div>

            <div class="fullscreen-btn" id="fullscreenBtn">FULL</div>
            <div class="skill-tree-btn" id="skillTreeBtn">SKILLS</div>
            <div class="instructions-btn" id="instructionsBtn">HELP</div>
            
            <!-- Save/Load Buttons -->
            <div class="save-load-container">
                <div class="save-btn" id="saveBtn">SAVE</div>
                <div class="load-btn" id="loadBtn">LOAD</div>
                <input type="file" id="fileInput" class="file-input" accept=".json">
            </div>
        </div>
        
        <div class="cinematic-overlay" id="cinematicOverlay">
            <div class="cinematic-text" id="cinematicText">YELLOW DRAGON DEFEATED!</div>
            <div class="cinematic-subtext" id="cinematicSubtext">Orange Dragon approaches...</div>
        </div>
        
        <div class="countdown-overlay" id="countdownOverlay">
            <div class="countdown-text" id="countdownText">X</div>
            <div class="countdown-subtext">MATCH BEGINS</div>
        </div>
        
        <div class="game-over" id="gameOverScreen">
            <h1 class="title" id="gameOverTitle">VICTORY!</h1>
            <div class="subtitle" id="gameOverMessage">All dragons defeated!</div>
            
            <div class="stats-container">
                <div class="stat-item">
                    <span>RUN TIME:</span>
                    <span class="stat-value" id="statTime">00:00</span>
                </div>
                <div class="stat-item">
                    <span>DAMAGE TAKEN:</span>
                    <span class="stat-value" id="statDamage">0</span>
                </div>
                <div class="stat-item">
                    <span>DRAGONS SLAYED:</span>
                    <span class="stat-value" id="statDragons">3</span>
                </div>
                <div class="stat-item">
                    <span>FINAL LEVEL:</span>
                    <span class="stat-value" id="statLevel">1</span>
                </div>
            </div>
            
            <div class="menu-options">
                <div class="menu-btn" id="playAgainBtn">PLAY AGAIN</div>
                <div class="menu-btn" id="mainMenuBtn">MAIN MENU</div>
            </div>
        </div>
        
        <div class="menu" id="mainMenu">
            <h1 class="title">TRIOS</h1>
            <div class="subtitle">DRAGON SLAYER</div>
            <div class="subtitle">DIRECTOR'S CUT BETA TEST</div>
            
            <div class="menu-options">
                <div class="menu-btn" id="startBtn">START BATTLE</div>
                <div class="menu-btn" id="importBtn">LOAD GAME</div>
                <div class="menu-btn" id="immortalToggle">IMMORTAL: ON</div>
            </div>
        </div>
        
        <!-- Instructions Overlay -->
        <div class="instructions" id="instructions">
            <h2>X-FORCE: TRIOS - GAME GUIDE</h2>
            <div class="close-instructions" id="closeInstructions">X</div>
            
            <p><strong>STORY:</strong> You are CAPTAIN PURGE battling 3 ancient dragons in a neon colosseum. Defeat them all!</p>
            
            <p><strong>CONTROLS:</strong><br>
            WASD - Move<br>
            Mouse - Aim<br>
            Left Click - Fire Neurot Gatling<br>
            Space - Boost/Jump<br>
            Shift - Speed Boost<br>
            R - Deploy Sword Drone / Reassign Target<br>
            ESC - Pause Menu</p>
            
            <p><strong>DRAGONS:</strong><br>
            - YELLOW: Fast melee attacker<br>
            - ORANGE: Ranged fireball spammer<br>
            - RED (TRIOS): Boss with lift attack</p>
            
            <p><strong>SWORD DRONE:</strong><br>
            - Deploys a cyber lightsaber broadsword<br>
            - Attacks and parries dragons for 10 seconds<br>
            - Deals 25% of dragon's max health<br>
            - 60-second cooldown<br>
            - Target with crosshair and press R</p>
            
            <p><strong>FEATURES:</strong><br>
            - Diablo 2 style leveling (1-99)<br>
            - Immortal mode (unlimited health/ammo)<br>
            - Save/Load system<br>
            - Neon colosseum with arches</p>
            
            <p><strong>CHAT COMMANDS:</strong><br>
            /help - Show this guide<br>
            /immortal - Toggle god mode<br>
            /level - Set player level<br>
            /kill - Defeat current dragon</p>
            
            <p><strong>OPEN SOURCE:</strong> This game is designed as a template for developers to build upon. Modify and extend as needed!</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game State
        const GameState = {
            MENU: 0,
            PLAYING: 1,
            GAME_OVER: 2,
            LOADING: 3,
            WAVE_TRANSITION: 4,
            COUNTDOWN: 5,
            CINEMATIC: 6
        };
        
        let currentState = GameState.LOADING;
        let mouseSensitivity = 0.002;
        let pointerLocked = false;
        let immortalMode = true; // Default to immortal for testing
        
        // Three.js variables
        let scene, camera, renderer;
        let player, dragons = [], projectiles = [], particles = [], neurotFlames = [];
        let clock = new THREE.Clock();
        let gameStartTime = 0;
        let gameTimer = 0;
        let runTime = 0;
        let timerInterval;
        let countdownValue = 10;
        let countdownInterval;
        let frameCount = 0;
        let lastFpsUpdate = 0;
        let fps = 60;
        
        // Gatling gun variables
        let gatlingGun = null;
        let gatlingBarrels = null;
        let gatlingBarrelRotation = 0;
        let gatlingBarrelSpeed = 0;
        
        // Sword Drone variables
        let swordDrone = null;
        let swordDroneTarget = null;
        let swordDroneCooldown = 0;
        let swordDroneMaxCooldown = 60; // 60 seconds
        let swordDroneActive = false;
        let swordDroneAttackTime = 0;
        let swordDroneAttackDuration = 10; // 10 seconds
        let swordDroneDamageRate = 0.025; // 2.5% per second = 25% total
        
        // Diablo 2 style leveling system (1-99)
        const diablo2Levels = {
            1: 0, 2: 500, 3: 1500, 4: 3750, 5: 7875, 6: 14175, 7: 22680, 8: 32886, 9: 44396, 10: 57715,
            11: 72144, 12: 90180, 13: 112725, 14: 140906, 15: 176132, 16: 220165, 17: 275207, 18: 344008, 19: 430010, 20: 537513,
            21: 671891, 22: 839864, 23: 1049830, 24: 1312287, 25: 1640359, 26: 2050449, 27: 2563061, 28: 3203826, 29: 3902260, 30: 4663553,
            31: 5493363, 32: 6397855, 33: 7383752, 34: 8458374, 35: 9629723, 36: 10906488, 37: 12298162, 38: 13815086, 39: 15468534, 40: 17270791,
            41: 19235252, 42: 21376515, 43: 23710491, 44: 26254525, 45: 29027522, 46: 32050088, 47: 35344686, 48: 38935798, 49: 42850109, 50: 47116709,
            51: 51767302, 52: 56836449, 53: 62361819, 54: 68384473, 55: 74949165, 56: 82104680, 57: 89904191, 58: 98405658, 59: 107672256, 60: 117772849,
            61: 128782495, 62: 140783010, 63: 153863570, 64: 168121381, 65: 183662396, 66: 200602101, 67: 219066380, 68: 239192444, 69: 261129853, 70: 285041630,
            71: 311105466, 72: 339515048, 73: 370481492, 74: 404234916, 75: 441026148, 76: 481128591, 77: 524840254, 78: 572485967, 79: 624419793, 80: 681027665,
            81: 742730244, 82: 809986056, 83: 883294891, 84: 963201521, 85: 1050299747, 86: 1145236814, 87: 1248718217, 88: 1361512946, 89: 1484459201, 90: 1618470619,
            91: 1764543065, 92: 1923762030, 93: 2097310703, 94: 2286478756, 95: 2492671933, 96: 2717422497, 97: 2962400612, 98: 3229426756, 99: 3520485254
        };
        
        // Game stats
        const gameStats = {
            score: 0,
            currentWave: 1,
            totalWaves: 3,
            playerHealth: 100,
            maxPlayerHealth: 100,
            playerSpeed: 10,
            speedBoost: false,
            playerDamage: 100,
            // Gatling gun stats
            heat: 0,
            maxHeat: 100,
            heatPerShot: 2,
            coolingRate: 30,
            isOverheated: false,
            fireRate: 50, // ms between shots
            lastFireTime: 0,
            // Boost system
            boostActive: false,
            boostForce: 15,
            boostFuel: 100,
            maxBoostFuel: 100,
            boostConsumption: 20,
            boostRegen: 10,
            // Stats tracking
            damageTaken: 0,
            dragonsSlayed: 0,
            experience: 0,
            level: 1,
            skillPoints: 0,
            // Skills
            skills: {
                healthBoost: { level: 0, maxLevel: 5, desc: "Increases maximum health by 10% per level" },
                damageBoost: { level: 0, maxLevel: 5, desc: "Increases weapon damage by 10% per level" },
                speedBoost: { level: 0, maxLevel: 5, desc: "Increases movement speed by 5% per level" },
                heatReduction: { level: 0, maxLevel: 5, desc: "Reduces heat generation by 15% per level" },
                boostEfficiency: { level: 0, maxLevel: 5, desc: "Reduces boost fuel consumption by 15% per level" }
            }
        };
        
        // Dragon types with massive HP and proper colors
        const dragonTypes = [
            { 
                name: "Yellow Dragon", 
                color: 0xffff00, 
                health: 50000,
                damage: 25, 
                speed: 12,
                size: 0.8,
                behavior: "gimbal",
                description: "Fast gimbal attacker with neurot fireballs"
            },
            { 
                name: "Orange Dragon", 
                color: 0xff8800, 
                health: 150000,
                damage: 35, 
                speed: 8,
                size: 1.2,
                behavior: "gimbal",
                description: "Medium range gimbal with neurot fireballs"
            },
            { 
                name: "Red Dragon", 
                color: 0xff0000, 
                health: 500000,
                damage: 50, 
                speed: 6,
                size: 1.5,
                behavior: "gimbal",
                description: "Large flying gimbal with lift attack"
            }
        ];
        
        // Controls
        const controls = {
            moveForward: false,
            moveBackward: false,
            moveLeft: false,
            moveRight: false,
            fireGatling: false,
            boost: false,
            speedBoost: false,
            swordDrone: false,
            mouseX: 0,
            mouseY: 0
        };
        
        // Initialize the game
        function init() {
            document.getElementById('loadingScreen').style.display = 'flex';
            
            setupPointerLock();
            
            let loadingProgress = 0;
            const loadingInterval = setInterval(() => {
                loadingProgress += 5;
                document.getElementById('loadingFill').style.width = `${loadingProgress}%`;
                
                if (loadingProgress >= 100) {
                    clearInterval(loadingInterval);
                    document.getElementById('loadingScreen').style.display = 'none';
                    currentState = GameState.MENU;
                    
                    try {
                        scene = new THREE.Scene();
                        scene.background = new THREE.Color(0x000000);
                        scene.fog = new THREE.Fog(0x000000, 15, 100);
                        
                        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
                        
                        const canvas = document.getElementById('gameCanvas');
                        renderer = new THREE.WebGLRenderer({
                            canvas: canvas,
                            antialias: false,
                            powerPreference: "low-power"
                        });
                        renderer.setSize(window.innerWidth, window.innerHeight);
                        renderer.shadowMap.enabled = false;
                        renderer.setPixelRatio(1);
                        
                        const ambientLight = new THREE.AmbientLight(0x202020);
                        scene.add(ambientLight);
                        
                        const directionalLight = new THREE.DirectionalLight(0x00ff00, 0.5);
                        directionalLight.position.set(12, 12, 12);
                        scene.add(directionalLight);
                        
                        createWorld();
                        createPlayer();
                        createSwordDrone();
                        setupEventListeners();
                        animate();
                        
                        // Set immortal mode by default and update UI
                        immortalMode = true;
                        document.getElementById('immortalToggle').textContent = `IMMORTAL: ON`;
                        document.getElementById('immortalIndicator').style.display = 'block';
                        
                        addChatMessage("SYSTEM: Welcome to X-FORCE: TRIOS - Neon Colosseum!");
                        addChatMessage("SYSTEM: IMMORTAL MODE ENGAGED - Unlimited health & ammo");
                        addChatMessage("SYSTEM: Sword Drone ready - Press R to deploy");
                        addChatMessage("SYSTEM: Type /help for game commands");
                    } catch (error) {
                        console.error('Error initializing game:', error);
                        document.getElementById('loadingScreen').innerHTML = '<h1>Error Initializing Game</h1><p>' + error.message + '</p>';
                    }
                }
            }, 50);
        }
        
        // Set up pointer lock for seamless aiming
        function setupPointerLock() {
            const canvas = document.getElementById('gameCanvas');
            
            canvas.addEventListener('click', () => {
                if (!pointerLocked && currentState === GameState.PLAYING) {
                    canvas.requestPointerLock();
                }
            });
            
            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === canvas) {
                    pointerLocked = true;
                } else {
                    pointerLocked = false;
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                if (pointerLocked && currentState === GameState.PLAYING) {
                    controls.mouseX = e.movementX * mouseSensitivity;
                    controls.mouseY = e.movementY * mouseSensitivity;
                    
                    player.rotation.y -= controls.mouseX;
                    camera.rotation.x -= controls.mouseY;
                    
                    camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                }
            });
        }
        
        // Create the Neon Colosseum Arena
        function createWorld() {
            // Create grid floor
            createGridFloor();
            
            // Create Colosseum walls
            createColosseumWalls();
            
            // Create starfield
            createStarfield();
            
            // Create Roman arches around the colosseum
            createRomanArches();
            
            // Create central platform
            createCentralPlatform();
        }
        
        // Create grid floor
        function createGridFloor() {
            const gridSize = 100;
            const gridDivisions = 20;
            const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0x00ff00, 0x003300);
            gridHelper.rotation.x = -Math.PI / 2;
            gridHelper.position.y = 0;
            scene.add(gridHelper);
        }
        
        // Create Colosseum walls
        function createColosseumWalls() {
            const wallMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00,
                wireframe: true,
                side: THREE.DoubleSide
            });
            
            // Create outer colosseum wall
            const wallGeometry = new THREE.CylinderGeometry(50, 50, 30, 32, 1, true);
            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.position.y = 15;
            scene.add(wall);
            
            // Create upper ring
            const ringGeometry = new THREE.TorusGeometry(50, 2, 8, 32);
            const ring = new THREE.Mesh(ringGeometry, wallMaterial);
            ring.position.y = 30;
            ring.rotation.x = Math.PI / 2;
            scene.add(ring);
            
            // Create lower ring
            const lowerRing = new THREE.Mesh(ringGeometry, wallMaterial);
            lowerRing.position.y = 5;
            lowerRing.rotation.x = Math.PI / 2;
            scene.add(lowerRing);
        }
        
        // Create Roman arches around the colosseum
        function createRomanArches() {
            const archMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00,
                wireframe: true
            });
            
            // Create arches around the colosseum
            const archCount = 16;
            const radius = 48;
            
            for (let i = 0; i < archCount; i++) {
                const angle = (i / archCount) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                // Create arch column
                const columnGeometry = new THREE.CylinderGeometry(1, 1, 25, 6);
                const column = new THREE.Mesh(columnGeometry, archMaterial);
                column.position.set(x, 12.5, z);
                column.rotation.y = angle;
                scene.add(column);
                
                // Create arch top
                const archGeometry = new THREE.BoxGeometry(5, 1, 1);
                const arch = new THREE.Mesh(archGeometry, archMaterial);
                arch.position.set(x, 25, z);
                arch.rotation.y = angle;
                scene.add(arch);
            }
        }
        
        // Create central platform
        function createCentralPlatform() {
            const platformMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00,
                wireframe: true
            });
            
            // Create central platform
            const platformGeometry = new THREE.CylinderGeometry(10, 10, 1, 16);
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.position.y = 0.5;
            scene.add(platform);
            
            // Create steps around platform
            const stepGeometry = new THREE.CylinderGeometry(12, 10, 1, 16);
            const step = new THREE.Mesh(stepGeometry, platformMaterial);
            step.position.y = 0;
            scene.add(step);
        }
        
        // Create starfield
        function createStarfield() {
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({
                color: 0x00ff00,
                size: 0.5,
                sizeAttenuation: true
            });
            
            const starVertices = [];
            for (let i = 0; i < 300; i++) {
                const x = (Math.random() - 0.5) * 500;
                const y = (Math.random() - 0.5) * 500;
                const z = (Math.random() - 0.5) * 500;
                starVertices.push(x, y, z);
            }
            
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }
        
        // Create the player
        function createPlayer() {
            player = new THREE.Object3D();
            player.position.set(0, 1.7, -40);
            player.rotation.y = Math.PI;
            scene.add(player);
            
            camera.position.set(0, 1.7, 0);
            player.add(camera);
            
            createGatlingGun();
            
            player.velocity = new THREE.Vector3();
            player.isGrounded = true;
            player.isGrabbed = false;
            player.grabTime = 0;
        }
        
        // Create the Neurot Gatling Gun (Neon Green, Multi-barrel, Spinning)
        function createGatlingGun() {
            const gunGroup = new THREE.Group();
            
            // Main body - box
            const bodyGeometry = new THREE.BoxGeometry(0.4, 0.4, 1.2);
            const bodyMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00, // Neon green
                wireframe: true
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            gunGroup.add(body);
            
            // Create barrel assembly group for spinning
            const barrelGroup = new THREE.Group();
            
            // Create multiple barrels in a circle
            const barrelCount = 6;
            const barrelRadius = 0.15;
            
            for (let i = 0; i < barrelCount; i++) {
                const angle = (i / barrelCount) * Math.PI * 2;
                const x = Math.cos(angle) * barrelRadius;
                const y = Math.sin(angle) * barrelRadius;
                
                const barrelGeometry = new THREE.CylinderGeometry(0.03, 0.03, 1.0, 6);
                const barrelMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff00, // Neon green
                    wireframe: true
                });
                const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
                barrel.position.set(x, y, 0);
                barrel.rotation.x = Math.PI / 2;
                barrelGroup.add(barrel);
            }
            
            // Position barrel group at the front of the gun
            barrelGroup.position.z = 0.8;
            gunGroup.add(barrelGroup);
            
            // Store reference to barrel group for animation
            gatlingBarrels = barrelGroup;
            
            // Ammo drum
            const drumGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.4, 8);
            const drumMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00, // Neon green
                wireframe: true
            });
            const drum = new THREE.Mesh(drumGeometry, drumMaterial);
            drum.position.set(0, 0, -0.2);
            drum.rotation.x = Math.PI / 2;
            gunGroup.add(drum);
            
            // Handle
            const handleGeometry = new THREE.BoxGeometry(0.15, 0.6, 0.15);
            const handleMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00, // Neon green
                wireframe: true
            });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.set(0, -0.4, 0.2);
            gunGroup.add(handle);
            
            // Trigger
            const triggerGeometry = new THREE.BoxGeometry(0.06, 0.1, 0.06);
            const triggerMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00, // Neon green
                wireframe: true
            });
            const trigger = new THREE.Mesh(triggerGeometry, triggerMaterial);
            trigger.position.set(0, -0.25, 0.5);
            gunGroup.add(trigger);
            
            // Position gun lower in the HUD view
            gunGroup.position.set(0.3, -0.4, -0.8);
            gunGroup.rotation.y = Math.PI;
            camera.add(gunGroup);
            
            // Store reference to the gun
            gatlingGun = gunGroup;
        }
        
        // Create Sword Drone (Neon Green Cyber Lightsaber)
        function createSwordDrone() {
            const droneGroup = new THREE.Group();
            
            // Drone body - small sphere
            const bodyGeometry = new THREE.SphereGeometry(0.3, 8, 6);
            const bodyMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00,
                wireframe: true
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            droneGroup.add(body);
            
            // Cyber lightsaber blade - large glowing rectangle
            const bladeGeometry = new THREE.BoxGeometry(0.1, 0.1, 3.0);
            const bladeMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00,
                wireframe: true
            });
            const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
            blade.position.z = 1.5;
            droneGroup.add(blade);
            
            // Blade glow effect - larger transparent blade
            const glowGeometry = new THREE.BoxGeometry(0.2, 0.2, 3.2);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00,
                transparent: true,
                opacity: 0.3,
                wireframe: true
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.z = 1.5;
            droneGroup.add(glow);
            
            // Sword hilt
            const hiltGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.5);
            const hiltMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00,
                wireframe: true
            });
            const hilt = new THREE.Mesh(hiltGeometry, hiltMaterial);
            hilt.position.z = 0.25;
            droneGroup.add(hilt);
            
            // Position drone above player initially
            droneGroup.position.set(0, 3, 0);
            droneGroup.visible = false;
            
            scene.add(droneGroup);
            swordDrone = droneGroup;
        }
        
        // Create a dragon (Simplified Cartoon Style)
        function createDragon(position, dragonType) {
            const dragonGroup = new THREE.Group();
            
            // Body - simple sphere
            const bodyGeometry = new THREE.SphereGeometry(1, 8, 6);
            const bodyMaterial = new THREE.MeshBasicMaterial({ 
                color: dragonType.color,
                wireframe: true
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            dragonGroup.add(body);
            
            // Head - smaller sphere
            const headGeometry = new THREE.SphereGeometry(0.6, 6, 4);
            const headMaterial = new THREE.MeshBasicMaterial({ 
                color: dragonType.color,
                wireframe: true
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.z = -1.5;
            dragonGroup.add(head);
            
            // Tail - simple cone
            const tailGeometry = new THREE.ConeGeometry(0.3, 2, 4);
            const tailMaterial = new THREE.MeshBasicMaterial({ 
                color: dragonType.color,
                wireframe: true
            });
            const tail = new THREE.Mesh(tailGeometry, tailMaterial);
            tail.position.z = 1.5;
            tail.rotation.x = Math.PI / 2;
            dragonGroup.add(tail);
            
            // Wings - simple triangles
            const wingGeometry = new THREE.ConeGeometry(0.8, 1.5, 3);
            const wingMaterial = new THREE.MeshBasicMaterial({ 
                color: dragonType.color,
                wireframe: true
            });
            
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(-1, 0, 0);
            leftWing.rotation.z = Math.PI / 2;
            leftWing.rotation.y = Math.PI / 6;
            dragonGroup.add(leftWing);
            
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(1, 0, 0);
            rightWing.rotation.z = -Math.PI / 2;
            rightWing.rotation.y = -Math.PI / 6;
            dragonGroup.add(rightWing);
            
            dragonGroup.wings = [leftWing, rightWing];
            
            // Legs - simple cylinders
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 4);
            const legMaterial = new THREE.MeshBasicMaterial({ 
                color: dragonType.color,
                wireframe: true
            });
            
            // Front legs
            const frontLeftLeg = new THREE.Mesh(legGeometry, legMaterial);
            frontLeftLeg.position.set(-0.5, -0.8, -0.8);
            dragonGroup.add(frontLeftLeg);
            
            const frontRightLeg = new THREE.Mesh(legGeometry, legMaterial);
            frontRightLeg.position.set(0.5, -0.8, -0.8);
            dragonGroup.add(frontRightLeg);
            
            // Back legs
            const backLeftLeg = new THREE.Mesh(legGeometry, legMaterial);
            backLeftLeg.position.set(-0.5, -0.8, 0.8);
            dragonGroup.add(backLeftLeg);
            
            const backRightLeg = new THREE.Mesh(legGeometry, legMaterial);
            backRightLeg.position.set(0.5, -0.8, 0.8);
            dragonGroup.add(backRightLeg);
            
            dragonGroup.position.copy(position);
            
            // Scale based on dragon type
            let scale = dragonType.size;
            dragonGroup.scale.set(scale, scale, scale);
            
            // Dragon properties
            dragonGroup.health = dragonType.health;
            dragonGroup.maxHealth = dragonType.health;
            dragonGroup.speed = dragonType.speed;
            dragonGroup.target = player;
            dragonGroup.lastFire = 0;
            dragonGroup.fireRate = 800; // ms between shots
            dragonGroup.damage = dragonType.damage;
            dragonGroup.dragonType = dragonType;
            dragonGroup.id = dragons.length;
            dragonGroup.isFlyingIn = true;
            dragonGroup.flyInProgress = 0;
            dragonGroup.flyInDuration = 3000;
            dragonGroup.startPosition = new THREE.Vector3(position.x, 50, position.z);
            dragonGroup.targetPosition = position.clone();
            
            // Special abilities
            dragonGroup.lastLift = 0;
            dragonGroup.liftCooldown = 15000;
            
            // Movement properties
            dragonGroup.orbitRadius = 15 + Math.random() * 10;
            dragonGroup.orbitSpeed = 0.5 + Math.random() * 0.5;
            dragonGroup.orbitAngle = Math.random() * Math.PI * 2;
            dragonGroup.heightOffset = 5 + Math.random() * 10;
            dragonGroup.wingFlapSpeed = 2 + Math.random();
            
            scene.add(dragonGroup);
            dragons.push(dragonGroup);
            
            // Update dragon health display
            updateDragonHealthDisplay(dragonGroup);
            
            return dragonGroup;
        }
        
        // Create neurot flame effect
        function createNeurotFlame(position, direction, color, size, duration) {
            const flameGroup = new THREE.Group();
            flameGroup.position.copy(position);
            
            // Create multiple layers for the flame effect
            for (let i = 0; i < 5; i++) {
                const flameGeometry = new THREE.SphereGeometry(size * (1 - i * 0.1), 8, 6);
                const flameMaterial = new THREE.MeshBasicMaterial({ 
                    color: color,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.7 - i * 0.1
                });
                const flame = new THREE.Mesh(flameGeometry, flameMaterial);
                flameGroup.add(flame);
            }
            
            flameGroup.userData = {
                velocity: direction.clone().multiplyScalar(15),
                lifetime: 0,
                maxLifetime: duration,
                color: color,
                size: size
            };
            
            scene.add(flameGroup);
            neurotFlames.push(flameGroup);
            
            return flameGroup;
        }
        
        // Update neurot flames
        function updateNeurotFlames(delta) {
            for (let i = neurotFlames.length - 1; i >= 0; i--) {
                const flame = neurotFlames[i];
                
                flame.position.add(flame.userData.velocity.clone().multiplyScalar(delta));
                flame.userData.lifetime += delta * 1000;
                
                // Update opacity based on lifetime
                const lifetimePercent = flame.userData.lifetime / flame.userData.maxLifetime;
                flame.children.forEach(child => {
                    child.material.opacity = (0.7 - lifetimePercent * 0.7) * (1 - child.userData?.layer * 0.1 || 1);
                });
                
                // Add rotation for visual effect
                flame.rotation.y += delta * 2;
                flame.rotation.x += delta * 1.5;
                
                if (flame.userData.lifetime > flame.userData.maxLifetime) {
                    scene.remove(flame);
                    neurotFlames.splice(i, 1);
                }
            }
        }
        
        // Start the game
        function startGame() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('runTime').style.display = 'none';
            
            // Reset game stats
            gameStats.score = 0;
            gameStats.currentWave = 1;
            gameStats.playerHealth = 100;
            gameStats.maxPlayerHealth = 100;
            gameStats.playerSpeed = 10;
            gameStats.playerDamage = 100;
            gameStats.speedBoost = false;
            // Reset gatling gun stats
            gameStats.heat = 0;
            gameStats.isOverheated = false;
            gameStats.lastFireTime = 0;
            // Reset boost system
            gameStats.boostActive = false;
            gameStats.boostFuel = 100;
            // Reset stats
            gameStats.damageTaken = 0;
            gameStats.dragonsSlayed = 0;
            gameStats.experience = 0;
            gameStats.level = 1;
            gameStats.skillPoints = 0;
            
            // Reset sword drone
            swordDroneCooldown = 0;
            swordDroneActive = false;
            swordDroneTarget = null;
            swordDrone.visible = false;
            document.getElementById('swordTargetCrosshair').style.display = 'none';
            updateSwordDroneUI();
            
            // Reset player position
            player.position.set(0, 1.7, -40);
            player.rotation.y = Math.PI;
            player.velocity.set(0, 0, 0);
            player.isGrabbed = false;
            player.grabTime = 0;
            
            // Clear existing entities
            clearEntities();
            
            // Update displays
            updateHealthBar();
            updateBoostBar();
            updateDragonCounter();
            updateLevelDisplay();
            
            // Start countdown
            startCountdown();
            
            addChatMessage("BATTLE: Match starting! Defeat all 3 dragons!");
            addChatMessage("SWORD DRONE: Ready to deploy - Press R to target dragons!");
        }
        
        // Start Roman numeral countdown
        function startCountdown() {
            currentState = GameState.COUNTDOWN;
            countdownValue = 10;
            document.getElementById('countdownOverlay').style.display = 'flex';
            updateCountdownDisplay();
            
            countdownInterval = setInterval(() => {
                countdownValue--;
                updateCountdownDisplay();
                
                if (countdownValue <= 0) {
                    clearInterval(countdownInterval);
                    document.getElementById('countdownOverlay').style.display = 'none';
                    currentState = GameState.PLAYING;
                    
                    // Start first wave
                    startWave(1);
                    
                    // Start timer
                    gameStartTime = performance.now();
                    runTime = 0;
                    clearInterval(timerInterval);
                    timerInterval = setInterval(() => {
                        if (currentState === GameState.PLAYING) {
                            runTime++;
                            updateRunTime();
                        }
                    }, 1000);
                    
                    document.getElementById('runTime').style.display = 'block';
                    addChatMessage("BATTLE: Yellow Dragon approaches! Watch for its fireballs!");
                }
            }, 1000);
        }
        
        // Update countdown display with Roman numerals
        function updateCountdownDisplay() {
            const romanNumerals = ["X", "IX", "VIII", "VII", "VI", "V", "IV", "III", "II", "I", "0"];
            document.getElementById('countdownText').textContent = romanNumerals[countdownValue] || countdownValue.toString();
        }
        
        // Update run time display
        function updateRunTime() {
            const minutes = Math.floor(runTime / 60);
            const seconds = runTime % 60;
            document.getElementById('runTime').textContent = `RUN TIME: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        // Start a wave
        function startWave(waveNumber) {
            gameStats.currentWave = waveNumber;
            updateDragonCounter();
            
            // Show wave indicator
            const waveIndicator = document.getElementById('waveIndicator');
            waveIndicator.textContent = `WAVE ${waveNumber}: ${dragonTypes[waveNumber-1].name.toUpperCase()}`;
            waveIndicator.style.display = 'block';
            
            setTimeout(() => {
                waveIndicator.style.display = 'none';
            }, 3000);
            
            // Create the dragon for this wave
            let position;
            if (waveNumber === 1) {
                position = new THREE.Vector3(0, 0, 30);
            } else if (waveNumber === 2) {
                position = new THREE.Vector3(0, 15, 0);
            } else {
                position = new THREE.Vector3(0, 25, -30);
            }
            
            createDragon(position, dragonTypes[waveNumber-1]);
            
            // For wave 3, revive previous dragons as minions
            if (waveNumber === 3) {
                addChatMessage("TRIOS: The Red Dragon awakens with its minions!");
                createDragon(new THREE.Vector3(-20, 0, 20), dragonTypes[0]); // Yellow minion
                createDragon(new THREE.Vector3(20, 15, 20), dragonTypes[1]); // Orange minion
            }
        }
        
        // Clear all entities
        function clearEntities() {
            dragons.forEach(dragon => {
                scene.remove(dragon);
            });
            dragons = [];
            projectiles.forEach(projectile => scene.remove(projectile));
            projectiles = [];
            particles.forEach(particle => scene.remove(particle));
            particles = [];
            neurotFlames.forEach(flame => scene.remove(flame));
            neurotFlames = [];
            
            // Hide dragon health bar
            document.getElementById('dragonHealthContainer').style.display = 'none';
        }
        
        // Update dragon counter
        function updateDragonCounter() {
            document.getElementById('waveCount').textContent = gameStats.currentWave;
        }
        
        // Update dragon health display
        function updateDragonHealthDisplay(dragon) {
            const healthPercent = (dragon.health / dragon.maxHealth) * 100;
            document.getElementById('dragonHealthFill').style.width = `${healthPercent}%`;
            document.getElementById('dragonHealthPercent').textContent = `${Math.round(healthPercent)}%`;
            document.getElementById('dragonHealthLabel').textContent = `${dragon.dragonType.name.toUpperCase()} HEALTH`;
            document.getElementById('dragonHealthContainer').style.display = 'block';
        }
        
        // Update health bar
        function updateHealthBar() {
            const healthPercent = (gameStats.playerHealth / gameStats.maxPlayerHealth) * 100;
            document.getElementById('healthFill').style.width = `${healthPercent}%`;
            document.getElementById('healthPercent').textContent = `${Math.round(healthPercent)}%`;
        }
        
        // Update boost bar
        function updateBoostBar() {
            const boostPercent = (gameStats.boostFuel / gameStats.maxBoostFuel) * 100;
            document.getElementById('boostFill').style.width = `${boostPercent}%`;
            document.getElementById('boostPercent').textContent = `${Math.round(boostPercent)}%`;
        }
        
        // Update level display
        function updateLevelDisplay() {
            document.getElementById('playerLevel').textContent = gameStats.level;
            document.getElementById('playerExp').textContent = gameStats.experience;
        }
        
        // Update sword drone UI
        function updateSwordDroneUI() {
            const cooldownPercent = (swordDroneCooldown / swordDroneMaxCooldown) * 100;
            document.getElementById('swordDroneFill').style.width = `${100 - cooldownPercent}%`;
            document.getElementById('swordDronePercent').textContent = `${Math.round(100 - cooldownPercent)}%`;
            
            if (swordDroneCooldown > 0) {
                document.getElementById('swordDroneStatus').textContent = `COOLDOWN: ${Math.ceil(swordDroneCooldown)}s`;
            } else if (swordDroneActive) {
                document.getElementById('swordDroneStatus').textContent = `ACTIVE: ${Math.ceil(swordDroneAttackDuration - swordDroneAttackTime)}s`;
            } else {
                document.getElementById('swordDroneStatus').textContent = "READY [R]";
            }
        }
        
        // Set up event listeners
        function setupEventListeners() {
            // Keyboard events
            document.addEventListener('keydown', (e) => {
                if (currentState !== GameState.PLAYING) return;
                
                switch(e.code) {
                    case 'KeyW': controls.moveForward = true; break;
                    case 'KeyS': controls.moveBackward = true; break;
                    case 'KeyA': controls.moveLeft = true; break;
                    case 'KeyD': controls.moveRight = true; break;
                    case 'Space': 
                        controls.boost = true;
                        break;
                    case 'ShiftLeft':
                    case 'ShiftRight':
                        controls.speedBoost = true;
                        break;
                    case 'KeyR':
                        if (!controls.swordDrone) {
                            controls.swordDrone = true;
                            activateSwordDrone();
                        }
                        break;
                    case 'Escape': 
                        if (currentState === GameState.PLAYING) {
                            togglePauseMenu();
                        }
                        break;
                    case 'Enter':
                        if (document.activeElement !== document.getElementById('chatInput')) {
                            document.getElementById('chatInput').focus();
                        }
                        break;
                }
            });
            
            document.addEventListener('keyup', (e) => {
                switch(e.code) {
                    case 'KeyW': controls.moveForward = false; break;
                    case 'KeyS': controls.moveBackward = false; break;
                    case 'KeyA': controls.moveLeft = false; break;
                    case 'KeyD': controls.moveRight = false; break;
                    case 'Space': 
                        controls.boost = false;
                        break;
                    case 'ShiftLeft':
                    case 'ShiftRight':
                        controls.speedBoost = false;
                        break;
                    case 'KeyR':
                        controls.swordDrone = false;
                        break;
                }
            });
            
            // Mouse events
            document.addEventListener('mousedown', (e) => {
                if (currentState === GameState.PLAYING && pointerLocked) {
                    if (e.button === 0) {
                        controls.fireGatling = true;
                    }
                }
            });
            
            document.addEventListener('mouseup', (e) => {
                if (e.button === 0) {
                    controls.fireGatling = false;
                }
            });
            
            // Prevent context menu on right click
            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
            
            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Fullscreen button
            document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);
            
            // Skill tree button
            document.getElementById('skillTreeBtn').addEventListener('click', openSkillTree);
            
            // Instructions button
            document.getElementById('instructionsBtn').addEventListener('click', showInstructions);
            document.getElementById('closeInstructions').addEventListener('click', hideInstructions);
            
            // UI events
            document.getElementById('startBtn').addEventListener('click', startGame);
            document.getElementById('playAgainBtn').addEventListener('click', startGame);
            document.getElementById('mainMenuBtn').addEventListener('click', () => {
                document.getElementById('gameOverScreen').style.display = 'none';
                document.getElementById('mainMenu').style.display = 'flex';
                currentState = GameState.MENU;
                clearInterval(timerInterval);
            });
            
            // Immortal mode toggle
            document.getElementById('immortalToggle').addEventListener('click', toggleImmortalMode);
            
            // Save/Load events
            document.getElementById('saveBtn').addEventListener('click', exportSaveData);
            document.getElementById('loadBtn').addEventListener('click', () => {
                document.getElementById('fileInput').click();
            });
            document.getElementById('fileInput').addEventListener('change', importSaveData);
            
            document.getElementById('importBtn').addEventListener('click', () => {
                document.getElementById('fileInput').click();
            });
            
            // Chat input
            document.getElementById('chatInput').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    processChatCommand();
                }
            });
        }
        
        // Toggle fullscreen
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                requestFullscreen();
            } else {
                exitFullscreen();
            }
        }
        
        // Request fullscreen
        function requestFullscreen() {
            const elem = document.documentElement;
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.webkitRequestFullscreen) {
                elem.webkitRequestFullscreen();
            } else if (elem.msRequestFullscreen) {
                elem.msRequestFullscreen();
            }
        }
        
        // Exit fullscreen
        function exitFullscreen() {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
        }
        
        // Toggle pause menu
        function togglePauseMenu() {
            if (currentState === GameState.PLAYING) {
                document.getElementById('mainMenu').style.display = 'flex';
                currentState = GameState.MENU;
            } else if (currentState === GameState.MENU) {
                document.getElementById('mainMenu').style.display = 'none';
                currentState = GameState.PLAYING;
            }
        }
        
        // Toggle immortal mode
        function toggleImmortalMode() {
            immortalMode = !immortalMode;
            document.getElementById('immortalToggle').textContent = `IMMORTAL: ${immortalMode ? 'ON' : 'OFF'}`;
            document.getElementById('immortalIndicator').style.display = immortalMode ? 'block' : 'none';
            addChatMessage(`SYSTEM: Immortal mode ${immortalMode ? 'ENGAGED' : 'deactivated'}`);
            
            if (immortalMode) {
                // Set unlimited health and ammo
                gameStats.playerHealth = gameStats.maxPlayerHealth;
                gameStats.heat = 0;
                gameStats.isOverheated = false;
                updateHealthBar();
                updateGunHeatVisual();
            }
        }
        
        // Open skill tree
        function openSkillTree() {
            addChatMessage("SYSTEM: Skill tree - Coming in next update!");
        }
        
        // Show instructions
        function showInstructions() {
            document.getElementById('instructions').style.display = 'block';
        }
        
        // Hide instructions
        function hideInstructions() {
            document.getElementById('instructions').style.display = 'none';
        }
        
        // Add message to chat
        function addChatMessage(message) {
            const chatMessages = document.getElementById('chatMessages');
            const messageElement = document.createElement('div');
            messageElement.textContent = `> ${message}`;
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        // Process chat commands
        function processChatCommand() {
            const input = document.getElementById('chatInput');
            const command = input.value.trim();
            input.value = '';
            
            if (!command) return;
            
            addChatMessage(`PLAYER: ${command}`);
            
            if (command === '/help') {
                showInstructions();
            } else if (command === '/immortal') {
                toggleImmortalMode();
            } else if (command.startsWith('/level ')) {
                const level = parseInt(command.split(' ')[1]);
                if (level >= 1 && level <= 99) {
                    gameStats.level = level;
                    gameStats.experience = diablo2Levels[level] || 0;
                    updateLevelDisplay();
                    addChatMessage(`SYSTEM: Level set to ${level}`);
                }
            } else if (command === '/kill') {
                if (dragons.length > 0) {
                    dragons[0].health = 0;
                    dragonDefeated(dragons[0]);
                    addChatMessage("SYSTEM: Current dragon defeated!");
                }
            } else {
                addChatMessage("SYSTEM: Unknown command. Type /help for commands.");
            }
        }
        
        // Activate Sword Drone
        function activateSwordDrone() {
            if (swordDroneCooldown > 0) {
                addChatMessage("SWORD DRONE: Still on cooldown!");
                return;
            }
            
            if (swordDroneActive) {
                // If already active, reassign target
                assignSwordDroneTarget();
                return;
            }
            
            // Find a target dragon
            assignSwordDroneTarget();
            
            if (swordDroneTarget) {
                swordDroneActive = true;
                swordDroneAttackTime = 0;
                swordDrone.visible = true;
                
                // Position drone near player initially
                swordDrone.position.copy(player.position);
                swordDrone.position.y += 3;
                
                addChatMessage(`SWORD DRONE: Deployed! Targeting ${swordDroneTarget.dragonType.name}!`);
                addChatMessage(`SWORD DRONE: Will attack for 10 seconds, dealing 25% damage!`);
            } else {
                addChatMessage("SWORD DRONE: No dragon in sight to target!");
            }
        }
        
        // Assign Sword Drone target
        function assignSwordDroneTarget() {
            const raycaster = new THREE.Raycaster();
            const cameraWorldPosition = new THREE.Vector3();
            camera.getWorldPosition(cameraWorldPosition);
            
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            
            raycaster.set(cameraWorldPosition, direction);
            
            // Check for intersections with dragons
            const intersects = raycaster.intersectObjects(dragons, true);
            
            if (intersects.length > 0) {
                const dragon = intersects[0].object.parent;
                swordDroneTarget = dragon;
                
                // Show target crosshair
                document.getElementById('swordTargetCrosshair').style.display = 'block';
                updateSwordTargetCrosshair();
                
                addChatMessage(`SWORD DRONE: Target locked - ${dragon.dragonType.name}!`);
            } else if (dragons.length > 0) {
                // If no dragon in crosshair, target the closest dragon
                let closestDragon = null;
                let closestDistance = Infinity;
                
                dragons.forEach(dragon => {
                    const distance = cameraWorldPosition.distanceTo(dragon.position);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestDragon = dragon;
                    }
                });
                
                swordDroneTarget = closestDragon;
                
                // Show target crosshair
                document.getElementById('swordTargetCrosshair').style.display = 'block';
                updateSwordTargetCrosshair();
                
                addChatMessage(`SWORD DRONE: Target locked - ${closestDragon.dragonType.name}!`);
            } else {
                swordDroneTarget = null;
                document.getElementById('swordTargetCrosshair').style.display = 'none';
                addChatMessage("SWORD DRONE: No dragons available to target!");
            }
        }
        
        // Update Sword Drone target crosshair position
        function updateSwordTargetCrosshair() {
            if (!swordDroneTarget) return;
            
            const targetPosition = swordDroneTarget.position.clone();
            const projectedPosition = targetPosition.project(camera);
            
            const x = (projectedPosition.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-projectedPosition.y * 0.5 + 0.5) * window.innerHeight;
            
            document.getElementById('swordTargetCrosshair').style.left = `${x}px`;
            document.getElementById('swordTargetCrosshair').style.top = `${y}px`;
        }
        
        // Update Sword Drone
        function updateSwordDrone(delta) {
            if (!swordDroneActive || !swordDroneTarget) return;
            
            swordDroneAttackTime += delta;
            
            // Move drone toward target with some dynamic movement
            const targetPosition = swordDroneTarget.position.clone();
            targetPosition.y += 2; // Position above the dragon
            
            const direction = new THREE.Vector3();
            direction.subVectors(targetPosition, swordDrone.position).normalize();
            
            // Move toward target
            swordDrone.position.add(direction.multiplyScalar(10 * delta));
            
            // Look at target
            swordDrone.lookAt(swordDroneTarget.position);
            
            // Add some rotation for visual effect
            swordDrone.rotation.z += delta * 5;
            
            // Deal damage over time
            if (swordDroneAttackTime >= 1) {
                const damage = swordDroneTarget.maxHealth * swordDroneDamageRate;
                swordDroneTarget.health -= damage;
                
                // Create hit effect
                createHitEffect(swordDroneTarget.position, 0x00ff00);
                
                // Update dragon health display
                updateDragonHealthDisplay(swordDroneTarget);
                
                swordDroneAttackTime = 0;
                
                // Check if dragon is defeated
                if (swordDroneTarget.health <= 0) {
                    dragonDefeated(swordDroneTarget);
                    swordDroneTarget = null;
                    swordDroneActive = false;
                    swordDrone.visible = false;
                    document.getElementById('swordTargetCrosshair').style.display = 'none';
                    swordDroneCooldown = swordDroneMaxCooldown;
                    updateSwordDroneUI();
                    addChatMessage("SWORD DRONE: Target eliminated! Returning to base.");
                    return;
                }
            }
            
            // Check if attack duration is over
            if (swordDroneAttackTime >= swordDroneAttackDuration) {
                swordDroneActive = false;
                swordDrone.visible = false;
                document.getElementById('swordTargetCrosshair').style.display = 'none';
                swordDroneCooldown = swordDroneMaxCooldown;
                updateSwordDroneUI();
                addChatMessage("SWORD DRONE: Attack complete! Returning to base.");
            }
        }
        
        // Update Sword Drone cooldown
        function updateSwordDroneCooldown(delta) {
            if (swordDroneCooldown > 0) {
                swordDroneCooldown -= delta;
                if (swordDroneCooldown < 0) swordDroneCooldown = 0;
                updateSwordDroneUI();
            }
        }
        
        // Fire neurot gatling cannon from camera position
        function fireGatlingCannon() {
            if (currentState !== GameState.PLAYING) return;
            
            const now = Date.now();
            
            // Check fire rate
            if (now - gameStats.lastFireTime < gameStats.fireRate) return;
            
            gameStats.lastFireTime = now;
            
            // In immortal mode, no heat buildup or overheating
            if (!immortalMode) {
                gameStats.heat += gameStats.heatPerShot;
                
                // Update gun heat visual
                updateGunHeatVisual();
                
                // Check for overheating
                if (gameStats.heat >= gameStats.maxHeat) {
                    gameStats.heat = gameStats.maxHeat;
                    gameStats.isOverheated = true;
                    addChatMessage("WEAPON: Gatling cannon overheated! Cooling down...");
                    
                    // Auto-cool after 3 seconds
                    setTimeout(() => {
                        gameStats.isOverheated = false;
                        addChatMessage("WEAPON: Gatling cannon ready!");
                    }, 3000);
                }
            }
            
            // Set barrel rotation speed when firing
            gatlingBarrelSpeed = 20;
            
            // Quake-style hitscan with raycasting FROM CAMERA
            const raycaster = new THREE.Raycaster();
            
            // Get camera position and direction
            const cameraWorldPosition = new THREE.Vector3();
            camera.getWorldPosition(cameraWorldPosition);
            
            // Get camera direction
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            
            // Add slight spread based on heat (if not immortal)
            const heatSpread = immortalMode ? 0 : (gameStats.heat / gameStats.maxHeat) * 0.05;
            direction.x += (Math.random() - 0.5) * heatSpread;
            direction.y += (Math.random() - 0.5) * heatSpread;
            direction.z += (Math.random() - 0.5) * heatSpread;
            direction.normalize();
            
            raycaster.set(cameraWorldPosition, direction);
            
            // Check for intersections with dragons
            const intersects = raycaster.intersectObjects(dragons, true);
            
            if (intersects.length > 0) {
                const dragon = intersects[0].object.parent; // Get the dragon group
                
                // Calculate damage (Quake-style with distance falloff)
                const distance = cameraWorldPosition.distanceTo(dragon.position);
                const damageFalloff = Math.max(0.5, 1 - (distance / 100));
                const damage = gameStats.playerDamage * damageFalloff;
                
                dragon.health -= damage;
                
                // Create hit effect
                createHitEffect(intersects[0].point, 0x00ff00); // Neon green hit effect
                
                // Add to score
                gameStats.score += damage;
                
                // Update dragon health display
                updateDragonHealthDisplay(dragon);
                
                if (dragon.health <= 0) {
                    dragonDefeated(dragon);
                }
            } else {
                // Create tracer effect for missed shots
                createTracerEffect(cameraWorldPosition, direction, 0x00ff00); // Neon green tracer
            }
            
            // Create muzzle flash at camera position
            createMuzzleFlash(cameraWorldPosition, direction, 0x00ff00, 3); // Neon green muzzle flash
        }
        
        // Update gun heat visual
        function updateGunHeatVisual() {
            const heatPercent = gameStats.heat / gameStats.maxHeat;
            const heatOverlay = document.getElementById('gunHeatOverlay');
            
            if (heatPercent > 0.7) {
                heatOverlay.style.opacity = (heatPercent - 0.7) * 3.33;
            } else {
                heatOverlay.style.opacity = 0;
            }
            
            // Update heat bar
            document.getElementById('heatFill').style.width = `${heatPercent * 100}%`;
            document.getElementById('heatPercent').textContent = `${Math.round(heatPercent * 100)}%`;
            
            // Update ammo display
            const ammoDisplay = document.getElementById('ammoCount');
            if (gameStats.isOverheated) {
                ammoDisplay.textContent = "OVERHEAT";
                ammoDisplay.style.color = '#ff0000';
            } else {
                ammoDisplay.textContent = immortalMode ? "INF" : "READY";
                ammoDisplay.style.color = '#0f0';
            }
        }
        
        // Update gatling gun animation
        function updateGatlingGun(delta) {
            if (!gatlingBarrels) return;
            
            // Rotate barrels when firing
            if (gatlingBarrelSpeed > 0) {
                gatlingBarrelRotation += gatlingBarrelSpeed * delta;
                gatlingBarrels.rotation.z = gatlingBarrelRotation;
                
                // Gradually slow down when not firing
                if (!controls.fireGatling) {
                    gatlingBarrelSpeed = Math.max(0, gatlingBarrelSpeed - 40 * delta);
                }
            }
            
            // Add slight weapon sway for more immersive feel
            if (currentState === GameState.PLAYING) {
                const time = Date.now() * 0.001;
                const swayAmount = 0.02;
                
                if (gatlingGun) {
                    gatlingGun.position.x = 0.3 + Math.sin(time * 2) * swayAmount * 0.5;
                    gatlingGun.position.y = -0.4 + Math.cos(time * 1.5) * swayAmount;
                }
            }
        }
        
        // Create muzzle flash effect
        function createMuzzleFlash(position, direction, color, count) {
            for (let i = 0; i < count; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.05, 4, 4);
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: color
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(position);
                
                // Random direction with forward bias
                const angle1 = (Math.random() - 0.5) * Math.PI / 8;
                const angle2 = (Math.random() - 0.5) * Math.PI / 8;
                const speed = 3 + Math.random() * 3;
                
                particle.velocity = direction.clone()
                    .applyAxisAngle(new THREE.Vector3(0, 1, 0), angle1)
                    .applyAxisAngle(new THREE.Vector3(1, 0, 0), angle2)
                    .multiplyScalar(speed);
                
                particle.lifetime = 0.1 + Math.random() * 0.1;
                
                scene.add(particle);
                particles.push(particle);
            }
        }
        
        // Create hit effect
        function createHitEffect(position, color) {
            const particleGeometry = new THREE.SphereGeometry(0.1, 4, 4);
            const particleMaterial = new THREE.MeshBasicMaterial({ 
                color: color
            });
            
            for (let i = 0; i < 5; i++) {
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(position);
                
                // Random direction
                const angle1 = Math.random() * Math.PI * 2;
                const angle2 = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 3;
                
                particle.velocity = new THREE.Vector3(
                    Math.sin(angle1) * Math.cos(angle2) * speed,
                    Math.sin(angle1) * Math.sin(angle2) * speed,
                    Math.cos(angle1) * speed
                );
                
                particle.lifetime = 0.5 + Math.random() * 0.5;
                
                scene.add(particle);
                particles.push(particle);
            }
        }
        
        // Create explosion effect
        function createExplosion(position, size, color, count) {
            for (let i = 0; i < count; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1, 4, 4);
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: color
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(position);
                
                // Random direction
                const angle1 = Math.random() * Math.PI * 2;
                const angle2 = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 3;
                
                particle.velocity = new THREE.Vector3(
                    Math.sin(angle1) * Math.cos(angle2) * speed,
                    Math.sin(angle1) * Math.sin(angle2) * speed,
                    Math.cos(angle1) * speed
                );
                
                particle.lifetime = 0.5 + Math.random() * 0.5;
                
                scene.add(particle);
                particles.push(particle);
            }
        }
        
        // Create tracer effect
        function createTracerEffect(start, direction, color) {
            const length = 50;
            const end = start.clone().add(direction.clone().multiplyScalar(length));
            
            const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
            const material = new THREE.LineBasicMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.7
            });
            
            const tracer = new THREE.Line(geometry, material);
            scene.add(tracer);
            
            // Remove tracer after a short time
            setTimeout(() => {
                scene.remove(tracer);
            }, 100);
        }
        
        // Create dragon projectile with neurot flame effect
        function createDragonProjectile(dragon) {
            const direction = new THREE.Vector3();
            direction.subVectors(player.position, dragon.position).normalize();
            
            // Add slight randomness to direction
            direction.x += (Math.random() - 0.5) * 0.2;
            direction.y += (Math.random() - 0.5) * 0.2;
            direction.z += (Math.random() - 0.5) * 0.2;
            direction.normalize();
            
            // Create neurot flame effect for dragon's breath
            createNeurotFlame(
                dragon.position, 
                direction, 
                dragon.dragonType.color, 
                0.8, 
                2000
            );
            
            // Create projectile for collision detection
            const projectileGeometry = new THREE.SphereGeometry(0.5, 6, 6);
            const projectileMaterial = new THREE.MeshBasicMaterial({ 
                color: dragon.dragonType.color,
                wireframe: true
            });
            const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
            
            projectile.position.copy(dragon.position);
            projectile.velocity = direction.clone().multiplyScalar(20);
            projectile.damage = dragon.damage;
            projectile.type = 'dragon';
            projectile.dragonType = dragon.dragonType;
            
            scene.add(projectile);
            projectiles.push(projectile);
        }
        
        // TRIOS lift attack (Red Dragon special)
        function performLiftAttack(dragon) {
            if (!player.isGrabbed) {
                player.isGrabbed = true;
                player.grabTime = 0;
                addChatMessage("TRIOS: The Red Dragon grabs you! Escape its grasp!");
                
                // Lift player up
                player.position.y += 10;
                
                // Apply random movement
                player.velocity.x = (Math.random() - 0.5) * 5;
                player.velocity.z = (Math.random() - 0.5) * 5;
            }
        }
        
        // Update player with physics and colosseum boundaries
        function updatePlayer(delta) {
            if (!player || currentState !== GameState.PLAYING) return;
            
            // Update gatling gun if firing
            if (controls.fireGatling) {
                fireGatlingCannon();
            }
            
            // Cool down gun when not firing (if not immortal)
            if (!controls.fireGatling && gameStats.heat > 0 && !gameStats.isOverheated && !immortalMode) {
                gameStats.heat = Math.max(0, gameStats.heat - gameStats.coolingRate * delta);
                updateGunHeatVisual();
            }
            
            // Handle player being grabbed by TRIOS
            if (player.isGrabbed) {
                player.grabTime += delta * 1000;
                
                // Apply random movement while grabbed
                player.position.x += (Math.random() - 0.5) * 0.5;
                player.position.z += (Math.random() - 0.5) * 0.5;
                
                // Release after 3 seconds
                if (player.grabTime > 3000) {
                    player.isGrabbed = false;
                    player.grabTime = 0;
                    // Drop player to ground
                    player.position.y = 1.7;
                    // Apply a random throw force
                    player.velocity.x = (Math.random() - 0.5) * 10;
                    player.velocity.y = 5;
                    player.velocity.z = (Math.random() - 0.5) * 10;
                    addChatMessage("TRIOS: The Red Dragon throws you! Regain control!");
                }
                
                return;
            }
            
            const moveVector = new THREE.Vector3();
            
            if (controls.moveForward) moveVector.z -= 1;
            if (controls.moveBackward) moveVector.z += 1;
            if (controls.moveLeft) moveVector.x -= 1;
            if (controls.moveRight) moveVector.x += 1;
            
            if (moveVector.length() > 0) {
                moveVector.normalize();
            }
            
            moveVector.applyEuler(new THREE.Euler(0, player.rotation.y, 0));
            
            let speed = gameStats.playerSpeed;
            
            // Apply speed boost
            if (controls.speedBoost && gameStats.boostFuel > 0) {
                speed *= 1.5;
                gameStats.boostActive = true;
                gameStats.boostFuel = Math.max(0, gameStats.boostFuel - gameStats.boostConsumption * delta);
            } else {
                gameStats.boostActive = false;
                // Regenerate boost fuel when not in use
                gameStats.boostFuel = Math.min(gameStats.maxBoostFuel, gameStats.boostFuel + gameStats.boostRegen * delta);
            }
            
            // Handle boost/jetpack
            if (controls.boost && gameStats.boostFuel > 0) {
                gameStats.boostActive = true;
                gameStats.boostFuel = Math.max(0, gameStats.boostFuel - gameStats.boostConsumption * delta);
                player.position.y += gameStats.boostForce * delta;
                
                // Create boost effect
                if (Math.random() < 0.3) {
                    const boostPosition = player.position.clone();
                    boostPosition.y -= 1.7;
                    createExplosion(boostPosition, 0.3, 0x00ff00, 2);
                }
            } else {
                gameStats.boostActive = false;
                // Regenerate boost fuel when not in use
                gameStats.boostFuel = Math.min(gameStats.maxBoostFuel, gameStats.boostFuel + gameStats.boostRegen * delta);
            }
            
            // Apply gravity if not using boost
            if (!gameStats.boostActive) {
                player.position.y -= 5 * delta;
                
                // Check if player hit the ground
                if (player.position.y <= 1.7) {
                    player.position.y = 1.7; // Ground level
                }
            }
            
            // Check if player hit the ceiling
            if (player.position.y >= 29) {
                player.position.y = 29;
            }
            
            // Apply velocity from being thrown
            player.position.add(player.velocity.clone().multiplyScalar(delta));
            player.velocity.multiplyScalar(0.95); // Dampen velocity
            
            moveVector.multiplyScalar(speed * delta);
            
            const newPosition = player.position.clone().add(moveVector);
            
            // Colosseum boundary check
            const boundaryDistance = newPosition.length();
            if (boundaryDistance > 48) {
                // Push player back inside the colosseum
                newPosition.normalize().multiplyScalar(48);
                
                // Dampen velocity when hitting wall
                player.velocity.multiplyScalar(0.5);
            }
            
            player.position.copy(newPosition);
            
            // Update displays
            updateHealthBar();
            updateBoostBar();
        }
        
        // Update dragons with improved movement
        function updateDrones(delta) {
            for (let i = 0; i < dragons.length; i++) {
                const dragon = dragons[i];
                
                if (dragon.health <= 0) continue;
                
                // Handle flying in animation
                if (dragon.isFlyingIn) {
                    dragon.flyInProgress += delta * 1000;
                    const progress = Math.min(dragon.flyInProgress / dragon.flyInDuration, 1);
                    
                    // Fly in from the sky
                    dragon.position.lerpVectors(dragon.startPosition, dragon.targetPosition, progress);
                    
                    // Add some flight animation
                    dragon.rotation.x = Math.sin(Date.now() * 0.005) * 0.2;
                    
                    // Land when progress is complete
                    if (progress >= 1) {
                        dragon.isFlyingIn = false;
                    }
                    
                    continue;
                }
                
                // All dragons use improved movement
                updateDragonMovement(dragon, delta);
                
                // Animate wings for flying dragons
                if (dragon.wings) {
                    const flap = Math.sin(Date.now() * 0.005 * dragon.wingFlapSpeed) * 0.3;
                    dragon.wings[0].rotation.z = Math.PI / 3 + flap;
                    dragon.wings[1].rotation.z = -Math.PI / 3 + flap;
                }
                
                // Keep dragons within colosseum boundary
                const boundaryDistance = dragon.position.length();
                if (boundaryDistance > 45) {
                    // Push dragon back inside the colosseum
                    const direction = dragon.position.clone().normalize();
                    dragon.position.copy(direction.multiplyScalar(45));
                }
            }
        }
        
        // Improved Dragon movement - orbiting and dynamic positioning
        function updateDragonMovement(dragon, delta) {
            const now = Date.now();
            
            // Look at player
            dragon.lookAt(player.position);
            
            // Calculate orbit position
            dragon.orbitAngle += dragon.orbitSpeed * delta;
            
            // Calculate target position (orbit around player)
            const targetX = Math.cos(dragon.orbitAngle) * dragon.orbitRadius;
            const targetZ = Math.sin(dragon.orbitAngle) * dragon.orbitRadius;
            const targetY = dragon.heightOffset + Math.sin(now * 0.002) * 3;
            
            const targetPosition = new THREE.Vector3(targetX, targetY, targetZ);
            
            // Move toward target position
            const direction = new THREE.Vector3();
            direction.subVectors(targetPosition, dragon.position).normalize();
            
            dragon.position.add(direction.multiplyScalar(dragon.speed * delta));
            
            const distanceToPlayer = dragon.position.distanceTo(player.position);
            
            // Dragon-specific behaviors
            if (dragon.dragonType.name === "Red Dragon") {
                // TRIOS special - lift attack
                if (now - dragon.lastLift > dragon.liftCooldown && distanceToPlayer < 25) {
                    const liftChance = 0.1; // 10% chance per check
                    if (Math.random() < liftChance) {
                        performLiftAttack(dragon);
                        dragon.lastLift = now;
                    }
                }
            }
            
            // Randomly shoot neurot fireballs
            if (now - dragon.lastFire > dragon.fireRate) {
                // Random chance to fire based on distance
                const fireChance = Math.max(0.1, 0.5 - (distanceToPlayer / 50));
                
                if (Math.random() < fireChance) {
                    createDragonProjectile(dragon);
                    dragon.lastFire = now;
                    
                    // Add some randomness to next fire time
                    dragon.fireRate = 500 + Math.random() * 1500;
                }
            }
            
            // Occasionally change orbit parameters for more dynamic movement
            if (Math.random() < 0.005) {
                dragon.orbitRadius = 15 + Math.random() * 10;
                dragon.heightOffset = 5 + Math.random() * 10;
            }
        }
        
        // Update projectiles
        function updateProjectiles(delta) {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const projectile = projectiles[i];
                
                // Move projectile
                if (projectile.velocity) {
                    projectile.position.add(projectile.velocity.clone().multiplyScalar(delta));
                }
                
                // Check if projectile is out of bounds
                if (projectile.position.length() > 100) {
                    scene.remove(projectile);
                    projectiles.splice(i, 1);
                    continue;
                }
                
                if (projectile.type === 'dragon') {
                    // Check for collision with player
                    const playerWorldPosition = new THREE.Vector3();
                    player.getWorldPosition(playerWorldPosition);
                    
                    if (projectile.position.distanceTo(playerWorldPosition) < 2) {
                        // Player takes damage (unless immortal)
                        if (!immortalMode) {
                            gameStats.playerHealth -= projectile.damage;
                            gameStats.damageTaken += projectile.damage;
                            updateHealthBar();
                            
                            if (gameStats.playerHealth <= 0) {
                                gameOver(false);
                            }
                        }
                        
                        createExplosion(projectile.position, 0.5, projectile.dragonType.color);
                        scene.remove(projectile);
                        projectiles.splice(i, 1);
                        
                        // Show damage indicator
                        showDamageIndicator();
                    }
                }
            }
        }
        
        // Update particles
        function updateParticles(delta) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                
                particle.position.add(particle.velocity.clone().multiplyScalar(delta));
                particle.velocity.y -= 10 * delta;
                
                particle.lifetime -= delta;
                if (particle.lifetime <= 0) {
                    scene.remove(particle);
                    particles.splice(i, 1);
                }
            }
        }
        
        // Dragon defeated
        function dragonDefeated(dragon) {
            createExplosion(dragon.position, 4.0, dragon.dragonType.color, 40);
            scene.remove(dragon);
            
            // Remove from dragons array
            const index = dragons.indexOf(dragon);
            if (index > -1) {
                dragons.splice(index, 1);
            }
            
            gameStats.dragonsSlayed++;
            
            // Award experience based on dragon type
            let expGained = 0;
            if (dragon.dragonType.name === "Yellow Dragon") {
                expGained = 1000;
            } else if (dragon.dragonType.name === "Orange Dragon") {
                expGained = 5000;
            } else if (dragon.dragonType.name === "Red Dragon") {
                expGained = 25000;
            }
            
            gameStats.experience += expGained;
            addChatMessage(`VICTORY: ${dragon.dragonType.name} defeated! +${expGained} EXP`);
            
            // Check for level up
            checkLevelUp();
            
            // Hide dragon health bar
            document.getElementById('dragonHealthContainer').style.display = 'none';
            
            // Check if all waves are complete
            if (gameStats.currentWave >= gameStats.totalWaves && dragons.length === 0) {
                // All dragons defeated
                gameOver(true);
            } else if (dragons.length === 0) {
                // Show cinematic before next wave
                showCinematic(gameStats.currentWave);
            }
        }
        
        // Check for level up (Diablo 2 style)
        function checkLevelUp() {
            let newLevel = 1;
            
            // Find the highest level the player can be based on experience
            for (let level = 99; level >= 1; level--) {
                if (gameStats.experience >= diablo2Levels[level]) {
                    newLevel = level;
                    break;
                }
            }
            
            if (newLevel > gameStats.level) {
                const levelsGained = newLevel - gameStats.level;
                gameStats.level = newLevel;
                gameStats.skillPoints += levelsGained;
                
                addChatMessage(`LEVEL UP: You are now level ${gameStats.level}! +${levelsGained} skill points`);
                updateLevelDisplay();
            }
        }
        
        // Show cinematic between waves
        function showCinematic(waveNumber) {
            currentState = GameState.CINEMATIC;
            document.getElementById('cinematicOverlay').style.display = 'flex';
            
            if (waveNumber === 1) {
                document.getElementById('cinematicText').textContent = "YELLOW DRAGON DEFEATED!";
                document.getElementById('cinematicSubtext').textContent = "Orange Dragon approaches...";
            } else if (waveNumber === 2) {
                document.getElementById('cinematicText').textContent = "ORANGE DRAGON DEFEATED!";
                document.getElementById('cinematicSubtext').textContent = "Red Dragon TRIOS awakens with minions!";
            }
            
            setTimeout(() => {
                document.getElementById('cinematicOverlay').style.display = 'none';
                currentState = GameState.PLAYING;
                
                // Start next wave after cinematic
                startWave(gameStats.currentWave + 1);
                
                if (gameStats.currentWave === 2) {
                    addChatMessage("BATTLE: Orange Dragon! It spams fireballs constantly!");
                } else if (gameStats.currentWave === 3) {
                    addChatMessage("BATTLE: TRIOS the Red Dragon! Watch for its lift attack!");
                }
            }, 5000);
        }
        
        // Game over
        function gameOver(victory) {
            currentState = GameState.GAME_OVER;
            clearInterval(timerInterval);
            
            // Update stats
            const minutes = Math.floor(runTime / 60);
            const seconds = runTime % 60;
            document.getElementById('statTime').textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('statDamage').textContent = Math.round(gameStats.damageTaken);
            document.getElementById('statDragons').textContent = gameStats.dragonsSlayed;
            document.getElementById('statLevel').textContent = gameStats.level;
            
            if (victory) {
                document.getElementById('gameOverTitle').textContent = "VICTORY!";
                document.getElementById('gameOverMessage').textContent = `You defeated all dragons in ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}!`;
                addChatMessage("VICTORY: All dragons defeated! You are the ultimate dragon slayer!");
            } else {
                document.getElementById('gameOverTitle').textContent = "DEFEAT!";
                document.getElementById('gameOverMessage').textContent = "You were overwhelmed by dragons!";
                addChatMessage("DEFEAT: The dragons have bested you. Try again!");
            }
            
            document.getElementById('gameOverScreen').style.display = 'flex';
        }
        
        // Show damage indicator
        function showDamageIndicator() {
            const indicator = document.getElementById('damageIndicator');
            indicator.style.opacity = '1';
            
            setTimeout(() => {
                indicator.style.opacity = '0';
            }, 300);
        }
        
        // Export save data
        function exportSaveData() {
            const saveData = {
                gameStats: gameStats,
                playerPosition: player.position,
                playerRotation: player.rotation,
                runTime: runTime,
                timestamp: new Date().toISOString(),
                version: "1.0"
            };
            
            const dataStr = JSON.stringify(saveData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `xf_trios_save_${new Date().toISOString().slice(0, 10)}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            addChatMessage("SYSTEM: Game data exported to JSON file!");
        }
        
        // Import save data
        function importSaveData(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const saveData = JSON.parse(e.target.result);
                    
                    // Validate save data
                    if (!saveData.gameStats || !saveData.playerPosition) {
                        throw new Error("Invalid save file");
                    }
                    
                    // Apply save data
                    Object.assign(gameStats, saveData.gameStats);
                    player.position.copy(saveData.playerPosition);
                    player.rotation.copy(saveData.playerRotation);
                    runTime = saveData.runTime || 0;
                    
                    // Update displays
                    updateRunTime();
                    updateHealthBar();
                    updateBoostBar();
                    updateDragonCounter();
                    updateLevelDisplay();
                    
                    // Clear existing entities and start from current wave
                    clearEntities();
                    if (gameStats.currentWave <= gameStats.totalWaves) {
                        startWave(gameStats.currentWave);
                    }
                    
                    addChatMessage("SYSTEM: Game data imported successfully!");
                } catch (error) {
                    console.error('Error importing save data:', error);
                    addChatMessage("ERROR: Failed to import save data! Invalid file format.");
                }
            };
            reader.readAsText(file);
            
            // Reset file input
            event.target.value = '';
        }
        
        // Update FPS counter
        function updateFPS(delta) {
            frameCount++;
            lastFpsUpdate += delta;
            
            if (lastFpsUpdate >= 1.0) {
                fps = Math.round(frameCount / lastFpsUpdate);
                document.getElementById('fpsCounter').textContent = `FPS: ${fps}`;
                frameCount = 0;
                lastFpsUpdate = 0;
            }
        }
        
        // Main game loop
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = Math.min(clock.getDelta(), 0.1);
            
            // Update FPS counter
            updateFPS(delta);
            
            switch(currentState) {
                case GameState.PLAYING:
                    updatePlayer(delta);
                    updateDrones(delta);
                    updateProjectiles(delta);
                    updateParticles(delta);
                    updateNeurotFlames(delta);
                    updateGatlingGun(delta);
                    updateSwordDrone(delta);
                    updateSwordDroneCooldown(delta);
                    if (swordDroneTarget) updateSwordTargetCrosshair();
                    break;
            }
            
            renderer.render(scene, camera);
        }
        
        // Initialize the game when the page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
