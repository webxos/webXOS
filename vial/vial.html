<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vial MCP Controller</title>
    <link rel="icon" href="/static/icon.png">
    <link rel="manifest" href="/static/manifest.json">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=stylesheet" rel="stylesheet">
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>
    <h1 role="heading" aria-level="1">Vial MCP Controller</h1>
    <div id="input-container">
        <input id="file-input" type="file" accept=".html,.css,.js,.py" aria-label="Upload code file for vial training">
        <input id="api-input" type="text" placeholder="Enter API URL for vial training (webxos.netlify.app)" aria-label="Enter API URL for vial training">
        <div id="input-results"></div>
    </div>
    <div id="console" role="log" aria-live="polite">
        <p>Vial MCP Controller: Create Vial: Initialize new vial | Troubleshoot: Debug vial errors | Monitor: Toggle latency monitoring | VOID: Destroy all vials | Export: Save vial as .md</p>
    </div>
    <div id="vial-stats">
        <div class="progress-container">
            <span class="progress-label">Vial 1:</span>
            <div class="progress-bar"><div class="progress-fill" id="vial1-bar" style="width: 0%"></div></div>
            <span id="vial1-value">0 ms</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">Vial 2:</span>
            <div class="progress-bar"><div class="progress-fill" id="vial2-bar" style="width: 0%"></div></div>
            <span id="vial2-value">0 ms</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">Vial 3:</span>
            <div class="progress-bar"><div class="progress-fill" id="vial3-bar" style="width: 0%"></div></div>
            <span id="vial3-value">0 ms</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">Vial 4:</span>
            <div class="progress-bar"><div class="progress-fill" id="vial4-bar" style="width: 0%"></div></div>
            <span id="vial4-value">0 ms</span>
        </div>
    </div>
    <div class="button-group">
        <button id="create-vial-btn" aria-label="Create new vial">Create Vial</button>
        <button id="troubleshoot-btn" aria-label="Troubleshoot vial errors">Troubleshoot</button>
        <button id="monitor-btn" aria-label="Toggle real-time latency monitoring">Monitor</button>
        <button id="void-btn" aria-label="Destroy all vials and reset">VOID</button>
        <button id="export-btn" aria-label="Export vial as markdown">Export Vial</button>
    </div>
    <footer>
        Â© 2025 WebXOS - Vial MCP Controller<br>
        Create Vial: Initialize new vial | Troubleshoot: Debug vial errors | Monitor: Toggle latency monitoring | VOID: Destroy all vials | Export: Save vial as .md
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/socket.io@4.7.5/dist/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
    <script src="https://cdn.pyodide.org/v0.26.2/full/pyodide.js"></script>
    <script src="/static/vial_network.js"></script>
    <script>
        let socket = null;
        let serverRunning = false;
        const consoleDiv = document.getElementById('console');
        const fileInput = document.getElementById('file-input');
        const apiInput = document.getElementById('api-input');
        const inputResults = document.getElementById('input-results');
        let logQueue = [];
        let monitorActive = false;
        let monitorInterval = null;
        let vials = [
            { name: 'vial1', latencyHistory: [], status: 'stopped', code: '' },
            { name: 'vial2', latencyHistory: [], status: 'stopped', code: '' },
            { name: 'vial3', latencyHistory: [], status: 'stopped', code: '' },
            { name: 'vial4', latencyHistory: [], status: 'stopped', code: '' }
        ];
        let token = null;
        let pyodide = null;

        async function initPyodide() {
            try {
                pyodide = await loadPyodide();
                await pyodide.loadPackage(['micropip']);
                await pyodide.runPythonAsync(`
                    import micropip
                    await micropip.install('numpy')
                `);
                console.log('[VIAL] Pyodide initialized with numpy');
            } catch (err) {
                logMessage(`Pyodide Init Error: ${err.message}\nAnalysis: Check Pyodide CDN or browser compatibility.`, true);
            }
        }

        async function getToken() {
            try {
                const response = await fetch('/api/auth/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username: 'user', password: 'pass' })
                });
                const data = await response.json();
                if (data.token) {
                    token = data.token;
                    localStorage.setItem('token', token);
                } else {
                    throw new Error('Authentication failed');
                }
            } catch (err) {
                logMessage(`Auth Error: ${err.message}\nAnalysis: Check credentials and server logs.`, true);
            }
        }

        function serverLog(message) {
            console.log(`[VIAL] ${message}`);
        }

        function logMessage(message, isCommand = false) {
            const timestamp = new Date().toISOString();
            const formattedMessage = isCommand 
                ? `<span class="command">${message}</span>`
                : message;
            logQueue.push(`[${timestamp}] ${formattedMessage}`);
            if (logQueue.length > 50) logQueue.shift();
            throttleConsoleUpdate();
        }

        const throttleConsoleUpdate = (() => {
            let timeout;
            return () => {
                if (!timeout) {
                    timeout = setTimeout(() => {
                        consoleDiv.innerHTML = logQueue.map(msg => `<p>${msg}</p>`).join('');
                        consoleDiv.scrollTop = consoleDiv.scrollHeight;
                        timeout = null;
                    }, 100);
                }
            };
        })();

        function triggerGlow() {
            document.body.classList.add('glow');
            setTimeout(() => document.body.classList.remove('glow'), 1000);
        }

        function flashRedGlow() {
            consoleDiv.classList.add('active-monitor');
            setTimeout(() => consoleDiv.classList.remove('active-monitor'), 500);
            setTimeout(() => {
                consoleDiv.classList.add('active-monitor');
                setTimeout(() => consoleDiv.classList.remove('active-monitor'), 500);
            }, 1000);
        }

        async function createVial() {
            serverLog('Create Vial button clicked');
            try {
                if (!token) await getToken();
                if (!socket || socket.disconnected) {
                    socket = io('ws://localhost:8080', { 
                        transports: ['websocket'], 
                        reconnectionAttempts: 3,
                        timeout: 10000,
                        auth: { token }
                    });
                }

                socket.on('connect', () => {
                    logMessage('Connected to Vial MCP server.', true);
                    serverRunning = true;
                    const codeInput = apiInput.value.trim();
                    let fileContent = '';
                    if (fileInput.files.length > 0) {
                        const file = fileInput.files[0];
                        fileContent = await file.text();
                        inputResults.innerHTML = `<p>Uploaded file: ${file.name}</p>`;
                    }
                    socket.emit('create-vial', { code: codeInput || fileContent || 'default' });
                });

                socket.on('connect_error', (err) => {
                    logMessage(`Connection Error: ${err.message}\nAnalysis: Check server availability at ws://localhost:8080 or authentication token.`, true);
                    serverLog(`Connection Error: ${err.stack}`);
                    serverRunning = false;
                });

                socket.on('vial-created', async (data) => {
                    logMessage(`[VIAL] Vial ${data.vialId} created with stats: Latency ${data.latency.toFixed(2)}ms`, true);
                    triggerGlow();
                    flashRedGlow();
                    try {
                        await VialNetworkModule();
                        const model = await tf.loadLayersModel('https://webxos.netlify.app/models/vial_model.json');
                        const inputTensor = tf.tensor([1.0]);
                        const result = await model.predict(inputTensor).dataSync()[0];
                        logMessage(`Vial ${data.vialId} tested with WebXOS: ${result.toFixed(2)}`, true);
                        if (pyodide && data.code.endsWith('.py')) {
                            try {
                                const pyResult = await pyodide.runPythonAsync(data.code);
                                logMessage(`Python Execution Result: ${pyResult}`, true);
                            } catch (pyErr) {
                                logMessage(`Python Execution Error: ${pyErr.message}\nAnalysis: Check Python syntax.`, true);
                            }
                        }
                        if (vials.length < 4) {
                            vials[vials.length - 1].status = 'running';
                            vials[vials.length - 1].code = data.code;
                        } else {
                            vials.push({ name: data.vialId, latencyHistory: [], status: 'running', code: data.code });
                        }
                        updateVialStatsUI();
                    } catch (err) {
                        logMessage(`Vial Network Error: ${err.message}\nAnalysis: Ensure /static/vial_network.wasm or WebXOS model is accessible.`, true);
                        serverLog(`Vial Network Error: ${err.stack}`);
                    }
                });

                socket.on('vial-status', (data) => {
                    const vialIndex = vials.findIndex(v => v.name === data.vial);
                    if (vialIndex !== -1) {
                        const latency = data.latency || 0;
                        vials[vialIndex].latencyHistory.push(latency);
                        vials[vialIndex].status = data.status;
                        if (vials[vialIndex].latencyHistory.length > 20) {
                            vials[vialIndex].latencyHistory.shift();
                        }
                        const bar = document.getElementById(`vial${vialIndex + 1}-bar`);
                        const value = document.getElementById(`vial${vialIndex + 1}-value`);
                        if (bar && value) {
                            bar.style.width = `${Math.min(100, latency / 2)}%`;
                            value.textContent = `${latency.toFixed(2)} ms`;
                        }
                        logMessage(`[VIAL] ${data.vial}: ${data.status} (Latency: ${latency.toFixed(2)}ms)`, true);
                    }
                });

                socket.on('server-error', (data) => {
                    logMessage(`Server Error: ${data.message}\nAnalysis: ${data.analysis || 'Check server logs.'}`, true);
                    flashRedGlow();
                });

                socket.on('disconnect', () => {
                    logMessage('Disconnected from Vial MCP server.', true);
                    serverRunning = false;
                    clearMonitor();
                });
            } catch (err) {
                logMessage(`Create Vial Error: ${err.message}\nAnalysis: Check client-side configuration, authentication, or server logs.`, true);
                serverLog(`Create Vial Error: ${err.stack}`);
            }
        }

        async function troubleshootVials() {
            serverLog('Troubleshoot button clicked');
            triggerGlow();
            flashRedGlow();
            if (!serverRunning) {
                logMessage('Server not running. Create a vial first.', true);
                return;
            }
            try {
                document.getElementById('troubleshoot-btn').disabled = true;
                logMessage('Running vial troubleshooting...', true);
                socket.emit('troubleshoot-vials');
                setTimeout(() => {
                    document.getElementById('troubleshoot-btn').disabled = false;
                }, 2000);
            } catch (err) {
                logMessage(`Troubleshoot Error: ${err.message}\nAnalysis: Verify server connection, authentication, or vial status.`, true);
                serverLog(`Troubleshoot Error: ${err.stack}`);
                document.getElementById('troubleshoot-btn').disabled = false;
            }
        }

        async function updateVialStats() {
            if (!serverRunning) return;
            try {
                socket.emit('check-vials');
            } catch (err) {
                logMessage(`Monitor Error: ${err.message}\nAnalysis: Check server connection or authentication.`, true);
                serverLog(`Monitor Error: ${err.stack}`);
            }
        }

        function clearMonitor() {
            if (monitorActive) {
                monitorActive = false;
                clearInterval(monitorInterval);
                const monitorBtn = document.getElementById('monitor-btn');
                const consoleDiv = document.getElementById('console');
                monitorBtn.classList.remove('active-monitor');
                consoleDiv.classList.remove('active-monitor');
                logMessage('Monitor: Real-time latency monitoring deactivated.', true);
            }
        }

        async function toggleMonitor() {
            serverLog('Monitor button clicked');
            monitorActive = !monitorActive;
            const monitorBtn = document.getElementById('monitor-btn');
            const consoleDiv = document.getElementById('console');
            monitorBtn.classList.toggle('active-monitor', monitorActive);
            consoleDiv.classList.toggle('active-monitor', monitorActive);
            triggerGlow();
            flashRedGlow();

            if (monitorActive) {
                if (!serverRunning) {
                    logMessage('Server not running. Create a vial first.', true);
                    monitorActive = false;
                    monitorBtn.classList.remove('active-monitor');
                    consoleDiv.classList.remove('active-monitor');
                    return;
                }
                logMessage('Monitor: Real-time latency monitoring activated.', true);
                await updateVialStats();
                monitorInterval = setInterval(updateVialStats, 5000);
            } else {
                clearMonitor();
            }
        }

        function voidVials() {
            serverLog('VOID button clicked');
            try {
                if (!serverRunning) {
                    logMessage('Server not running. No vials to destroy.', true);
                    return;
                }
                socket.emit('void-vials');
                logQueue = ['Vial MCP Controller: Create Vial: Initialize new vial | Troubleshoot: Debug vial errors | Monitor: Toggle latency monitoring | VOID: Destroy all vials | Export: Save vial as .md'];
                vials = [
                    { name: 'vial1', latencyHistory: [], status: 'stopped', code: '' },
                    { name: 'vial2', latencyHistory: [], status: 'stopped', code: '' },
                    { name: 'vial3', latencyHistory: [], status: 'stopped', code: '' },
                    { name: 'vial4', latencyHistory: [], status: 'stopped', code: '' }
                ];
                updateVialStatsUI();
                throttleConsoleUpdate();
                logMessage('All vials destroyed and console reset.', true);
                triggerGlow();
                flashRedGlow();
                serverRunning = false;
                if (socket) socket.disconnect();
            } catch (err) {
                logMessage(`VOID Error: ${err.message}\nAnalysis: Check server connection, authentication, or vial status.`, true);
                serverLog(`VOID Error: ${err.stack}`);
            }
        }

        async function exportVial() {
            serverLog('Export Vial button clicked');
            try {
                const activeVial = vials.find(v => v.status === 'running');
                if (!activeVial) {
                    logMessage('No active vials to export.', true);
                    return;
                }
                const content = `# Vial Agent: ${activeVial.name}\n\n` +
                                `**Status**: ${activeVial.status}\n` +
                                `**Created**: ${new Date().toISOString()}\n` +
                                `**Code**: \n\`\`\`\n${activeVial.code || 'No code provided'}\n\`\`\`\n` +
                                `**Latency History**: ${activeVial.latencyHistory.map(l => l.toFixed(2)).join(', ')} ms\n` +
                                `**Training**: Integrated with WebXOS (webxos.netlify.app)\n` +
                                `**API Endpoints**:\n- Input: /api/input\n- Output: /api/output/${activeVial.name}\n` +
                                `**Usage**: Edit this file to customize the vial agent, then use WebXOS tools to train and deploy.`;
                const blob = new Blob([content], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${activeVial.name}.md`;
                a.click();
                URL.revokeObjectURL(url);
                logMessage(`Exported vial ${activeVial.name} as .md file.`, true);
                triggerGlow();
            } catch (err) {
                logMessage(`Export Error: ${err.message}\nAnalysis: Check vial status or browser permissions.`, true);
                serverLog(`Export Error: ${err.stack}`);
            }
        }

        function updateVialStatsUI() {
            const vialStatsDiv = document.getElementById('vial-stats');
            vialStatsDiv.innerHTML = vials.slice(0, 4).map((vial, index) => `
                <div class="progress-container">
                    <span class="progress-label">Vial ${index + 1}:</span>
                    <div class="progress-bar"><div class="progress-fill" id="vial${index + 1}-bar" style="width: 0%"></div></div>
                    <span id="vial${index + 1}-value">0 ms</span>
                </div>
            `).join('');
        }

        const debounce = (func, wait) => {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        };

        document.getElementById('create-vial-btn').addEventListener('click', debounce(createVial, 200));
        document.getElementById('troubleshoot-btn').addEventListener('click', debounce(troubleshootVials, 200));
        document.getElementById('monitor-btn').addEventListener('click', debounce(toggleMonitor, 200));
        document.getElementById('void-btn').addEventListener('click', debounce(voidVials, 200));
        document.getElementById('export-btn').addEventListener('click', debounce(exportVial, 200));

        fileInput.addEventListener('change', async () => {
            if (fileInput.files.length > 0) {
                const file = fileInput.files[0];
                try {
                    const formData = new FormData();
                    formData.append('file', file);
                    formData.append('vialId', `vial${vials.length + 1}_${Date.now()}`);
                    const response = await fetch('/api/input', {
                        method: 'POST',
                        headers: { 'Authorization': `Bearer ${token}` },
                        body: formData
                    });
                    const data = await response.json();
                    inputResults.innerHTML = `<p>${data.message}</p>`;
                    serverLog(`File uploaded: ${file.name}`);
                } catch (err) {
                    inputResults.innerHTML = `<p>Error uploading file: ${err.message}</p>`;
                    serverLog(`File Upload Error: ${err.stack}`);
                }
            }
        });

        apiInput.addEventListener('change', () => {
            const input = apiInput.value.trim();
            if (input) {
                inputResults.innerHTML = `<p>Submitted API URL: ${input}</p>`;
                serverLog(`API URL input: ${input}`);
            }
        });

        document.addEventListener('keydown', e => {
            serverLog(`Key pressed: ${e.key}`);
            if (e.key === 'Enter' || e.key === ' ') troubleshootVials();
            else if (e.key === 'm' || e.key === 'M') toggleMonitor();
            else if (e.key === 'v' || e.key === 'V') voidVials();
            else if (e.key === 'c' || e.key === 'C') createVial();
            else if (e.key === 'e' || e.key === 'E') exportVial();
        });

        window.onload = async () => {
            logMessage('Vial MCP Controller: Create Vial: Initialize new vial | Troubleshoot: Debug vial errors | Monitor: Toggle latency monitoring | VOID: Destroy all vials | Export: Save vial as .md', true);
            try {
                await getToken();
                await VialNetworkModule();
                await initPyodide();
                logMessage('Vial Network and Pyodide modules loaded successfully.', true);
            } catch (err) {
                logMessage(`Vial Network Load Error: ${err.message}\nAnalysis: Verify /static/vial_network.js, /static/vial_network.wasm, or authentication.`, true);
                serverLog(`Vial Network Error: ${err.stack}`);
            }
        };
    </script>
</body>
</html>
