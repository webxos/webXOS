<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vial MCP Controller</title>
    <link rel="icon" href="/static/icon.png">
    <link rel="manifest" href="/static/manifest.json">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: monospace, sans-serif;
        }

        html, body {
            height: 100vh;
            overflow: hidden;
            background: #000 !important;
            color: #0f0 !important;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: background 0.3s, box-shadow 0.3s;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        body.glow {
            background: rgba(255, 0, 0, 0.1) !important;
            box-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000 inset;
        }

        body.train-glow {
            background: rgba(255, 255, 0, 0.1) !important;
            box-shadow: 0 0 20px #ff0, 0 0 40px #ff0 inset;
        }

        h1 {
            font-size: 1.6rem;
            text-align: center;
            margin: 0.8rem 0;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 0 5px #0f0;
            color: #0f0 !important;
        }

        #console {
            width: 90%;
            max-width: 900px;
            background: rgba(0, 255, 0, 0.1) !important;
            border: 1px solid #0f0;
            padding: 0.6rem;
            flex: 1;
            max-height: calc(100vh - 300px);
            overflow-y: auto;
            margin: 0.5rem 0;
            border-radius: 5px;
            font-size: 0.8rem;
            -webkit-overflow-scrolling: touch;
            transition: border-color 0.3s, box-shadow 0.3s;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        #console.active-monitor {
            border-color: #ff0000 !important;
            box-shadow: 0 0 10px #ff0000;
        }

        #console.active-train {
            border-color: #ff0 !important;
            box-shadow: 0 0 10px #ff0;
        }

        #console p {
            margin: 0.2rem 0;
            color: #0f0 !important;
        }

        #console .command {
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            text-shadow: 0 0 3px #0f0;
        }

        #console .error {
            color: #ff0000 !important;
            text-shadow: 0 0 3px #ff0000;
        }

        .button-group {
            display: flex;
            gap: 0.5rem;
            margin: 0.5rem 0;
            padding: 0.5rem;
            flex-wrap: wrap;
            justify-content: center;
            width: 90%;
            max-width: 900px;
        }

        button {
            background: #0f0 !important;
            color: #000 !important;
            border: none;
            padding: 0.6rem 1.2rem;
            font-size: 0.9rem;
            cursor: pointer;
            border-radius: 3px;
            min-width: 90px;
            text-align: center;
            touch-action: manipulation;
            transition: background 0.3s, box-shadow 0.3s;
            -webkit-user-select: none;
            user-select: none;
        }

        button:hover, button:focus, button:active {
            background: #0c0 !important;
            outline: 2px solid #0f0;
        }

        button.active-monitor {
            background: #ff0000 !important;
            box-shadow: 0 0 10px #ff0000;
        }

        button.active-train {
            background: #ff0 !important;
            color: #000 !important;
            box-shadow: 0 0 10px #ff0;
        }

        button:disabled {
            background: #666 !important;
            cursor: not-allowed;
        }

        #vial-stats {
            width: 90%;
            max-width: 900px;
            margin: 0.5rem 0;
            display: flex;
            flex-direction: column;
            gap: 0.2rem;
        }

        .progress-container {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .progress-label {
            width: 90px;
            font-size: 0.75rem;
            color: #0f0 !important;
        }

        .progress-bar {
            flex: 1;
            height: 8px;
            background: #333 !important;
            border: 1px solid #0f0;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #0f0 !important;
            transition: width 0.5s;
        }

        #input-container {
            width: 90%;
            max-width: 900px;
            margin: 0.5rem 0;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        #file-input, #api-input {
            width: 100%;
            padding: 0.5rem;
            background: #000 !important;
            color: #0f0 !important;
            border: 1px solid #0f0;
            border-radius: 3px;
            font-size: 0.8rem;
        }

        #input-results {
            margin-top: 0.5rem;
            max-height: 100px;
            overflow-y: auto;
            font-size: 0.8rem;
            color: #0f0 !important;
        }

        #input-results .error {
            color: #ff0000 !important;
        }

        footer {
            width: 100%;
            padding: 0.4rem;
            font-size: 9pt;
            text-align: center;
            color: #0f0 !important;
            background: rgba(0, 0, 0, 0.8) !important;
            line-height: 1.2;
        }

        @media (max-width: 600px) {
            h1 { font-size: 1.1rem; margin: 0.5rem 0; }
            #console { 
                font-size: 0.75rem; 
                padding: 0.5rem; 
                max-height: calc(100vh - 320px); 
            }
            button { 
                padding: 0.5rem 1rem; 
                font-size: 0.85rem; 
                min-width: 80px; 
            }
            #file-input, #api-input { font-size: 0.75rem; }
            footer { padding: 0.3rem; }
            .progress-label { width: 70px; font-size: 0.7rem; }
            .progress-bar { height: 7px; }
        }

        @media (max-width: 400px) {
            .button-group { flex-direction: column; align-items: center; }
            button { width: 100%; max-width: 160px; }
            #console { max-height: calc(100vh - 280px); }
            #vial-stats { gap: 0.15rem; }
        }
    </style>
</head>
<body>
    <h1 role="heading" aria-level="1">Vial MCP Controller</h1>
    <div id="input-container">
        <input id="file-input" type="file" accept=".html,.css,.js,.py" aria-label="Upload code file for vial training">
        <input id="api-input" type="text" placeholder="Enter API URL for vial training (webxos.netlify.app)" aria-label="Enter API URL for vial training">
        <div id="input-results"></div>
    </div>
    <div id="console" role="log" aria-live="polite">
        <p>Vial MCP Controller: Create Vial: Initialize new vial | Troubleshoot: Debug vial errors | Monitor: Toggle latency monitoring | Train: Start vial training | VOID: Destroy all vials | Export: Save all vials as .md</p>
    </div>
    <div id="vial-stats">
        <div class="progress-container">
            <span class="progress-label">Vial 1:</span>
            <div class="progress-bar"><div class="progress-fill" id="vial1-bar" style="width: 0%"></div></div>
            <span id="vial1-value">0 ms</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">Vial 2:</span>
            <div class="progress-bar"><div class="progress-fill" id="vial2-bar" style="width: 0%"></div></div>
            <span id="vial2-value">0 ms</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">Vial 3:</span>
            <div class="progress-bar"><div class="progress-fill" id="vial3-bar" style="width: 0%"></div></div>
            <span id="vial3-value">0 ms</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">Vial 4:</span>
            <div class="progress-bar"><div class="progress-fill" id="vial4-bar" style="width: 0%"></div></div>
            <span id="vial4-value">0 ms</span>
        </div>
    </div>
    <div class="button-group">
        <button id="create-vial-btn" aria-label="Create new vial">Create Vial</button>
        <button id="troubleshoot-btn" aria-label="Troubleshoot vial errors">Troubleshoot</button>
        <button id="monitor-btn" aria-label="Toggle real-time latency monitoring">Monitor</button>
        <button id="train-btn" aria-label="Start training all vials">Train</button>
        <button id="void-btn" aria-label="Destroy all vials and reset">VOID</button>
        <button id="export-btn" aria-label="Export all vials as markdown">Export Vials</button>
    </div>
    <footer>
        Â© 2025 WebXOS - Vial MCP Controller<br>
        Create Vial: Initialize new vial | Troubleshoot: Debug vial errors | Monitor: Toggle latency monitoring | Train: Start vial training | VOID: Destroy all vials | Export: Save all vials as .md
    </footer>

    <script type="module">
        // Simulated VialAgent class
        class VialAgent {
            constructor(id) {
                this.id = id;
                this.status = 'running';
                this.createdAt = new Date().toISOString();
                this.code = 'default';
                this.latency = Math.random() * 100;
                this.codeLength = this.code.length;
            }

            init() {
                return { status: this.status, latency: this.latency, createdAt: this.createdAt, codeLength: this.codeLength };
            }

            process() {
                this.latency = Math.random() * 100;
                return { result: Math.random(), latency: this.latency };
            }

            train(input) {
                this.latency = Math.random() * 100;
                this.code = input || this.code;
                this.codeLength = this.code.length;
                return { status: 'trained', latency: this.latency, codeLength: this.codeLength };
            }
        }

        // State management
        let monitorActive = false;
        let trainActive = false;
        let monitorInterval = null;
        let trainTimeout = null;
        let vials = [
            { name: 'vial1', latencyHistory: [], status: 'stopped', code: '', filePath: '', createdAt: '', codeLength: 0 },
            { name: 'vial2', latencyHistory: [], status: 'stopped', code: '', filePath: '', createdAt: '', codeLength: 0 },
            { name: 'vial3', latencyHistory: [], status: 'stopped', code: '', filePath: '', createdAt: '', codeLength: 0 },
            { name: 'vial4', latencyHistory: [], status: 'stopped', code: '', filePath: '', createdAt: '', codeLength: 0 }
        ];
        let logQueue = [];
        let errorLog = [];

        // DOM elements with fallbacks
        const consoleDiv = document.getElementById('console') || document.createElement('div');
        const fileInput = document.getElementById('file-input') || null;
        const apiInput = document.getElementById('api-input') || null;
        const inputResults = document.getElementById('input-results') || document.createElement('div');
        const vialStatsDiv = document.getElementById('vial-stats') || document.createElement('div');

        function serverLog(message) {
            console.log(`[VIAL] ${message}`);
        }

        function logMessage(message, isCommand = false) {
            try {
                const timestamp = new Date().toISOString();
                const formattedMessage = isCommand 
                    ? `[${timestamp}] COMMAND: ${message}`
                    : `[${timestamp}] ${message}`;
                logQueue.push(formattedMessage);
                if (logQueue.length > 50) logQueue.shift();
                updateConsole();
            } catch (err) {
                logError(`Log Message Error: ${err.message}`, 'Check console update logic.', err.stack, 'LOW');
            }
        }

        function logError(message, analysis, stack = '', urgency = 'HIGH') {
            try {
                const timestamp = new Date().toISOString();
                const errorMessage = `[${timestamp}] ERROR: ${message}\nAnalysis: ${analysis}\nTraceback: ${stack || 'No stack available'}\nUrgency: ${urgency}`;
                errorLog.push({ message: errorMessage, urgency });
                errorLog.sort((a, b) => {
                    const urgencyOrder = { 'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3 };
                    return urgencyOrder[a.urgency] - urgencyOrder[b.urgency];
                });
                logQueue.push(`<span class="error">${errorMessage}</span>`);
                if (logQueue.length > 50) logQueue.shift();
                updateConsole();
                if (urgency !== 'LOW') flashRedGlow();
            } catch (err) {
                console.error(`[VIAL] Log Error Error: ${err.message}`, err.stack);
            }
        }

        function updateConsole() {
            try {
                if (!consoleDiv) {
                    logError('Console Update Error: console div not found', 'Check HTML structure for id="console".', '', 'CRITICAL');
                    return;
                }
                consoleDiv.innerHTML = logQueue.map(msg => `<p>${msg}</p>`).join('');
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            } catch (err) {
                logError(`Console Update Error: ${err.message}`, 'Check consoleDiv DOM or JavaScript execution.', err.stack, 'HIGH');
            }
        }

        function triggerGlow() {
            try {
                if (!document.body) {
                    logError('Glow Effect Error: document.body not found', 'Check HTML structure.', '', 'MEDIUM');
                    return;
                }
                document.body.classList.add('glow');
                setTimeout(() => document.body.classList.remove('glow'), 1000);
            } catch (err) {
                logError(`Glow Effect Error: ${err.message}`, 'Check DOM or CSS classes.', err.stack, 'LOW');
            }
        }

        function flashRedGlow() {
            try {
                if (!consoleDiv) {
                    logError('Flash Red Glow Error: console div not found', 'Check HTML structure for id="console".', '', 'MEDIUM');
                    return;
                }
                consoleDiv.classList.add('active-monitor');
                setTimeout(() => consoleDiv.classList.remove('active-monitor'), 500);
                setTimeout(() => {
                    consoleDiv.classList.add('active-monitor');
                    setTimeout(() => consoleDiv.classList.remove('active-monitor'), 500);
                }, 1000);
            } catch (err) {
                logError(`Flash Red Glow Error: ${err.message}`, 'Check DOM or CSS classes.', err.stack, 'LOW');
            }
        }

        function flashYellowGlow() {
            try {
                if (!consoleDiv) {
                    logError('Flash Yellow Glow Error: console div not found', 'Check HTML structure for id="console".', '', 'MEDIUM');
                    return;
                }
                consoleDiv.classList.add('active-train');
                setTimeout(() => consoleDiv.classList.remove('active-train'), 500);
                setTimeout(() => {
                    consoleDiv.classList.add('active-train');
                    setTimeout(() => consoleDiv.classList.remove('active-train'), 500);
                }, 1000);
            } catch (err) {
                logError(`Flash Yellow Glow Error: ${err.message}`, 'Check DOM or CSS classes.', err.stack, 'LOW');
            }
        }

        function createVial() {
            try {
                serverLog('Create Vial button clicked');
                const activeVials = vials.filter(v => v.status === 'running').length;
                if (activeVials >= 4) {
                    logError('Vial Creation Error: Maximum 4 vials created, VOID or refresh page', 'VOID existing vials or refresh the page to create new ones.', '', 'HIGH');
                    return;
                }

                const vialId = Math.floor(100000 + Math.random() * 900000).toString();
                let codeInput = apiInput?.value?.trim() || '';
                let fileContent = '';
                if (fileInput?.files?.length > 0) {
                    try {
                        fileContent = fileInput.files[0].text();
                        inputResults.innerHTML = `<p>Uploaded file: ${fileInput.files[0].name}</p>`;
                    } catch (err) {
                        logError(`File Read Error: ${err.message}`, 'Check file format or browser permissions.', err.stack, 'MEDIUM');
                        return;
                    }
                }

                const vialAgent = new VialAgent(vialId);
                const { latency, createdAt, codeLength } = vialAgent.init();
                const vialIndex = vials.findIndex(v => v.status === 'stopped');
                if (vialIndex === -1) {
                    logError(`Vial Creation Error: No available slots`, 'Maximum 4 vials allowed. VOID existing vials.', '', 'HIGH');
                    return;
                }

                vials[vialIndex] = {
                    name: vialId,
                    latencyHistory: [latency],
                    status: 'running',
                    code: codeInput || fileContent || 'default',
                    filePath: `/webxos/vial/lab/vial${vialId}.js`,
                    createdAt,
                    codeLength
                };

                logMessage(`[VIAL] Vial ${vialId} created at /webxos/vial/lab/vial${vialId}.js with stats: Latency ${latency.toFixed(2)}ms, Code Length ${codeLength} chars`, true);
                updateVialStatsUI();
                triggerGlow();
                if (activeVials + 1 === 4) {
                    logError('Maximum 4 vials created, VOID or refresh page', 'VOID existing vials or refresh the page to create new ones.', '', 'HIGH');
                }
            } catch (err) {
                logError(`Create Vial Error: ${err.message}`, 'Check vial creation logic or browser environment.', err.stack, 'CRITICAL');
            }
        }

        function troubleshootVials() {
            try {
                serverLog('Troubleshoot button clicked');
                triggerGlow();
                flashRedGlow();
                const troubleshootBtn = document.getElementById('troubleshoot-btn');
                if (!troubleshootBtn) {
                    logError('Troubleshoot Error: troubleshoot-btn not found', 'Check HTML structure for id="troubleshoot-btn".', '', 'CRITICAL');
                    return;
                }
                troubleshootBtn.disabled = true;
                logMessage('Running vial troubleshooting...', true);
                vials.forEach(vial => {
                    if (vial.status === 'running') {
                        const vialAgent = new VialAgent(vial.name);
                        const { status, latency, createdAt, codeLength } = vialAgent.init();
                        const avgLatency = vial.latencyHistory.length > 0 
                            ? (vial.latencyHistory.reduce((a, b) => a + b, 0) / vial.latencyHistory.length).toFixed(2)
                            : '0.00';
                        const minLatency = vial.latencyHistory.length > 0 
                            ? Math.min(...vial.latencyHistory).toFixed(2)
                            : '0.00';
                        const maxLatency = vial.latencyHistory.length > 0 
                            ? Math.max(...vial.latencyHistory).toFixed(2)
                            : '0.00';
                        logMessage(`Troubleshoot: ${vial.name} - Status: ${status}, Created: ${createdAt}, Latency: ${latency.toFixed(2)}ms (Avg: ${avgLatency}ms, Min: ${minLatency}ms, Max: ${maxLatency}ms), Code Length: ${codeLength} chars`, true);
                    }
                });
                if (vials.every(v => v.status === 'stopped')) {
                    logError('Troubleshoot Error: No active vials', 'Create a vial first.', '', 'HIGH');
                }
            } catch (err) {
                logError(`Troubleshoot Error: ${err.message}`, 'Check vial status or JavaScript execution.', err.stack, 'HIGH');
            } finally {
                const troubleshootBtn = document.getElementById('troubleshoot-btn');
                if (troubleshootBtn) troubleshootBtn.disabled = false;
            }
        }

        function updateVialStats() {
            try {
                vials.forEach((vial, index) => {
                    if (vial.status === 'running') {
                        const vialAgent = new VialAgent(vial.name);
                        const { latency } = vialAgent.process();
                        vial.latencyHistory.push(latency);
                        if (vial.latencyHistory.length > 20) vial.latencyHistory.shift();
                        const bar = document.getElementById(`vial${index + 1}-bar`);
                        const value = document.getElementById(`vial${index + 1}-value`);
                        if (bar && value) {
                            bar.style.width = `${Math.min(100, latency / 2)}%`;
                            value.textContent = `${latency.toFixed(2)} ms`;
                        } else {
                            logError(`Vial Status UI Error: Missing DOM elements for vial${index + 1}`, 'Check vial-stats HTML.', '', 'MEDIUM');
                        }
                        logMessage(`[VIAL] ${vial.name}: ${vial.status} (Latency: ${latency.toFixed(2)}ms)`, true);
                    }
                });
            } catch (err) {
                logError(`Monitor Error: ${err.message}`, 'Check vial stats update logic.', err.stack, 'HIGH');
            }
        }

        function clearMonitor() {
            try {
                if (monitorActive) {
                    monitorActive = false;
                    clearInterval(monitorInterval);
                    const monitorBtn = document.getElementById('monitor-btn');
                    if (monitorBtn && consoleDiv) {
                        monitorBtn.classList.remove('active-monitor');
                        consoleDiv.classList.remove('active-monitor');
                        logMessage('Monitor: Real-time latency monitoring deactivated.', true);
                    } else {
                        logError(`Clear Monitor Error: Missing DOM elements`, 'Check monitor-btn or console DOM IDs.', '', 'MEDIUM');
                    }
                }
            } catch (err) {
                logError(`Clear Monitor Error: ${err.message}`, 'Check monitor state or DOM elements.', err.stack, 'LOW');
            }
        }

        function toggleMonitor() {
            try {
                serverLog('Monitor button clicked');
                const monitorBtn = document.getElementById('monitor-btn');
                if (!monitorBtn || !consoleDiv) {
                    logError(`Monitor Error: Missing DOM elements`, 'Check monitor-btn or console DOM IDs.', '', 'CRITICAL');
                    return;
                }
                monitorActive = !monitorActive;
                monitorBtn.classList.toggle('active-monitor', monitorActive);
                consoleDiv.classList.toggle('active-monitor', monitorActive);
                triggerGlow();
                flashRedGlow();

                if (monitorActive) {
                    const activeVials = vials.filter(v => v.status === 'running').length;
                    if (activeVials === 0) {
                        logError('Monitor Error: No active vials', 'Create a vial first.', '', 'HIGH');
                        monitorActive = false;
                        monitorBtn.classList.remove('active-monitor');
                        consoleDiv.classList.remove('active-monitor');
                        return;
                    }
                    logMessage('Monitor: Real-time latency monitoring activated.', true);
                    updateVialStats();
                    monitorInterval = setInterval(updateVialStats, 5000);
                } else {
                    clearMonitor();
                }
            } catch (err) {
                logError(`Monitor Error: ${err.message}`, 'Check monitor logic or DOM elements.', err.stack, 'CRITICAL');
            }
        }

        function clearTrain() {
            try {
                if (trainActive) {
                    trainActive = false;
                    clearTimeout(trainTimeout);
                    const trainBtn = document.getElementById('train-btn');
                    if (trainBtn && consoleDiv) {
                        trainBtn.classList.remove('active-train');
                        consoleDiv.classList.remove('active-train');
                        logMessage('Train: Training mode deactivated.', true);
                    } else {
                        logError(`Clear Train Error: Missing DOM elements`, 'Check train-btn or console DOM IDs.', '', 'MEDIUM');
                    }
                }
            } catch (err) {
                logError(`Clear Train Error: ${err.message}`, 'Check train state or DOM elements.', err.stack, 'LOW');
            }
        }

        function trainVials() {
            try {
                serverLog('Train button clicked');
                const trainBtn = document.getElementById('train-btn');
                if (!trainBtn || !consoleDiv) {
                    logError(`Train Error: Missing DOM elements`, 'Check train-btn or console DOM IDs.', '', 'CRITICAL');
                    return;
                }
                trainActive = !trainActive;
                trainBtn.classList.toggle('active-train', trainActive);
                consoleDiv.classList.toggle('active-train', trainActive);
                flashYellowGlow();

                if (trainActive) {
                    const activeVials = vials.filter(v => v.status === 'running').length;
                    if (activeVials === 0) {
                        logError('Train Error: No active vials', 'Create a vial first.', '', 'HIGH');
                        trainActive = false;
                        trainBtn.classList.remove('active-train');
                        consoleDiv.classList.remove('active-train');
                        return;
                    }
                    let inputData = apiInput?.value?.trim() || '';
                    if (fileInput?.files?.length > 0) {
                        try {
                            inputData = fileInput.files[0].text();
                            inputResults.innerHTML = `<p>Training with file: ${fileInput.files[0].name}</p>`;
                        } catch (err) {
                            logError(`Train File Read Error: ${err.message}`, 'Check file format or browser permissions.', err.stack, 'MEDIUM');
                            trainActive = false;
                            trainBtn.classList.remove('active-train');
                            consoleDiv.classList.remove('active-train');
                            return;
                        }
                    }
                    if (!inputData) {
                        logError('Train Error: No input data provided', 'Provide an API URL or upload a file.', '', 'HIGH');
                        trainActive = false;
                        trainBtn.classList.remove('active-train');
                        consoleDiv.classList.remove('active-train');
                        return;
                    }
                    logMessage('Train: Starting training for all vials...', true);
                    vials.forEach(vial => {
                        if (vial.status === 'running') {
                            const vialAgent = new VialAgent(vial.name);
                            const { status, latency, codeLength } = vialAgent.train(inputData);
                            vial.latencyHistory.push(latency);
                            vial.code = inputData;
                            vial.codeLength = codeLength;
                            if (vial.latencyHistory.length > 20) vial.latencyHistory.shift();
                            logMessage(`Train: ${vial.name} - ${status} (Latency: ${latency.toFixed(2)}ms, Code Length: ${codeLength} chars)`, true);
                        }
                    });
                    trainTimeout = setTimeout(() => {
                        logMessage('Train: Training completed for all vials.', true);
                        clearTrain();
                    }, 3000);
                } else {
                    clearTrain();
                }
            } catch (err) {
                logError(`Train Error: ${err.message}`, 'Check training logic or input data.', err.stack, 'CRITICAL');
            }
        }

        function destroyAllVials() {
            try {
                logQueue = ['Vial MCP Controller: Create Vial: Initialize new vial | Troubleshoot: Debug vial errors | Monitor: Toggle latency monitoring | Train: Start vial training | VOID: Destroy all vials | Export: Save all vials as .md'];
                vials = [
                    { name: 'vial1', latencyHistory: [], status: 'stopped', code: '', filePath: '', createdAt: '', codeLength: 0 },
                    { name: 'vial2', latencyHistory: [], status: 'stopped', code: '', filePath: '', createdAt: '', codeLength: 0 },
                    { name: 'vial3', latencyHistory: [], status: 'stopped', code: '', filePath: '', createdAt: '', codeLength: 0 },
                    { name: 'vial4', latencyHistory: [], status: 'stopped', code: '', filePath: '', createdAt: '', codeLength: 0 }
                ];
                updateVialStatsUI();
                updateConsole();
                logMessage('All vials destroyed and console reset.', true);
                clearMonitor();
                clearTrain();
            } catch (err) {
                logError(`Destroy Vials Error: ${err.message}`, 'Check vial reset logic.', err.stack, 'HIGH');
            }
        }

        function voidVials() {
            try {
                serverLog('VOID button clicked');
                destroyAllVials();
                triggerGlow();
                flashRedGlow();
            } catch (err) {
                logError(`VOID Error: ${err.message}`, 'Check vial reset logic.', err.stack, 'HIGH');
            }
        }

        function saveVialAsMarkdown() {
            try {
                serverLog('Export Vials button clicked');
                const content = vials.map(vial => {
                    const avgLatency = vial.latencyHistory.length > 0 
                        ? (vial.latencyHistory.reduce((a, b) => a + b, 0) / vial.latencyHistory.length).toFixed(2)
                        : '0.00';
                    return `# Vial Agent: ${vial.name}\n\n` +
                           `**Status**: ${vial.status}\n` +
                           `**Created**: ${vial.createdAt || 'Not created'}\n` +
                           `**File Path**: ${vial.filePath || 'Not generated'}\n` +
                           `**Code**: \n\`\`\`\n${vial.code || 'No code provided'}\n\`\`\`\n` +
                           `**Latency History**: ${vial.latencyHistory.map(l => l.toFixed(2)).join(', ')} ms\n` +
                           `**Average Latency**: ${avgLatency} ms\n` +
                           `**Code Length**: ${vial.codeLength || 0} chars\n` +
                           `**Training**: Integrated with WebXOS (webxos.netlify.app)\n` +
                           `**API Endpoints**:\n- Input: /api/input\n- Output: /api/output/${vial.name}\n` +
                           `**Usage**: Edit this file to customize the vial agent, then use WebXOS tools to train and deploy.\n\n`;
                }).join('---\n\n');
                if (!content) {
                    logError('Export Error: No vials to export', 'Create a vial first.', '', 'HIGH');
                    return;
                }
                const blob = new Blob([content], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `vial_export_${new Date().toISOString().replace(/[:.]/g, '-')}.md`;
                a.click();
                URL.revokeObjectURL(url);
                logMessage('Exported all vials as .md file.', true);
                triggerGlow();
            } catch (err) {
                logError(`Export Error: ${err.message}`, 'Check browser permissions or vial status.', err.stack, 'HIGH');
            }
        }

        function updateVialStatsUI() {
            try {
                if (!vialStatsDiv) {
                    logError(`Update UI Error: vial-stats DOM element missing`, 'Check HTML structure for id="vial-stats".', '', 'CRITICAL');
                    return;
                }
                vialStatsDiv.innerHTML = vials.slice(0, 4).map((vial, index) => `
                    <div class="progress-container">
                        <span class="progress-label">Vial ${index + 1}:</span>
                        <div class="progress-bar"><div class="progress-fill" id="vial${index + 1}-bar" style="width: 0%"></div></div>
                        <span id="vial${index + 1}-value">0 ms</span>
                    </div>
                `).join('');
            } catch (err) {
                logError(`Update UI Error: ${err.message}`, 'Check DOM elements or JavaScript execution.', err.stack, 'HIGH');
            }
        }

        function setupEventListeners() {
            try {
                const buttons = {
                    'create-vial-btn': createVial,
                    'troubleshoot-btn': troubleshootVials,
                    'monitor-btn': toggleMonitor,
                    'train-btn': trainVials,
                    'void-btn': voidVials,
                    'export-btn': saveVialAsMarkdown
                };
                for (const [id, handler] of Object.entries(buttons)) {
                    const button = document.getElementById(id);
                    if (!button) {
                        logError(`Button Setup Error: ${id} not found`, `Check HTML structure for id="${id}".`, '', 'CRITICAL');
                        continue;
                    }
                    button.addEventListener('click', handler);
                    button.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        handler();
                    });
                }

                if (fileInput) {
                    fileInput.addEventListener('change', async () => {
                        try {
                            if (fileInput.files.length > 0) {
                                const file = fileInput.files[0];
                                inputResults.innerHTML = `<p>Uploaded file: ${file.name}</p>`;
                                serverLog(`File uploaded: ${file.name}`);
                            }
                        } catch (err) {
                            logError(`File Upload Error: ${err.message}`, 'Check file input or browser permissions.', err.stack, 'MEDIUM');
                            inputResults.innerHTML = `<p class="error">Error uploading file: ${err.message}</p>`;
                        }
                    });
                } else {
                    logError(`File Input Error: file-input not found`, 'Check HTML structure for id="file-input".', '', 'CRITICAL');
                }

                if (apiInput) {
                    apiInput.addEventListener('change', () => {
                        try {
                            const input = apiInput.value.trim();
                            if (input) {
                                inputResults.innerHTML = `<p>Submitted API URL: ${input}</p>`;
                                serverLog(`API URL input: ${input}`);
                            }
                        } catch (err) {
                            logError(`API Input Error: ${err.message}`, 'Check input field or JavaScript execution.', err.stack, 'MEDIUM');
                        }
                    });
                } else {
                    logError(`API Input Error: api-input not found`, 'Check HTML structure for id="api-input".', '', 'CRITICAL');
                }

                document.addEventListener('keydown', e => {
                    try {
                        serverLog(`Key pressed: ${e.key}`);
                        if (e.key === 'Enter' || e.key === ' ') troubleshootVials();
                        else if (e.key === 'm' || e.key === 'M') toggleMonitor();
                        else if (e.key === 't' || e.key === 'T') trainVials();
                        else if (e.key === 'v' || e.key === 'V') voidVials();
                        else if (e.key === 'c' || e.key === 'C') createVial();
                        else if (e.key === 'e' || e.key === 'E') saveVialAsMarkdown();
                    } catch (err) {
                        logError(`Keydown Error: ${err.message}`, 'Check key event handling.', err.stack, 'MEDIUM');
                    }
                });

                window.addEventListener('beforeunload', () => {
                    serverLog('Page closing, destroying all vials');
                    destroyAllVials();
                });

                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        serverLog('Tab inactive, simulating connection loss');
                        destroyAllVials();
                        logMessage('Connection lost: All vials destroyed due to tab inactivity. Export vials to save them.', true);
                    }
                });
            } catch (err) {
                logError(`Event Listener Setup Error: ${err.message}`, 'Check DOM element IDs or JavaScript execution.', err.stack, 'CRITICAL');
            }
        }

        window.addEventListener('load', () => {
            try {
                logMessage('Vial MCP Controller: Create Vial: Initialize new vial | Troubleshoot: Debug vial errors | Monitor: Toggle latency monitoring | Train: Start vial training | VOID: Destroy all vials | Export: Save all vials as .md', true);
                setupEventListeners();
                logMessage('Vial MCP Controller initialized successfully.', true);
            } catch (err) {
                logError(`Initialization Error: ${err.message}`, 'Check JavaScript execution or HTML structure.', err.stack, 'CRITICAL');
            }
        });
    </script>
</body>
</html>
