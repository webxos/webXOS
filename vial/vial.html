<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vial MCP Controller</title>
    <link rel="icon" href="/static/icon.png">
    <link rel="manifest" href="/static/manifest.json">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: monospace, sans-serif;
        }

        html, body {
            height: 100vh;
            overflow: hidden;
            background: #000 !important;
            color: #0f0 !important;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: background 0.3s, box-shadow 0.3s;
            -webkit-tap-highlight-color: transparent;
        }

        body.glow {
            background: rgba(255, 0, 0, 0.1) !important;
            box-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000 inset;
        }

        h1 {
            font-size: 1.6rem;
            text-align: center;
            margin: 0.8rem 0;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 0 5px #0f0;
            color: #0f0 !important;
        }

        #console {
            width: 90%;
            max-width: 900px;
            background: rgba(0, 255, 0, 0.1) !important;
            border: 1px solid #0f0;
            padding: 0.6rem;
            flex: 1;
            max-height: calc(100vh - 280px);
            overflow-y: auto;
            margin: 0.5rem 0;
            border-radius: 5px;
            font-size: 0.8rem;
            -webkit-overflow-scrolling: touch;
            transition: border-color 0.3s, box-shadow 0.3s;
        }

        #console.active-monitor {
            border-color: #ff0000 !important;
            box-shadow: 0 0 10px #ff0000;
        }

        #console p {
            margin: 0.2rem 0;
            color: #0f0 !important;
        }

        #console .command {
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            text-shadow: 0 0 3px #0f0;
        }

        #console .error {
            color: #ff0000 !important;
            text-shadow: 0 0 3px #ff0000;
        }

        .button-group {
            display: flex;
            gap: 0.5rem;
            margin: 0.5rem 0;
            padding: 0.5rem;
            flex-wrap: wrap;
            justify-content: center;
            width: 90%;
            max-width: 900px;
        }

        button {
            background: #0f0 !important;
            color: #000 !important;
            border: none;
            padding: 0.6rem 1.2rem;
            font-size: 0.9rem;
            cursor: pointer;
            border-radius: 3px;
            min-width: 90px;
            text-align: center;
            touch-action: manipulation;
            transition: background 0.3s, box-shadow 0.3s;
        }

        button:hover, button:focus {
            background: #0c0 !important;
            outline: 2px solid #0f0;
        }

        button.active-monitor {
            background: #ff0000 !important;
            box-shadow: 0 0 10px #ff0000;
        }

        button:disabled {
            background: #666 !important;
            cursor: not-allowed;
        }

        #vial-stats {
            width: 90%;
            max-width: 900px;
            margin: 0.5rem 0;
            display: flex;
            flex-direction: column;
            gap: 0.2rem;
        }

        .progress-container {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .progress-label {
            width: 90px;
            font-size: 0.75rem;
            color: #0f0 !important;
        }

        .progress-bar {
            flex: 1;
            height: 8px;
            background: #333 !important;
            border: 1px solid #0f0;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #0f0 !important;
            transition: width 0.5s;
        }

        #input-container {
            width: 90%;
            max-width: 900px;
            margin: 0.5rem 0;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        #file-input, #api-input {
            width: 100%;
            padding: 0.5rem;
            background: #000 !important;
            color: #0f0 !important;
            border: 1px solid #0f0;
            border-radius: 3px;
            font-size: 0.8rem;
        }

        #input-results {
            margin-top: 0.5rem;
            max-height: 100px;
            overflow-y: auto;
            font-size: 0.8rem;
            color: #0f0 !important;
        }

        #input-results .error {
            color: #ff0000 !important;
        }

        footer {
            width: 100%;
            padding: 0.4rem;
            font-size: 9pt;
            text-align: center;
            color: #0f0 !important;
            background: rgba(0, 0, 0, 0.8) !important;
            line-height: 1.2;
        }

        @media (max-width: 600px) {
            h1 { font-size: 1.1rem; margin: 0.5rem 0; }
            #console { 
                font-size: 0.75rem; 
                padding: 0.5rem; 
                max-height: calc(100vh - 300px); 
            }
            button { 
                padding: 0.5rem 1rem; 
                font-size: 0.85rem; 
                min-width: 80px; 
            }
            #file-input, #api-input { font-size: 0.75rem; }
            footer { padding: 0.3rem; }
            .progress-label { width: 70px; font-size: 0.7rem; }
            .progress-bar { height: 7px; }
        }

        @media (max-width: 400px) {
            .button-group { flex-direction: column; align-items: center; }
            button { width: 100%; max-width: 160px; }
            #console { max-height: calc(100vh - 260px); }
            #vial-stats { gap: 0.15rem; }
        }
    </style>
</head>
<body>
    <h1 role="heading" aria-level="1">Vial MCP Controller</h1>
    <div id="input-container">
        <input id="file-input" type="file" accept=".html,.css,.js,.py" aria-label="Upload code file for vial training">
        <input id="api-input" type="text" placeholder="Enter API URL for vial training (webxos.netlify.app)" aria-label="Enter API URL for vial training">
        <div id="input-results"></div>
    </div>
    <div id="console" role="log" aria-live="polite">
        <p>Vial MCP Controller: Create Vial: Initialize new vial | Troubleshoot: Debug vial errors | Monitor: Toggle latency monitoring | VOID: Destroy all vials | Export: Save vial as .md</p>
    </div>
    <div id="vial-stats">
        <div class="progress-container">
            <span class="progress-label">Vial 1:</span>
            <div class="progress-bar"><div class="progress-fill" id="vial1-bar" style="width: 0%"></div></div>
            <span id="vial1-value">0 ms</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">Vial 2:</span>
            <div class="progress-bar"><div class="progress-fill" id="vial2-bar" style="width: 0%"></div></div>
            <span id="vial1-value">0 ms</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">Vial 3:</span>
            <div class="progress-bar"><div class="progress-fill" id="vial3-bar" style="width: 0%"></div></div>
            <span id="vial1-value">0 ms</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">Vial 4:</span>
            <div class="progress-bar"><div class="progress-fill" id="vial4-bar" style="width: 0%"></div></div>
            <span id="vial1-value">0 ms</span>
        </div>
    </div>
    <div class="button-group">
        <button id="create-vial-btn" aria-label="Create new vial">Create Vial</button>
        <button id="troubleshoot-btn" aria-label="Troubleshoot vial errors">Troubleshoot</button>
        <button id="monitor-btn" aria-label="Toggle real-time latency monitoring">Monitor</button>
        <button id="void-btn" aria-label="Destroy all vials and reset">VOID</button>
        <button id="export-btn" aria-label="Export vial as markdown">Export Vial</button>
    </div>
    <footer>
        Â© 2025 WebXOS - Vial MCP Controller<br>
        Create Vial: Initialize new vial | Troubleshoot: Debug vial errors | Monitor: Toggle latency monitoring | VOID: Destroy all vials | Export: Save vial as .md
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/socket.io@4.7.5/dist/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
    <script src="https://cdn.pyodide.org/v0.26.2/full/pyodide.js"></script>
    <script src="/static/vial_network.js?t=<%= Date.now() %>"></script>
    <script type="module">
        let socket = null;
        let serverRunning = false;
        const consoleDiv = document.getElementById('console');
        const fileInput = document.getElementById('file-input');
        const apiInput = document.getElementById('api-input');
        const inputResults = document.getElementById('input-results');
        let logQueue = [];
        let monitorActive = false;
        let monitorInterval = null;
        let vials = [
            { name: 'vial1', latencyHistory: [], status: 'stopped', code: '', filePath: '' },
            { name: 'vial2', latencyHistory: [], status: 'stopped', code: '', filePath: '' },
            { name: 'vial3', latencyHistory: [], status: 'stopped', code: '', filePath: '' },
            { name: 'vial4', latencyHistory: [], status: 'stopped', code: '', filePath: '' }
        ];
        let token = null;
        let pyodide = null;

        function serverLog(message) {
            console.log(`[VIAL] ${message}`);
        }

        function logMessage(message, isCommand = false) {
            const timestamp = new Date().toISOString();
            const formattedMessage = isCommand 
                ? `<span class="command">${message}</span>`
                : message;
            logQueue.push(`[${timestamp}] ${formattedMessage}`);
            if (logQueue.length > 50) logQueue.shift();
            throttleConsoleUpdate();
        }

        function logError(message, analysis, stack = '') {
            const timestamp = new Date().toISOString();
            logQueue.push(`[${timestamp}] <span class="error">${message}<br>Analysis: ${analysis}<br>Traceback: ${stack || 'No stack available'}</span>`);
            if (logQueue.length > 50) logQueue.shift();
            throttleConsoleUpdate();
            flashRedGlow();
        }

        const throttleConsoleUpdate = (() => {
            let timeout;
            return () => {
                if (!timeout) {
                    timeout = setTimeout(() => {
                        consoleDiv.innerHTML = logQueue.map(msg => `<p>${msg}</p>`).join('');
                        consoleDiv.scrollTop = consoleDiv.scrollHeight;
                        timeout = null;
                    }, 100);
                }
            };
        })();

        function triggerGlow() {
            document.body.classList.add('glow');
            setTimeout(() => document.body.classList.remove('glow'), 1000);
        }

        function flashRedGlow() {
            consoleDiv.classList.add('active-monitor');
            setTimeout(() => consoleDiv.classList.remove('active-monitor'), 500);
            setTimeout(() => {
                consoleDiv.classList.add('active-monitor');
                setTimeout(() => consoleDiv.classList.remove('active-monitor'), 500);
            }, 1000);
        }

        async function initPyodide() {
            try {
                pyodide = await window.loadPyodide();
                await pyodide.loadPackage(['micropip']);
                await pyodide.runPythonAsync(`
                    import micropip
                    await micropip.install('numpy')
                `);
                logMessage('[VIAL] Pyodide initialized with numpy', true);
            } catch (err) {
                logError(`Pyodide Init Error: ${err.message}`, 'Check Pyodide CDN or browser compatibility.', err.stack);
            }
        }

        async function getToken() {
            try {
                const response = await fetch('/api/auth/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username: 'user', password: 'pass' })
                });
                const data = await response.json();
                if (data.token) {
                    token = data.token;
                    localStorage.setItem('token', token);
                    logMessage('Authentication successful', true);
                } else {
                    throw new Error('Authentication failed');
                }
            } catch (err) {
                logError(`Auth Error: ${err.message}`, 'Check credentials or server status.', err.stack);
            }
        }

        async function createVial() {
            try {
                serverLog('Create Vial button clicked');
                const activeVials = vials.filter(v => v.status === 'running').length;
                if (activeVials >= 4) {
                    logError('Vial Creation Error: Maximum 4 vials allowed per session', 'VOID existing vials to create new ones.', '');
                    return;
                }
                if (!token) await getToken();
                if (!token) throw new Error('No valid token available');
                if (!socket || socket.disconnected) {
                    socket = io('ws://localhost:8080', { 
                        transports: ['websocket'], 
                        reconnectionAttempts: 3,
                        timeout: 10000,
                        auth: { token }
                    });
                }

                socket.on('connect', () => {
                    logMessage('Connected to Vial MCP server.', true);
                    serverRunning = true;
                    const codeInput = apiInput.value.trim();
                    let fileContent = '';
                    if (fileInput.files.length > 0) {
                        try {
                            fileContent = await fileInput.files[0].text();
                            inputResults.innerHTML = `<p>Uploaded file: ${fileInput.files[0].name}</p>`;
                        } catch (err) {
                            logError(`File Read Error: ${err.message}`, 'Check file format or browser permissions.', err.stack);
                            return;
                        }
                    }
                    socket.emit('create-vial', { code: codeInput || fileContent || 'default' });
                });

                socket.on('connect_error', (err) => {
                    logError(`Connection Error: ${err.message}`, 'Check server availability at ws://localhost:8080 or authentication token.', err.stack);
                    serverRunning = false;
                });

                socket.on('vial-created', async (data) => {
                    logMessage(`[VIAL] Vial ${data.vialId} created at /webxos/vial/lab/vial${data.vialId}.js with stats: Latency ${data.latency.toFixed(2)}ms`, true);
                    triggerGlow();
                    try {
                        await VialNetworkModule();
                        const model = await tf.loadLayersModel('https://webxos.netlify.app/models/vial_model.json').catch(err => {
                            throw new Error(`Model Load Error: ${err.message}`);
                        });
                        const inputTensor = tf.tensor([1.0]);
                        const result = await model.predict(inputTensor).dataSync()[0];
                        logMessage(`Vial ${data.vialId} tested with WebXOS: ${result.toFixed(2)}`, true);
                        if (pyodide && data.code.endsWith('.py')) {
                            try {
                                const pyResult = await pyodide.runPythonAsync(data.code);
                                logMessage(`Python Execution Result: ${pyResult}`, true);
                            } catch (pyErr) {
                                logError(`Python Execution Error: ${pyErr.message}`, 'Check Python syntax.', pyErr.stack);
                            }
                        }
                        const vialIndex = vials.findIndex(v => v.status === 'stopped');
                        if (vialIndex !== -1) {
                            vials[vialIndex].name = data.vialId;
                            vials[vialIndex].status = 'running';
                            vials[vialIndex].code = data.code;
                            vials[vialIndex].filePath = `/webxos/vial/lab/vial${data.vialId}.js`;
                            updateVialStatsUI();
                        } else {
                            logError(`Vial Creation Error: No available slots`, 'Maximum 4 vials allowed. VOID existing vials.', '');
                        }
                    } catch (err) {
                        logError(`Vial Network Error: ${err.message}`, 'Ensure /static/vial_network.wasm or WebXOS model is accessible.', err.stack);
                    }
                });

                socket.on('vial-status', (data) => {
                    const vialIndex = vials.findIndex(v => v.name === data.vial);
                    if (vialIndex !== -1) {
                        const latency = data.latency || 0;
                        vials[vialIndex].latencyHistory.push(latency);
                        vials[vialIndex].status = data.status;
                        if (vials[vialIndex].latencyHistory.length > 20) {
                            vials[vialIndex].latencyHistory.shift();
                        }
                        const bar = document.getElementById(`vial${vialIndex + 1}-bar`);
                        const value = document.getElementById(`vial${vialIndex + 1}-value`);
                        if (bar && value) {
                            bar.style.width = `${Math.min(100, latency / 2)}%`;
                            value.textContent = `${latency.toFixed(2)} ms`;
                        }
                        logMessage(`[VIAL] ${data.vial}: ${data.status} (Latency: ${latency.toFixed(2)}ms)`, true);
                    } else {
                        logError(`Vial Status Error: Vial ${data.vial} not found`, 'Check server vial data.', '');
                    }
                });

                socket.on('server-error', (data) => {
                    logError(`Server Error: ${data.message}`, data.analysis || 'Check server logs.', '');
                });

                socket.on('disconnect', () => {
                    logMessage('Disconnected from Vial MCP server.', true);
                    serverRunning = false;
                    clearMonitor();
                });
            } catch (err) {
                logError(`Create Vial Error: ${err.message}`, 'Check client-side configuration, authentication, or server logs.', err.stack);
            }
        }

        async function troubleshootVials() {
            try {
                serverLog('Troubleshoot button clicked');
                triggerGlow();
                flashRedGlow();
                if (!serverRunning || !socket || socket.disconnected) {
                    logError('Troubleshoot Error: Server not running', 'Create a vial first or check server connection.', '');
                    return;
                }
                document.getElementById('troubleshoot-btn').disabled = true;
                logMessage('Running vial troubleshooting...', true);
                let retries = 3;
                let success = false;

                while (retries > 0 && !success) {
                    try {
                        await new Promise((resolve, reject) => {
                            socket.emit('troubleshoot-vials');
                            socket.once('vial-status', (data) => {
                                logMessage(`Troubleshoot: ${data.vial} - ${data.status}`, true);
                                success = true;
                                resolve();
                            });
                            socket.once('server-error', (data) => {
                                reject(new Error(`${data.message}: ${data.analysis || 'Check server logs.'}`));
                            });
                            setTimeout(() => {
                                reject(new Error('Troubleshoot Timeout: Server response took too long.'));
                            }, 5000);
                        });
                    } catch (err) {
                        retries--;
                        if (retries === 0) {
                            logError(`Troubleshoot Failed: ${err.message}`, 'Check server logs or retry.', err.stack);
                        } else {
                            logMessage(`Troubleshoot Retry (${3 - retries}/3)...`, true);
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        }
                    }
                }
            } catch (err) {
                logError(`Troubleshoot Error: ${err.message}`, 'Verify server connection, authentication, or vial status.', err.stack);
            } finally {
                document.getElementById('troubleshoot-btn').disabled = false;
            }
        }

        async function updateVialStats() {
            try {
                if (!serverRunning || !socket || socket.disconnected) return;
                socket.emit('check-vials');
            } catch (err) {
                logError(`Monitor Error: ${err.message}`, 'Check server connection or authentication.', err.stack);
            }
        }

        function clearMonitor() {
            try {
                if (monitorActive) {
                    monitorActive = false;
                    clearInterval(monitorInterval);
                    const monitorBtn = document.getElementById('monitor-btn');
                    const consoleDiv = document.getElementById('console');
                    monitorBtn.classList.remove('active-monitor');
                    consoleDiv.classList.remove('active-monitor');
                    logMessage('Monitor: Real-time latency monitoring deactivated.', true);
                }
            } catch (err) {
                logError(`Clear Monitor Error: ${err.message}`, 'Check monitor state or DOM elements.', err.stack);
            }
        }

        async function toggleMonitor() {
            try {
                serverLog('Monitor button clicked');
                monitorActive = !monitorActive;
                const monitorBtn = document.getElementById('monitor-btn');
                const consoleDiv = document.getElementById('console');
                monitorBtn.classList.toggle('active-monitor', monitorActive);
                consoleDiv.classList.toggle('active-monitor', monitorActive);
                triggerGlow();
                flashRedGlow();

                if (monitorActive) {
                    if (!serverRunning || !socket || socket.disconnected) {
                        logError('Monitor Error: Server not running', 'Create a vial first.', '');
                        monitorActive = false;
                        monitorBtn.classList.remove('active-monitor');
                        consoleDiv.classList.remove('active-monitor');
                        return;
                    }
                    logMessage('Monitor: Real-time latency monitoring activated.', true);
                    await updateVialStats();
                    monitorInterval = setInterval(updateVialStats, 5000);
                } else {
                    clearMonitor();
                }
            } catch (err) {
                logError(`Monitor Error: ${err.message}`, 'Check client-side configuration or server connection.', err.stack);
            }
        }

        function voidVials() {
            try {
                serverLog('VOID button clicked');
                if (!serverRunning || !socket || socket.disconnected) {
                    logError('VOID Error: Server not running', 'No vials to destroy.', '');
                    return;
                }
                socket.emit('void-vials');
                logQueue = ['Vial MCP Controller: Create Vial: Initialize new vial | Troubleshoot: Debug vial errors | Monitor: Toggle latency monitoring | VOID: Destroy all vials | Export: Save vial as .md'];
                vials = [
                    { name: 'vial1', latencyHistory: [], status: 'stopped', code: '', filePath: '' },
                    { name: 'vial2', latencyHistory: [], status: 'stopped', code: '', filePath: '' },
                    { name: 'vial3', latencyHistory: [], status: 'stopped', code: '', filePath: '' },
                    { name: 'vial4', latencyHistory: [], status: 'stopped', code: '', filePath: '' }
                ];
                updateVialStatsUI();
                throttleConsoleUpdate();
                logMessage('All vials destroyed and console reset.', true);
                triggerGlow();
                flashRedGlow();
                serverRunning = false;
                if (socket) socket.disconnect();
            } catch (err) {
                logError(`VOID Error: ${err.message}`, 'Check server connection, authentication, or vial status.', err.stack);
            }
        }

        async function saveVialAsMarkdown() {
            try {
                serverLog('Export Vial button clicked');
                const activeVial = vials.find(v => v.status === 'running');
                if (!activeVial) {
                    logError('Export Error: No active vials to export', 'Create a vial first.', '');
                    return;
                }
                const content = `# Vial Agent: ${activeVial.name}\n\n` +
                                `**Status**: ${activeVial.status}\n` +
                                `**Created**: ${new Date().toISOString()}\n` +
                                `**File Path**: ${activeVial.filePath || 'Not generated'}\n` +
                                `**Code**: \n\`\`\`\n${activeVial.code || 'No code provided'}\n\`\`\`\n` +
                                `**Latency History**: ${activeVial.latencyHistory.map(l => l.toFixed(2)).join(', ')} ms\n` +
                                `**Training**: Integrated with WebXOS (webxos.netlify.app)\n` +
                                `**API Endpoints**:\n- Input: /api/input\n- Output: /api/output/${activeVial.name}\n` +
                                `**Usage**: Edit this file to customize the vial agent, then use WebXOS tools to train and deploy.`;
                const blob = new Blob([content], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${activeVial.name}.md`;
                a.click();
                URL.revokeObjectURL(url);
                logMessage(`Exported vial ${activeVial.name} as .md file.`, true);
                triggerGlow();
            } catch (err) {
                logError(`Export Error: ${err.message}`, 'Check vial status or browser permissions.', err.stack);
            }
        }

        function updateVialStatsUI() {
            try {
                const vialStatsDiv = document.getElementById('vial-stats');
                vialStatsDiv.innerHTML = vials.slice(0, 4).map((vial, index) => `
                    <div class="progress-container">
                        <span class="progress-label">Vial ${index + 1}:</span>
                        <div class="progress-bar"><div class="progress-fill" id="vial${index + 1}-bar" style="width: 0%"></div></div>
                        <span id="vial${index + 1}-value">0 ms</span>
                    </div>
                `).join('');
            } catch (err) {
                logError(`Update UI Error: ${err.message}`, 'Check DOM elements or JavaScript execution.', err.stack);
            }
        }

        const debounce = (func, wait) => {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => {
                    try {
                        func.apply(this, args);
                    } catch (err) {
                        logError(`Button Handler Error: ${err.message}`, `Check ${func.name} function.`, err.stack);
                    }
                }, wait);
            };
        };

        try {
            document.getElementById('create-vial-btn').addEventListener('click', debounce(createVial, 200));
            document.getElementById('troubleshoot-btn').addEventListener('click', debounce(troubleshootVials, 200));
            document.getElementById('monitor-btn').addEventListener('click', debounce(toggleMonitor, 200));
            document.getElementById('void-btn').addEventListener('click', debounce(voidVials, 200));
            document.getElementById('export-btn').addEventListener('click', debounce(saveVialAsMarkdown, 200));
        } catch (err) {
            logError(`Event Listener Error: ${err.message}`, 'Check DOM element IDs or JavaScript execution.', err.stack);
        }

        fileInput.addEventListener('change', async () => {
            try {
                if (fileInput.files.length > 0) {
                    const file = fileInput.files[0];
                    if (!token) await getToken();
                    if (!token) throw new Error('No valid token available');
                    const formData = new FormData();
                    formData.append('file', file);
                    formData.append('vialId', `vial${vials.length + 1}_${Date.now()}`);
                    const response = await fetch('/api/input', {
                        method: 'POST',
                        headers: { 'Authorization': `Bearer ${token}` },
                        body: formData
                    });
                    const data = await response.json();
                    inputResults.innerHTML = `<p>${data.message}</p>`;
                    serverLog(`File uploaded: ${file.name}`);
                }
            } catch (err) {
                logError(`File Upload Error: ${err.message}`, 'Check server connection or file format.', err.stack);
                inputResults.innerHTML = `<p class="error">Error uploading file: ${err.message}</p>`;
            }
        });

        apiInput.addEventListener('change', () => {
            try {
                const input = apiInput.value.trim();
                if (input) {
                    inputResults.innerHTML = `<p>Submitted API URL: ${input}</p>`;
                    serverLog(`API URL input: ${input}`);
                }
            } catch (err) {
                logError(`API Input Error: ${err.message}`, 'Check input field or JavaScript execution.', err.stack);
            }
        });

        document.addEventListener('keydown', e => {
            try {
                serverLog(`Key pressed: ${e.key}`);
                if (e.key === 'Enter' || e.key === ' ') troubleshootVials();
                else if (e.key === 'm' || e.key === 'M') toggleMonitor();
                else if (e.key === 'v' || e.key === 'V') voidVials();
                else if (e.key === 'c' || e.key === 'C') createVial();
                else if (e.key === 'e' || e.key === 'E') saveVialAsMarkdown();
            } catch (err) {
                logError(`Keydown Error: ${err.message}`, 'Check key event handling.', err.stack);
            }
        });

        window.addEventListener('load', async () => {
            try {
                logMessage('Vial MCP Controller: Create Vial: Initialize new vial | Troubleshoot: Debug vial errors | Monitor: Toggle latency monitoring | VOID: Destroy all vials | Export: Save vial as .md', true);
                await getToken();
                await VialNetworkModule();
                await initPyodide();
                logMessage('Vial Network and Pyodide modules loaded successfully.', true);
            } catch (err) {
                logError(`Initialization Error: ${err.message}`, 'Verify /static/vial_network.js, /static/vial_network.wasm, authentication, or server connection.', err.stack);
            }
        });
    </script>
</body>
</html>
