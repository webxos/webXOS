<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vial MCP Controller</title>
    <link rel="icon" href="/vial/static/icon.png" onerror="logError('Icon Load Error', 'Check /vial/static/icon.png', 'No stack', 'LOW')">
    <link rel="manifest" href="/vial/static/manifest.json" onerror="logError('Manifest Load Error', 'Check /vial/static/manifest.json', 'No stack', 'LOW')">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet" onerror="logError('Font Load Error', 'Check Google Fonts CDN or use local font', 'No stack', 'LOW')">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: monospace, sans-serif; }
        html, body { height: 100vh; overflow: hidden; background: #000 !important; color: #0f0 !important; display: flex; flex-direction: column; align-items: center; transition: background 0.3s, box-shadow 0.3s; -webkit-tap-highlight-color: transparent; touch-action: manipulation; }
        body.glow { background: rgba(255, 0, 0, 0.1) !important; box-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000 inset; }
        body.train-glow { background: rgba(255, 255, 0, 0.1) !important; box-shadow: 0 0 20px #ff0, 0 0 40px #ff0 inset; }
        h1 { font-size: 1.6rem; text-align: center; margin: 0.8rem 0; text-transform: uppercase; letter-spacing: 1px; text-shadow: 0 0 5px #0f0; color: #0f0 !important; }
        #console { width: 90%; max-width: 900px; background: rgba(0, 255, 0, 0.1) !important; border: 1px solid #0f0; padding: 0.6rem; flex: 1; max-height: calc(100vh - 300px); overflow-y: auto; margin: 0.5rem 0; border-radius: 5px; font-size: 0.8rem; -webkit-overflow-scrolling: touch; transition: border-color 0.3s, box-shadow 0.3s; white-space: pre-wrap; word-wrap: break-word; }
        #console.active-monitor { border-color: #ff0000 !important; box-shadow: 0 0 10px #ff0000; }
        #console.active-train { border-color: #ff0 !important; box-shadow: 0 0 10px #ff0; }
        #console p { margin: 0.2rem 0; color: #0f0 !important; }
        #console .command { font-family: 'Orbitron', monospace; font-weight: 700; text-shadow: 0 0 3px #0f0; }
        #console .error { color: #ff0000 !important; text-shadow: 0 0 3px #ff0000; }
        .button-group { display: flex; gap: 0.5rem; margin: 0.5rem 0; padding: 0.5rem; flex-wrap: wrap; justify-content: center; width: 90%; max-width: 900px; }
        button { background: #0f0 !important; color: #000 !important; border: none; padding: 0.6rem 1.2rem; font-size: 0.9rem; cursor: pointer; border-radius: 3px; min-width: 90px; text-align: center; touch-action: manipulation; transition: background 0.3s, box-shadow 0.3s; -webkit-user-select: none; user-select: none; }
        button:hover, button:focus, button:active { background: #0c0 !important; outline: 2px solid #0f0; }
        button.active-monitor { background: #ff0000 !important; box-shadow: 0 0 10px #ff0000; }
        button.active-train { background: #ff0 !important; color: #000 !important; box-shadow: 0 0 10px #ff0; }
        button:disabled { background: #666 !important; cursor: not-allowed; }
        #vial-stats { width: 90%; max-width: 900px; margin: 0.5rem 0; display: flex; flex-direction: column; gap: 0.2rem; }
        .progress-container { display: flex; align-items: center; gap: 0.4rem; }
        .progress-label { width: 90px; font-size: 0.75rem; color: #0f0 !important; }
        .progress-bar { flex: 1; height: 8px; background: #333 !important; border: 1px solid #0f0; border-radius: 3px; overflow: hidden; }
        .progress-fill { height: 100%; background: #0f0 !important; transition: width 0.5s; }
        #input-container { width: 90%; max-width: 900px; margin: 0.5rem 0; display: flex; flex-direction: column; gap: 0.5rem; }
        #file-input, #api-input { width: 100%; padding: 0.5rem; background: #000 !important; color: #0f0 !important; border: 1px solid #0f0; border-radius: 3px; font-size: 0.8rem; }
        #input-results { margin-top: 0.5rem; max-height: 100px; overflow-y: auto; font-size: 0.8rem; color: #0f0 !important; }
        #input-results .error { color: #ff0000 !important; }
        footer { width: 100%; padding: 0.4rem; font-size: 9pt; text-align: center; color: #0f0 !important; background: rgba(0, 0, 0, 0.8) !important; line-height: 1.2; }
        @media (max-width: 600px) {
            h1 { font-size: 1.1rem; margin: 0.5rem 0; }
            #console { font-size: 0.75rem; padding: 0.5rem; max-height: calc(100vh - 320px); }
            button { padding: 0.5rem 1rem; font-size: 0.85rem; min-width: 80px; }
            #file-input, #api-input { font-size: 0.75rem; }
            footer { padding: 0.3rem; }
            .progress-label { width: 70px; font-size: 0.7rem; }
            .progress-bar { height: 7px; }
        }
        @media (max-width: 400px) {
            .button-group { flex-direction: column; align-items: center; }
            button { width: 100%; max-width: 160px; }
            #console { max-height: calc(100vh - 280px); }
            #vial-stats { gap: 0.15rem; }
        }
    </style>
    <script>
        // Early definition of logError to prevent ReferenceError
        let errorLog = [], logQueue = ['<p>Vial MCP Controller initialized</p>'];
        function logError(message, analysis, stack, urgency) {
            const timestamp = new Date().toISOString();
            const errorMessage = `[${timestamp}] ERROR: ${message}\nAnalysis: ${analysis}\nTraceback: ${stack || 'No stack'}`;
            errorLog.push(errorMessage);
            logQueue.push(`<p class="error">${errorMessage}</p>`);
            if (logQueue.length > 50) logQueue.shift();
            const consoleDiv = document.getElementById('console');
            if (consoleDiv) {
                consoleDiv.innerHTML = logQueue.join('');
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }
            if (typeof worker !== 'undefined' && worker) {
                worker.postMessage({ action: 'saveErrorLog', content: errorLog.join('\n---\n') });
            }
        }
    </script>
    <script src="/vial/static/redaxios.min.js" onerror="logError('redaxios Load Error', 'Check /vial/static/redaxios.min.js or download from https://cdn.jsdelivr.net/npm/redaxios@0.5.1/dist/redaxios.min.js', 'No stack', 'CRITICAL')"></script>
    <script src="/vial/static/lz-string.min.js" onerror="logError('LZString Load Error', 'Check /vial/static/lz-string.min.js or download from https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js', 'No stack', 'CRITICAL')"></script>
    <script src="/vial/static/mustache.min.js" onerror="logError('Mustache Load Error', 'Check /vial/static/mustache.min.js or download from https://cdn.jsdelivr.net/npm/mustache@4.2.0/mustache.min.js', 'No stack', 'CRITICAL')"></script>
    <script src="/vial/static/dexie.min.js" onerror="logError('Dexie Load Error', 'Check /vial/static/dexie.min.js or download from https://cdn.jsdelivr.net/npm/dexie@3.2.4/dist/dexie.min.js', 'No stack', 'CRITICAL')"></script>
    <script src="/vial/static/jwt-decode.min.js" onerror="logError('jwt-decode Load Error', 'Check /vial/static/jwt-decode.min.js or download from https://cdn.jsdelivr.net/npm/jwt-decode@3.1.2/build/jwt-decode.min.js', 'No stack', 'CRITICAL')"></script>
    <script src="/vial/static/sql-wasm.wasm" type="application/wasm" onerror="logError('sql-wasm Load Error', 'Check /vial/static/sql-wasm.wasm or download from https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/dist/sql-wasm.wasm', 'No stack', 'CRITICAL')"></script>
    <script src="/vial/static/worker.js" onerror="logError('worker.js Load Error', 'Check /vial/static/worker.js or restore from /vial/src/worker.js', 'No stack', 'CRITICAL')"></script>
    <script>
        // Global state
        const API_BASE_URL = 'http://localhost:8080/mcp';
        const WS_URL = 'ws://localhost:8080/ws';
        let ws = null, monitorActive = false, trainActive = false, monitorInterval = null, trainTimeout = null;
        let vials = Array(4).fill().map((_, i) => ({ name: `vial${i+1}`, latencyHistory: [], status: 'stopped', code: '', filePath: '', createdAt: '', codeLength: 0 }));
        let isOnline = navigator.onLine, oauthToken = null;
        let db = null, isUpdatingConsole = false, worker = null;

        // Core logging functions
        function logEvent(event_type, message, metadata, urgency) {
            try {
                const timestamp = new Date().toISOString();
                const logData = { timestamp, event_type, message, metadata, urgency };
                if (worker) worker.postMessage({ action: 'log', data: logData });
                if (db) db.logs.add(logData).catch(err => logError(`Log Save Error: ${err.message}`, 'Check /vial/static/dexie.min.js:30 or browser IndexedDB support', err.stack || 'No stack', 'HIGH'));
                const compressedLog = typeof LZString !== 'undefined' ? LZString.compressToUTF16(JSON.stringify(logData)) : JSON.stringify(logData);
                if (isOnline && oauthToken && typeof redaxios !== 'undefined') {
                    redaxios.post(`${API_BASE_URL}/log-sync`, { log: compressedLog }, { headers: { Authorization: `Bearer ${oauthToken}` } })
                        .catch(err => logError(`Log Sync Error: ${err.message}`, 'Check /vial/src/log_manager.js:50 or network connectivity', err.stack || 'No stack', 'HIGH'));
                } else if (db) {
                    db.logs.add({ ...logData, synced: false }).catch(err => logError(`Log Save Error: ${err.message}`, 'Check /vial/static/dexie.min.js:30 or browser IndexedDB support', err.stack || 'No stack', 'HIGH'));
                }
                logQueue.push(`<p class="${event_type === 'error' ? 'error' : 'command'}">[${timestamp}] ${message}</p>`);
                if (logQueue.length > 50) logQueue.shift();
                debouncedUpdateConsole();
            } catch (err) {
                logError(`Log Error: ${err.message}`, 'Check /vial/src/log_manager.js:20 or worker initialization', err.stack || 'No stack', 'CRITICAL');
            }
        }

        function debounce(func, wait) {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func(...args), wait);
            };
        }

        const debouncedUpdateConsole = debounce((logs = null) => {
            if (isUpdatingConsole) return;
            isUpdatingConsole = true;
            const consoleDiv = document.getElementById('console');
            if (consoleDiv) {
                consoleDiv.innerHTML = logs ? (typeof Mustache !== 'undefined' ? Mustache.render('{{#logs}}<p>{{message}}</p>{{/logs}}', { logs }) : '<p>Error: Mustache not loaded</p>') : logQueue.join('');
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            } else {
                logError(`Console Div Missing`, 'Check /vial/static/vial.html:50 for <div id="console">', 'No stack', 'CRITICAL');
            }
            isUpdatingConsole = false;
        }, 100);

        // Dependency checks
        const dependencies = [
            { name: 'redaxios', check: () => typeof redaxios !== 'undefined', path: '/vial/static/redaxios.min.js', cdn: 'https://cdn.jsdelivr.net/npm/redaxios@0.5.1/dist/redaxios.min.js', line: 10 },
            { name: 'LZString', check: () => typeof LZString !== 'undefined', path: '/vial/static/lz-string.min.js', cdn: 'https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js', line: 10 },
            { name: 'Mustache', check: () => typeof Mustache !== 'undefined', path: '/vial/static/mustache.min.js', cdn: 'https://cdn.jsdelivr.net/npm/mustache@4.2.0/mustache.min.js', line: 10 },
            { name: 'Dexie', check: () => typeof Dexie !== 'undefined', path: '/vial/static/dexie.min.js', cdn: 'https://cdn.jsdelivr.net/npm/dexie@3.2.4/dist/dexie.min.js', line: 10 },
            { name: 'jwt_decode', check: () => typeof jwt_decode !== 'undefined', path: '/vial/static/jwt-decode.min.js', cdn: 'https://cdn.jsdelivr.net/npm/jwt-decode@3.1.2/build/jwt-decode.min.js', line: 10 },
            { name: 'sql-wasm', check: () => typeof SQL !== 'undefined', path: '/vial/static/sql-wasm.wasm', cdn: 'https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/dist/sql-wasm.wasm', line: 10 },
            { name: 'worker', check: () => typeof Worker !== 'undefined', path: '/vial/static/worker.js', cdn: 'N/A (restore from /vial/src/worker.js)', line: 10 }
        ];

        async function initWorker() {
            try {
                const workerResponse = await fetch('/vial/static/worker.js', { method: 'HEAD' });
                if (!workerResponse.ok) throw new Error('Worker script not found');
                worker = new Worker('/vial/static/worker.js');
                worker.onmessage = (e) => {
                    const { status, logs, message } = e.data;
                    if (status === 'initialized') logEvent('system', 'SQLite initialized', { component: 'worker' }, 'LOW');
                    else if (status === 'logs') debouncedUpdateConsole(logs);
                    else if (status === 'error') logError(`Worker Error: ${message}`, 'Check /vial/static/worker.js:15', message.stack || 'No stack', 'HIGH');
                };
                worker.postMessage({ action: 'init' });
            } catch (err) {
                logError(`Worker Init Error: ${err.message}`, 'Check /vial/static/worker.js:10 or restore from /vial/src/worker.js', err.stack || 'No stack', 'CRITICAL');
            }
        }

        function initializeWebSocket() {
            if (!isOnline || !oauthToken) {
                logEvent('websocket', 'WebSocket skipped due to offline mode or missing token', {}, 'INFO');
                return;
            }
            try {
                ws = new WebSocket(`${WS_URL}?token=${encodeURIComponent(oauthToken)}`);
                ws.onopen = () => { logEvent('websocket', 'Connected', { url: WS_URL }, 'INFO'); isOnline = true; };
                ws.onmessage = (e) => {
                    try {
                        const { event_type, message, metadata } = JSON.parse(e.data);
                        logEvent(event_type, message, metadata, 'INFO');
                        updateVialStatsUI();
                    } catch (err) {
                        logError(`WebSocket Message Error: ${err.message}`, 'Check /vial/src/server.js:100 for WebSocket parsing', err.stack || 'No stack', 'HIGH');
                    }
                };
                ws.onerror = (e) => { logError('WebSocket Error', 'Check /vial/src/server.js:90 or network', e.message, 'HIGH'); isOnline = false; };
                ws.onclose = () => { logEvent('websocket', 'Disconnected', {}, 'HIGH'); isOnline = false; setTimeout(initializeWebSocket, 5000); };
            } catch (err) {
                logError(`WebSocket Init Error: ${err.message}`, 'Check /vial/src/server.js:80, OAuth, or network', err.stack || 'No stack', 'HIGH');
            }
        }

        async function authenticateOAuth() {
            if (!isOnline || typeof redaxios === 'undefined') {
                oauthToken = 'anonymous';
                logEvent('auth', 'Using anonymous token due to offline mode or missing redaxios', {}, 'INFO');
                return false;
            }
            try {
                const storedToken = localStorage.getItem('mcp_token');
                if (storedToken && typeof jwt_decode !== 'undefined' && jwt_decode(storedToken).exp * 1000 > Date.now()) {
                    oauthToken = storedToken;
                    initializeWebSocket();
                    logEvent('auth', 'OAuth token loaded from localStorage', { token: oauthToken.slice(0, 10) + '...' }, 'INFO');
                    return true;
                }
                const res = await redaxios.post(`${API_BASE_URL}/auth`, { token: storedToken || 'anonymous' });
                oauthToken = res.data.token || 'anonymous';
                localStorage.setItem('mcp_token', oauthToken);
                initializeWebSocket();
                logEvent('auth', 'OAuth authenticated', { token: oauthToken.slice(0, 10) + '...' }, 'INFO');
                return true;
            } catch (err) {
                oauthToken = 'anonymous';
                logError(`OAuth Error: ${err.message}`, 'Check /vial/src/oauth.js:30, /vial/mcp.json:10, or network', err.stack || 'No stack', 'HIGH');
                initializeWebSocket();
                return false;
            }
        }

        async function systemDiagnostics() {
            try {
                logEvent('diagnostics', 'Starting system diagnostics', {}, 'INFO');
                const checks = [
                    { name: 'Network', test: () => navigator.onLine, error: 'Offline mode detected', analysis: 'Check network connection', file: 'N/A', line: 0 },
                    { name: 'WebSocket', test: () => ws?.readyState === WebSocket.OPEN, error: 'WebSocket disconnected', analysis: 'Check /vial/src/server.js:90 or network', file: '/vial/src/server.js', line: 90 },
                    { name: 'OAuth', test: () => !!oauthToken && oauthToken !== 'anonymous' && typeof jwt_decode !== 'undefined' && jwt_decode(oauthToken).exp * 1000 > Date.now(), error: 'Invalid or expired OAuth token', analysis: 'Check /vial/src/oauth.js:30 or /vial/mcp.json:10', file: '/vial/src/oauth.js', line: 30 },
                    { name: 'Worker', test: () => !!worker, error: 'Web Worker not initialized', analysis: 'Check /vial/static/worker.js:10 or restore from /vial/src/worker.js', file: '/vial/static/worker.js', line: 10 },
                    { name: 'Dexie', test: async () => typeof Dexie !== 'undefined' && window.indexedDB, error: 'IndexedDB not supported or Dexie not loaded', analysis: 'Check /vial/static/dexie.min.js:30 or browser support', file: '/vial/static/dexie.min.js', line: 30 },
                    { name: 'Files', test: async () => {
                        const files = [
                            { path: '/vial/static/redaxios.min.js', line: 10 },
                            { path: '/vial/static/lz-string.min.js', line: 10 },
                            { path: '/vial/static/mustache.min.js', line: 10 },
                            { path: '/vial/static/dexie.min.js', line: 10 },
                            { path: '/vial/static/jwt-decode.min.js', line: 10 },
                            { path: '/vial/static/sql-wasm.wasm', line: 10 },
                            { path: '/vial/static/worker.js', line: 10 },
                            { path: '/vial/static/icon.png', line: 0 },
                            { path: '/vial/static/manifest.json', line: 0 }
                        ];
                        for (const file of files) {
                            try {
                                const res = await fetch(file.path, { method: 'HEAD' });
                                if (!res.ok) throw new Error(`Missing file: ${file.path}`);
                            } catch (e) {
                                throw new Error(`File check failed: ${file.path}`);
                            }
                        }
                        return true;
                    }, error: 'Missing static files', analysis: 'Check /vial/static/ or download from CDNs in /vial/cdn-links.md', file: '/vial/static/', line: 0 },
                    { name: 'API', test: async () => {
                        if (!isOnline || !oauthToken || oauthToken === 'anonymous' || typeof redaxios === 'undefined') return false;
                        const res = await redaxios.get(`${API_BASE_URL}/health`, { headers: { Authorization: `Bearer ${oauthToken}` } });
                        return res.status === 200;
                    }, error: 'API health check failed', analysis: 'Check /vial/src/server.js:50 or network', file: '/vial/src/server.js', line: 50 }
                ];
                for (const { name, test, error, analysis, file, line } of checks) {
                    try {
                        if (await test()) {
                            logEvent('diagnostics', `${name} check passed`, {}, 'INFO');
                        } else {
                            throw new Error(error);
                        }
                    } catch (err) {
                        logError(`${name} Failure: ${err.message}`, `${analysis} at ${file}:${line}`, err.stack || 'No stack', 'HIGH');
                    }
                }
                if (isOnline && oauthToken && oauthToken !== 'anonymous' && typeof redaxios !== 'undefined') {
                    try {
                        const res = await redaxios.get(`${API_BASE_URL}/diagnostics`, { headers: { Authorization: `Bearer ${oauthToken}` } });
                        res.data.issues?.forEach(issue => logError(`Server Issue: ${issue.message}`, `${issue.analysis || 'Check /vial/src/server.js:60'} at /vial/src/server.js:60`, issue.stack || 'No stack', 'HIGH'));
                        logEvent('diagnostics', 'Diagnostics complete', { issues: res.data.issues?.length || 0 }, 'INFO');
                    } catch (err) {
                        logError(`Server Diagnostics Error: ${err.message}`, 'Check /vial/src/diagnostics.js:40 or network', err.stack || 'No stack', 'HIGH');
                    }
                } else {
                    logEvent('diagnostics', 'Diagnostics skipped server checks due to offline mode or anonymous token', {}, 'INFO');
                }
            } catch (err) {
                logError(`Diagnostics Error: ${err.message}`, 'Check /vial/src/diagnostics.js:20 or network', err.stack || 'No stack', 'HIGH');
            }
        }

        async function createVial() {
            try {
                logEvent('vial', 'Attempting to authenticate and create vial', {}, 'INFO');
                const authSuccess = await authenticateOAuth();
                if (!authSuccess) {
                    logError('Create Vial Error: Authentication failed', 'Check /vial/src/oauth.js:30, /vial/mcp.json:10, or network', 'No stack', 'HIGH');
                    return;
                }
                if (typeof redaxios === 'undefined') {
                    logError('Create Vial Error: redaxios not defined', 'Check /vial/static/redaxios.min.js:10 or download from https://cdn.jsdelivr.net/npm/redaxios@0.5.1/dist/redaxios.min.js', 'No stack', 'CRITICAL');
                    return;
                }
                const activeVials = vials.filter(v => v.status === 'running').length;
                if (activeVials >= 4) {
                    logError('Create Vial Error: Maximum 4 vials', 'Destroy vials using VOID button', 'No stack', 'HIGH');
                    return;
                }
                const vialIndex = vials.findIndex(v => v.status === 'stopped');
                if (vialIndex === -1) {
                    logError('Create Vial Error: No free vials', 'Destroy vials using VOID button', 'No stack', 'HIGH');
                    return;
                }
                const vialId = `vial_${Math.floor(100000 + Math.random() * 900000)}`;
                const fileInput = document.getElementById('file-input');
                const apiInput = document.getElementById('api-input');
                let code = apiInput?.value?.trim() || '';
                if (fileInput?.files?.length > 0) {
                    code = await fileInput.files[0].text();
                }
                code = code.replace(/[<>&"]/g, (c) => ({ '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;' })[c] || c); // Sanitize input
                const vialData = { id: vialId, code: { js: code || 'console.log("Hello, Vial!");' }, training: { model: 'nanoGPT', epochs: 5 }, agentId: 'agent_nanoGPT' };
                const res = await redaxios.post(`${API_BASE_URL}/vial`, vialData, { headers: { Authorization: `Bearer ${oauthToken}` } });
                const { id, latency, createdAt, codeLength } = res.data;
                vials[vialIndex] = { name: id, latencyHistory: [latency], status: 'running', code, filePath: `/vial/uploads/vial${id}.js`, createdAt, codeLength };
                if (db) await db.vials.put(vials[vialIndex]).catch(() => logError('Vial Save Error', 'Check /vial/static/dexie.min.js:30 or IndexedDB support', 'No stack', 'HIGH'));
                logEvent('vial', `Created vial ${id}`, { latency, codeLength }, 'INFO');
                listVials();
                updateVialStatsUI();
            } catch (err) {
                logError(`Create Vial Error: ${err.message}`, 'Check /vial/src/vial_manager.js:40, OAuth, or input', err.stack || 'No stack', 'HIGH');
            }
        }

        async function listVials() {
            try {
                const vialList = vials.map(vial => `${vial.name} (${vial.status}, ${vial.latencyHistory.length ? vial.latencyHistory[vial.latencyHistory.length - 1].toFixed(2) : 0}ms)`).join(', ');
                logEvent('vials', `Vials: ${vialList || 'None'}`, {}, 'INFO');
            } catch (err) {
                logError(`List Vials Error: ${err.message}`, 'Check vial data structure in /vial/static/vial.html:200', err.stack || 'No stack', 'HIGH');
            }
        }

        async function toggleMonitor() {
            try {
                logEvent('monitor', 'Attempting to toggle monitor', {}, 'INFO');
                if (!oauthToken || oauthToken === 'anonymous') {
                    logError('Monitor Error: Unauthorized', 'Check /vial/src/oauth.js:30 or network', 'No stack', 'HIGH');
                    return;
                }
                if (typeof redaxios === 'undefined') {
                    logError('Monitor Error: redaxios not defined', 'Check /vial/static/redaxios.min.js:10 or download from https://cdn.jsdelivr.net/npm/redaxios@0.5.1/dist/redaxios.min.js', 'No stack', 'CRITICAL');
                    return;
                }
                monitorActive = !monitorActive;
                const monitorBtn = document.getElementById('monitor-btn');
                const consoleDiv = document.getElementById('console');
                if (monitorBtn && consoleDiv) {
                    monitorBtn.classList.toggle('active-monitor', monitorActive);
                    consoleDiv.classList.toggle('active-monitor', monitorActive);
                    logEvent('monitor', monitorActive ? 'Monitoring started' : 'Monitoring stopped', {}, 'INFO');
                    if (monitorActive) {
                        monitorInterval = setInterval(async () => {
                            try {
                                const res = await redaxios.get(`${API_BASE_URL}/vials`, { headers: { Authorization: `Bearer ${oauthToken}` } });
                                vials = res.data.map(vial => ({
                                    name: vial.id, latencyHistory: vial.latencyHistory, status: vial.status, code: vial.code.js, filePath: vial.filePath, createdAt: vial.createdAt, codeLength: vial.codeLength
                                }));
                                if (db) await db.vials.bulkPut(vials).catch(() => logError('Vial Bulk Save Error', 'Check /vial/static/dexie.min.js:30 or IndexedDB support', 'No stack', 'HIGH'));
                                listVials();
                                updateVialStatsUI();
                            } catch (err) {
                                logError(`Monitor Update Error: ${err.message}`, 'Check /vial/src/vial_manager.js:50 or OAuth', err.stack || 'No stack', 'HIGH');
                            }
                        }, 5000);
                    } else {
                        clearInterval(monitorInterval);
                    }
                } else {
                    logError('Monitor UI Error', 'Check /vial/static/vial.html:50 for monitor button or console div', 'No stack', 'CRITICAL');
                }
            } catch (err) {
                logError(`Monitor Error: ${err.message}`, 'Check /vial/src/vial_manager.js:30 or DOM', err.stack || 'No stack', 'HIGH');
            }
        }

        async function trainVials() {
            try {
                logEvent('training', 'Attempting to start training', {}, 'INFO');
                if (!oauthToken || oauthToken === 'anonymous') {
                    logError('Train Error: Unauthorized', 'Check /vial/src/oauth.js:30 or network', 'No stack', 'HIGH');
                    return;
                }
                if (typeof redaxios === 'undefined') {
                    logError('Train Error: redaxios not defined', 'Check /vial/static/redaxios.min.js:10 or download from https://cdn.jsdelivr.net/npm/redaxios@0.5.1/dist/redaxios.min.js', 'No stack', 'CRITICAL');
                    return;
                }
                trainActive = !trainActive;
                const trainBtn = document.getElementById('train-btn');
                const consoleDiv = document.getElementById('console');
                if (trainBtn && consoleDiv) {
                    trainBtn.classList.toggle('active-train', trainActive);
                    consoleDiv.classList.toggle('active-train', trainActive);
                    document.body.classList.toggle('train-glow', trainActive);
                    logEvent('training', trainActive ? 'Training started' : 'Training stopped', {}, 'INFO');
                    if (trainActive) {
                        const inputData = document.getElementById('api-input')?.value?.trim();
                        if (!inputData) {
                            logError('Train Error: No input data', 'Enter API URL or upload file (e.g., /vial/src/agents/nanoGPT.py)', 'No stack', 'HIGH');
                            trainActive = false;
                            trainBtn.classList.remove('active-train');
                            consoleDiv.classList.remove('active-train');
                            document.body.classList.remove('train-glow');
                            return;
                        }
                        for (const vial of vials) {
                            if (vial.status === 'running') {
                                const res = await redaxios.post(`${API_BASE_URL}/train`, { id: vial.name, input: inputData, agentId: 'agent_nanoGPT' }, { headers: { Authorization: `Bearer ${oauthToken}` } });
                                vial.latencyHistory.push(res.data.latency);
                                vial.code = inputData;
                                vial.codeLength = res.data.codeLength;
                                if (db) await db.vials.put(vial).catch(() => logError('Vial Save Error', 'Check /vial/static/dexie.min.js:30 or IndexedDB support', 'No stack', 'HIGH'));
                                logEvent('training', `Trained vial ${vial.name}`, { latency: res.data.latency }, 'INFO');
                            }
                        }
                        trainTimeout = setTimeout(() => {
                            trainActive = false;
                            trainBtn.classList.remove('active-train');
                            consoleDiv.classList.remove('active-train');
                            document.body.classList.remove('train-glow');
                            logEvent('training', 'Training completed', {}, 'INFO');
                        }, 3000);
                    } else {
                        clearTimeout(trainTimeout);
                        consoleDiv.classList.remove('active-train');
                        document.body.classList.remove('train-glow');
                    }
                } else {
                    logError('Train UI Error', 'Check /vial/static/vial.html:50 for train button or console div', 'No stack', 'CRITICAL');
                }
            } catch (err) {
                logError(`Train Error: ${err.message}`, 'Check /vial/src/training.js:20, OAuth, or input', err.stack || 'No stack', 'HIGH');
            }
        }

        async function voidVials() {
            try {
                logEvent('void', 'Attempting to destroy all vials', {}, 'INFO');
                if (!oauthToken || oauthToken === 'anonymous') {
                    logEvent('void', 'Skipped server destroy due to anonymous token', {}, 'INFO');
                } else if (isOnline && typeof redaxios !== 'undefined') {
                    await redaxios.post(`${API_BASE_URL}/destroy`, {}, { headers: { Authorization: `Bearer ${oauthToken}` } });
                } else {
                    logEvent('void', 'Skipped server destroy due to offline mode', {}, 'INFO');
                }
                vials = Array(4).fill().map((_, i) => ({ name: `vial${i+1}`, latencyHistory: [], status: 'stopped', code: '', filePath: '', createdAt: '', codeLength: 0 }));
                if (db) await db.vials.clear().catch(() => logError('Vial Clear Error', 'Check /vial/static/dexie.min.js:30 or IndexedDB support', 'No stack', 'HIGH'));
                if (db) await db.vials.bulkPut(vials).catch(() => logError('Vial Bulk Save Error', 'Check /vial/static/dexie.min.js:30 or IndexedDB support', 'No stack', 'HIGH'));
                logQueue = ['<p>Vial MCP Controller initialized</p>'];
                updateVialStatsUI();
                debouncedUpdateConsole();
                logEvent('void', 'All vials destroyed', {}, 'HIGH');
                listVials();
            } catch (err) {
                logError(`VOID Error: ${err.message}`, 'Check /vial/src/vial_manager.js:60 or OAuth', err.stack || 'No stack', 'HIGH');
            }
        }

        async function saveVialAsMarkdown() {
            try {
                logEvent('export', 'Attempting to export vials as Markdown', {}, 'INFO');
                if (!oauthToken || oauthToken === 'anonymous') {
                    logEvent('export', 'Using local vial data due to anonymous token', {}, 'INFO');
                }
                let vialData = vials;
                if (isOnline && oauthToken && oauthToken !== 'anonymous' && typeof redaxios !== 'undefined') {
                    try {
                        const res = await redaxios.get(`${API_BASE_URL}/vials`, { headers: { Authorization: `Bearer ${oauthToken}` } });
                        vialData = res.data;
                    } catch (err) {
                        logError('Export Fetch Error: Unable to fetch vials from server', 'Check /vial/src/vial_manager.js:50 or network', err.stack || 'No stack', 'HIGH');
                    }
                }
                const content = vialData.map(vial => (typeof Mustache !== 'undefined' ? Mustache.render(
                    '# Vial Agent: {{id}}\n\nStatus: {{status}}\nCreated: {{createdAt}}\nCode:\n```js\n{{code.js}}\n```\nLatency: {{latencyHistory}} ms\n',
                    { ...vial, id: vial.name, code: { js: vial.code } }
                ) : `Vial ${vial.name}: No Mustache template`)).join('---\n\n');
                const blob = new Blob([content], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `vial_export_${new Date().toISOString().replace(/[:.]/g, '-')}.md`;
                a.click();
                URL.revokeObjectURL(url);
                logEvent('export', 'Exported vials as Markdown', {}, 'INFO');
            } catch (err) {
                logError(`Export Error: ${err.message}`, 'Check /vial/src/vial_manager.js:70 or browser', err.stack || 'No stack', 'HIGH');
            }
        }

        function updateVialStatsUI() {
            try {
                const vialStatsDiv = document.getElementById('vial-stats');
                if (vialStatsDiv) {
                    vialStatsDiv.innerHTML = vials.map((vial, index) => `
                        <div class="progress-container">
                            <span class="progress-label">Vial ${index + 1}:</span>
                            <div class="progress-bar"><div class="progress-fill" id="vial${index + 1}-bar" style="width: ${vial.latencyHistory.length ? Math.min(100, vial.latencyHistory[vial.latencyHistory.length - 1] / 2) : 0}%"></div></div>
                            <span id="vial${index + 1}-value">${vial.latencyHistory.length ? vial.latencyHistory[vial.latencyHistory.length - 1].toFixed(2) : 0} ms</span>
                        </div>
                    `).join('');
                } else {
                    logError('Vial Stats Div Missing', 'Check /vial/static/vial.html:50 for <div id="vial-stats">', 'No stack', 'CRITICAL');
                }
            } catch (err) {
                logError(`Update Vial Stats Error: ${err.message}`, 'Check /vial/static/vial.html:200 or vial data structure', err.stack || 'No stack', 'CRITICAL');
            }
        }

        function setupEventListeners() {
            try {
                const buttons = [
                    { id: 'create-vial-btn', handler: createVial, label: 'Create Vial' },
                    { id: 'troubleshoot-btn', handler: systemDiagnostics, label: 'Troubleshoot' },
                    { id: 'monitor-btn', handler: toggleMonitor, label: 'Monitor' },
                    { id: 'train-btn', handler: trainVials, label: 'Train' },
                    { id: 'void-btn', handler: voidVials, label: 'VOID' },
                    { id: 'export-btn', handler: saveVialAsMarkdown, label: 'Export Vials' }
                ];
                buttons.forEach(({ id, handler, label }) => {
                    const btn = document.getElementById(id);
                    if (btn) {
                        const handleClick = (e) => {
                            e.preventDefault();
                            logEvent('button', `Clicked ${label}`, { id }, 'INFO');
                            handler();
                        };
                        btn.addEventListener('click', handleClick);
                        btn.addEventListener('touchstart', (e) => {
                            e.preventDefault();
                            logEvent('button', `Touched ${label}`, { id }, 'INFO');
                            handler();
                        }, { passive: false });
                    } else {
                        logError(`Button Missing: ${id}`, `Check /vial/static/vial.html:60 for ${label} button`, 'No stack', 'CRITICAL');
                    }
                });
                const fileInput = document.getElementById('file-input');
                if (fileInput) {
                    fileInput.addEventListener('change', async () => {
                        try {
                            const file = fileInput.files[0];
                            if (file) logEvent('file', `Uploaded file: ${file.name}`, { size: file.size }, 'INFO');
                        } catch (err) {
                            logError(`File Input Error: ${err.message}`, 'Check /vial/static/vial.html:40 for file input handling', err.stack || 'No stack', 'HIGH');
                        }
                    });
                } else {
                    logError('File Input Missing', 'Check /vial/static/vial.html:40 for <input id="file-input">', 'No stack', 'CRITICAL');
                }
                const apiInput = document.getElementById('api-input');
                if (apiInput) {
                    apiInput.addEventListener('input', () => {
                        try {
                            const input = apiInput.value.replace(/[<>&"]/g, (c) => ({ '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;' })[c] || c);
                            if (input) logEvent('api', `API URL: ${input}`, {}, 'INFO');
                        } catch (err) {
                            logError(`API Input Error: ${err.message}`, 'Check /vial/static/vial.html:40 for api input handling', err.stack || 'No stack', 'HIGH');
                        }
                    });
                } else {
                    logError('API Input Missing', 'Check /vial/static/vial.html:40 for <input id="api-input">', 'No stack', 'CRITICAL');
                }
            } catch (err) {
                logError(`Event Listener Setup Error: ${err.message}`, 'Check /vial/static/vial.html:150 for event listener code', err.stack || 'No stack', 'CRITICAL');
            }
        }

        // Initialize Dexie
        if (typeof Dexie !== 'undefined' && window.indexedDB) {
            try {
                db = new Dexie('VialMCP');
                db.version(1).stores({ logs: '++id,timestamp,event_type', vials: 'name' });
                logEvent('system', 'IndexedDB initialized', {}, 'INFO');
            } catch (err) {
                logError(`Dexie Init Error: ${err.message}`, 'Check /vial/static/dexie.min.js:30 or browser IndexedDB support', err.stack || 'No stack', 'HIGH');
                db = null;
            }
        } else {
            logError('Dexie Not Loaded or IndexedDB Not Supported', 'Check /vial/static/dexie.min.js:10 or browser support', 'No stack', 'HIGH');
            db = null;
        }

        document.addEventListener('DOMContentLoaded', async () => {
            try {
                dependencies.forEach(dep => {
                    if (!dep.check()) {
                        logError(`${dep.name} Not Loaded`, `Check ${dep.path}:${dep.line} or download from ${dep.cdn}`, 'No stack', 'CRITICAL');
                    }
                });
                await initWorker();
                updateVialStatsUI();
                debouncedUpdateConsole();
                await authenticateOAuth();
                setupEventListeners();
                if (!isOnline && db) {
                    try {
                        const cachedVials = await db.vials.toArray();
                        if (cachedVials.length) {
                            vials = cachedVials;
                            updateVialStatsUI();
                            logEvent('system', 'Loaded cached vials', { count: cachedVials.length }, 'INFO');
                            listVials();
                        }
                    } catch (err) {
                        logError(`Cached Vials Load Error: ${err.message}`, 'Check /vial/static/dexie.min.js:30 or IndexedDB support', err.stack || 'No stack', 'HIGH');
                    }
                }
                logEvent('system', 'Vial MCP Controller initialized', {}, 'INFO');
            } catch (err) {
                logError(`Initialization Error: ${err.message}`, 'Check /vial/static/vial.html:100 for DOMContentLoaded event', err.stack || 'No stack', 'CRITICAL');
            }
        });

        window.addEventListener('online', () => {
            try {
                isOnline = true;
                logEvent('network', 'Network online', {}, 'INFO');
                authenticateOAuth();
            } catch (err) {
                logError(`Network Online Error: ${err.message}`, 'Check /vial/static/vial.html:250 for network handling', err.stack || 'No stack', 'HIGH');
            }
        });

        window.addEventListener('offline', () => {
            try {
                isOnline = false;
                logEvent('network', 'Network offline', {}, 'HIGH');
                oauthToken = 'anonymous';
                logEvent('auth', 'Switched to anonymous token due to offline mode', {}, 'INFO');
            } catch (err) {
                logError(`Network Offline Error: ${err.message}`, 'Check /vial/static/vial.html:250 for network handling', err.stack || 'No stack', 'HIGH');
            }
        });

        window.addEventListener('error', (e) => {
            logError(`Global Error: ${e.message}`, 'Check browser console or /vial/static/ files', e.stack || 'No stack', 'CRITICAL');
        });

        window.addEventListener('unhandledrejection', (e) => {
            logError(`Promise Rejection: ${e.reason}`, 'Check async operations in /vial/static/vial.html:200 or /vial/src/ files', e.reason?.stack || 'No stack', 'CRITICAL');
        });
    </script>
</head>
<body>
    <h1 role="heading" aria-level="1">Vial MCP Controller</h1>
    <div id="input-container">
        <input id="file-input" type="file" accept=".html,.css,.js,.py" aria-label="Upload code file for vial training">
        <input id="api-input" type="text" placeholder="Enter API URL for vial training (webxos.netlify.app)" aria-label="Enter API URL for vial training">
        <div id="input-results"></div>
    </div>
    <div id="console" role="log" aria-live="polite">
        <p>Vial MCP Controller: Create Vial: Authenticate and initialize new vial | Troubleshoot: Run system diagnostics | Monitor: Toggle latency monitoring | Train: Start vial training | VOID: Destroy all vials | Export: Save all vials as .md</p>
    </div>
    <div id="vial-stats">
        <div class="progress-container">
            <span class="progress-label">Vial 1:</span>
            <div class="progress-bar"><div class="progress-fill" id="vial1-bar" style="width: 0%"></div></div>
            <span id="vial1-value">0 ms</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">Vial 2:</span>
            <div class="progress-bar"><div class="progress-fill" id="vial2-bar" style="width: 0%"></div></div>
            <span id="vial2-value">0 ms</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">Vial 3:</span>
            <div class="progress-bar"><div class="progress-fill" id="vial3-bar" style="width: 0%"></div></div>
            <span id="vial3-value">0 ms</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">Vial 4:</span>
            <div class="progress-bar"><div class="progress-fill" id="vial4-bar" style="width: 0%"></div></div>
            <span id="vial4-value">0 ms</span>
        </div>
    </div>
    <div class="button-group">
        <button id="create-vial-btn" aria-label="Authenticate and create new vial">Create Vial</button>
        <button id="troubleshoot-btn" aria-label="Run system diagnostics">Troubleshoot</button>
        <button id="monitor-btn" aria-label="Toggle real-time latency monitoring">Monitor</button>
        <button id="train-btn" aria-label="Start training all vials">Train</button>
        <button id="void-btn" aria-label="Destroy all vials and reset">VOID</button>
        <button id="export-btn" aria-label="Export all vials as markdown">Export Vials</button>
    </div>
    <footer>
        © 2025 WebXOS - Vial MCP Controller<br>
        Create Vial: Authenticate and initialize new vial | Troubleshoot: Run system diagnostics | Monitor: Toggle latency monitoring | Train: Start vial training | VOID: Destroy all vials | Export: Save all vials as .md
    </footer>
</body>
</html>
