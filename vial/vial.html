<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vial MCP Controller</title>
    <link rel="icon" href="/vial/static/icon.png" onerror="logError('Icon Load Error', 'Check /vial/static/icon.png', 'No stack', 'LOW')">
    <link rel="manifest" href="/vial/static/manifest.json" onerror="logError('Manifest Load Error', 'Check /vial/static/manifest.json', 'No stack', 'LOW')">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet" onerror="logError('Font Load Error', 'Check Google Fonts CDN or use local font', 'No stack', 'LOW')">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: monospace, sans-serif; }
        html, body { height: 100vh; overflow: hidden; background: #000 !important; color: #0f0 !important; display: flex; flex-direction: column; align-items: center; transition: background 0.3s, box-shadow 0.3s; -webkit-tap-highlight-color: transparent; touch-action: manipulation; }
        body.glow { background: rgba(255, 0, 0, 0.1) !important; box-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000 inset; }
        body.train-glow { background: rgba(255, 255, 0, 0.1) !important; box-shadow: 0 0 20px #ff0, 0 0 40px #ff0 inset; }
        h1 { font-size: 1.6rem; text-align: center; margin: 0.8rem 0; text-transform: uppercase; letter-spacing: 1px; text-shadow: 0 0 5px #0f0; color: #0f0 !important; }
        #console { width: 90%; max-width: 900px; background: rgba(0, 255, 0, 0.1) !important; border: 1px solid #0f0; padding: 0.6rem; flex: 1; max-height: calc(100vh - 300px); overflow-y: auto; margin: 0.5rem 0; border-radius: 5px; font-size: 0.8rem; -webkit-overflow-scrolling: touch; transition: border-color 0.3s, box-shadow 0.3s; white-space: pre-wrap; word-wrap: break-word; }
        #console.active-monitor { border-color: #ff0000 !important; box-shadow: 0 0 10px #ff0000; }
        #console.active-train { border-color: #ff0 !important; box-shadow: 0 0 10px #ff0; }
        #console p { margin: 0.2rem 0; color: #0f0 !important; }
        #console .command { font-family: 'Orbitron', monospace; font-weight: 700; text-shadow: 0 0 3px #0f0; }
        #console .error { color: #ff0000 !important; text-shadow: 0 0 3px #ff0000; }
        .button-group { display: flex; gap: 0.5rem; margin: 0.5rem 0; padding: 0.5rem; flex-wrap: wrap; justify-content: center; width: 90%; max-width: 900px; }
        button { background: #0f0 !important; color: #000 !important; border: none; padding: 0.6rem 1.2rem; font-size: 0.9rem; cursor: pointer; border-radius: 3px; min-width: 90px; text-align: center; touch-action: manipulation; transition: background 0.3s, box-shadow 0.3s; -webkit-user-select: none; user-select: none; }
        button:hover, button:focus, button:active { background: #0c0 !important; outline: 2px solid #0f0; }
        button.active-monitor { background: #ff0000 !important; box-shadow: 0 0 10px #ff0000; }
        button.active-train { background: #ff0 !important; color: #000 !important; box-shadow: 0 0 10px #ff0; }
        button:disabled { background: #666 !important; cursor: not-allowed; }
        #vial-stats { width: 90%; max-width: 900px; margin: 0.5rem 0; display: flex; flex-direction: column; gap: 0.2rem; }
        .progress-container { display: flex; align-items: center; gap: 0.4rem; }
        .progress-label { width: 90px; font-size: 0.75rem; color: #0f0 !important; }
        .progress-bar { flex: 1; height: 8px; background: #333 !important; border: 1px solid #0f0; border-radius: 3px; overflow: hidden; }
        .progress-fill { height: 100%; background: #0f0 !important; transition: width 0.5s; }
        #input-container { width: 90%; max-width: 900px; margin: 0.5rem 0; display: flex; flex-direction: column; gap: 0.5rem; }
        #file-input, #api-input { width: 100%; padding: 0.5rem; background: #000 !important; color: #0f0 !important; border: 1px solid #0f0; border-radius: 3px; font-size: 0.8rem; }
        #input-results { margin-top: 0.5rem; max-height: 100px; overflow-y: auto; font-size: 0.8rem; color: #0f0 !important; }
        #input-results .error { color: #ff0000 !important; }
        footer { width: 100%; padding: 0.4rem; font-size: 9pt; text-align: center; color: #0f0 !important; background: rgba(0, 0, 0, 0.8) !important; line-height: 1.2; }
        @media (max-width: 600px) {
            h1 { font-size: 1.1rem; margin: 0.5rem 0; }
            #console { font-size: 0.75rem; padding: 0.5rem; max-height: calc(100vh - 320px); }
            button { padding: 0.5rem 1rem; font-size: 0.85rem; min-width: 80px; }
            #file-input, #api-input { font-size: 0.75rem; }
            footer { padding: 0.3rem; }
            .progress-label { width: 70px; font-size: 0.7rem; }
            .progress-bar { height: 7px; }
        }
        @media (max-width: 400px) {
            .button-group { flex-direction: column; align-items: center; }
            button { width: 100%; max-width: 160px; }
            #console { max-height: calc(100vh - 280px); }
            #vial-stats { gap: 0.15rem; }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/redaxios@0.5.1/dist/redaxios.min.js" onerror="logError('redaxios Load Error', 'Check CDN https://cdn.jsdelivr.net/npm/redaxios@0.5.1/dist/redaxios.min.js', 'No stack', 'CRITICAL')"></script>
    <script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js" onerror="logError('LZString Load Error', 'Check CDN https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js', 'No stack', 'CRITICAL')"></script>
    <script src="https://cdn.jsdelivr.net/npm/mustache@4.2.0/mustache.min.js" onerror="logError('Mustache Load Error', 'Check CDN https://cdn.jsdelivr.net/npm/mustache@4.2.0/mustache.min.js', 'No stack', 'CRITICAL')"></script>
    <script src="https://cdn.jsdelivr.net/npm/dexie@3.2.4/dist/dexie.min.js" onerror="logError('Dexie Load Error', 'Check CDN https://cdn.jsdelivr.net/npm/dexie@3.2.4/dist/dexie.min.js', 'No stack', 'CRITICAL')"></script>
    <script src="https://cdn.jsdelivr.net/npm/jwt-decode@3.1.2/build/jwt-decode.min.js" onerror="logError('jwt-decode Load Error', 'Check CDN https://cdn.jsdelivr.net/npm/jwt-decode@3.1.2/build/jwt-decode.min.js', 'No stack', 'CRITICAL')"></script>
    <script>
        // Early error logging
        let errorLog = [], logQueue = ['<p>Vial MCP Controller initialized</p>'];
        function logError(message, analysis, stack, urgency) {
            const timestamp = new Date().toISOString();
            const errorMessage = `[${timestamp}] ERROR: ${message}\nAnalysis: ${analysis}\nTraceback: ${stack || 'No stack'}`;
            errorLog.push(errorMessage);
            logQueue.push(`<p class="error">${errorMessage}</p>`);
            if (logQueue.length > 50) logQueue.shift();
            const consoleDiv = document.getElementById('console');
            if (consoleDiv) {
                consoleDiv.innerHTML = logQueue.join('');
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            }
            if (typeof worker !== 'undefined' && worker) {
                worker.postMessage({ action: 'saveErrorLog', content: errorLog.join('\n---\n') });
            }
        }

        // Global state
        const API_BASE_URL = 'http://localhost:8080/mcp';
        const WS_URL = 'ws://localhost:8080/ws';
        let ws = null, monitorActive = false, trainActive = false, monitorInterval = null, trainTimeout = null;
        let vials = Array(4).fill().map((_, i) => ({ name: `vial${i+1}`, latencyHistory: [], status: 'stopped', code: '', filePath: '', createdAt: '', codeLength: 0 }));
        let isOnline = navigator.onLine, oauthToken = null;
        let db = null, isUpdatingConsole = false, worker = null;

        // Core logging
        function logEvent(event_type, message, metadata, urgency) {
            try {
                const timestamp = new Date().toISOString();
                const logData = { timestamp, event_type, message, metadata, urgency };
                if (worker) worker.postMessage({ action: 'log', data: logData });
                if (db) db.logs.add(logData).catch(err => logError(`Log Save Error: ${err.message}`, 'Check /vial/static/dexie.min.js:30', err.stack || 'No stack', 'HIGH'));
                const compressedLog = typeof LZString !== 'undefined' ? LZString.compressToUTF16(JSON.stringify(logData)) : JSON.stringify(logData);
                if (isOnline && oauthToken && typeof redaxios !== 'undefined') {
                    redaxios.post(`${API_BASE_URL}/log-sync`, { log: compressedLog }, { headers: { Authorization: `Bearer ${oauthToken}` } })
                        .catch(err => logError(`Log Sync Error: ${err.message}`, 'Check /vial/src/log_manager.js:50', err.stack || 'No stack', 'HIGH'));
                }
                logQueue.push(`<p class="${event_type === 'error' ? 'error' : 'command'}">[${timestamp}] ${message}</p>`);
                if (logQueue.length > 50) logQueue.shift();
                debouncedUpdateConsole();
            } catch (err) {
                logError(`Log Event Error: ${err.message}`, 'Check /vial/static/vial.html:100', err.stack || 'No stack', 'CRITICAL');
            }
        }

        function debounce(func, wait) {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func(...args), wait);
            };
        }

        const debouncedUpdateConsole = debounce((logs = null) => {
            if (isUpdatingConsole) return;
            isUpdatingConsole = true;
            const consoleDiv = document.getElementById('console');
            if (consoleDiv) {
                consoleDiv.innerHTML = logs ? Mustache.render('{{#logs}}<p>{{message}}</p>{{/logs}}', { logs }) : logQueue.join('');
                consoleDiv.scrollTop = consoleDiv.scrollHeight;
            } else {
                logError(`Console Div Missing`, 'Check /vial/static/vial.html:50', 'No stack', 'CRITICAL');
            }
            isUpdatingConsole = false;
        }, 100);

        // Dependency checks
        const dependencies = [
            { name: 'redaxios', check: () => typeof redaxios !== 'undefined', cdn: 'https://cdn.jsdelivr.net/npm/redaxios@0.5.1/dist/redaxios.min.js' },
            { name: 'LZString', check: () => typeof LZString !== 'undefined', cdn: 'https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js' },
            { name: 'Mustache', check: () => typeof Mustache !== 'undefined', cdn: 'https://cdn.jsdelivr.net/npm/mustache@4.2.0/mustache.min.js' },
            { name: 'Dexie', check: () => typeof Dexie !== 'undefined', cdn: 'https://cdn.jsdelivr.net/npm/dexie@3.2.4/dist/dexie.min.js' },
            { name: 'jwt_decode', check: () => typeof jwt_decode !== 'undefined', cdn: 'https://cdn.jsdelivr.net/npm/jwt-decode@3.1.2/build/jwt-decode.min.js' }
        ];

        async function initWorker() {
            try {
                worker = new Worker('/vial/static/worker.js');
                worker.onmessage = (e) => {
                    const { status, logs, message } = e.data;
                    if (status === 'initialized') logEvent('system', 'SQLite initialized', { component: 'worker' }, 'LOW');
                    else if (status === 'logs') debouncedUpdateConsole(logs);
                    else if (status === 'error') logError(`Worker Error: ${message}`, 'Check /vial/static/worker.js:15', message.stack || 'No stack', 'HIGH');
                };
                worker.postMessage({ action: 'init' });
            } catch (err) {
                logError(`Worker Init Error: ${err.message}`, 'Check /vial/static/worker.js:10', err.stack || 'No stack', 'CRITICAL');
            }
        }

        function initializeWebSocket() {
            if (!isOnline || !oauthToken) {
                logEvent('websocket', 'WebSocket skipped: offline or no token', {}, 'INFO');
                return;
            }
            try {
                ws = new WebSocket(`${WS_URL}?token=${encodeURIComponent(oauthToken)}`);
                ws.onopen = () => { logEvent('websocket', 'Connected', { url: WS_URL }, 'INFO'); isOnline = true; };
                ws.onmessage = (e) => {
                    try {
                        const { event_type, message, metadata } = JSON.parse(e.data);
                        logEvent(event_type, message, metadata, 'INFO');
                        updateVialStatsUI();
                    } catch (err) {
                        logError(`WebSocket Message Error: ${err.message}`, 'Check /vial/src/server.js:120', err.stack || 'No stack', 'HIGH');
                    }
                };
                ws.onerror = () => { logError('WebSocket Error', 'Check /vial/src/server.js:130', 'No stack', 'HIGH'); isOnline = false; };
                ws.onclose = () => { logEvent('websocket', 'Disconnected', {}, 'HIGH'); isOnline = false; setTimeout(initializeWebSocket, 5000); };
            } catch (err) {
                logError(`WebSocket Init Error: ${err.message}`, 'Check /vial/src/server.js:130', err.stack || 'No stack', 'HIGH');
            }
        }

        async function authenticateOAuth() {
            if (!isOnline || typeof redaxios === 'undefined') {
                oauthToken = 'anonymous';
                logEvent('auth', 'Using anonymous token: offline or no redaxios', {}, 'INFO');
                return false;
            }
            try {
                const storedToken = localStorage.getItem('mcp_token');
                if (storedToken && jwt_decode(storedToken).exp * 1000 > Date.now()) {
                    oauthToken = storedToken;
                    initializeWebSocket();
                    logEvent('auth', 'OAuth token loaded from localStorage', { token: oauthToken.slice(0, 10) + '...' }, 'INFO');
                    return true;
                }
                const res = await redaxios.post(`${API_BASE_URL}/auth`, { token: storedToken || 'anonymous' });
                oauthToken = res.data.token || 'anonymous';
                localStorage.setItem('mcp_token', oauthToken);
                initializeWebSocket();
                logEvent('auth', 'OAuth authenticated', { token: oauthToken.slice(0, 10) + '...' }, 'INFO');
                return true;
            } catch (err) {
                oauthToken = 'anonymous';
                logError(`OAuth Error: ${err.message}`, 'Check /vial/src/oauth.js:20', err.stack || 'No stack', 'HIGH');
                initializeWebSocket();
                return false;
            }
        }

        async function systemDiagnostics() {
            try {
                logEvent('diagnostics', 'Starting diagnostics', {}, 'INFO');
                const checks = [
                    { name: 'Network', test: () => navigator.onLine, error: 'Offline mode', analysis: 'Check network' },
                    { name: 'WebSocket', test: () => ws?.readyState === WebSocket.OPEN, error: 'WebSocket disconnected', analysis: 'Check /vial/src/server.js:130' },
                    { name: 'OAuth', test: () => oauthToken && oauthToken !== 'anonymous' && jwt_decode(oauthToken).exp * 1000 > Date.now(), error: 'Invalid OAuth token', analysis: 'Check /vial/src/oauth.js:30' },
                    { name: 'Worker', test: () => !!worker, error: 'Worker not initialized', analysis: 'Check /vial/static/worker.js:10' },
                    { name: 'Dexie', test: () => typeof Dexie !== 'undefined' && window.indexedDB, error: 'IndexedDB/Dexie not supported', analysis: 'Check /vial/static/dexie.min.js:30' }
                ];
                for (const { name, test, error, analysis } of checks) {
                    if (await test()) {
                        logEvent('diagnostics', `${name} check passed`, {}, 'INFO');
                    } else {
                        logError(`${name} Failure: ${error}`, analysis, 'No stack', 'HIGH');
                    }
                }
                if (isOnline && oauthToken && oauthToken !== 'anonymous' && typeof redaxios !== 'undefined') {
                    const res = await redaxios.get(`${API_BASE_URL}/diagnostics`, { headers: { Authorization: `Bearer ${oauthToken}` } });
                    res.data.issues?.forEach(issue => logError(`Server Issue: ${issue.message}`, issue.analysis || 'Check /vial/src/diagnostics.js:40', issue.stack || 'No stack', 'HIGH'));
                    logEvent('diagnostics', 'Diagnostics complete', { issues: res.data.issues?.length || 0 }, 'INFO');
                } else {
                    logEvent('diagnostics', 'Skipped server diagnostics: offline or anonymous', {}, 'INFO');
                }
            } catch (err) {
                logError(`Diagnostics Error: ${err.message}`, 'Check /vial/src/diagnostics.js:40', err.stack || 'No stack', 'HIGH');
            }
        }

        async function createVial() {
            try {
                logEvent('vial', 'Creating vial', {}, 'INFO');
                if (!await authenticateOAuth()) {
                    logError('Create Vial Error: Authentication failed', 'Check /vial/src/oauth.js:20', 'No stack', 'HIGH');
                    return;
                }
                const activeVials = vials.filter(v => v.status === 'running').length;
                if (activeVials >= 4) {
                    logError('Create Vial Error: Maximum 4 vials', 'Use VOID to clear', 'No stack', 'HIGH');
                    return;
                }
                const vialIndex = vials.findIndex(v => v.status === 'stopped');
                const vialId = `vial_${Math.floor(100000 + Math.random() * 900000)}`;
                const fileInput = document.getElementById('file-input');
                const apiInput = document.getElementById('api-input');
                let code = apiInput?.value?.trim() || '';
                if (fileInput?.files?.length > 0) {
                    code = await fileInput.files[0].text();
                }
                code = code.replace(/[<>&"]/g, c => ({ '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;' })[c] || c);
                const vialData = { id: vialId, code: { js: code || 'console.log("Hello, Vial!");' }, training: { model: 'nanoGPT', epochs: 5 }, agentId: 'agent_nanoGPT' };
                let res;
                if (isOnline && oauthToken !== 'anonymous') {
                    res = await redaxios.post(`${API_BASE_URL}/vial`, vialData, { headers: { Authorization: `Bearer ${oauthToken}` } });
                } else {
                    res = { data: { id: vialId, latency: 50, createdAt: new Date().toISOString(), codeLength: code.length } };
                }
                const { id, latency, createdAt, codeLength } = res.data;
                vials[vialIndex] = { name: id, latencyHistory: [latency], status: 'running', code, filePath: `/vial/uploads/vial${id}.js`, createdAt, codeLength };
                if (db) await db.vials.put(vials[vialIndex]).catch(err => logError(`Vial Save Error: ${err.message}`, 'Check /vial/static/dexie.min.js:30', err.stack || 'No stack', 'HIGH'));
                logEvent('vial', `Created vial ${id}`, { latency, codeLength }, 'INFO');
                listVials();
                updateVialStatsUI();
            } catch (err) {
                logError(`Create Vial Error: ${err.message}`, 'Check /vial/src/vial_manager.js:40', err.stack || 'No stack', 'HIGH');
            }
        }

        async function listVials() {
            try {
                const vialList = vials.map(vial => `${vial.name} (${vial.status}, ${vial.latencyHistory.length ? vial.latencyHistory[vial.latencyHistory.length - 1].toFixed(2) : 0}ms)`).join(', ');
                logEvent('vials', `Vials: ${vialList || 'None'}`, {}, 'INFO');
            } catch (err) {
                logError(`List Vials Error: ${err.message}`, 'Check /vial/static/vial.html:200', err.stack || 'No stack', 'HIGH');
            }
        }

        async function toggleMonitor() {
            try {
                logEvent('monitor', 'Toggling monitor', {}, 'INFO');
                monitorActive = !monitorActive;
                const monitorBtn = document.getElementById('monitor-btn');
                const consoleDiv = document.getElementById('console');
                if (monitorBtn && consoleDiv) {
                    monitorBtn.classList.toggle('active-monitor', monitorActive);
                    consoleDiv.classList.toggle('active-monitor', monitorActive);
                    logEvent('monitor', monitorActive ? 'Monitoring started' : 'Monitoring stopped', {}, 'INFO');
                    if (monitorActive) {
                        monitorInterval = setInterval(async () => {
                            try {
                                let res;
                                if (isOnline && oauthToken !== 'anonymous') {
                                    res = await redaxios.get(`${API_BASE_URL}/vials`, { headers: { Authorization: `Bearer ${oauthToken}` } });
                                    vials = res.data.map(vial => ({
                                        name: vial.id, latencyHistory: vial.latencyHistory, status: vial.status, code: vial.code.js, filePath: vial.filePath, createdAt: vial.createdAt, codeLength: vial.codeLength
                                    }));
                                    if (db) await db.vials.bulkPut(vials).catch(err => logError(`Vial Bulk Save Error: ${err.message}`, 'Check /vial/static/dexie.min.js:30', err.stack || 'No stack', 'HIGH'));
                                }
                                listVials();
                                updateVialStatsUI();
                            } catch (err) {
                                logError(`Monitor Update Error: ${err.message}`, 'Check /vial/src/vial_manager.js:50', err.stack || 'No stack', 'HIGH');
                            }
                        }, 5000);
                    } else {
                        clearInterval(monitorInterval);
                    }
                } else {
                    logError('Monitor UI Error', 'Check /vial/static/vial.html:50', 'No stack', 'CRITICAL');
                }
            } catch (err) {
                logError(`Monitor Error: ${err.message}`, 'Check /vial/src/vial_manager.js:30', err.stack || 'No stack', 'HIGH');
            }
        }

        async function trainVials() {
            try {
                logEvent('training', 'Starting training', {}, 'INFO');
                if (!oauthToken || oauthToken === 'anonymous') {
                    logError('Train Error: Unauthorized', 'Check /vial/src/oauth.js:20', 'No stack', 'HIGH');
                    return;
                }
                trainActive = !trainActive;
                const trainBtn = document.getElementById('train-btn');
                const consoleDiv = document.getElementById('console');
                if (trainBtn && consoleDiv) {
                    trainBtn.classList.toggle('active-train', trainActive);
                    consoleDiv.classList.toggle('active-train', trainActive);
                    document.body.classList.toggle('train-glow', trainActive);
                    logEvent('training', trainActive ? 'Training started' : 'Training stopped', {}, 'INFO');
                    if (trainActive) {
                        const inputData = document.getElementById('api-input')?.value?.trim();
                        if (!inputData) {
                            logError('Train Error: No input data', 'Enter API URL or upload file', 'No stack', 'HIGH');
                            trainActive = false;
                            trainBtn.classList.remove('active-train');
                            consoleDiv.classList.remove('active-train');
                            document.body.classList.remove('train-glow');
                            return;
                        }
                        for (const vial of vials.filter(v => v.status === 'running')) {
                            const res = await redaxios.post(`${API_BASE_URL}/train`, { id: vial.name, input: inputData, agentId: 'agent_nanoGPT' }, { headers: { Authorization: `Bearer ${oauthToken}` } });
                            vial.latencyHistory.push(res.data.latency);
                            vial.code = inputData;
                            vial.codeLength = res.data.codeLength;
                            if (db) await db.vials.put(vial).catch(err => logError(`Vial Save Error: ${err.message}`, 'Check /vial/static/dexie.min.js:30', err.stack || 'No stack', 'HIGH'));
                            logEvent('training', `Trained vial ${vial.name}`, { latency: res.data.latency }, 'INFO');
                        }
                        trainTimeout = setTimeout(() => {
                            trainActive = false;
                            trainBtn.classList.remove('active-train');
                            consoleDiv.classList.remove('active-train');
                            document.body.classList.remove('train-glow');
                            logEvent('training', 'Training completed', {}, 'INFO');
                        }, 3000);
                    } else {
                        clearTimeout(trainTimeout);
                    }
                } else {
                    logError('Train UI Error', 'Check /vial/static/vial.html:50', 'No stack', 'CRITICAL');
                }
            } catch (err) {
                logError(`Train Error: ${err.message}`, 'Check /vial/src/training.js:20', err.stack || 'No stack', 'HIGH');
            }
        }

        async function voidVials() {
            try {
                logEvent('void', 'Destroying all vials', {}, 'INFO');
                if (isOnline && oauthToken !== 'anonymous') {
                    await redaxios.post(`${API_BASE_URL}/destroy`, {}, { headers: { Authorization: `Bearer ${oauthToken}` } });
                }
                vials = Array(4).fill().map((_, i) => ({ name: `vial${i+1}`, latencyHistory: [], status: 'stopped', code: '', filePath: '', createdAt: '', codeLength: 0 }));
                if (db) await db.vials.clear().catch(err => logError(`Vial Clear Error: ${err.message}`, 'Check /vial/static/dexie.min.js:30', err.stack || 'No stack', 'HIGH'));
                if (db) await db.vials.bulkPut(vials).catch(err => logError(`Vial Bulk Save Error: ${err.message}`, 'Check /vial/static/dexie.min.js:30', err.stack || 'No stack', 'HIGH'));
                logQueue = ['<p>Vial MCP Controller initialized</p>'];
                updateVialStatsUI();
                debouncedUpdateConsole();
                logEvent('void', 'All vials destroyed', {}, 'HIGH');
                listVials();
            } catch (err) {
                logError(`VOID Error: ${err.message}`, 'Check /vial/src/vial_manager.js:60', err.stack || 'No stack', 'HIGH');
            }
        }

        async function saveVialAsMarkdown() {
            try {
                logEvent('export', 'Exporting vials as Markdown', {}, 'INFO');
                let vialData = vials;
                if (isOnline && oauthToken !== 'anonymous') {
                    const res = await redaxios.get(`${API_BASE_URL}/vials`, { headers: { Authorization: `Bearer ${oauthToken}` } });
                    vialData = res.data;
                }
                const content = vialData.map(vial => Mustache.render(
                    '# Vial Agent: {{id}}\n\nStatus: {{status}}\nCreated: {{createdAt}}\nCode:\n```js\n{{code.js}}\n```\nLatency: {{latencyHistory}} ms\n',
                    { ...vial, id: vial.name, code: { js: vial.code } }
                )).join('---\n\n');
                const blob = new Blob([content], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `vial_export_${new Date().toISOString().replace(/[:.]/g, '-')}.md`;
                a.click();
                URL.revokeObjectURL(url);
                logEvent('export', 'Exported vials as Markdown', {}, 'INFO');
            } catch (err) {
                logError(`Export Error: ${err.message}`, 'Check /vial/src/vial_manager.js:70', err.stack || 'No stack', 'HIGH');
            }
        }

        function updateVialStatsUI() {
            try {
                const vialStatsDiv = document.getElementById('vial-stats');
                if (vialStatsDiv) {
                    vialStatsDiv.innerHTML = vials.map((vial, index) => `
                        <div class="progress-container">
                            <span class="progress-label">Vial ${index + 1}:</span>
                            <div class="progress-bar"><div class="progress-fill" id="vial${index + 1}-bar" style="width: ${vial.latencyHistory.length ? Math.min(100, vial.latencyHistory[vial.latencyHistory.length - 1] / 2) : 0}%"></div></div>
                            <span id="vial${index + 1}-value">${vial.latencyHistory.length ? vial.latencyHistory[vial.latencyHistory.length - 1].toFixed(2) : 0} ms</span>
                        </div>
                    `).join('');
                } else {
                    logError('Vial Stats Div Missing', 'Check /vial/static/vial.html:50', 'No stack', 'CRITICAL');
                }
            } catch (err) {
                logError(`Update Vial Stats Error: ${err.message}`, 'Check /vial/static/vial.html:200', err.stack || 'No stack', 'CRITICAL');
            }
        }

        function setupEventListeners() {
            try {
                const buttons = [
                    { id: 'create-vial-btn', handler: createVial, label: 'Create Vial' },
                    { id: 'troubleshoot-btn', handler: systemDiagnostics, label: 'Troubleshoot' },
                    { id: 'monitor-btn', handler: toggleMonitor, label: 'Monitor' },
                    { id: 'train-btn', handler: trainVials, label: 'Train' },
                    { id: 'void-btn', handler: voidVials, label: 'VOID' },
                    { id: 'export-btn', handler: saveVialAsMarkdown, label: 'Export Vials' }
                ];
                buttons.forEach(({ id, handler, label }) => {
                    const btn = document.getElementById(id);
                    if (btn) {
                        const handleInteraction = (e) => {
                            e.preventDefault();
                            logEvent('button', `Clicked/Touched ${label}`, { id }, 'INFO');
                            handler();
                        };
                        btn.onclick = handleInteraction;
                        btn.ontouchstart = (e) => {
                            e.preventDefault();
                            handleInteraction(e);
                        };
                    } else {
                        logError(`Button Missing: ${id}`, `Check /vial/static/vial.html:60`, 'No stack', 'CRITICAL');
                    }
                });
                const fileInput = document.getElementById('file-input');
                if (fileInput) {
                    fileInput.onchange = () => {
                        const file = fileInput.files[0];
                        if (file) logEvent('file', `Uploaded file: ${file.name}`, { size: file.size }, 'INFO');
                    };
                } else {
                    logError('File Input Missing', 'Check /vial/static/vial.html:40', 'No stack', 'CRITICAL');
                }
                const apiInput = document.getElementById('api-input');
                if (apiInput) {
                    apiInput.oninput = () => {
                        const input = apiInput.value.replace(/[<>&"]/g, c => ({ '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;' })[c] || c);
                        if (input) logEvent('api', `API URL: ${input}`, {}, 'INFO');
                    };
                } else {
                    logError('API Input Missing', 'Check /vial/static/vial.html:40', 'No stack', 'CRITICAL');
                }
            } catch (err) {
                logError(`Event Listener Error: ${err.message}`, 'Check /vial/static/vial.html:150', err.stack || 'No stack', 'CRITICAL');
            }
        }

        // Initialize Dexie
        if (typeof Dexie !== 'undefined' && window.indexedDB) {
            try {
                db = new Dexie('VialMCP');
                db.version(1).stores({ logs: '++id,timestamp,event_type', vials: 'name' });
                logEvent('system', 'IndexedDB initialized', {}, 'INFO');
            } catch (err) {
                logError(`Dexie Init Error: ${err.message}`, 'Check /vial/static/dexie.min.js:30', err.stack || 'No stack', 'HIGH');
            }
        } else {
            logError('Dexie/IndexedDB Not Supported', 'Check /vial/static/dexie.min.js:10', 'No stack', 'HIGH');
        }

        document.addEventListener('DOMContentLoaded', async () => {
            try {
                dependencies.forEach(dep => {
                    if (!dep.check()) logError(`${dep.name} Not Loaded`, `Check CDN ${dep.cdn}`, 'No stack', 'CRITICAL');
                });
                await initWorker();
                updateVialStatsUI();
                debouncedUpdateConsole();
                await authenticateOAuth();
                setupEventListeners();
                if (!isOnline && db) {
                    const cachedVials = await db.vials.toArray();
                    if (cachedVials.length) {
                        vials = cachedVials;
                        updateVialStatsUI();
                        logEvent('system', 'Loaded cached vials', { count: cachedVials.length }, 'INFO');
                        listVials();
                    }
                }
                logEvent('system', 'Vial MCP Controller initialized', {}, 'INFO');
            } catch (err) {
                logError(`Initialization Error: ${err.message}`, 'Check /vial/static/vial.html:100', err.stack || 'No stack', 'CRITICAL');
            }
        });

        window.addEventListener('online', () => {
            isOnline = true;
            logEvent('network', 'Network online', {}, 'INFO');
            authenticateOAuth();
        });

        window.addEventListener('offline', () => {
            isOnline = false;
            logEvent('network', 'Network offline', {}, 'HIGH');
            oauthToken = 'anonymous';
            logEvent('auth', 'Switched to anonymous token', {}, 'INFO');
        });

        window.addEventListener('error', e => logError(`Global Error: ${e.message}`, 'Check /vial/static/vial.html', e.stack || 'No stack', 'CRITICAL'));
        window.addEventListener('unhandledrejection', e => logError(`Promise Rejection: ${e.reason}`, 'Check /vial/static/vial.html:200', e.reason?.stack || 'No stack', 'CRITICAL'));
    </script>
</head>
<body>
    <h1 role="heading" aria-level="1">Vial MCP Controller</h1>
    <div id="input-container">
        <input id="file-input" type="file" accept=".html,.css,.js,.py" aria-label="Upload code file for vial training">
        <input id="api-input" type="text" placeholder="Enter API URL for vial training (webxos.netlify.app)" aria-label="Enter API URL for vial training">
        <div id="input-results"></div>
    </div>
    <div id="console" role="log" aria-live="polite">
        <p>Vial MCP Controller: Create Vial: Authenticate and initialize new vial | Troubleshoot: Run system diagnostics | Monitor: Toggle latency monitoring | Train: Start vial training | VOID: Destroy all vials | Export: Save all vials as .md</p>
    </div>
    <div id="vial-stats">
        <div class="progress-container">
            <span class="progress-label">Vial 1:</span>
            <div class="progress-bar"><div class="progress-fill" id="vial1-bar" style="width: 0%"></div></div>
            <span id="vial1-value">0 ms</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">Vial 2:</span>
            <div class="progress-bar"><div class="progress-fill" id="vial2-bar" style="width: 0%"></div></div>
            <span id="vial2-value">0 ms</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">Vial 3:</span>
            <div class="progress-bar"><div class="progress-fill" id="vial3-bar" style="width: 0%"></div></div>
            <span id="vial3-value">0 ms</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">Vial 4:</span>
            <div class="progress-bar"><div class="progress-fill" id="vial4-bar" style="width: 0%"></div></div>
            <span id="vial4-value">0 ms</span>
        </div>
    </div>
    <div class="button-group">
        <button id="create-vial-btn" aria-label="Authenticate and create new vial">Create Vial</button>
        <button id="troubleshoot-btn" aria-label="Run system diagnostics">Troubleshoot</button>
        <button id="monitor-btn" aria-label="Toggle real-time latency monitoring">Monitor</button>
        <button id="train-btn" aria-label="Start training all vials">Train</button>
        <button id="void-btn" aria-label="Destroy all vials and reset">VOID</button>
        <button id="export-btn" aria-label="Export all vials as markdown">Export Vials</button>
    </div>
    <footer>
        © 2025 WebXOS - Vial MCP Controller<br>
        Create Vial: Authenticate and initialize new vial | Troubleshoot: Run system diagnostics | Monitor: Toggle latency monitoring | Train: Start vial training | VOID: Destroy all vials | Export: Save all vials as .md
    </footer>
</body>
</html>
