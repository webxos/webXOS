<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vial 3D Controller</title>
    <link rel="icon" href="/vial/static/icon.png">
    <link rel="manifest" href="/vial/static/manifest.json">
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'VT323', monospace; }
        body { background: #000; color: #0f0; display: flex; flex-direction: column; align-items: center; height: 100vh; overflow: hidden; }
        h1 { font-size: 28px; margin: 10px 0; text-align: center; text-shadow: 0 0 5px #0f0; }
        #canvas-container { width: 80%; max-width: 800px; height: 400px; border: 2px solid #0f0; margin: 10px 0; }
        #console { width: 80%; max-width: 800px; height: 120px; background: #000; border: 1px solid #0f0; padding: 8px; overflow-y: auto; font-size: 16px; line-height: 1.2; }
        #console p { margin: 0; color: #0f0; }
        #console .error { color: #ff0000; }
        #controls { width: 80%; max-width: 800px; display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; margin: 10px 0; }
        button { background: #0f0; color: #000; border: 1px solid #0f0; padding: 5px 10px; font-size: 16px; cursor: pointer; }
        button:hover { background: #0c0; }
        button.active { background: #ff0; color: #000; }
        #input-container { width: 80%; max-width: 800px; margin: 10px 0; }
        #file-input, #api-input { width: 100%; background: #000; color: #0f0; border: 1px solid #0f0; padding: 5px; font-size: 16px; }
        #input-results { margin-top: 5px; font-size: 14px; color: #0f0; }
        #input-results .error { color: #ff0000; }
        @media (max-width: 600px) {
            h1 { font-size: 20px; }
            #canvas-container { height: 300px; }
            #console { height: 100px; font-size: 14px; }
            button { font-size: 14px; padding: 4px 8px; }
            #file-input, #api-input { font-size: 14px; }
        }
    </style>
    <script>
        let retryCount = 0, isLoggingError = false, logQueue = ['Vial 3D Controller initialized'];
        let ws, monitorActive = false, renderActive = false, monitorInterval, renderTimeout;
        let vials = Array(4).fill().map((_, i) => ({ name: `vial${i+1}`, latencyHistory: [], status: 'stopped', code: '', filePath: '', createdAt: '', codeLength: 0 }));
        let isOnline = navigator.onLine, oauthToken = null;
        let scene, camera, renderer, current3DScript, db;
        let worker;
        const API_BASE_URL = 'http://localhost:8080/mcp';
        const WS_URL = 'ws://localhost:8080/ws';

        try {
            db = new Dexie('VialDB');
            db.version(1).stores({ logs: '++id,timestamp,event_type', vials: 'name' });
        } catch (err) {
            logError(`Dexie Init Error: ${err.message}`, 'Check dexie.min.js', err.stack, 'CRITICAL');
        }

        try {
            worker = new Worker('/vial/static/worker.js');
        } catch (err) {
            logError(`Worker Init Error: ${err.message}`, 'Check /vial/static/worker.js or browser support', err.stack, 'CRITICAL');
        }

        function updateConsole(logs = null) {
            const consoleDiv = document.getElementById('console');
            if (!consoleDiv) return;
            consoleDiv.innerHTML = logs ? Mustache.render('{{#logs}}<p>{{message}}</p>{{/logs}}', { logs }) : logQueue.join('');
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        async function logEvent(event_type, message, metadata, urgency) {
            const timestamp = new Date().toISOString();
            const logData = { timestamp, event_type, message, metadata, urgency };
            if (worker) {
                try {
                    worker.postMessage({ action: 'log', data: logData });
                } catch (err) {
                    logError(`Worker Post Error: ${err.message}`, 'Check worker.js or message format', err.stack, 'HIGH');
                }
            }
            if (db) await db.logs.add(logData);
            if (isOnline && window.LZString) {
                try {
                    await redaxios.post(`${API_BASE_URL}/log-sync`, { log: LZString.compressToUTF16(JSON.stringify(logData)) }, { headers: { Authorization: `Bearer ${oauthToken}` } });
                } catch (err) {
                    if (db) await db.logs.add({ ...logData, synced: false });
                }
            }
            logQueue.push(`<p class="${event_type === 'error' ? 'error' : ''}">[${timestamp}] ${message}</p>`);
            if (logQueue.length > 50) logQueue.shift();
            updateConsole();
        }

        function logError(message, analysis, stack, urgency) {
            if (isLoggingError) return;
            isLoggingError = true;
            const timestamp = new Date().toISOString();
            const errorMessage = `[${timestamp}] ERROR: ${message}\nAnalysis: ${analysis}\nTraceback: ${stack || 'No stack'}`;
            logQueue.push(`<p class="error">${errorMessage}</p>`);
            if (logQueue.length > 50) logQueue.shift();
            updateConsole();
            logEvent('error', message, { analysis, stack }, urgency);
            isLoggingError = false;
        }

        async function loadScript(url) {
            if (retryCount > 2) return logError(`Failed to load script: ${url}`, 'Check CDN, network, or CORS settings', '', 'CRITICAL');
            retryCount++;
            try {
                const script = document.createElement('script');
                script.src = url;
                script.crossOrigin = 'anonymous';
                script.onerror = () => logError(`Fallback load failed: ${url}`, 'Check CDN, file path, or CORS headers', '', 'CRITICAL');
                document.head.appendChild(script);
            } catch (err) {
                logError(`Script Load Error: ${url} - ${err.message}`, 'Check browser console or network', err.stack, 'CRITICAL');
            }
        }
    </script>
    <script src="/vial/static/redaxios.min.js" crossOrigin="anonymous" onerror="loadScript('https://cdn.jsdelivr.net/npm/redaxios@0.5.1/dist/redaxios.min.js')"></script>
    <script src="/vial/static/lz-string.min.js" crossOrigin="anonymous" onerror="loadScript('https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js')"></script>
    <script src="/vial/static/mustache.min.js" crossOrigin="anonymous" onerror="loadScript('https://cdn.jsdelivr.net/npm/mustache@4.2.0/mustache.min.js')"></script>
    <script src="/vial/static/dexie.min.js" crossOrigin="anonymous" onerror="loadScript('https://cdn.jsdelivr.net/npm/dexie@3.2.4/dist/dexie.min.js')"></script>
    <script src="/vial/static/jwt-decode.min.js" crossOrigin="anonymous" onerror="loadScript('https://cdn.jsdelivr.net/npm/jwt-decode@3.1.2/build/jwt-decode.min.js')"></script>
    <script src="/vial/static/three.min.js" crossOrigin="anonymous" onerror="loadScript('https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js')"></script>
    <script src="/vial/static/webgpu-polyfill.min.js" crossOrigin="anonymous" onerror="loadScript('https://cdn.jsdelivr.net/npm/webgpu-polyfill@0.1.0/dist/webgpu-polyfill.min.js')"></script>
    <script>
        if (worker) {
            worker.onmessage = (e) => {
                const { status, logs, message } = e.data;
                if (status === 'initialized') logEvent('system', 'SQLite initialized', { component: 'worker' }, 'LOW');
                else if (status === 'logs') updateConsole(logs);
                else if (status === 'error') logError(`Worker Error: ${message}`, 'Check worker.js', '', 'HIGH');
            };
            worker.onerror = (e) => logError(`Worker Script Error: ${e.message}`, 'Check worker.js or CORS', `${e.filename}:${e.lineno}:${e.colno}`, 'CRITICAL');
            try {
                worker.postMessage({ action: 'init' });
            } catch (err) {
                logError(`Worker Init Message Error: ${err.message}`, 'Check worker.js or browser support', err.stack, 'CRITICAL');
            }
        }

        function init3DCanvas() {
            const container = document.getElementById('canvas-container');
            if (!container) return logError('Canvas container not found', 'Check HTML', '', 'CRITICAL');
            if (!window.THREE) return logError('Three.js not loaded for canvas', 'Check three.min.js', '', 'CRITICAL');
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            camera.position.z = 5;
            logEvent('3d', '3D canvas initialized', { width: container.clientWidth, height: container.clientHeight }, 'INFO');
        }

        function initializeWebSocket() {
            if (!oauthToken) return logError('No OAuth token', 'Authenticate first', '', 'CRITICAL');
            ws = new WebSocket(`${WS_URL}?token=${encodeURIComponent(oauthToken)}`);
            ws.onopen = () => { logEvent('websocket', 'Connected', { url: WS_URL }, 'INFO'); isOnline = true; retryCount = 0; };
            ws.onmessage = (e) => {
                try {
                    const { event_type, message, metadata } = JSON.parse(e.data);
                    logEvent(event_type, message, metadata, 'INFO');
                } catch (err) {
                    logError(`WebSocket Message Error: ${err.message}`, 'Check message format', err.stack, 'HIGH');
                }
            };
            ws.onerror = () => { logError('WebSocket Error', 'Check server or token', '', 'CRITICAL'); isOnline = false; };
            ws.onclose = () => {
                logEvent('websocket', 'Disconnected', {}, 'HIGH');
                isOnline = false;
                setTimeout(initializeWebSocket, Math.min(1000 * 2 ** retryCount, 30000));
            };
        }

        async function authenticateOAuth() {
            try {
                const storedToken = localStorage.getItem('mcp_token');
                if (storedToken && window.jwt_decode && jwt_decode(storedToken).exp * 1000 > Date.now()) {
                    oauthToken = storedToken;
                    initializeWebSocket();
                    return;
                }
                const res = await redaxios.post(`${API_BASE_URL}/auth`, { token: storedToken || 'anonymous' });
                oauthToken = res.data.token;
                localStorage.setItem('mcp_token', oauthToken);
                initializeWebSocket();
                logEvent('auth', 'OAuth authenticated', { token: oauthToken.slice(0, 10) + '...' }, 'INFO');
            } catch (err) {
                logError(`OAuth Error: ${err.message}`, 'Check auth endpoint', err.stack, 'CRITICAL');
                oauthToken = null;
            }
        }

        async function systemDiagnostics() {
            const checks = [
                { name: 'Network', test: () => navigator.onLine, error: 'Offline mode detected' },
                { name: 'WebSocket', test: () => ws?.readyState === WebSocket.OPEN, error: 'WebSocket disconnected' },
                { name: 'OAuth', test: () => !!oauthToken && window.jwt_decode && jwt_decode(oauthToken).exp * 1000 > Date.now(), error: 'Invalid OAuth token' },
                { name: 'Worker', test: () => !!worker, error: 'Web Worker not initialized' },
                { name: 'Dexie', test: async () => db && (await db.logs.count()) >= 0, error: 'IndexedDB failure' },
                { name: 'ThreeJS', test: () => !!window.THREE, error: 'Three.js not loaded' },
                { name: 'WebGPU', test: () => !!navigator.gpu || !!window.WebGPUPolyfill, error: 'WebGPU not supported' },
                { name: 'Redaxios', test: () => !!window.redaxios, error: 'Redaxios not loaded' },
                { name: 'LZString', test: () => !!window.LZString, error: 'LZString not loaded' },
                { name: 'Mustache', test: () => !!window.Mustache, error: 'Mustache not loaded' }
            ];
            logEvent('diagnostics', 'Starting system diagnostics', {}, 'INFO');
            for (const { name, test, error } of checks) {
                try {
                    if (!(await test())) throw new Error(error);
                    logEvent('diagnostics', `${name} check passed`, {}, 'INFO');
                } catch (err) {
                    logError(`${name} Failure: ${err.message}`, `Check ${name.toLowerCase()}`, err.stack, 'CRITICAL');
                }
            }
            if (isOnline) {
                try {
                    const res = await redaxios.get(`${API_BASE_URL}/diagnostics`, { headers: { Authorization: `Bearer ${oauthToken}` } });
                    res.data.issues.forEach(issue => logError(`Server Issue: ${issue.message}`, issue.analysis, issue.stack, 'HIGH'));
                    logEvent('diagnostics', 'Diagnostics complete', { issues: res.data.issues.length }, 'INFO');
                } catch (err) {
                    logError(`Diagnostics Error: ${err.message}`, 'Check diagnostics endpoint', err.stack, 'CRITICAL');
                }
            }
        }

        async function createVial() {
            if (!oauthToken) return logError('Unauthorized', 'Authenticate first', '', 'CRITICAL');
            const fileInput = document.getElementById('file-input'), apiInput = document.getElementById('api-input');
            if (!fileInput || !apiInput) return logError('Missing input elements', 'Check HTML', '', 'CRITICAL');
            if (!fileInput.files?.length && !apiInput.value?.trim()) return logError('No input provided', 'Select file or enter script', '', 'HIGH');
            if (vials.filter(v => v.status === 'running').length >= 4) return logError('Maximum 4 vials', 'Stop a vial', '', 'HIGH');
            const vialIndex = vials.findIndex(v => v.status === 'stopped');
            if (vialIndex === -1) return logError('No free vials', 'Stop a vial', '', 'HIGH');
            try {
                const vialId = `vial_${Math.floor(100000 + Math.random() * 900000)}`;
                let code = apiInput.value?.trim() || '';
                if (fileInput.files?.length > 0) code = await fileInput.files[0].text();
                if (!code.includes('THREE.') || !window.THREE) {
                    if (!window.THREE) {
                        code = `console.log('Basic 3D rendering unavailable; Three.js not loaded');`;
                        logError('Three.js not loaded for default code', 'Ensure three.min.js is loaded', '', 'HIGH');
                    } else {
                        code = `const geometry = new THREE.BoxGeometry(1, 1, 1); const material = new THREE.MeshBasicMaterial({color: 0x00ff00}); const cube = new THREE.Mesh(geometry, material); scene.add(cube); cube.rotation.x += 0.01; cube.rotation.y += 0.01;`;
                    }
                }
                const vialData = { id: vialId, code: { js: code }, training: { model: '3d', epochs: 5 } };
                const res = await redaxios.post(`${API_BASE_URL}/vial`, vialData, { headers: { Authorization: `Bearer ${oauthToken}` } });
                const { id, latency, createdAt, codeLength } = res.data;
                vials[vialIndex] = { name: id, latencyHistory: [latency], status: 'running', code, filePath: `/vial/uploads/vial${id}.js`, createdAt, codeLength };
                localStorage.setItem('vials', JSON.stringify(vials));
                if (db) await db.vials.put(vials[vialIndex]);
                logEvent('vial', `Created 3D vial ${id}`, { latency, codeLength }, 'INFO');
            } catch (err) {
                logError(`Create Vial Error: ${err.message}`, 'Check backend or input', err.stack, 'CRITICAL');
            }
        }

        async function toggleMonitor() {
            if (!oauthToken) return logError('Unauthorized', 'Authenticate first', '', 'CRITICAL');
            monitorActive = !monitorActive;
            const monitorBtn = document.getElementById('monitor-btn');
            if (monitorBtn) monitorBtn.classList.toggle('active', monitorActive);
            logEvent('monitor', monitorActive ? 'Monitoring started' : 'Monitoring stopped', {}, 'INFO');
            if (monitorActive) {
                monitorInterval = setInterval(async () => {
                    try {
                        const res = await redaxios.get(`${API_BASE_URL}/vials`, { headers: { Authorization: `Bearer ${oauthToken}` } });
                        vials = res.data.map(vial => ({
                            name: vial.id, latencyHistory: vial.latencyHistory, status: vial.status, code: vial.code.js, filePath: vial.filePath, createdAt: vial.createdAt, codeLength: vial.codeLength
                        }));
                        localStorage.setItem('vials', JSON.stringify(vials));
                        if (db) await db.vials.bulkPut(vials);
                    } catch (err) {
                        logError(`Monitor Update Error: ${err.message}`, 'Check backend', err.stack, 'HIGH');
                    }
                }, 5000);
            } else {
                clearInterval(monitorInterval);
            }
        }

        async function render3D() {
            if (!oauthToken) return logError('Unauthorized', 'Authenticate first', '', 'CRITICAL');
            renderActive = !renderActive;
            const renderBtn = document.getElementById('render-btn');
            if (renderBtn) renderBtn.classList.toggle('active', renderActive);
            logEvent('render', renderActive ? '3D rendering started' : '3D rendering stopped', {}, 'INFO');
            if (renderActive) {
                const inputData = document.getElementById('api-input')?.value?.trim() || '';
                if (!inputData && !vials.some(v => v.status === 'running')) return logError('No 3D script or active vials', 'Provide input or start vial', '', 'HIGH');
                for (const vial of vials) {
                    if (vial.status !== 'running') continue;
                    try {
                        scene.clear();
                        current3DScript = new Function('THREE', 'scene', 'camera', vial.code);
                        try {
                            current3DScript(THREE, scene, camera);
                        } catch (err) {
                            logError(`3D Script Execution Error for ${vial.name}: ${err.message}`, 'Check vial script syntax', err.stack, 'CRITICAL');
                        }
                        const animate = () => {
                            if (!renderActive) return;
                            requestAnimationFrame(animate);
                            renderer.render(scene, camera);
                        };
                        animate();
                        logEvent('render', `Rendered 3D vial ${vial.name}`, { codeLength: vial.codeLength }, 'INFO');
                    } catch (err) {
                        logError(`3D Render Error for ${vial.name}: ${err.message}`, 'Check script syntax or Three.js', err.stack, 'CRITICAL');
                    }
                }
                renderTimeout = setTimeout(() => { renderActive = false; if (renderBtn) renderBtn.classList.remove('active'); }, 30000);
            } else {
                clearTimeout(renderTimeout);
                scene.clear();
                renderer.render(scene, camera);
            }
        }

        async function voidVials() {
            if (!oauthToken) return logError('Unauthorized', 'Authenticate first', '', 'CRITICAL');
            try {
                await redaxios.post(`${API_BASE_URL}/destroy`, {}, { headers: { Authorization: `Bearer ${oauthToken}` } });
                vials = Array(4).fill().map((_, i) => ({ name: `vial${i+1}`, latencyHistory: [], status: 'stopped', code: '', filePath: '', createdAt: '', codeLength: 0 }));
                localStorage.setItem('vials', JSON.stringify(vials));
                if (db) await db.vials.clear();
                if (db) await db.vials.bulkPut(vials);
                logQueue = ['Vial 3D Controller initialized'];
                scene.clear();
                renderer.render(scene, camera);
                updateConsole();
                logEvent('void', 'All 3D vials destroyed', {}, 'HIGH');
            } catch (err) {
                logError(`VOID Error: ${err.message}`, 'Check backend', err.stack, 'HIGH');
            }
        }

        async function loadMarkdown() {
            if (!oauthToken) return logError('Unauthorized', 'Authenticate first', '', 'CRITICAL');
            const fileInput = document.getElementById('file-input');
            if (!fileInput?.files?.length) return logError('No Markdown file selected', 'Select a file', '', 'HIGH');
            try {
                const text = await fileInput.files[0].text();
                const sections = text.split('---\n\n').filter(s => s.includes('Code:\n```js'));
                if (!sections.length) return logError('No valid JS code blocks found', 'Check Markdown format', '', 'HIGH');
                for (const section of sections) {
                    const codeMatch = section.match(/```js\n([\s\S]*?)\n```/);
                    if (!codeMatch) continue;
                    const code = codeMatch[1];
                    const vialId = `vial_${Math.floor(100000 + Math.random() * 900000)}`;
                    const vialData = { id: vialId, code: { js: code }, training: { model: '3d', epochs: 5 } };
                    const res = await redaxios.post(`${API_BASE_URL}/vial`, vialData, { headers: { Authorization: `Bearer ${oauthToken}` } });
                    const { id, latency, createdAt, codeLength } = res.data;
                    const vialIndex = vials.findIndex(v => v.status === 'stopped');
                    if (vialIndex === -1) return logError('No free vials', 'Stop a vial', '', 'HIGH');
                    vials[vialIndex] = { name: id, latencyHistory: [latency], status: 'running', code, filePath: `/vial/uploads/vial${id}.js`, createdAt, codeLength };
                    localStorage.setItem('vials', JSON.stringify(vials));
                    if (db) await db.vials.put(vials[vialIndex]);
                    logEvent('load', `Loaded 3D vial ${id} from Markdown`, { latency, codeLength }, 'INFO');
                }
            } catch (err) {
                logError(`Load Markdown Error: ${err.message}`, 'Check file format', err.stack, 'CRITICAL');
            }
        }

        function setupEventListeners() {
            const buttons = [
                { id: 'create-btn', handler: createVial },
                { id: 'diagnose-btn', handler: systemDiagnostics },
                { id: 'monitor-btn', handler: toggleMonitor },
                { id: 'render-btn', handler: render3D },
                { id: 'void-btn', handler: voidVials },
                { id: 'load-btn', handler: loadMarkdown }
            ];
            buttons.forEach(({ id, handler }) => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.addEventListener('click', handler);
                    btn.addEventListener('touchstart', handler);
                }
            });
            const fileInput = document.getElementById('file-input');
            if (fileInput) fileInput.addEventListener('change', () => fileInput.files[0] && logEvent('file', `Uploaded file: ${fileInput.files[0].name}`, { size: fileInput.files[0].size }, 'INFO'));
            const apiInput = document.getElementById('api-input');
            if (apiInput) apiInput.addEventListener('input', () => apiInput.value && logEvent('api', `API URL: ${apiInput.value}`, {}, 'INFO'));
            window.addEventListener('resize', () => {
                if (renderer && document.getElementById('canvas-container')) {
                    const container = document.getElementById('canvas-container');
                    renderer.setSize(container.clientWidth, container.clientHeight);
                    camera.aspect = container.clientWidth / container.clientHeight;
                    camera.updateProjectionMatrix();
                }
            });
        }

        window.addEventListener('load', async () => {
            if (!window.redaxios) logError('Dependency Missing: redaxios', 'Check /vial/static/redaxios.min.js', '', 'CRITICAL');
            if (!window.LZString) logError('Dependency Missing: lz-string', 'Check /vial/static/lz-string.min.js', '', 'CRITICAL');
            if (!window.Mustache) logError('Dependency Missing: mustache', 'Check /vial/static/mustache.min.js', '', 'CRITICAL');
            if (!window.jwt_decode) logError('Dependency Missing: jwt-decode', 'Check /vial/static/jwt-decode.min.js', '', 'CRITICAL');
            if (!window.THREE) logError('Dependency Missing: Three.js', 'Check /vial/static/three.min.js', '', 'CRITICAL');
            if (!window.Dexie) logError('Dependency Missing: Dexie', 'Check /vial/static/dexie.min.js', '', 'CRITICAL');
            init3DCanvas();
            await authenticateOAuth();
            logEvent('system', 'Vial 3D Controller initialized', {}, 'INFO');
            setupEventListeners();
            if (!isOnline && db) {
                logEvent('system', 'Offline mode: Using cached data', {}, 'INFO');
                vials = JSON.parse(localStorage.getItem('vials')) || await db.vials.toArray();
            }
        });

        window.addEventListener('online', () => { isOnline = true; logEvent('network', 'Network online', {}, 'INFO'); authenticateOAuth(); });
        window.addEventListener('offline', () => { isOnline = false; logEvent('network', 'Network offline', {}, 'HIGH'); });
        window.addEventListener('error', (e) => logError(`Global Error: ${e.message}`, 'Check browser console or CORS settings', e.stack || `${e.filename}:${e.lineno}:${e.colno}`, 'CRITICAL'));
        window.addEventListener('unhandledrejection', (e) => logError(`Promise Rejection: ${e.reason}`, 'Check async operations', e.reason?.stack, 'CRITICAL'));
    </script>
</head>
<body>
    <h1>Vial 3D Controller</h1>
    <div id="input-container">
        <input id="file-input" type="file" accept=".md,.js" aria-label="Upload Markdown or JS file">
        <input id="api-input" type="text" placeholder="Enter 3D script or API URL" aria-label="Enter 3D script or API URL">
        <div id="input-results" aria-live="polite"></div>
    </div>
    <div id="canvas-container" aria-label="3D rendering canvas"></div>
    <div id="console" aria-live="polite">
        <p>Vial 3D Controller: Create: Initialize new 3D vial | Diagnose: Run diagnostics | Monitor: Toggle monitoring | Render: Start 3D rendering | Void: Destroy all vials | Load: Import Markdown</p>
    </div>
    <div id="controls">
        <button id="create-btn" aria-label="Create new 3D vial">Create</button>
        <button id="diagnose-btn" aria-label="Run system diagnostics">Diagnose</button>
        <button id="monitor-btn" aria-label="Toggle real-time monitoring">Monitor</button>
        <button id="render-btn" aria-label="Start 3D rendering">Render</button>
        <button id="void-btn" aria-label="Destroy all 3D vials">Void</button>
        <button id="load-btn" aria-label="Load Markdown vials">Load</button>
    </div>
</body>
</html>
<!-- Rebuild Instructions: Place in /vial/static/. Ensure /vial/static/redaxios.min.js, /vial/static/lz-string.min.js, /vial/static/mustache.min.js, /vial/static/dexie.min.js, /vial/static/jwt-decode.min.js, /vial/static/three.min.js, /vial/static/webgpu-polyfill.min.js, /vial/static/worker.js, /vial/static/icon.png, and /vial/static/manifest.json exist. Run `node src/server.js` for backend. Test in browser at http://localhost:8080/vial/static/vial3d.html. Check /vial/errorlog.md for issues. -->
