<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>TEMPEST 2k26 ¬∑ AI TRAINING DASHBOARD</title>
  <style>
    /* ---------- your original styles (condensed) ---------- */
    * { margin:0; padding:0; box-sizing:border-box; font-family:'Orbitron','Courier New',monospace; }
    body { background:#000; color:#0ff; height:100vh; overflow:hidden; touch-action:none; }
    #gameCanvas { position:absolute; top:0; left:0; width:100%; height:100%; z-index:0; }
    .ui-container {
      position:fixed; bottom:20px; left:50%; transform:translateX(-50%);
      display:flex; gap:15px; z-index:20; padding:15px;
      background:rgba(0,20,30,0.7); border-radius:20px; border:2px solid #0ff;
      backdrop-filter:blur(5px);
    }
    .ui-btn {
      width:70px; height:70px; border-radius:50%;
      background:linear-gradient(145deg,#003344,#001122);
      border:2px solid #0ff; color:#0ff; cursor:pointer;
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      font-size:12px; text-transform:uppercase; letter-spacing:1px;
      box-shadow:0 0 15px rgba(0,255,255,0.5); transition:all 0.2s;
    }
    .ui-btn:hover { background:linear-gradient(145deg,#004455,#002233); box-shadow:0 0 20px #0ff; }
    .ui-btn .key { font-size:20px; font-weight:bold; margin-bottom:4px; }
    /* ----- dashboard overlay (new) ----- */
    #dashboard {
      position:absolute; top:20px; right:20px; width:300px;
      background:rgba(0,10,20,0.9); border:2px solid #0ff; border-radius:12px;
      padding:15px; color:#0f0; font-family:'Courier New',monospace;
      box-shadow:0 0 30px #0f0; backdrop-filter:blur(5px); z-index:30;
      pointer-events:all;
    }
    #dashboard h2 { text-align:center; margin-bottom:15px; font-size:22px; text-shadow:0 0 8px #0f0; }
    .metric { display:flex; justify-content:space-between; margin:8px 0; }
    .metric .label { color:#8f8; }
    .metric .value { color:#fff; font-weight:bold; text-shadow:0 0 5px #0f0; }
    .slider-container { margin:15px 0 5px; }
    .slider-container label { display:block; margin-bottom:5px; color:#afa; }
    input[type=range] { width:100%; background:#030; height:5px; border-radius:5px; accent-color:#0f0; }
    button {
      background:#030; border:2px solid #0f0; color:#0f0; font-family:inherit;
      font-size:14px; padding:8px 12px; margin:5px 2px; border-radius:20px;
      cursor:pointer; transition:0.2s; font-weight:bold;
    }
    button:hover { background:#0f0; color:#000; box-shadow:0 0 20px #0f0; }
    #exportBtn { background:#330; border-color:#ff0; color:#ff0; }
    #exportBtn:hover { background:#ff0; color:#000; }
    #statusBar {
      position:absolute; bottom:20px; left:20px; color:#0f0; font-size:14px;
      background:rgba(0,0,0,0.6); padding:6px 12px; border-radius:20px;
      border:1px solid #0f0; z-index:30;
    }
    /* keep all your original UI classes (combat-ui, etc.) ‚Äì they are already in the rest of the code */
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <!-- Original UI elements (condensed, but all IDs kept) -->
  <div class="combat-ui" id="combatUI"><div class="grid-overlay"></div><div class="targeting-grid"><div class="ring"></div><div class="ring"></div><div class="ring"></div><div class="ring"></div><div class="ring"></div></div></div>
  <div class="light-speed-effect" id="lightSpeedEffect"></div>
  <div class="combat-stats"><div>WAVE: <span id="waveCount">1</span></div><div>ENEMIES: <span id="enemyCount">0</span></div><div>SCORE: <span id="combatScore">0</span></div><div>HEALTH:</div><div class="health-bar"><div class="health-fill" id="healthFill" style="width:100%"></div></div><div>SHIELD:</div><div class="shield-bar"><div class="shield-fill" id="shieldFill" style="width:100%"></div></div></div>
  <div class="currency-display"><span class="currency-icon">$</span><span id="currencyCount">0</span></div>
  <div class="drone-status" id="droneStatus"><div>DRONES: <span id="droneCount">0</span>/3</div><div>FORMATION: <span id="formationType">FOLLOW</span></div><div>LEVEL: <span id="droneLevel">1</span></div></div>
  <div class="warning-alert" id="warningAlert">INCOMING!</div>
  <div class="ui-container">
    <div class="ui-btn" id="thrustBtn"><div class="key">W</div><div>THRUST</div></div>
    <div class="ui-btn" id="combatBtn"><div class="key">ALT</div><div>SWARM</div></div>
    <div class="ui-btn" id="ecoBtn"><div class="key">TAB</div><div>ECO MODE</div></div>
    <div class="ui-btn" id="fireBtn"><div class="key">SPC</div><div>FIRE</div></div>
    <div class="ui-btn" id="boostBtn"><div class="key">SHIFT</div><div>BOOST</div></div>
    <div class="ui-btn" id="menuBtn"><div class="key">ESC</div><div>MENU</div></div>
  </div>
  <div class="console-message" id="consoleMessage"></div>
  <div class="main-menu" id="mainMenu">
    <h1 class="game-title">TEMPEST 2k26 (BETA)</h1>
    <div class="menu-options">
      <div class="menu-btn" id="startBtn">SINGLE PLAYER</div>
      <div class="menu-btn" id="multiplayerBtn">(Updates Soon)</div>
      <div class="menu-btn" id="settingsBtn">SETTINGS</div>
      <div class="menu-btn" id="quitBtn">WASD + SPACE + ALT etc.</div>
    </div>
    <div class="settings-panel" id="settingsPanel"><button class="close-settings" id="closeSettings">X</button><h2>SETTINGS</h2> ... (same as your original) ...</div>
  </div>

  <!-- New Dashboard -->
  <div id="dashboard">
    <h2>‚ö° AI TRAINING ‚ö°</h2>
    <div class="metric"><span class="label">Episode:</span><span id="episodeVal" class="value">0</span></div>
    <div class="metric"><span class="label">Score:</span><span id="scoreVal" class="value">0</span></div>
    <div class="metric"><span class="label">Steps:</span><span id="stepsVal" class="value">0</span></div>
    <div class="metric"><span class="label">Reward (sum):</span><span id="rewardVal" class="value">0.00</span></div>
    <div class="metric"><span class="label">Œµ (explore):</span><span id="epsilonVal" class="value">0.20</span></div>
    <div class="slider-container">
      <label>Œ± (learning rate) <span id="lrDisplay">0.10</span></label>
      <input type="range" id="lrSlider" min="0.01" max="0.5" step="0.01" value="0.1">
    </div>
    <div class="slider-container">
      <label>Œµ (exploration) <span id="epsDisplay">0.20</span></label>
      <input type="range" id="epsSlider" min="0.01" max="0.9" step="0.01" value="0.2">
    </div>
    <div class="slider-container">
      <label>Œ≥ (discount) <span id="gammaDisplay">0.95</span></label>
      <input type="range" id="gammaSlider" min="0.5" max="0.99" step="0.01" value="0.95">
    </div>
    <div style="display:flex; justify-content:space-between;">
      <button id="pauseBtn">‚è∏Ô∏è PAUSE</button>
      <button id="resetBtn">üîÑ RESET</button>
      <button id="exportBtn">üì• EXPORT LOGS</button>
    </div>
  </div>
  <div id="statusBar">ü§ñ AI PLAYING ¬∑ WORKER ACTIVE</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
    // ---------- MAIN THREAD (RENDERING) ----------
    let scene, camera, renderer;
    let player;               // the ship group (already defined in createPlayerShip)
    let enemies = [], projectiles = [];
    let clock = new THREE.Clock();

    // Display stats
    let displayStats = { episode:0, score:0, steps:0, reward:0, epsilon:0.2 };

    // Tube geometry (for positioning)
    const TUBE_RADIUS = 12;
    const TUBE_SEGMENTS = 16;

    function initThree() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000010);
      scene.fog = new THREE.Fog(0x000010, 50, 500);
      
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
      camera.position.set(0, 3, 10);
      
      renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias:true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
      
      // Lighting
      const ambient = new THREE.AmbientLight(0x444455);
      scene.add(ambient);
      const dirLight = new THREE.DirectionalLight(0xffffff,1);
      dirLight.position.set(5,5,5);
      scene.add(dirLight);
      
      createStarfield();
      createCelestialObjects();
      createPlayerShip();     // your original ship builder
      createHomePlanet();
      
      // Draw a simple tube outline (optional)
      const tubeMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
      for (let i = 0; i <= TUBE_SEGMENTS; i++) {
        const angle = (i / TUBE_SEGMENTS) * Math.PI * 2;
        const x = Math.cos(angle) * TUBE_RADIUS;
        const y = Math.sin(angle) * TUBE_RADIUS;
        const points = [];
        for (let z = -20; z <= 10; z += 2) {
          points.push(new THREE.Vector3(x, y, z));
        }
        const geo = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geo, tubeMaterial);
        scene.add(line);
      }
    }

    // Your original helper functions (starfield, planets, ship) ‚Äì unchanged
    function createStarfield() {
      const geo = new THREE.BufferGeometry();
      const mat = new THREE.PointsMaterial({color:0xffffff,size:0.5,sizeAttenuation:true});
      const vertices = [];
      for(let i=0;i<10000;i++) vertices.push((Math.random()-0.5)*2000,(Math.random()-0.5)*2000,(Math.random()-0.5)*2000);
      geo.setAttribute('position',new THREE.Float32BufferAttribute(vertices,3));
      scene.add(new THREE.Points(geo,mat));
    }
    function createCelestialObjects() {
      for(let i=0;i<5;i++) {
        const size = 10+Math.random()*20;
        const geo = new THREE.SphereGeometry(size,32,32);
        const colors = [0x3366ff,0xff6633,0x33ff66,0xff33cc,0xffff33];
        const mat = new THREE.MeshPhongMaterial({color:colors[i],emissive:colors[i]-0x222222});
        const planet = new THREE.Mesh(geo,mat);
        const angle = (i/5)*Math.PI*2;
        planet.position.set(Math.cos(angle)*400, (Math.random()-0.5)*100, Math.sin(angle)*400);
        scene.add(planet);
      }
    }
    function createHomePlanet() {
      const geo = new THREE.SphereGeometry(25,32,32);
      const mat = new THREE.MeshPhongMaterial({color:0x00ff00,emissive:0x00aa00});
      const planet = new THREE.Mesh(geo,mat);
      planet.position.set(0,0,-200);
      scene.add(planet);
    }
    function createPlayerShip() {
      player = new THREE.Group();
      const bodyGeo = new THREE.CylinderGeometry(0.8,1.2,4,8);
      const wingGeo = new THREE.BoxGeometry(3,0.2,1.5);
      const tailGeo = new THREE.BoxGeometry(1,1,1);
      const mat = new THREE.MeshPhongMaterial({color:0x0066ff,emissive:0x0033aa});
      
      const body = new THREE.Mesh(bodyGeo,mat);
      body.rotation.x = Math.PI/2;
      body.position.z = -2;
      player.add(body);
      
      const leftWing = new THREE.Mesh(wingGeo,mat);
      leftWing.position.set(-1.5,0,-1.5);
      leftWing.rotation.z = Math.PI/6;
      player.add(leftWing);
      
      const rightWing = new THREE.Mesh(wingGeo,mat);
      rightWing.position.set(1.5,0,-1.5);
      rightWing.rotation.z = -Math.PI/6;
      player.add(rightWing);
      
      const tail = new THREE.Mesh(tailGeo,mat);
      tail.position.set(0,0,-3);
      tail.scale.set(0.5,1,2);
      player.add(tail);
      
      const engineMat = new THREE.MeshBasicMaterial({color:0x00ffff,emissive:0x0088ff,transparent:true,opacity:0.9});
      const leftEngine = new THREE.Mesh(new THREE.SphereGeometry(0.6,16),engineMat);
      leftEngine.position.set(-0.8,0,-3.5);
      player.add(leftEngine);
      const rightEngine = leftEngine.clone();
      rightEngine.position.set(0.8,0,-3.5);
      player.add(rightEngine);
      
      scene.add(player);
      player.position.set(0,0,-5); // initial position at bottom of tube
    }

    // Helper to position objects on tube rim given segment and depth
    function getTubePosition(segment, depth) {
      const angle = (segment / TUBE_SEGMENTS) * Math.PI * 2;
      return new THREE.Vector3(
        Math.cos(angle) * TUBE_RADIUS,
        Math.sin(angle) * TUBE_RADIUS,
        depth   // depth: negative = far, positive = near (bottom ~ -5)
      );
    }

    // Create enemy mesh
    function createEnemyMesh(segment, depth) {
      const geo = new THREE.ConeGeometry(1.2,2.5,3);
      const mat = new THREE.MeshPhongMaterial({color:0xff0000,emissive:0xaa0000});
      const mesh = new THREE.Mesh(geo,mat);
      mesh.rotation.x = Math.PI/2;
      const pos = getTubePosition(segment, depth);
      mesh.position.copy(pos);
      scene.add(mesh);
      return mesh;
    }

    function createProjectileMesh(segment, depth, color=0xffff00) {
      const geo = new THREE.SphereGeometry(0.2,8);
      const mat = new THREE.MeshBasicMaterial({color,emissive:color});
      const mesh = new THREE.Mesh(geo,mat);
      const pos = getTubePosition(segment, depth);
      mesh.position.copy(pos);
      scene.add(mesh);
      return mesh;
    }

    // ---------- WEB WORKER (proper Tempest simulation) ----------
    const workerCode = `
      // Worker: Tempest tube simulation
      const TUBE_SEGMENTS = 16;
      const TUBE_DEPTH_MIN = -20;  // far end
      const TUBE_DEPTH_MAX = -5;    // bottom (player area)
      
      let episode = 0, score = 0, steps = 0, done = false;
      let rewardSum = 0;
      
      // Player state
      let playerSegment = 0; // 0-15
      
      // Game objects
      let enemies = [];       // {segment, depth}
      let projectiles = [];   // {segment, depth}
      
      // RL parameters
      let alpha = 0.1;
      let epsilon = 0.2;
      let gamma = 0.95;
      
      let logs = [];
      
      // Actions: 0 = left, 1 = right, 2 = fire
      function chooseAction() {
        if (Math.random() < epsilon) return Math.floor(Math.random() * 3);
        else return Math.floor(Math.random() * 3); // placeholder greedy
      }
      
      // Physics constants
      const ENEMY_SPEED = 0.3;
      const PROJ_SPEED = 0.8;
      
      function step(action) {
        // Move player
        if (action === 0) playerSegment = (playerSegment - 1 + TUBE_SEGMENTS) % TUBE_SEGMENTS;
        else if (action === 1) playerSegment = (playerSegment + 1) % TUBE_SEGMENTS;
        else if (action === 2) {
          // Fire a shot from player's segment, at current depth
          projectiles.push({ segment: playerSegment, depth: TUBE_DEPTH_MAX });
        }
        
        // Move enemies inward (increase depth toward bottom)
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          e.depth += ENEMY_SPEED;
          if (e.depth >= TUBE_DEPTH_MAX) {
            // Enemy reached bottom ‚Äì player loses life (game over for now)
            done = true;
            rewardSum -= 10;
            enemies.splice(i, 1);
          }
        }
        
        // Move projectiles outward (decrease depth)
        for (let i = projectiles.length - 1; i >= 0; i--) {
          const p = projectiles[i];
          p.depth -= PROJ_SPEED;
          if (p.depth < TUBE_DEPTH_MIN) {
            projectiles.splice(i, 1);
            continue;
          }
          // Check collision with enemies (same segment and close depth)
          for (let j = enemies.length - 1; j >= 0; j--) {
            const e = enemies[j];
            if (e.segment === p.segment && Math.abs(e.depth - p.depth) < 1.5) {
              // Enemy destroyed
              enemies.splice(j, 1);
              projectiles.splice(i, 1);
              score += 100;
              rewardSum += 5;
              break;
            }
          }
        }
        
        // Spawn new enemies randomly
        if (enemies.length < 10 && Math.random() < 0.03) {
          enemies.push({
            segment: Math.floor(Math.random() * TUBE_SEGMENTS),
            depth: TUBE_DEPTH_MIN + Math.random() * 10
          });
        }
        
        steps++;
        rewardSum -= 0.1; // step penalty
        
        if (steps > 2000) done = true;
        
        return {
          playerSegment,
          enemies: enemies.map(e => ({...e})),
          projectiles: projectiles.map(p => ({...p})),
          score, steps, rewardSum, episode, done
        };
      }
      
      function reset() {
        playerSegment = 0;
        enemies = [];
        projectiles = [];
        steps = 0;
        done = false;
        rewardSum = 0;
        episode++;
        // Spawn a few initial enemies
        for (let i = 0; i < 3; i++) {
          enemies.push({
            segment: Math.floor(Math.random() * TUBE_SEGMENTS),
            depth: TUBE_DEPTH_MIN + Math.random() * 10
          });
        }
      }
      reset();
      
      self.onmessage = function(e) {
        const data = e.data;
        if (data.cmd === 'step') {
          if (!done) {
            const action = chooseAction();
            const state = step(action);
            self.postMessage({ type: 'state', ...state, epsilon });
          } else {
            logs.push({
              episode,
              score,
              totalReward: rewardSum,
              steps,
              epsilon
            });
            reset();
          }
        } else if (data.cmd === 'params') {
          if (data.alpha !== undefined) alpha = data.alpha;
          if (data.epsilon !== undefined) epsilon = data.epsilon;
          if (data.gamma !== undefined) gamma = data.gamma;
        } else if (data.cmd === 'getLogs') {
          self.postMessage({ type: 'logs', logs });
        } else if (data.cmd === 'reset') {
          episode = 0; logs = []; reset();
        }
      };
    `;

    const blob = new Blob([workerCode], { type: 'application/javascript' });
    const worker = new Worker(URL.createObjectURL(blob));

    // ---------- MESSAGE HANDLING ----------
    worker.onmessage = function(e) {
      const data = e.data;
      if (data.type === 'state') {
        // Update display stats
        displayStats.episode = data.episode;
        displayStats.score = data.score;
        displayStats.steps = data.steps;
        displayStats.reward = data.rewardSum;
        displayStats.epsilon = data.epsilon;
        updateDashboard();

        // Update player position on tube rim
        if (player) {
          const pos = getTubePosition(data.playerSegment, -5); // bottom
          player.position.copy(pos);
          // Rotate ship to face outward (tangent to tube)
          const angle = (data.playerSegment / TUBE_SEGMENTS) * Math.PI * 2;
          player.rotation.y = angle + Math.PI/2; // adjust for model orientation
        }

        // Update enemies
        while (enemies.length) scene.remove(enemies.pop());
        data.enemies.forEach(e => {
          const mesh = createEnemyMesh(e.segment, e.depth);
          enemies.push(mesh);
        });

        // Update projectiles
        while (projectiles.length) scene.remove(projectiles.pop());
        data.projectiles.forEach(p => {
          const mesh = createProjectileMesh(p.segment, p.depth, 0xffff00);
          projectiles.push(mesh);
        });

        // Update UI stats (original)
        document.getElementById('combatScore').innerText = data.score;
        document.getElementById('enemyCount').innerText = data.enemies.length;
      } else if (data.type === 'logs') {
        // Export logs
        const blob = new Blob([JSON.stringify(data.logs, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `tempest_training_${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
      }
    };

    // ---------- DASHBOARD UPDATE ----------
    function updateDashboard() {
      document.getElementById('episodeVal').innerText = displayStats.episode;
      document.getElementById('scoreVal').innerText = displayStats.score;
      document.getElementById('stepsVal').innerText = displayStats.steps;
      document.getElementById('rewardVal').innerText = displayStats.reward.toFixed(2);
      document.getElementById('epsilonVal').innerText = displayStats.epsilon.toFixed(2);
    }

    // ---------- SLIDERS & CONTROLS ----------
    document.getElementById('lrSlider').addEventListener('input', (e) => {
      const val = parseFloat(e.target.value);
      document.getElementById('lrDisplay').innerText = val.toFixed(2);
      worker.postMessage({ cmd: 'params', alpha: val });
    });
    document.getElementById('epsSlider').addEventListener('input', (e) => {
      const val = parseFloat(e.target.value);
      document.getElementById('epsDisplay').innerText = val.toFixed(2);
      worker.postMessage({ cmd: 'params', epsilon: val });
    });
    document.getElementById('gammaSlider').addEventListener('input', (e) => {
      const val = parseFloat(e.target.value);
      document.getElementById('gammaDisplay').innerText = val.toFixed(2);
      worker.postMessage({ cmd: 'params', gamma: val });
    });

    let paused = false;
    document.getElementById('pauseBtn').addEventListener('click', (btn) => {
      paused = !paused;
      btn.target.innerText = paused ? '‚ñ∂Ô∏è RESUME' : '‚è∏Ô∏è PAUSE';
    });
    document.getElementById('resetBtn').addEventListener('click', () => {
      worker.postMessage({ cmd: 'reset' });
    });
    document.getElementById('exportBtn').addEventListener('click', () => {
      worker.postMessage({ cmd: 'getLogs' });
    });

    // ---------- GAME LOOP (step worker) ----------
    setInterval(() => {
      if (!paused) worker.postMessage({ cmd: 'step' });
    }, 100); // 10 fps simulation

    // ---------- RENDER LOOP ----------
    function animate() {
      requestAnimationFrame(animate);
      
      // Update camera to follow player (same as original)
      if (player) {
        // Place camera behind and above the player, looking forward
        const offset = new THREE.Vector3(0, 3, 10);
        camera.position.copy(player.position).add(offset);
        const lookAt = player.position.clone().add(new THREE.Vector3(0, 0, -20));
        camera.lookAt(lookAt);
      }
      
      renderer.render(scene, camera);
    }

    // ---------- START ----------
    window.addEventListener('load', () => {
      initThree();
      animate();
      // Disable original keyboard controls (they would interfere)
      // but keep menu buttons functional
    });

    // Keep original menu functionality (simplified)
    document.getElementById('startBtn').addEventListener('click', () => {
      document.getElementById('mainMenu').style.display = 'none';
    });
    document.getElementById('menuBtn').addEventListener('click', () => {
      document.getElementById('mainMenu').style.display = 'flex';
    });
    // (other menu buttons can be kept as they were)
  </script>
</body>
</html>