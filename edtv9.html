<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>EDT v3 â€” Thermal SLAM Point Cloud</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { margin:0; background:#0b0f14; color:#eaf0f6; font-family:system-ui; }
    #ui { position:fixed; top:0; left:0; right:0; display:flex; flex-wrap:wrap; gap:8px;
          padding:10px; background:rgba(10,14,22,0.7); border-bottom:1px solid #223; z-index:10; }
    button, input[type="range"], select { background:#142033; color:#eaf0f6; border:1px solid #2a3b59;
          border-radius:6px; padding:6px 10px; }
    #viewport { position:fixed; inset:0; top:52px; }
    #status { position:fixed; bottom:0; left:0; right:0; max-height:30vh; overflow:auto;
              background:rgba(10,14,22,0.75); font-size:12px; padding:6px; border-top:1px solid #223; }
    #status .item { margin:4px 0; }
    video#cam { display:none; }
  </style>
</head>
<body>
  <div id="ui">
    <button id="btnStart">Start</button>
    <button id="btnStop" disabled>Stop</button>
    <button id="btnSwitch">Switch Camera</button>
    <button id="btnClear">Clear Map</button>
    <label>Depth scale <input id="depthScale" type="range" min="0.2" max="4" step="0.1" value="1.0"></label>
    <label>Sampling <input id="sampling" type="range" min="1" max="8" step="1" value="2"></label>
    <label>Point size <input id="pointSize" type="range" min="1" max="8" step="1" value="3"></label>
  </div>

  <canvas id="viewport"></canvas>
  <video id="cam" autoplay playsinline></video>
  <div id="status"></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    const statusEl = document.getElementById('status');
    function log(level,msg){
      const ts=new Date().toLocaleTimeString();
      const div=document.createElement('div');
      div.className='item';
      div.textContent=`[${ts}] ${level.toUpperCase()}: ${msg}`;
      statusEl.prepend(div);
    }

    // Scene setup
    const scene=new THREE.Scene();
    const camera=new THREE.PerspectiveCamera(60,window.innerWidth/(window.innerHeight-52),0.1,1000);
    camera.position.set(0,2,6);
    const renderer=new THREE.WebGLRenderer({canvas:document.getElementById('viewport')});
    renderer.setSize(window.innerWidth,window.innerHeight-52);
    const controls=new THREE.OrbitControls(camera,renderer.domElement);
    controls.enableDamping=true;
    controls.dampingFactor=0.05;

    const grid=new THREE.GridHelper(20,20,0x335577,0x223344);
    scene.add(grid);
    const light=new THREE.HemisphereLight(0x88aaff,0x223344,0.8);
    scene.add(light);

    // Point cloud
    let points=null;
    function createPointCloudFromFrame(frame){
      const w=frame.width, h=frame.height;
      const step=parseInt(document.getElementById('sampling').value);
      const positions=[];
      const colors=[];
      const ctx=offscreen.getContext('2d');
      ctx.drawImage(frame,0,0,w,h);
      const data=ctx.getImageData(0,0,w,h).data;
      for(let y=0;y<h;y+=step){
        for(let x=0;x<w;x+=step){
          const i=(y*w+x)*4;
          const r=data[i], g=data[i+1], b=data[i+2];
          const depth=(r+g+b)/3/255*parseFloat(document.getElementById('depthScale').value)*5;
          positions.push((x/w-0.5)*10,(y/h-0.5)*-10,depth);
          const tempColor=new THREE.Color().setHSL((1-depth/5),1.0,0.5);
          colors.push(tempColor.r,tempColor.g,tempColor.b);
        }
      }
      const geometry=new THREE.BufferGeometry();
      geometry.setAttribute('position',new THREE.Float32BufferAttribute(positions,3));
      geometry.setAttribute('color',new THREE.Float32BufferAttribute(colors,3));
      const material=new THREE.PointsMaterial({
        size:parseFloat(document.getElementById('pointSize').value),
        vertexColors:true,
        sizeAttenuation:false
      });
      if(points){ scene.remove(points); points.geometry.dispose(); points.material.dispose(); }
      points=new THREE.Points(geometry,material);
      scene.add(points);
    }

    const offscreen=document.createElement('canvas');

    function animate(){
      requestAnimationFrame(animate);
      controls.update();
      if(video.readyState>=2){
        offscreen.width=video.videoWidth;
        offscreen.height=video.videoHeight;
        createPointCloudFromFrame(video);
      }
      renderer.render(scene,camera);
    }
    animate();

    // Resize handler
    window.addEventListener('resize',()=>{
      camera.aspect=window.innerWidth/(window.innerHeight-52);
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight-52);
    });

    // UI handlers
    document.getElementById('depthScale').addEventListener('input',e=>{
      log('info','Depth scale set to '+e.target.value);
    });
    document.getElementById('sampling').addEventListener('input',e=>{
      log('info','Sampling step set to '+e.target.value);
    });
    document.getElementById('pointSize').addEventListener('input',e=>{
      log('info','Point size set to '+e.target.value);
      if(points) points.material.size=parseFloat(e.target.value);
    });

    let stream=null;
    let currentDeviceId=null;
    const video=document.getElementById('cam');

    async function initCamera(){
      if(location.protocol!=='https:' && location.hostname!=='localhost'){
        log('critical','Camera requires HTTPS or localhost. Running in demo mode.');
        return;
      }
      try{
        const constraints={video:{deviceId:currentDeviceId?{exact:currentDeviceId}:undefined}};
        stream=await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject=stream;
        log('info','Camera stream started.');
        document.getElementById('btnStop').disabled=false;
      }catch(err){
        log('error','Camera init failed: '+err.message);
      }
    }

    document.getElementById('btnStart').onclick=()=>initCamera();
    document.getElementById('btnStop').onclick=()=>{
      if(stream){
        stream.getTracks().forEach(t=>t.stop());
        stream=null;
        log('info','Camera stopped.');
      }
      document.getElementById('btnStop').disabled=true;
    };
    document.getElementById('btnSwitch').onclick=async()=>{
      const devices=await navigator.mediaDevices.enumerateDevices();
      const cams=devices.filter(d=>d.kind==='videoinput');
      if(cams.length>1){
        const idx=cams.findIndex(d=>d.deviceId===currentDeviceId);
        const next=cams[(idx+1)%cams.length];
        currentDeviceId=next.deviceId;
        log('info','Switching to camera: '+(next.label||'unknown'));
        if(stream){
          stream.getTracks().forEach(t=>t.stop());
          stream=null;
        }
        initCamera();
      }else{
        log('warn','No alternate camera found.');
      }
    };
    document.getElementById('btnClear').onclick=()=>{
      if(points){
        scene.remove(points);
        points.geometry.dispose();
        points.material.dispose();
        points=null;
        log('info','Point cloud cleared.');
      }
    };
  </script>
</body>
</html>
