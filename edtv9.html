<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>EDTV: Thermal SLAM Point Cloud</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { margin:0; background:#0b0f14; color:#eaf0f6; font-family:system-ui; }
    #ui { position:fixed; top:0; left:0; right:0; display:flex; flex-wrap:wrap; gap:8px;
          padding:10px; background:rgba(10,14,22,0.7); border-bottom:1px solid #223; z-index:10; }
    button, input[type="range"] { background:#142033; color:#eaf0f6; border:1px solid #2a3b59;
          border-radius:6px; padding:6px 10px; }
    #viewport { position:fixed; inset:0; top:52px; }
    #status { position:fixed; bottom:0; left:0; right:0; max-height:30vh; overflow:auto;
              background:rgba(10,14,22,0.75); font-size:12px; padding:6px; border-top:1px solid #223; }
    #status .item { margin:4px 0; }
    video#cam { display:none; }
    
    /* Status level colors */
    .info { color: #a0c8ff; }
    .warn { color: #ffcc00; }
    .error { color: #ff6666; }
    .critical { color: #ff3333; font-weight: bold; }
  </style>
</head>
<body>
  <div id="ui">
    <button id="btnStart">Start Camera</button>
    <button id="btnStop" disabled>Stop</button>
    <button id="btnClear">Clear Map</button>
    <label>Sampling <input id="sampling" type="range" min="2" max="12" step="1" value="6"></label>
    <label>Point size <input id="pointSize" type="range" min="1" max="8" step="1" value="3"></label>
  </div>

  <canvas id="viewport"></canvas>
  <video id="cam" autoplay playsinline crossorigin="anonymous"></video>
  <div id="status">
    <div class="item info">[14:32:11] INFO: Page loaded</div>
    <div class="item info">[14:32:12] INFO: Waiting for camera permission...</div>
    <div class="item error">[14:32:15] ERROR: Camera access denied (NotAllowedError)</div>
    <div class="item critical">[14:32:15] CRITICAL: getUserMedia failed: Permission denied</div>
    <div class="item info">[14:32:20] INFO: Start Camera button clicked</div>
    <div class="item error">[14:32:20] ERROR: Camera requires HTTPS or localhost</div>
    <div class="item info">[14:32:25] INFO: Webcam started (640x480)</div>
    <div class="item warn">[14:32:26] WARN: video.videoWidth = 0 (stream not ready)</div>
    <div class="item info">[14:32:30] INFO: Point cloud updated (1247 points)</div>
    <div class="item error">[14:32:45] ERROR: getImageData failed: canvas tainted by cross-origin</div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    const statusEl = document.getElementById('status');
    
    function log(level, msg) {
      const ts = new Date().toLocaleTimeString();
      const div = document.createElement('div');
      div.className = `item ${level}`;
      div.textContent = `[${ts}] ${level.toUpperCase()}: ${msg}`;
      statusEl.prepend(div);
      // Auto-scroll to show latest message
      statusEl.scrollTop = 0;
    }

    // Initialize Three.js scene
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / (window.innerHeight - 52), 0.1, 1000);
    camera.position.set(0, 2, 6);
    const renderer = new THREE.WebGLRenderer({ 
      canvas: document.getElementById('viewport'),
      antialias: true 
    });
    renderer.setSize(window.innerWidth, window.innerHeight - 52);
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // Add grid and lighting
    const grid = new THREE.GridHelper(20, 20, 0x335577, 0x223344);
    scene.add(grid);
    const light = new THREE.HemisphereLight(0x88aaff, 0x223344, 0.8);
    scene.add(light);

    // User position indicator
    const userDot = new THREE.Mesh(
      new THREE.SphereGeometry(0.1, 16, 16),
      new THREE.MeshBasicMaterial({ color: 0xff0000 })
    );
    scene.add(userDot);

    // Variables for point cloud and video processing
    let points = null;
    const video = document.getElementById('cam');
    const offscreen = document.createElement('canvas');
    const ctx = offscreen.getContext('2d', { willReadFrequently: true });

    // Track video ready state
    let videoReady = false;

    function updatePointCloud() {
      if (!videoReady || video.videoWidth === 0) {
        if (video.srcObject && video.videoWidth === 0) {
          log('warn', 'video.videoWidth = 0 (stream not ready)');
        }
        return;
      }
      
      offscreen.width = video.videoWidth;
      offscreen.height = video.videoHeight;
      
      try {
        ctx.drawImage(video, 0, 0, offscreen.width, offscreen.height);
        const data = ctx.getImageData(0, 0, offscreen.width, offscreen.height).data;
        const step = parseInt(document.getElementById('sampling').value);
        const positions = [], colors = [];
        
        for (let y = 0; y < offscreen.height; y += step) {
          for (let x = 0; x < offscreen.width; x += step) {
            const i = (y * offscreen.width + x) * 4;
            const r = data[i], g = data[i + 1], b = data[i + 2];
            const depth = (r + g + b) / 3 / 255 * 5;
            positions.push((x / offscreen.width - 0.5) * 10, (y / offscreen.height - 0.5) * -10, depth);
            colors.push(r / 255, g / 255, b / 255);
          }
        }
        
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        
        const material = new THREE.PointsMaterial({
          size: parseFloat(document.getElementById('pointSize').value),
          vertexColors: true,
          sizeAttenuation: false
        });
        
        if (points) {
          scene.remove(points);
          points.geometry.dispose();
          points.material.dispose();
        }
        
        points = new THREE.Points(geometry, material);
        scene.add(points);
        log('info', 'Point cloud updated (' + (positions.length / 3) + ' points)');
      } catch (err) {
        log('error', 'Point cloud update failed: ' + err.message);
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      updatePointCloud();
      renderer.render(scene, camera);
    }
    animate();

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / (window.innerHeight - 52);
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight - 52);
    });

    // Camera management
    let stream = null;
    
    async function initCamera() {
      // Check for HTTPS/localhost requirement
      if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
        log('error', 'Camera requires HTTPS or localhost');
        return;
      }
      
      // Check if getUserMedia is available
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        log('error', 'getUserMedia is not supported in this browser');
        return;
      }
      
      try {
        log('info', 'Waiting for camera permission...');
        stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            width: { ideal: 640 },
            height: { ideal: 480 }
          } 
        });
        
        video.srcObject = stream;
        videoReady = false;
        
        video.onloadedmetadata = () => {
          videoReady = true;
          log('info', 'Webcam started (' + video.videoWidth + 'x' + video.videoHeight + ')');
        };
        
        video.onerror = () => {
          log('error', 'Video element error');
          videoReady = false;
        };
        
        document.getElementById('btnStop').disabled = false;
        document.getElementById('btnStart').disabled = true;
        
      } catch (err) {
        if (err.name === 'NotAllowedError') {
          log('error', 'Camera access denied (NotAllowedError)');
        } else if (err.name === 'NotFoundError') {
          log('error', 'No camera found');
        } else if (err.name === 'NotSupportedError') {
          log('error', 'Camera not supported');
        } else {
          log('error', 'Camera error: ' + err.message);
        }
        log('critical', 'getUserMedia failed: ' + err.name);
      }
    }

    // Button event handlers
    document.getElementById('btnStart').onclick = () => { 
      log('info', 'Start Camera button clicked'); 
      initCamera(); 
    };
    
    document.getElementById('btnStop').onclick = () => {
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      video.srcObject = null;
      videoReady = false;
      log('info', 'Camera stopped.');
      document.getElementById('btnStop').disabled = true;
      document.getElementById('btnStart').disabled = false;
    };
    
    document.getElementById('btnClear').onclick = () => {
      if (points) {
        scene.remove(points);
        points.geometry.dispose();
        points.material.dispose();
        points = null;
      }
      log('info', 'Point cloud cleared.');
    };

    // Initialize the app
    log('info', 'Page loaded');
  </script>
</body>
</html>
