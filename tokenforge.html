<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>webXOS TOKEN FORGE</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=VT323&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Press Start 2P', monospace; }
        html, body { 
            height: 100vh; 
            overflow: hidden; 
            background: #000; 
            color: #0f0; 
            display: flex; 
            flex-direction: column; 
            touch-action: manipulation; 
            position: relative;
        }
        
        /* Scanlines effect */
        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 100;
        }
        
        /* Grid background */
        body::after {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 0, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 0, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
            pointer-events: none;
            z-index: -1;
        }
        
        header {
            padding: 10px;
            text-align: center;
            border-bottom: 2px solid #0f0;
            background: rgba(0, 20, 0, 0.8);
            z-index: 10;
        }
        
        h1 {
            font-size: 1.6rem;
            text-shadow: 0 0 5px #0f0;
            margin-bottom: 5px;
        }
        
        .header-info {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            margin-top: 5px;
        }
        
        #terminal {
            flex: 1;
            margin: 10px;
            background: rgba(0, 20, 0, 0.7);
            border: 2px solid #0f0;
            border-radius: 5px;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        
        #terminal-log {
            flex: 1;
            overflow-y: auto;
            padding-right: 5px;
        }
        
        #terminal-log p {
            margin: 5px 0;
            font-size: 0.8rem;
            line-height: 1.3;
        }
        
        #terminal-input {
            display: flex;
            margin-top: 10px;
            border-top: 1px solid #0f0;
            padding-top: 10px;
        }
        
        #prompt-input {
            flex: 1;
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 8px;
            font-size: 0.8rem;
        }
        
        #send-button {
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 8px 15px;
            margin-left: 5px;
            cursor: pointer;
        }
        
        #vial-status {
            height: 120px;
            margin: 0 10px 10px;
            display: flex;
            gap: 10px;
        }
        
        .vial-container {
            flex: 1;
            background: rgba(0, 20, 0, 0.7);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 8px;
            display: flex;
            flex-direction: column;
        }
        
        .vial-header {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            margin-bottom: 5px;
        }
        
        .vial-name {
            font-weight: bold;
        }
        
        .vial-status {
            color: #0f0;
        }
        
        .vial-status.mining {
            color: #ff0;
            animation: pulse 1s infinite;
        }
        
        .vial-status.error {
            color: #f00;
        }
        
        .metric-bar {
            height: 8px;
            background: #333;
            border: 1px solid #0f0;
            border-radius: 2px;
            margin: 3px 0;
            overflow: hidden;
        }
        
        .metric-fill {
            height: 100%;
            transition: width 0.3s;
        }
        
        .hash-fill {
            background: linear-gradient(90deg, #0f0, #0ff);
        }
        
        .progress-fill {
            background: linear-gradient(90deg, #ff0, #f80);
        }
        
        .vial-metrics {
            font-size: 0.6rem;
            margin-top: 5px;
        }
        
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 0 10px 10px;
            justify-content: center;
        }
        
        button {
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 8px 12px;
            font-size: 0.7rem;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #0f0;
            color: #000;
        }
        
        button:disabled {
            background: #333;
            color: #666;
            border-color: #666;
            cursor: not-allowed;
        }
        
        button.active {
            background: #0f0;
            color: #000;
        }
        
        #error-notification {
            display: none;
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(255, 0, 0, 0.8);
            color: #fff;
            padding: 10px;
            border-radius: 3px;
            font-size: 0.8rem;
            max-width: 300px;
            z-index: 1000;
            box-shadow: 0 0 10px #ff0000;
            border: 1px solid #ff0000;
        }
        
        #error-notification.visible {
            display: block;
        }
        
        .command {
            color: #0ff;
        }
        
        .success {
            color: #0f0;
        }
        
        .warning {
            color: #ff0;
        }
        
        .error {
            color: #f00;
        }
        
        .balance {
            color: #0af;
        }
        
        .network {
            color: #f0f;
        }
        
        .bot {
            color: #0ff;
            font-style: italic;
        }
        
        .info {
            color: #ff0;
        }
        
        .parameter {
            color: #0af;
        }
        
        .hash-earnings {
            color: #0f0;
            font-weight: bold;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        /* Scrollbar styling */
        #terminal-log::-webkit-scrollbar {
            width: 8px;
        }
        
        #terminal-log::-webkit-scrollbar-track {
            background: rgba(0, 30, 0, 0.5);
        }
        
        #terminal-log::-webkit-scrollbar-thumb {
            background: #0f0;
            border-radius: 4px;
        }
        
        /* Neurot particles */
        .neurot {
            position: fixed;
            width: 3px;
            height: 3px;
            background-color: #0f0;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1;
            box-shadow: 0 0 5px #0f0;
        }
        
        /* Mining indicator */
        .mining-indicator {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 20, 0, 0.8);
            border: 1px solid #0f0;
            padding: 5px 10px;
            font-size: 0.6rem;
            border-radius: 3px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .mining-dot {
            width: 6px;
            height: 6px;
            background: #0f0;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }
        
        .network-limit {
            position: fixed;
            bottom: 40px;
            right: 10px;
            background: rgba(0, 20, 0, 0.8);
            border: 1px solid #ff0;
            padding: 5px 10px;
            font-size: 0.6rem;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <header>
        <h1>TOKEN FORGE</h1>
        <div class="header-info">
            <span>NETWORK: <span id="network-status">AUTO-AUTH</span></span>
            <span>TOKENS: <span id="token-count">0</span></span>
            <span>WALLETS: <span id="wallet-count">1</span></span>
            <span>HASH/SEC: <span id="hash-rate">1</span></span>
        </div>
    </header>
    
    <div id="terminal">
        <div id="terminal-log">
            <p>> TOKEN FORGE initialized. Auto-authentication complete.</p>
            <p class="bot">BOT: Welcome to TOKEN FORGE. I'm your automated forging assistant.</p>
            <p class="bot">BOT: You're automatically authenticated. Start by creating your first network!</p>
            <p class="info">TIP: Earn 1 HASH/second for every network you create or join.</p>
            <p class="info">TIP: Networks auto-mine when you're connected to them.</p>
        </div>
        <div id="terminal-input">
            <input type="text" id="prompt-input" placeholder="Enter command...">
            <button id="send-button">SEND</button>
        </div>
    </div>
    
    <div id="vial-status">
        <!-- Vial status bars will be generated here -->
    </div>
    
    <div class="button-group">
        <button id="createButton">CREATE NETWORK</button>
        <button id="joinButton">JOIN NETWORK</button>
        <button id="exportButton">EXPORT WALLET</button>
        <button id="importButton">IMPORT WALLET</button>
        <button id="setLimitButton">SET NETWORK LIMIT</button>
        <button id="voidButton">VOID SESSION</button>
    </div>
    
    <div class="mining-indicator" id="mining-indicator">
        <div class="mining-dot"></div>
        <span>MINING: <span id="mining-network">NONE</span></span>
    </div>
    
    <div class="network-limit" id="network-limit" style="display: none;">
        NETWORK LIMIT: <span id="limit-value">1000</span> HASHES
    </div>
    
    <div id="error-notification"></div>
    
    <input type="file" id="file-input" accept=".md,.json" style="display: none;">

    <script>
        // Global state
        let isAuthenticated = true; // Auto-authenticated
        let currentSession = null;
        let networks = [];
        let wallets = [];
        let vials = [];
        let currentNetworkLimit = 1000; // Default limit
        let miningInterval = null;
        let hashEarningsInterval = null;
        let totalHashesEarned = 0;
        
        // Bot guidance messages
        const botMessages = {
            welcome: "BOT: Auto-authentication complete. You're ready to create networks!",
            createHelp: "BOT: Use /create <name> <supply> - that's it! Defaults: decimals=18, no max per wallet, 0% fee",
            createSimple: "BOT: Simple! Just /create <network_name> <total_supply>",
            joinHelp: "BOT: Use /join to import a wallet file and join existing networks.",
            exportHelp: "BOT: Use /export to save your wallet as markdown with all earned hashes.",
            voidWarning: "BOT: Warning: /void will clear all data. Use /export first to save!",
            networkCreated: "BOT: Network created! Earning 1 HASH/second while connected.",
            walletInfo: "BOT: Your wallet address and balance will be displayed here.",
            miningStarted: "BOT: Mining started! Earning 1 HASH/second for this network.",
            limitSet: "BOT: Network limit set. Mining will stop after reaching limit."
        };
        
        // PyTorch templates for vials
        const pytorchTemplates = [
            "nn.Sequential(nn.Linear(128, 64), nn.ReLU(), nn.Linear(64, 32), nn.ReLU(), nn.Linear(32, 16))",
            "nn.Sequential(nn.Linear(256, 128), nn.ReLU(), nn.Linear(128, 64), nn.ReLU(), nn.Linear(64, 32))",
            "nn.Sequential(nn.Linear(512, 256), nn.ReLU(), nn.Linear(256, 128), nn.ReLU(), nn.Linear(128, 64))",
            "nn.Sequential(nn.Linear(1024, 512), nn.ReLU(), nn.Linear(512, 256), nn.ReLU(), nn.Linear(256, 128))"
        ];

        // Initialize vials
        function initializeVials() {
            vials = [];
            for (let i = 0; i < 4; i++) {
                vials.push({
                    id: `vial${i+1}`,
                    name: `MINER-${String.fromCharCode(65 + i)}`,
                    status: 'idle',
                    hashRate: 0,
                    progress: 0,
                    template: pytorchTemplates[i],
                    wallet: {
                        address: generateAddress(),
                        balance: 0,
                        hashesMined: 0
                    }
                });
            }
            updateVialStatusBars();
        }

        // Generate random address
        function generateAddress() {
            return '0x' + Array.from(crypto.getRandomValues(new Uint8Array(20)))
                .map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // Generate network hash using 4 vials
        function generateNetworkHash(networkData) {
            let combinedString = JSON.stringify(networkData) + Date.now().toString();
            for (let vial of vials) {
                combinedString += vial.template + vial.wallet.address;
            }
            
            // Use Web Crypto API for hashing
            const encoder = new TextEncoder();
            const data = encoder.encode(combinedString);
            return crypto.subtle.digest('SHA-256', data)
                .then(hash => {
                    const hashArray = Array.from(new Uint8Array(hash));
                    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                });
        }

        // Parse markdown wallet format
        function parseMarkdownWallet(markdownText) {
            const lines = markdownText.split('\n');
            const result = {
                session: {},
                networks: [],
                wallets: []
            };
            
            let currentNetwork = null;
            let currentWallet = null;
            
            for (let line of lines) {
                line = line.trim();
                
                // Session info
                if (line.startsWith('# Session:')) {
                    result.session.name = line.split(':')[1].trim();
                } else if (line.startsWith('- Created:')) {
                    result.session.created = line.split(':')[1].trim();
                } else if (line.startsWith('- Hashes Earned:')) {
                    result.session.hashesEarned = parseInt(line.split(':')[1].trim()) || 0;
                }
                
                // Network info
                else if (line.startsWith('## Network:')) {
                    if (currentNetwork) result.networks.push(currentNetwork);
                    currentNetwork = {
                        name: line.split(':')[1].trim(),
                        details: {}
                    };
                } else if (line.startsWith('- Token:')) {
                    if (currentNetwork) {
                        currentNetwork.details.token = line.split(':')[1].trim();
                    }
                } else if (line.startsWith('- Supply:')) {
                    if (currentNetwork) {
                        currentNetwork.details.supply = line.split(':')[1].trim();
                    }
                } else if (line.startsWith('- Hash:')) {
                    if (currentNetwork) {
                        currentNetwork.details.hash = line.split(':')[1].trim();
                    }
                } else if (line.startsWith('- Hashes Mined:')) {
                    if (currentNetwork) {
                        currentNetwork.details.hashesMined = parseInt(line.split(':')[1].trim()) || 0;
                    }
                }
                
                // Wallet info
                else if (line.startsWith('### Wallet:')) {
                    if (currentWallet) result.wallets.push(currentWallet);
                    currentWallet = {
                        name: line.split(':')[1].trim(),
                        details: {}
                    };
                } else if (line.startsWith('- Address:')) {
                    if (currentWallet) {
                        currentWallet.details.address = line.split(':')[1].trim();
                    }
                } else if (line.startsWith('- Balance:')) {
                    if (currentWallet) {
                        currentWallet.details.balance = parseFloat(line.split(':')[1].trim()) || 0;
                    }
                } else if (line.startsWith('- Total Hashes:')) {
                    if (currentWallet) {
                        currentWallet.details.totalHashes = parseInt(line.split(':')[1].trim()) || 0;
                    }
                }
            }
            
            if (currentNetwork) result.networks.push(currentNetwork);
            if (currentWallet) result.wallets.push(currentWallet);
            
            return result;
        }

        // Log event to terminal with bot simulation
        function logEvent(message, type = '') {
            const log = document.getElementById('terminal-log');
            const p = document.createElement('p');
            p.textContent = message;
            if (type) p.classList.add(type);
            log.appendChild(p);
            log.scrollTop = log.scrollHeight;
            
            // Simulate bot response with delay for certain messages
            if (type === 'command') {
                const msg = message.toLowerCase();
                setTimeout(() => {
                    if (msg.includes('/create') && isAuthenticated) {
                        logEvent(botMessages.createSimple, 'bot');
                    } else if (msg.includes('/help')) {
                        logEvent("BOT: Simple commands: /create <name> <supply>, /join, /export, /limit <value>", 'bot');
                    } else if (msg.includes('/void')) {
                        logEvent(botMessages.voidWarning, 'bot warning');
                    } else if (msg.includes('/limit')) {
                        logEvent(botMessages.limitSet, 'bot');
                    }
                }, 500);
            }
        }

        // Show error notification
        function showErrorNotification(message) {
            const notif = document.getElementById('error-notification');
            notif.textContent = message;
            notif.classList.add('visible');
            setTimeout(() => notif.classList.remove('visible'), 3000);
        }

        // Update vial status bars
        function updateVialStatusBars() {
            const statusDiv = document.getElementById('vial-status');
            statusDiv.innerHTML = '';
            
            vials.forEach(vial => {
                const container = document.createElement('div');
                container.className = 'vial-container';
                
                const header = document.createElement('div');
                header.className = 'vial-header';
                header.innerHTML = `
                    <span class="vial-name">${vial.name}</span>
                    <span class="vial-status ${vial.status === 'mining' ? 'mining' : ''}">${vial.status.toUpperCase()}</span>
                `;
                container.appendChild(header);
                
                // Hash rate bar
                const hashBar = document.createElement('div');
                hashBar.className = 'metric-bar';
                const hashFill = document.createElement('div');
                hashFill.className = 'metric-fill hash-fill';
                hashFill.style.width = `${(vial.hashRate / 100) * 100}%`;
                hashBar.appendChild(hashFill);
                container.appendChild(hashBar);
                
                // Progress bar
                const progBar = document.createElement('div');
                progBar.className = 'metric-bar';
                const progFill = document.createElement('div');
                progFill.className = 'metric-fill progress-fill';
                progFill.style.width = `${vial.progress}%`;
                progBar.appendChild(progFill);
                container.appendChild(progBar);
                
                // Metrics
                const metrics = document.createElement('div');
                metrics.className = 'vial-metrics';
                metrics.innerHTML = `
                    HASH: ${Math.round(vial.hashRate)}<br>
                    MINED: ${vial.wallet.hashesMined}<br>
                    BAL: ${vial.wallet.balance.toFixed(2)}
                `;
                container.appendChild(metrics);
                
                statusDiv.appendChild(container);
            });
            
            document.getElementById('token-count').textContent = networks.reduce((sum, n) => sum + n.totalSupply, 0).toLocaleString();
            document.getElementById('wallet-count').textContent = wallets.length;
        }

        // Start mining for a network
        function startMining(networkName) {
            stopMining();
            
            const network = networks.find(n => n.name === networkName);
            if (!network) {
                logEvent(`Network ${networkName} not found`, 'error');
                return;
            }
            
            // Update mining indicator
            document.getElementById('mining-indicator').style.display = 'flex';
            document.getElementById('mining-network').textContent = networkName;
            
            // Start vial mining animation
            vials.forEach(vial => {
                vial.status = 'mining';
                vial.hashRate = 25; // 25% each for 4 vials = 100%
            });
            
            // Start earning 1 hash per second
            miningInterval = setInterval(() => {
                if (!network.hashesMined) network.hashesMined = 0;
                if (!network.miningLimit || network.hashesMined < network.miningLimit) {
                    network.hashesMined++;
                    totalHashesEarned++;
                    
                    // Update vials
                    vials.forEach(vial => {
                        vial.wallet.hashesMined++;
                        vial.wallet.balance += 0.01; // Small reward per hash
                    });
                    
                    // Update wallet balance
                    wallets[0].balance = totalHashesEarned;
                    
                    // Show earnings notification every 10 hashes
                    if (network.hashesMined % 10 === 0) {
                        logEvent(`EARNED: ${network.hashesMined} hashes from ${networkName}`, 'hash-earnings');
                    }
                    
                    updateVialStatusBars();
                    
                    // Check if limit reached
                    if (network.miningLimit && network.hashesMined >= network.miningLimit) {
                        stopMining();
                        logEvent(`Mining limit reached for ${networkName}: ${network.miningLimit} hashes`, 'warning');
                        document.getElementById('network-limit').style.display = 'none';
                    }
                }
            }, 1000);
            
            logEvent(`Started mining ${networkName}. Earning 1 HASH/second.`, 'success');
            logEvent(botMessages.miningStarted, 'bot');
        }

        // Stop mining
        function stopMining() {
            if (miningInterval) {
                clearInterval(miningInterval);
                miningInterval = null;
            }
            
            vials.forEach(vial => {
                vial.status = 'idle';
                vial.hashRate = 0;
            });
            
            document.getElementById('mining-indicator').style.display = 'none';
            updateVialStatusBars();
        }

        // Create new network via command (SIMPLIFIED)
        async function createNetworkCommand(params) {
            const args = params.split(' ').filter(p => p);
            
            if (args.length < 2) {
                logEvent("Usage: /create <name> <supply>", 'info');
                logEvent("Example: /create MYTOKEN 1000000", 'info');
                logEvent("Defaults: decimals=18, no max per wallet, 0% fee", 'info');
                return;
            }
            
            const [name, supplyStr] = args;
            const totalSupply = parseInt(supplyStr);
            
            if (!name) {
                logEvent("Please provide a network name", 'error');
                return;
            }
            
            if (totalSupply <= 0 || isNaN(totalSupply)) {
                logEvent("Total supply must be greater than 0", 'error');
                return;
            }
            
            logEvent(`Creating network "${name}" with ${totalSupply.toLocaleString()} tokens...`, 'command');
            logEvent("Using defaults: decimals=18, no max per wallet, 0% fee", 'info');
            
            try {
                // Generate token symbol from name
                const tokenSymbol = name.substring(0, 4).toUpperCase();
                
                // Generate network hash
                const networkData = {
                    name: name,
                    totalSupply,
                    decimals: 18,
                    maxPerWallet: totalSupply, // No limit
                    transferFee: 0, // 0% fee
                    tokenSymbol,
                    timestamp: Date.now()
                };
                
                const hash = await generateNetworkHash(networkData);
                
                // Create network object
                const network = {
                    ...networkData,
                    hash: hash,
                    id: generateUUID(),
                    created: new Date().toISOString(),
                    wallets: [{
                        name: 'FOUNDER',
                        address: wallets[0].address,
                        balance: totalSupply,
                        allocation: 100
                    }],
                    vialHashes: vials.map(v => v.template.substring(0, 32) + hash.substring(0, 32)),
                    hashesMined: 0,
                    miningLimit: null
                };
                
                networks.push(network);
                
                // Add network to main wallet
                wallets[0].networks = wallets[0].networks || [];
                wallets[0].networks.push({
                    name: name,
                    symbol: tokenSymbol,
                    balance: totalSupply,
                    networkHash: hash
                });
                
                logEvent(`Network "${name}" created successfully!`, 'success');
                logEvent(`Token: ${tokenSymbol}`, 'network');
                logEvent(`Supply: ${totalSupply.toLocaleString()}`, 'network');
                logEvent(`Hash: ${hash.substring(0, 16)}...`, 'network');
                logEvent(botMessages.networkCreated, 'bot');
                
                // Auto-start mining for this network
                setTimeout(() => {
                    startMining(name);
                }, 1000);
                
            } catch (error) {
                logEvent("Network creation failed: " + error.message, 'error');
            }
        }

        // Join network via command
        function joinNetworkCommand() {
            logEvent("Select wallet file to import and join networks...", 'command');
            document.getElementById('file-input').click();
        }

        // Handle file import
        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            logEvent(`Importing ${file.name}...`, 'command');
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const fileContent = e.target.result;
                    let importData;
                    
                    if (file.name.endsWith('.md')) {
                        importData = parseMarkdownWallet(fileContent);
                        logEvent("Parsing markdown wallet...", 'info');
                    } else {
                        importData = JSON.parse(fileContent);
                        logEvent("Parsing JSON wallet...", 'info');
                    }
                    
                    let importedNetworks = 0;
                    let importedWallets = 0;
                    
                    // Merge networks
                    if (importData.networks && Array.isArray(importData.networks)) {
                        importData.networks.forEach(impNetwork => {
                            const existingIndex = networks.findIndex(n => n.name === impNetwork.name);
                            if (existingIndex === -1) {
                                const newNetwork = {
                                    name: impNetwork.name,
                                    tokenSymbol: impNetwork.details.token || impNetwork.name.substring(0, 4).toUpperCase(),
                                    totalSupply: parseFloat(impNetwork.details.supply) || 1000000,
                                    decimals: 18,
                                    hash: impNetwork.details.hash || generateUUID().replace(/-/g, ''),
                                    maxPerWallet: parseFloat(impNetwork.details.supply) || 1000000,
                                    transferFee: 0,
                                    hashesMined: parseInt(impNetwork.details.hashesMined) || 0,
                                    miningLimit: null,
                                    imported: true
                                };
                                
                                networks.push(newNetwork);
                                importedNetworks++;
                                logEvent(`Joined network: ${impNetwork.name}`, 'network');
                                
                                // Auto-start mining for imported network
                                setTimeout(() => {
                                    startMining(impNetwork.name);
                                }, 500);
                            }
                        });
                    }
                    
                    // Merge wallets
                    if (importData.wallets && Array.isArray(importData.wallets)) {
                        importData.wallets.forEach(impWallet => {
                            const existingIndex = wallets.findIndex(w => w.name === impWallet.name);
                            if (existingIndex === -1) {
                                wallets.push({
                                    name: impWallet.name,
                                    address: impWallet.details.address || generateAddress(),
                                    balance: parseFloat(impWallet.details.balance) || 0,
                                    networks: [],
                                    totalHashes: parseInt(impWallet.details.totalHashes) || 0
                                });
                                importedWallets++;
                                logEvent(`Added wallet: ${impWallet.name}`, 'balance');
                            }
                        });
                    }
                    
                    // Update total hashes if imported from session
                    if (importData.session && importData.session.hashesEarned) {
                        totalHashesEarned = importData.session.hashesEarned;
                        wallets[0].balance = totalHashesEarned;
                    }
                    
                    updateVialStatusBars();
                    
                    logEvent(`Import complete: ${importedNetworks} networks joined, ${importedWallets} wallets added`, 'success');
                    logEvent(`Total networks: ${networks.length}, Total wallets: ${wallets.length}`, 'info');
                    logEvent(`Auto-mining started for all joined networks. Earning 1 HASH/second each.`, 'hash-earnings');
                    
                } catch (error) {
                    logEvent("Import failed: " + error.message, 'error');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // Export wallet with all hashes earned
        function exportWalletCommand() {
            const exportData = {
                session: {
                    ...currentSession,
                    hashesEarned: totalHashesEarned
                },
                networks: networks.map(n => ({
                    name: n.name,
                    details: {
                        token: n.tokenSymbol,
                        supply: n.totalSupply,
                        decimals: n.decimals,
                        hash: n.hash,
                        hashesMined: n.hashesMined || 0,
                        miningLimit: n.miningLimit
                    }
                })),
                wallets: wallets.map(w => ({
                    name: w.name,
                    details: {
                        address: w.address,
                        balance: w.balance,
                        totalHashes: w.totalHashes || 0
                    }
                }))
            };
            
            // Create markdown format with hashes
            let markdown = `# TOKENFORGE VIAL WALLET EXPORT\n\n`;
            markdown += `# Session: ${exportData.session.name}\n`;
            markdown += `- Created: ${exportData.session.created}\n`;
            markdown += `- Hashes Earned: ${exportData.session.hashesEarned}\n`;
            markdown += `- ID: ${exportData.session.id}\n\n`;
            
            markdown += `## MINING SUMMARY\n`;
            markdown += `- Total Networks: ${exportData.networks.length}\n`;
            markdown += `- Total Hashes Mined: ${exportData.session.hashesEarned}\n`;
            markdown += `- Mining Rate: ${exportData.networks.length} HASH/second\n\n`;
            
            exportData.networks.forEach(network => {
                markdown += `## Network: ${network.name}\n`;
                markdown += `- Token: ${network.details.token}\n`;
                markdown += `- Supply: ${network.details.supply}\n`;
                markdown += `- Decimals: ${network.details.decimals}\n`;
                markdown += `- Hash: ${network.details.hash}\n`;
                markdown += `- Hashes Mined: ${network.details.hashesMined}\n`;
                if (network.details.miningLimit) {
                    markdown += `- Mining Limit: ${network.details.miningLimit}\n`;
                }
                markdown += `\n`;
            });
            
            exportData.wallets.forEach(wallet => {
                markdown += `### Wallet: ${wallet.name}\n`;
                markdown += `- Address: ${wallet.details.address}\n`;
                markdown += `- Balance: ${wallet.details.balance}\n`;
                markdown += `- Total Hashes: ${wallet.details.totalHashes}\n\n`;
            });
            
            const blob = new Blob([markdown], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `tokenforge_wallet_${currentSession.name}_${Date.now()}.md`;
            a.click();
            URL.revokeObjectURL(url);
            
            logEvent("Wallet exported successfully with all hashes earned!", 'success');
            logEvent(`Saved as: ${a.download}`, 'info');
        }

        // Set network mining limit
        function setNetworkLimit() {
            const networkName = prompt("Enter network name to set limit:");
            if (!networkName) return;
            
            const network = networks.find(n => n.name === networkName);
            if (!network) {
                logEvent(`Network ${networkName} not found`, 'error');
                return;
            }
            
            const limit = prompt(`Set mining limit for ${networkName} (hashes):`, "1000");
            if (!limit || isNaN(parseInt(limit))) {
                logEvent("Invalid limit value", 'error');
                return;
            }
            
            network.miningLimit = parseInt(limit);
            currentNetworkLimit = parseInt(limit);
            
            // Show limit indicator
            document.getElementById('network-limit').style.display = 'block';
            document.getElementById('limit-value').textContent = limit;
            
            logEvent(`Set mining limit for ${networkName}: ${limit} hashes`, 'success');
            logEvent(`Mining will stop after reaching ${limit} hashes.`, 'info');
        }

        // Void session
        function voidSessionCommand() {
            if (!confirm("VOID will clear all data. Are you sure?")) return;
            
            isAuthenticated = true; // Still auto-authenticated
            currentSession = null;
            networks = [];
            wallets = [];
            totalHashesEarned = 0;
            
            stopMining();
            initializeVials();
            
            // Re-create auto-session
            autoAuthenticate();
            
            logEvent("Session voided. New auto-session created.", 'warning');
            logEvent(botMessages.welcome, 'bot');
        }

        // List networks
        function listNetworks() {
            if (networks.length === 0) {
                logEvent("No networks found. Create one with /create", 'info');
                return;
            }
            
            logEvent(`=== NETWORKS (${networks.length}) ===`, 'command');
            networks.forEach((network, index) => {
                logEvent(`${index + 1}. ${network.name}`, 'network');
                logEvent(`   Token: ${network.tokenSymbol}`, 'parameter');
                logEvent(`   Supply: ${network.totalSupply.toLocaleString()}`, 'parameter');
                logEvent(`   Hashes Mined: ${network.hashesMined || 0}`, 'hash-earnings');
                if (network.miningLimit) {
                    logEvent(`   Mining Limit: ${network.miningLimit}`, 'warning');
                }
                logEvent(`   Hash: ${network.hash.substring(0, 16)}...`, 'parameter');
            });
        }

        // List wallets
        function listWallets() {
            logEvent(`=== WALLETS (${wallets.length}) ===`, 'command');
            wallets.forEach((wallet, index) => {
                logEvent(`${index + 1}. ${wallet.name}`, 'balance');
                logEvent(`   Address: ${wallet.address}`, 'parameter');
                logEvent(`   Balance: ${wallet.balance}`, 'parameter');
                logEvent(`   Total Hashes: ${wallet.totalHashes || 0}`, 'hash-earnings');
                if (wallet.networks && wallet.networks.length > 0) {
                    logEvent(`   Networks: ${wallet.networks.length}`, 'parameter');
                }
            });
        }

        // Show session info
        function showSessionInfo() {
            logEvent(`=== AUTO-SESSION INFO ===`, 'command');
            logEvent(`Name: ${currentSession.name}`, 'info');
            logEvent(`Created: ${new Date(currentSession.created).toLocaleString()}`, 'info');
            logEvent(`Networks: ${networks.length}`, 'info');
            logEvent(`Wallets: ${wallets.length}`, 'info');
            logEvent(`Total Tokens: ${networks.reduce((sum, n) => sum + n.totalSupply, 0).toLocaleString()}`, 'info');
            logEvent(`Total Hashes Earned: ${totalHashesEarned}`, 'hash-earnings');
            logEvent(`Current Mining Rate: ${networks.length} HASH/second`, 'hash-earnings');
        }

        // Auto-authenticate on startup
        function autoAuthenticate() {
            currentSession = {
                name: `AUTO-SESSION-${Date.now().toString().slice(-6)}`,
                created: new Date().toISOString(),
                id: generateUUID()
            };
            
            wallets = [];
            
            // Initialize with a default wallet
            wallets.push({
                name: 'MAIN',
                address: generateAddress(),
                balance: 0,
                networks: [],
                totalHashes: 0
            });
            
            initializeVials();
            
            document.getElementById('createButton').disabled = false;
            document.getElementById('joinButton').disabled = false;
            document.getElementById('exportButton').disabled = false;
            document.getElementById('importButton').disabled = false;
            document.getElementById('setLimitButton').disabled = false;
            document.getElementById('network-status').textContent = 'AUTO-AUTH';
            document.getElementById('network-status').style.color = '#0f0';
            
            logEvent(`Auto-authenticated! Session: ${currentSession.name}`, 'success');
            logEvent(`Main wallet address: ${wallets[0].address}`, 'balance');
        }

        // Handle command input
        function handleCommand() {
            const input = document.getElementById('prompt-input');
            const command = input.value.trim();
            input.value = '';
            
            if (!command) return;
            
            logEvent(`> ${command}`, 'command');
            
            if (command === '/help' || command === 'help') {
                logEvent("Available commands:", 'command');
                logEvent("/create <name> <supply> - Create network (SIMPLIFIED!)", 'info');
                logEvent("/join - Import wallet file and join networks", 'info');
                logEvent("/export - Export wallet as markdown with hashes", 'info');
                logEvent("/import - Import wallet file", 'info');
                logEvent("/limit - Set mining limit for current network", 'info');
                logEvent("/mine <network> - Start mining a network", 'info');
                logEvent("/stop - Stop mining", 'info');
                logEvent("/void - Clear all data", 'info');
                logEvent("/networks - List all networks", 'info');
                logEvent("/wallets - List all wallets", 'info');
                logEvent("/session - Show session info", 'info');
                logEvent("/status - Show vial status", 'info');
                logEvent("/balance - Show wallet balance", 'info');
                logEvent("/hashes - Show total hashes earned", 'info');
                return;
            }
            
            if (command.startsWith('/create ')) {
                const params = command.substring(8);
                createNetworkCommand(params);
                return;
            }
            
            if (command === '/join') {
                joinNetworkCommand();
                return;
            }
            
            if (command === '/export') {
                exportWalletCommand();
                return;
            }
            
            if (command === '/import') {
                joinNetworkCommand();
                return;
            }
            
            if (command === '/limit' || command === '/setlimit') {
                setNetworkLimit();
                return;
            }
            
            if (command.startsWith('/mine ')) {
                const networkName = command.substring(6);
                startMining(networkName);
                return;
            }
            
            if (command === '/stop') {
                stopMining();
                logEvent("Mining stopped.", 'warning');
                return;
            }
            
            if (command === '/void') {
                voidSessionCommand();
                return;
            }
            
            if (command === '/networks') {
                listNetworks();
                return;
            }
            
            if (command === '/wallets') {
                listWallets();
                return;
            }
            
            if (command === '/session') {
                showSessionInfo();
                return;
            }
            
            if (command === '/status') {
                vials.forEach(vial => {
                    logEvent(`${vial.name}: ${vial.status} | Hash: ${Math.round(vial.hashRate)} | Mined: ${vial.wallet.hashesMined}`);
                });
                logEvent(`Total hashes mined: ${totalHashesEarned}`, 'hash-earnings');
                return;
            }
            
            if (command === '/balance') {
                wallets.forEach(wallet => {
                    logEvent(`${wallet.name}: ${wallet.balance} tokens`, 'balance');
                    logEvent(`  Hashes: ${wallet.totalHashes || 0}`, 'hash-earnings');
                });
                return;
            }
            
            if (command === '/hashes') {
                logEvent(`Total hashes earned: ${totalHashesEarned}`, 'hash-earnings');
                logEvent(`Current mining rate: ${networks.length} HASH/second`, 'hash-earnings');
                logEvent(`Networks mining: ${networks.filter(n => n.hashesMined > 0).length}`, 'info');
                return;
            }
            
            logEvent(`Unknown command: ${command}. Type /help for available commands.`, 'error');
        }

        // UUID generator
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
                const r = Math.random() * 16 | 0;
                return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
            });
        }

        // Neurot particle system
        function createNeurotParticles() {
            const neurotCount = 20;
            
            for (let i = 0; i < neurotCount; i++) {
                createNeurot();
            }
            
            function createNeurot() {
                const neurot = document.createElement('div');
                neurot.className = 'neurot';
                
                const x = Math.random() * window.innerWidth;
                const y = Math.random() * window.innerHeight;
                const size = Math.random() * 2 + 1;
                const opacity = Math.random() * 0.3 + 0.2;
                
                neurot.style.left = `${x}px`;
                neurot.style.top = `${y}px`;
                neurot.style.width = `${size}px`;
                neurot.style.height = `${size}px`;
                neurot.style.opacity = opacity;
                
                document.body.appendChild(neurot);
                animateNeurot(neurot);
            }
            
            function animateNeurot(neurot) {
                let x = parseFloat(neurot.style.left);
                let y = parseFloat(neurot.style.top);
                
                const xSpeed = (Math.random() - 0.5) * 0.2;
                const ySpeed = (Math.random() - 0.5) * 0.2;
                
                function move() {
                    x += xSpeed;
                    y += ySpeed;
                    
                    if (x > window.innerWidth) x = 0;
                    if (x < 0) x = window.innerWidth;
                    if (y > window.innerHeight) y = 0;
                    if (y < 0) y = window.innerHeight;
                    
                    neurot.style.left = `${x}px`;
                    neurot.style.top = `${y}px`;
                    
                    requestAnimationFrame(move);
                }
                
                move();
            }
        }

        // Update hash rate display
        function updateHashRateDisplay() {
            document.getElementById('hash-rate').textContent = networks.length;
        }

        // Initialize the application
        function initialize() {
            createNeurotParticles();
            autoAuthenticate(); // Auto-authenticate on load
            
            // Set up event listeners for buttons
            document.getElementById('createButton').addEventListener('click', () => {
                const params = prompt("Enter network parameters:\nFormat: name supply\nExample: MYTOKEN 1000000");
                if (params) {
                    createNetworkCommand(params);
                }
            });
            document.getElementById('joinButton').addEventListener('click', joinNetworkCommand);
            document.getElementById('exportButton').addEventListener('click', exportWalletCommand);
            document.getElementById('importButton').addEventListener('click', joinNetworkCommand);
            document.getElementById('setLimitButton').addEventListener('click', setNetworkLimit);
            document.getElementById('voidButton').addEventListener('click', voidSessionCommand);
            
            // Terminal input
            document.getElementById('file-input').addEventListener('change', handleFileImport);
            document.getElementById('send-button').addEventListener('click', handleCommand);
            document.getElementById('prompt-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleCommand();
                }
            });
            
            // Update hash rate display periodically
            setInterval(() => {
                updateHashRateDisplay();
            }, 1000);
            
            // Focus input on start
            document.getElementById('prompt-input').focus();
        }
        
        // Start the application when the page loads
        window.addEventListener('load', initialize);
    </script>
</body>
</html>
