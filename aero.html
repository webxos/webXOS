<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>AeroBuilder â€“ Lightweight Three.js Drone Editor + AVL Export</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- Three.js core and controls -->
<script src="https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.168.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.168.0/examples/js/controls/TransformControls.js"></script>
<style>
  body{margin:0;overflow:hidden;background:#0b1020;font-family:monospace;color:#8ff}
  #ui{position:fixed;top:10px;left:10px;z-index:10;background:rgba(0,24,48,0.95);padding:10px;border:1px solid #0ff;border-radius:4px;min-width:300px}
  button{margin:5px;padding:6px 10px;background:#003a3a;border:1px solid #0ff;color:#0ff;cursor:pointer}
  button:hover{background:#006666}
  input, select{margin:5px;width:calc(100% - 10px);background:#002233;border:1px solid #0ff;color:#0ff;padding:4px}
  #info{position:fixed;bottom:10px;left:10px;background:rgba(0,0,0,0.7);padding:8px;border-radius:4px;color:#aef}
  .row{display:flex;gap:6px;flex-wrap:wrap}
  .half{flex:1 1 48%}
  .full{flex:1 1 100%}
</style>
</head>
<body>
<div id="ui">
  <h3>ðŸ›© AeroBuilder (nTop-style Drone Editor)</h3>
  <div class="row">
    <button id="addFuselage">+ Fuselage</button>
    <button id="addWing">+ Wing</button>
    <button id="addTail">+ Tail</button>
    <button id="addProp">+ Prop</button>
  </div>
  <div class="row">
    <select id="tool" class="half">
      <option value="select">Select</option>
      <option value="translate">Move</option>
      <option value="rotate">Rotate</option>
      <option value="scale">Scale</option>
    </select>
    <select id="symmetry" class="half">
      <option value="none">No symmetry</option>
      <option value="yd">Y-duplicate</option>
    </select>
  </div>
  <div class="row">
    <button id="exportAVL" class="half">Export AVL</button>
    <button id="exportJSON" class="half">Export JSON</button>
  </div>
  <div class="row">
    <button id="genAero" class="half">Generate Aero Tables</button>
    <button id="genReport" class="half">Generate Report</button>
  </div>
  <div class="row">
    <button id="deleteSel" class="full">Delete Selected</button>
  </div>
</div>
<div id="info">Tips: Click part to select â€¢ Use Move/Rotate/Scale â€¢ Symmetry for wings/tails â€¢ Export AVL/JSON â€¢ Generate aero + report</div>

<script>
// Scene setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x07131f);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.05, 2000);
camera.position.set(6, 4, 10);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Controls
const orbit = new THREE.OrbitControls(camera, renderer.domElement);
orbit.enableDamping = true;
orbit.dampingFactor = 0.08;

const transform = new THREE.TransformControls(camera, renderer.domElement);
scene.add(transform);

// Make orbit pause while using transform
transform.addEventListener('dragging-changed', (ev) => { orbit.enabled = !ev.value; });

// Lighting and helpers
const hemi = new THREE.HemisphereLight(0xbdd9ff, 0x223344, 0.6);
scene.add(hemi);

const dir = new THREE.DirectionalLight(0xffffff, 1.8);
dir.position.set(6, 10, 8);
scene.add(dir);

const grid = new THREE.GridHelper(20, 20, 0x225566, 0x113344);
grid.position.y = -0.0001;
scene.add(grid);

const axes = new THREE.AxesHelper(1.0);
scene.add(axes);

// Drone group
const drone = new THREE.Group();
drone.name = 'Drone';
scene.add(drone);

// Selection outline
const outlineMat = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.BackSide });
let selectionOutline = null;
let selected = null;

function setSelected(obj) {
  selected = obj || null;
  transform.detach();
  if (selectionOutline) {
    scene.remove(selectionOutline);
    selectionOutline = null;
  }
  if (obj) {
    transform.attach(obj);
    const outlineGeo = obj.geometry.clone();
    selectionOutline = new THREE.Mesh(outlineGeo, outlineMat);
    selectionOutline.position.copy(obj.position);
    selectionOutline.quaternion.copy(obj.quaternion);
    selectionOutline.scale.copy(obj.scale).multiplyScalar(1.03);
    scene.add(selectionOutline);
  }
}

function syncOutline() {
  if (selected && selectionOutline) {
    selectionOutline.position.copy(selected.position);
    selectionOutline.quaternion.copy(selected.quaternion);
    selectionOutline.scale.copy(selected.scale).multiplyScalar(1.03);
  }
}

// Raycasting with proper canvas offset
const raycaster = new THREE.Raycaster();
const ndc = new THREE.Vector2();
renderer.domElement.addEventListener('pointerdown', (e) => {
  const rect = renderer.domElement.getBoundingClientRect();
  const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
  ndc.set(x, y);
  raycaster.setFromCamera(ndc, camera);
  const hits = raycaster.intersectObjects(drone.children, false);
  if (hits.length) {
    setSelected(hits[0].object);
  } else {
    setSelected(null);
  }
});

// Part factories with metadata
function makeMaterial(color) {
  return new THREE.MeshStandardMaterial({ color, roughness: 0.6, metalness: 0.1 });
}

function addFuselage({ length = 2.0, width = 0.4, height = 0.3, color = 0xcccccc } = {}) {
  const geo = new THREE.BoxGeometry(width, height, length);
  const mesh = new THREE.Mesh(geo, makeMaterial(color));
  mesh.name = 'fuselage';
  mesh.userData = { type: 'fuselage', dims: { length, width, height } };
  mesh.position.set(0, 0.15, 0);
  drone.add(mesh);
  setSelected(mesh);
  return mesh;
}

function addWing({ span = 3.0, thickness = 0.08, chord = 0.6, color = 0x00ff88 } = {}) {
  const geo = new THREE.BoxGeometry(span, thickness, chord); // x: span, y: thickness, z: chord
  const mesh = new THREE.Mesh(geo, makeMaterial(color));
  mesh.name = 'wing';
  mesh.userData = { type: 'wing', dims: { span, chord, thickness }, airfoil: 'NACA0012' };
  mesh.position.set(0, 0.2, 0.0);
  drone.add(mesh);
  setSelected(mesh);
  return mesh;
}

function addTail({ span = 1.0, thickness = 0.06, chord = 0.4, color = 0x00ffaa } = {}) {
  const geo = new THREE.BoxGeometry(span, thickness, chord);
  const mesh = new THREE.Mesh(geo, makeMaterial(color));
  mesh.name = 'tail';
  mesh.userData = { type: 'tail', dims: { span, chord, thickness }, airfoil: 'NACA0012' };
  mesh.position.set(0, 0.15, -0.9); // aft
  drone.add(mesh);
  setSelected(mesh);
  return mesh;
}

function addProp({ radius = 0.35, hub = 0.06, color = 0xff8800 } = {}) {
  const geo = new THREE.CylinderGeometry(radius, radius, hub, 32);
  const mesh = new THREE.Mesh(geo, makeMaterial(color));
  mesh.name = 'prop';
  mesh.userData = { type: 'prop', dims: { radius, hub } };
  mesh.rotation.x = Math.PI / 2;
  mesh.position.set(0, 0.2, 0.8);
  drone.add(mesh);
  setSelected(mesh);
  return mesh;
}

// UI hooks
document.getElementById('addFuselage').onclick = () => addFuselage();
document.getElementById('addWing').onclick = () => addWing();
document.getElementById('addTail').onclick = () => addTail();
document.getElementById('addProp').onclick = () => addProp();

document.getElementById('tool').onchange = (e) => {
  const mode = e.target.value;
  if (mode === 'select') {
    transform.detach();
  } else {
    transform.setMode(mode);
    if (selected) transform.attach(selected);
  }
};
document.getElementById('symmetry').onchange = (e) => {
  // stored per-part, default used during AVL export
  const val = e.target.value; // 'none' or 'yd'
  drone.userData.symmetry = val;
};

document.getElementById('deleteSel').onclick = () => {
  if (!selected) return;
  drone.remove(selected);
  setSelected(null);
};

// AVL export (lightweight surface + section mapping)
function exportAVL() {
  const sym = drone.userData.symmetry === 'yd' ? 'YDUPLICATE' : null;

  let avl = '';
  avl += '# AeroBuilder â†’ AVL export\n';
  avl += 'MACH 0.05\n';
  avl += 'IYsym 0 0 0\n\n';

  const parts = drone.children.filter(m => m.visible);

  for (const part of parts) {
    const p = part.position.clone();
    const s = part.scale.clone();
    const q = part.quaternion.clone(); // not used in simple export
    const ud = part.userData || {};
    const dims = ud.dims || {};

    if (ud.type === 'wing' || ud.type === 'tail') {
      const span = dims.span || part.geometry.parameters.width || 1.0;
      const chord = dims.chord || part.geometry.parameters.depth || 0.3;
      const thick = dims.thickness || part.geometry.parameters.height || 0.05;

      avl += `SURFACE\n${ud.type === 'wing' ? 'MainWing' : 'TailPlane'}\n`;
      if (sym) avl += `${sym}\n0.0\n`;
      avl += 'COMPONENT\n1\n';
      avl += 'TRANSLATE\n' + `${p.x.toFixed(3)} ${p.y.toFixed(3)} ${p.z.toFixed(3)}\n`;
      // Two-section approximation along span
      // SECTION: y, x, z, chord, aoa, claf, NACA
      const y0 = -span / 2;
      const y1 = span / 2;
      const x = 0.0;
      const z = 0.0;
      const aoa = 0.0;
      const claf = 1.0;
      const airfoil = (ud.airfoil || 'NACA0012');

      avl += `SECTION\n${y0.toFixed(3)} ${x.toFixed(3)} ${z.toFixed(3)}  ${chord.toFixed(3)} ${aoa} ${claf}  ${airfoil}\n`;
      avl += `SECTION\n${y1.toFixed(3)} ${x.toFixed(3)} ${z.toFixed(3)}  ${chord.toFixed(3)} ${aoa} ${claf}  ${airfoil}\n\n`;
    }

    if (ud.type === 'fuselage') {
      const L = dims.length || part.geometry.parameters.depth || 2.0;
      const W = dims.width || part.geometry.parameters.width || 0.4;
      const H = dims.height || part.geometry.parameters.height || 0.3;
      avl += `BODY\nFuselage\nTRANSLATE\n${p.x.toFixed(3)} ${p.y.toFixed(3)} ${p.z.toFixed(3)}\n`;
      avl += `# Approximate fuselage body; L=${L.toFixed(3)} W=${W.toFixed(3)} H=${H.toFixed(3)}\n\n`;
    }
  }

  downloadText('drone.avl', avl);
  alert('AVL file exported.');
}

// JSON export for downstream CLI
function exportJSON() {
  const payload = {
    meta: {
      tool: 'AeroBuilder',
      version: '0.2',
      symmetry: drone.userData.symmetry || 'none'
    },
    parts: drone.children.filter(m => m.visible).map(m => ({
      name: m.name,
      type: m.userData.type,
      dims: m.userData.dims,
      airfoil: m.userData.airfoil || null,
      position: m.position.toArray(),
      quaternion: m.quaternion.toArray(),
      scale: m.scale.toArray()
    }))
  };
  downloadText('drone.json', JSON.stringify(payload, null, 2));
  alert('JSON exported for CLI pipeline.');
}

// Lightweight aero tables (mock heuristics)
function generateAeroTables() {
  const parts = drone.children.filter(m => m.visible);
  let spanSum = 0;
  let chordAvg = 0;
  let wingCount = 0;

  parts.forEach(p => {
    const ud = p.userData || {};
    if (ud.type === 'wing' || ud.type === 'tail') {
      wingCount += 1;
      spanSum += ud.dims.span || 1.0;
      chordAvg += ud.dims.chord || 0.3;
    }
  });

  if (wingCount === 0) {
    alert('Add a wing or tail to generate aero tables.');
    return;
  }

  chordAvg = chordAvg / wingCount;
  const AR = (spanSum > 0 && chordAvg > 0) ? (Math.pow(spanSum, 2) / (spanSum * chordAvg)) : 6.0; // AR â‰ˆ span/chord
  const mach = 0.05;
  const beta = Math.sqrt(1 - mach * mach);
  const CL_alpha = (2 * Math.PI) / beta * (AR / (AR + 2)); // crude lifting-line trend
  const CD0 = 0.018; // baseline
  const Cm_alpha = -0.3; // stable nose-down tendency
  const Cn_beta = -0.09; // directional stability

  const dutch_w = 2.0 + 0.1 * AR;
  const dutch_z = 0.10 + 0.02 * (AR > 6 ? 1 : 0);
  const short_w = 4.0 + 0.1 * AR;

  const aileron_eff = 0.003 + 0.00005 * spanSum;
  const elevator_eff = 0.0038 + 0.00006 * chordAvg;
  const rudder_eff = 0.0026 + 0.00004 * spanSum;

  const tables = {
    config: 'Group 3 Tactical UAS',
    mach,
    derivatives: {
      CL_alpha: Number(CL_alpha.toFixed(3)),
      CD_0: CD0,
      Cm_alpha: Cm_alpha,
      Cn_beta: Cn_beta
    },
    modes: {
      dutch_roll: { omega_rad_s: Number(dutch_w.toFixed(2)), zeta: Number(dutch_z.toFixed(2)) },
      short_period: { omega_rad_s: Number(short_w.toFixed(2)), zeta: 0.25 }
    },
    control_effectiveness: {
      aileron_per_deg: Number(aileron_eff.toFixed(4)),
      elevator_per_deg: Number(elevator_eff.toFixed(4)),
      rudder_per_deg: Number(rudder_eff.toFixed(4))
    }
  };

  downloadText('aero_tables.json', JSON.stringify(tables, null, 2));
  alert('Aero tables generated (mock).');
  return tables;
}

// LLM-style text report
function generateReport() {
  const t = generateAeroTables();
  if (!t) return;
  const r = `
AERODYNAMIC SUMMARY (Generated by LLM-style reporter)

Configuration: ${t.config}
Mach: ${t.mach}

Stability Derivatives:
CL_alpha = ${t.derivatives.CL_alpha} /rad
CD_0     = ${t.derivatives.CD_0}
Cm_alpha = ${t.derivatives.Cm_alpha} /rad
Cn_beta  = ${t.derivatives.Cn_beta} /rad

Dynamic Modes:
Dutch Roll: Ï‰ = ${t.modes.dutch_roll.omega_rad_s} rad/s, Î¶ = ${t.modes.dutch_roll.zeta}
Short Period: Ï‰ = ${t.modes.short_period.omega_rad_s} rad/s, Î¶ = ${t.modes.short_period.zeta}

Control Effectiveness:
Aileron  : ${t.control_effectiveness.aileron_per_deg} per deg
Elevator : ${t.control_effectiveness.elevator_per_deg} per deg
Rudder   : ${t.control_effectiveness.rudder_per_deg} per deg

Conclusion: Static and dynamic stability within expected margins for Group 3 UAS. Ready for AVL/XFOIL validation and 6-DOF simulation.
  `.trim();
  downloadText('Aero_Report.txt', r);
  alert('LLM-style report generated (text).');
}

// Downloads
function downloadText(name, text) {
  const blob = new Blob([text], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = name; a.click();
  URL.revokeObjectURL(url);
}

// Buttons
document.getElementById('exportAVL').onclick = exportAVL;
document.getElementById('exportJSON').onclick = exportJSON;
document.getElementById('genAero').onclick = generateAeroTables;
document.getElementById('genReport').onclick = generateReport;

// Animate
function animate() {
  requestAnimationFrame(animate);
  orbit.update();
  transform.update();
  syncOutline();
  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
