<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XFORC3D: TANKS VS DRONES by webXOS 2025</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: #00ff00;
            font-family: 'Press Start 2P', monospace;
            overflow: hidden;
            user-select: none;
            font-size: 10px;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            pointer-events: none;
            text-shadow: 0 0 5px #00ff00;
        }
        
        #logo {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00;
            animation: pulse 2s infinite;
        }
        
        #healthBar, #ammoBar, #towerHealthBar {
            width: 200px;
            height: 20px;
            background: rgba(0, 255, 0, 0.2);
            border: 1px solid #00ff00;
            margin-bottom: 5px;
            position: relative;
            overflow: hidden;
        }
        
        #healthFill, #ammoFill, #towerHealthFill {
            height: 100%;
            background: #00ff00;
            box-shadow: 0 0 10px #00ff00;
            transition: width 0.3s;
        }
        
        #ammoFill {
            background: #ffff00;
            box-shadow: 0 0 10px #ffff00;
        }
        
        #towerHealthFill {
            background: #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }
        
        #waveInfo, #enemiesCount, #score, #timer {
            margin: 5px 0;
            font-size: 14px;
        }
        
        #vehicleToggle {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            background: transparent;
            border: 1px solid #00ff00;
            color: #00ff00;
            font-family: 'Press Start 2P', monospace;
            cursor: pointer;
            pointer-events: auto;
            z-index: 101;
            text-shadow: 0 0 5px #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }
        
        #vehicleToggle:hover {
            background: rgba(0, 255, 0, 0.2);
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff00;
            font-size: 24px;
            z-index: 100;
            pointer-events: none;
            text-shadow: 0 0 5px #00ff00;
        }
        
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 99;
            background: transparent;
            box-shadow: inset 0 0 20px #00ff00;
            border: 4px solid #00ff00;
        }
        
        #hud::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 80%;
            height: 80%;
            border: 2px dashed #00ff00;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px #00ff00;
        }
        
        #weaponInfo {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 14px;
        }
        
        #menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 200;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
            transform: scale(1);
            transform-origin: center center;
        }
        
        #title {
            font-size: 48px;
            margin-bottom: 20px;
            color: #00ff00;
            text-shadow: 0 0 20px #00ff00, 0 0 40px #00ff00;
            animation: pulse 2s infinite;
        }
        
        #tankMode, #droneMode, #settingsButton, #startButton {
            margin: 20px 0;
            padding: 10px 20px;
            background: transparent;
            border: 2px solid #00ff00;
            color: #00ff00;
            font-family: 'Press Start 2P', monospace;
            font-size: 18px;
            cursor: pointer;
            text-shadow: 0 0 10px #00ff00;
            box-shadow: 0 0 20px #00ff00;
            transition: all 0.3s;
        }
        
        #tankMode:hover, #droneMode:hover, #settingsButton:hover, #startButton:hover {
            background: rgba(0, 255, 0, 0.2);
            box-shadow: 0 0 40px #00ff00;
        }
        
        #settings {
            display: none;
            flex-direction: column;
            align-items: center;
        }
        
        #gameGuide {
            max-width: 600px;
            margin: 20px;
            text-align: left;
            font-size: 14px;
            line-height: 1.5;
        }
        
        #gameOver {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 200;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
            transform: scale(1);
            transform-origin: center center;
        }
        
        #gameOverTitle {
            font-size: 48px;
            margin-bottom: 20px;
        }
        
        #restartButton {
            margin: 20px 0;
            padding: 10px 20px;
            background: transparent;
            border: 2px solid #00ff00;
            color: #00ff00;
            font-family: 'Press Start 2P', monospace;
            font-size: 18px;
            cursor: pointer;
            text-shadow: 0 0 10px #00ff00;
            box-shadow: 0 0 20px #00ff00;
            transition: all 0.3s;
        }
        
        #restartButton:hover {
            background: rgba(0, 255, 0, 0.2);
            box-shadow: 0 0 40px #00ff00;
        }
        
        #credits {
            font-size: 12px;
            margin-top: 20px;
            text-align: center;
            width: 80%;
        }
        
        #loadSplash, #loadBar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #00ff00;
            z-index: 300;
            transform: scale(1);
            transform-origin: center center;
        }
        
        #loadTitle {
            font-size: 32px;
            margin-bottom: 20px;
        }
        
        #progressBar {
            width: 300px;
            height: 20px;
            background: rgba(0, 255, 0, 0.2);
            border: 2px solid #00ff00;
        }
        
        #loadFill {
            height: 100%;
            background: #00ff00;
            width: 0%;
        }
        
        #webxosLogo {
            font-size: 48px;
            color: #00ff00;
            text-shadow: 0 0 20px #00ff00;
            animation: pulse 2s infinite;
        }
        
        #slogan {
            font-size: 24px;
            color: #00ff00;
            text-shadow: 0 0 20px #00ff00;
            animation: matrix-fall 2s linear infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.8; }
            50% { opacity: 1; }
            100% { opacity: 0.8; }
        }
        
        @keyframes matrix-fall {
            0% { transform: translateY(-20px); opacity: 1; }
            100% { transform: translateY(20px); opacity: 0; }
        }
        
        .glitch {
            position: relative;
        }
        
        .glitch::before, .glitch::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .glitch::before {
            left: 4px;
            text-shadow: -4px 0 #ff00ff;
            clip: rect(88px, 900px, 112px, 0);
            animation: glitch-anim 5s infinite linear alternate-reverse;
        }
        
        .glitch::after {
            left: -4px;
            text-shadow: -4px 0 #00ffff;
            clip: rect(88px, 900px, 112px, 0);
            animation: glitch-anim2 5s infinite linear alternate-reverse;
        }
        
        @keyframes glitch-anim {
            0% { clip: rect(84px, 9999px, 88px, 0); }
            5% { clip: rect(24px, 9999px, 118px, 0); }
            10% { clip: rect(96px, 9999px, 58px, 0); }
            15% { clip: rect(84px, 9999px, 146px, 0); }
            20% { clip: rect(126px, 9999px, 54px, 0); }
            25% { clip: rect(68px, 9999px, 110px, 0); }
            30% { clip: rect(172px, 9999px, 146px, 0); }
            35% { clip: rect(40px, 9999px, 40px, 0); }
            40% { clip: rect(52px, 9999px, 120px, 0); }
            45% { clip: rect(50px, 9999px, 132px, 0); }
            50% { clip: rect(114px, 9999px, 196px, 0); }
            55% { clip: rect(10px, 9999px, 92px, 0); }
            60% { clip: rect(164px, 9999px, 62px, 0); }
            65% { clip: rect(108px, 9999px, 54px, 0); }
            70% { clip: rect(56px, 9999px, 198px, 0); }
            75% { clip: rect(90px, 9999px, 138px, 0); }
            80% { clip: rect(46px, 9999px, 170px, 0); }
            85% { clip: rect(108px, 9999px, 168px, 0); }
            90% { clip: rect(90px, 9999px, 94px, 0); }
            95% { clip: rect(74px, 9999px, 40px, 0); }
            100% { clip: rect(8px, 9999px, 182px, 0); }
        }
        
        @keyframes glitch-anim2 {
            0% { clip: rect(130px, 9999px, 200px, 0); }
            5% { clip: rect(104px, 9999px, 148px, 0); }
            10% { clip: rect(158px, 9999px, 170px, 0); }
            15% { clip: rect(150px, 9999px, 10px, 0); }
            20% { clip: rect(134px, 9999px, 122px, 0); }
            25% { clip: rect(28px, 9999px, 158px, 0); }
            30% { clip: rect(2px, 9999px, 132px, 0); }
            35% { clip: rect(172px, 9999px, 60px, 0); }
            40% { clip: rect(46px, 9999px, 196px, 0); }
            45% { clip: rect(170px, 9999px, 144px, 0); }
            50% { clip: rect(142px, 9999px, 150px, 0); }
            55% { clip: rect(4px, 9999px, 96px, 0); }
            60% { clip: rect(60px, 9999px, 32px, 0); }
            65% { clip: rect(118px, 9999px, 100px, 0); }
            70% { clip: rect(82px, 9999px, 124px, 0); }
            75% { clip: rect(4px, 9999px, 164px, 0); }
            80% { clip: rect(94px, 9999px, 146px, 0); }
            85% { clip: rect(6px, 9999px, 54px, 0); }
            90% { clip: rect(52px, 9999px, 110px, 0); }
            95% { clip: rect(84px, 9999px, 194px, 0); }
            100% { clip: rect(76px, 9999px, 98px, 0); }
        }
    </style>
</head>
<body>
    <div id="loadSplash">
        <div id="webxosLogo">WEBXOS</div>
        <div id="slogan">BROWSER BASED GAMES</div>
    </div>
    <div id="loadBar" style="display:none;">
        <div id="loadTitle" class="glitch" data-text="XFORC3D: TANK VS DRONE">XFORC3D: TANK VS DRONE</div>
        <div id="progressBar"><div id="loadFill"></div></div>
    </div>
    <div id="gameContainer">
        <div id="hud"></div>
        <div id="ui">
            <div id="logo" class="glitch" data-text="XFORC3D: TANKS VS DRONES">XFORC3D: TANKS VS DRONES</div>
            <div>HEALTH: <span id="healthValue">100</span>/100</div>
            <div id="healthBar"><div id="healthFill" style="width: 100%;"></div></div>
            <div>AMMO: <span id="ammoValue">100</span>/100</div>
            <div id="ammoBar"><div id="ammoFill" style="width: 100%;"></div></div>
            <div>TOWER: <span id="towerHealthValue">100</span>/100</div>
            <div id="towerHealthBar"><div id="towerHealthFill" style="width: 100%;"></div></div>
            <div id="waveInfo">WAVE: <span id="waveNumber">1</span>/1</div>
            <div id="enemiesCount">ENEMIES: <span id="enemiesLeft">0</span></div>
            <div id="score">SCORE: <span id="scoreValue">0</span></div>
            <div id="timer">TIME: <span id="timeValue">0</span></div>
        </div>
        
        <button id="vehicleToggle">SWITCH MODE</button>
        
        <div id="crosshair">+</div>
        
        <div id="weaponInfo">
            <div>VEHICLE: <span id="vehicleName">TANK</span></div>
            <div>WEAPON: <span id="weaponName">GATLING GUN</span></div>
            <div>AMMO: <span id="ammoDisplay">âˆž</span></div>
            <div>LMB: FIRE | RMB: ZOOM | WASD: MOVE | MOUSE: AIM</div>
            <div>SPACE: SPECIAL | SHIFT: BOOST | CTRL: DESCEND (DRONE)</div>
        </div>
        
        <div id="menu" style="display:none;">
            <h1 id="title" class="glitch" data-text="XFORC3D: TANKS VS DRONES">XFORC3D: TANKS VS DRONES</h1>
            <button id="tankMode">TANK MODE</button>
            <button id="droneMode">DRONE MODE</button>
            <button id="settingsButton">SETTINGS</button>
            <div id="settings" style="display:none;">
                <label>Y Invert <input type="checkbox" id="invertY"></label>
                <label>Sensitivity <input type="range" id="sensitivity" min="0.1" max="2" step="0.1" value="1"></label>
                <button id="closeSettings">CLOSE</button>
            </div>
            <div id="gameGuide">
                <h2>MISSION BRIEFING</h2>
                <p>Defend the central Tesla Tower from invaders.</p>
                <p><strong>MODES:</strong></p>
                <ul>
                    <li>TANK MODE: Control tank vs 10 red drones</li>
                    <li>DRONE MODE: Control drone vs 10 red tanks</li>
                </ul>
                <p><strong>ENEMIES:</strong></p>
                <ul>
                    <li>Scout Drones: Fast, low health</li>
                    <li>Assault Drones: Medium speed, moderate health</li>
                    <li>Bomber Drones: Slow, high health, explosive damage</li>
                    <li>Red Tanks: High health, slow, gatling attack</li>
                </ul>
                <p><strong>DEFENSES:</strong></p>
                <ul>
                    <li>Central Tesla Tower with energy shield</li>
                    <li>Switch mode during battle (V)</li>
                    <li>Use terrain for cover (tank only)</li>
                </ul>
                <p><strong>CONTROLS:</strong></p>
                <ul>
                    <li>WASD: Move | Mouse: Aim | LMB: Fire | RMB: Zoom 4x</li>
                    <li>Space: Special/Lift | Shift: Boost | Ctrl: Descend (drone)</li>
                    <li>V: Switch Mode | ESC: Pause | F11: Fullscreen</li>
                </ul>
            </div>
        </div>
        
        <div id="gameOver" style="display:none;">
            <h1 id="gameOverTitle">TOWER DESTROYED</h1>
            <div id="finalScore">FINAL SCORE: <span id="finalScoreValue">0</span></div>
            <div id="enemiesCleared">ENEMIES CLEARED: <span id="enemiesClearedValue">0</span></div>
            <div id="timeTaken">TIME TAKEN: <span id="timeTakenValue">0</span></div>
            <div id="damageTaken">DAMAGE TAKEN: <span id="damageTakenValue">0</span></div>
            <div id="damageDone">DAMAGE DONE: <span id="damageDoneValue">0</span></div>
            <div id="credits">webXOS 2025 browser based gaming designed on the XFORC3D engine all rights reserved Open source MIT license webxos.netlify.app</div>
            <button id="restartButton">RESTART</button>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        const PI_2 = Math.PI / 2;
        PointerLockControls.prototype.onMouseMove = function ( event ) {
            if ( this.enabled === false ) return;
            var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
            var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
            const sens = window.game ? window.game.sensitivity : 1;
            const inv = window.game && window.game.invertY ? -1 : 1;
            this.yawObject.rotation.y -= movementX * 0.002 * sens;
            this.pitchObject.rotation.x -= movementY * 0.002 * sens * inv;
            this.pitchObject.rotation.x = Math.max( - PI_2, Math.min( PI_2, this.pitchObject.rotation.x ) );
        };

        class Game {
            constructor() {
                window.game = this;
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: false });
                
                this.setupRenderer();
                this.setupScene();
                this.createCentralTower();
                this.createTown();
                this.setupLighting();
                this.setupParticles();
                this.setupControls();
                
                this.enemies = [];
                this.projectiles = [];
                this.enemyProjectiles = [];
                
                this.health = 100;
                this.ammo = 100;
                this.towerHealth = 100;
                this.score = 0;
                this.wave = 1;
                this.enemiesInWave = 0;
                this.enemiesKilled = 0;
                this.damageTaken = 0;
                this.damageDone = 0;
                
                this.mode = 'tank';
                this.gameActive = false;
                this.gameOver = false;
                this.shieldActive = false;
                this.sensitivity = 1;
                this.invertY = false;
                
                this.projectilePool = [];
                this.enemyProjectilePool = [];
                this.poolSize = 300;
                this.activeProjectiles = [];
                this.activeEnemyProjectiles = [];
                this.initPools();
                
                this.enemyPool = [];
                this.activeEnemies = [];
                this.initEnemyPools();
                
                this.spatialGrid = new Map();
                this.gridSize = 25;
                this.cellsX = Math.ceil(400 / this.gridSize);
                this.cellsZ = Math.ceil(400 / this.gridSize);
                
                this.flowField = new Float32Array(this.cellsX * this.cellsZ * 3);
                this.buildFlowField();
                
                document.getElementById('loadSplash').style.display = 'flex';
                document.getElementById('loadBar').style.display = 'none';
                document.getElementById('menu').style.display = 'none';
                document.getElementById('gameOver').style.display = 'none';
                
                setTimeout(() => {
                    document.getElementById('loadSplash').style.display = 'none';
                    document.getElementById('loadBar').style.display = 'flex';
                    document.getElementById('loadFill').style.transition = 'width 3s linear';
                    setTimeout(() => {
                        document.getElementById('loadFill').style.width = '100%';
                    }, 100);
                    setTimeout(() => {
                        document.getElementById('loadBar').style.display = 'none';
                        document.getElementById('menu').style.display = 'flex';
                    }, 3100);
                }, 2000);
                
                this.animate();
                this.setupEventListeners();
            }

            initPools() {
                for (let i = 0; i < this.poolSize; i++) {
                    this.projectilePool.push(this.createPooledProjectile(false));
                    this.enemyProjectilePool.push(this.createPooledProjectile(true));
                }
            }

            createPooledProjectile(isEnemy) {
                const geo = new THREE.SphereGeometry(isEnemy ? 0.3 : 0.2, 6, 4);
                const mat = new THREE.MeshBasicMaterial({ 
                    color: isEnemy ? 0xff0000 : 0xffff00,
                    wireframe: true,
                    emissive: isEnemy ? 0x440000 : 0xaaaa00
                });
                const proj = new THREE.Mesh(geo, mat);
                proj.visible = false;
                proj.userData.active = false;
                return proj;
            }

            initEnemyPools() {
                for (let i = 0; i < this.poolSize; i++) {
                    this.enemyPool.push(this.createPooledEnemy('drone'));
                    this.enemyPool.push(this.createPooledEnemy('tank'));
                }
            }

            createPooledEnemy(type) {
                const group = new THREE.Group();
                const isDrone = type === 'drone';
                
                const bodyGeo = new THREE.BoxGeometry(isDrone ? 1.5 : 3, isDrone ? 0.5 : 1.5, isDrone ? 1.5 : 5);
                const bodyMat = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true, emissive: 0x440000 });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                group.add(body);
                
                if (isDrone) {
                    const rotorGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 6);
                    const rotorMat = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true, emissive: 0x440000 });
                    const positions = [[0.8,0.3,0.8], [-0.8,0.3,0.8], [0.8,0.3,-0.8], [-0.8,0.3,-0.8]];
                    positions.forEach(pos => {
                        const rotor = new THREE.Mesh(rotorGeo, rotorMat);
                        rotor.position.set(...pos);
                        group.add(rotor);
                    });
                } else {
                    const turretGeo = new THREE.CylinderGeometry(1.2, 1.2, 1, 8);
                    const turret = new THREE.Mesh(turretGeo, bodyMat);
                    turret.position.y = 1.5;
                    group.add(turret);
                    
                    const gunGeo = new THREE.CylinderGeometry(0.3, 0.3, 4, 6);
                    const gun = new THREE.Mesh(gunGeo, bodyMat);
                    gun.position.set(0, 1.5, 2.5);
                    gun.rotation.x = Math.PI / 2;
                    turret.add(gun);
                    
                    const treadGeo = new THREE.BoxGeometry(3.5, 0.5, 5.5);
                    const treadL = new THREE.Mesh(treadGeo, bodyMat);
                    treadL.position.set(-1.8, -0.5, 0);
                    group.add(treadL);
                    const treadR = new THREE.Mesh(treadGeo, bodyMat);
                    treadR.position.set(1.8, -0.5, 0);
                    group.add(treadR);
                }
                
                group.visible = false;
                group.userData = { active: false, health: 0, type: type === 'drone' ? 'drone' : 'tank', baseType: type };
                return group;
            }

            buildFlowField() {
                const gridW = this.cellsX, gridH = this.cellsZ;
                const costField = new Uint8Array(gridW * gridH).fill(255); // INF
                const dirs = [[0,-1],[1,-1],[1,0],[1,1],[0,1],[-1,1],[-1,0],[-1,-1]];
                
                // Mark obstacles
                this.buildings.forEach(b => {
                    const minX = Math.max(0, Math.floor((b.position.x - 10 + 200) / this.gridSize));
                    const maxX = Math.min(gridW - 1, Math.floor((b.position.x + 10 + 200) / this.gridSize));
                    const minZ = Math.max(0, Math.floor((b.position.z - 10 + 200) / this.gridSize));
                    const maxZ = Math.min(gridH - 1, Math.floor((b.position.z + 10 + 200) / this.gridSize));
                    for (let gx = minX; gx <= maxX; gx++) for (let gz = minZ; gz <= maxZ; gz++) {
                        costField[gx + gz * gridW] = 0; // Blocked
                    }
                });
                
                // BFS from tower
                const towerX = Math.floor(200 / this.gridSize), towerZ = Math.floor(200 / this.gridSize);
                const queue = [{x: towerX, z: towerZ, cost: 0}];
                costField[towerX + towerZ * gridW] = 0;
                
                while (queue.length) {
                    const curr = queue.shift();
                    for (const [dx, dz] of dirs) {
                        const nx = curr.x + dx, nz = curr.z + dz;
                        if (nx < 0 || nx >= gridW || nz < 0 || nz >= gridH) continue;
                        const nidx = nx + nz * gridW;
                        if (costField[nidx] === 0) continue; // Blocked
                        if (costField[nidx] > curr.cost + 1) {
                            costField[nidx] = curr.cost + 1;
                            queue.push({x: nx, z: nz, cost: curr.cost + 1});
                        }
                    }
                }
                
                // Flow vectors
                for (let gz = 0; gz < gridH; gz++) for (let gx = 0; gx < gridW; gx++) {
                    const idx = (gx + gz * gridW) * 3;
                    if (costField[gx + gz * gridW] === 255 || costField[gx + gz * gridW] === 0) {
                        this.flowField[idx] = 0; this.flowField[idx+2] = 0;
                        continue;
                    }
                    let bestDx = 0, bestDz = 0, bestCost = 255;
                    for (const [dx, dz] of dirs) {
                        const nx = gx + dx, nz = gz + dz;
                        if (nx < 0 || nx >= gridW || nz < 0 || nz >= gridH) continue;
                        const ncost = costField[nx + nz * gridW];
                        if (ncost < bestCost && ncost !== 0) {
                            bestCost = ncost;
                            bestDx = dx; bestDz = dz;
                        }
                    }
                    const flow = new THREE.Vector3(bestDx, 0, bestDz).normalize();
                    this.flowField[idx] = flow.x;
                    this.flowField[idx+2] = flow.z;
                }
            }

            setupRenderer() {
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
                this.renderer.setClearColor(0x000000);
                document.getElementById('gameContainer').appendChild(this.renderer.domElement);
            }

            setupScene() {
                const groundGeometry = new THREE.PlaneGeometry(400, 400, 40, 40);
                const groundMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x003300, 
                    wireframe: true,
                    transparent: true,
                    opacity: 0.3
                });
                this.ground = new THREE.Mesh(groundGeometry, groundMaterial);
                this.ground.rotation.x = -Math.PI / 2;
                this.scene.add(this.ground);

                const gridHelper = new THREE.GridHelper(400, 40, 0x003300, 0x001100);
                gridHelper.material.transparent = true;
                gridHelper.material.opacity = 0.5;
                this.scene.add(gridHelper);
            }

            createCentralTower() {
                this.tower = new THREE.Group();
                
                const baseGeometry = new THREE.CylinderGeometry(5, 7, 20, 8);
                const baseMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x222222, 
                    wireframe: true,
                    emissive: 0x111111
                });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = 10;
                this.tower.add(base);
                
                const midGeometry = new THREE.CylinderGeometry(4, 5, 15, 8);
                const mid = new THREE.Mesh(midGeometry, baseMaterial);
                mid.position.y = 27.5;
                this.tower.add(mid);
                
                const topGeometry = new THREE.SphereGeometry(6, 8, 6);
                const topMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff00, 
                    wireframe: true,
                    emissive: 0x00aa00
                });
                const top = new THREE.Mesh(topGeometry, topMaterial);
                top.position.y = 40;
                this.tower.add(top);
                
                const spikeGeometry = new THREE.ConeGeometry(0.5, 3, 4);
                const spikeMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff00, 
                    wireframe: true,
                    emissive: 0x00aa00
                });
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
                    spike.position.set(
                        Math.cos(angle) * 5,
                        40,
                        Math.sin(angle) * 5
                    );
                    spike.rotation.x = Math.PI / 2;
                    this.tower.add(spike);
                }
                
                this.tower.position.set(0, 0, 0);
                this.scene.add(this.tower);
                
                const energyFieldGeometry = new THREE.SphereGeometry(15, 16, 16);
                const energyFieldMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff00, 
                    wireframe: true,
                    transparent: true,
                    opacity: 0.2
                });
                this.energyField = new THREE.Mesh(energyFieldGeometry, energyFieldMaterial);
                this.energyField.position.set(0, 20, 0);
                this.scene.add(this.energyField);
            }

            createTown() {
                this.buildings = [];
                
                this.createDistrict(-50, 0, -50, 4, 4);
                this.createDistrict(50, 0, -30, 3, 3);
                this.createDistrict(-30, 0, 30, 3, 3);
                this.createDistrict(30, 0, 50, 4, 4);
            }

            createDistrict(x, y, z, rows, cols) {
                const buildingMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x003300, 
                    wireframe: true,
                    emissive: 0x001100
                });

                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        const building = this.createBuilding();
                        building.position.set(x + i * 15, 0, z + j * 12);
                        this.scene.add(building);
                        this.buildings.push(building);
                    }
                }
            }

            createBuilding() {
                const building = new THREE.Group();
                const height = 5 + Math.random() * 10;
                const width = 4 + Math.random() * 4;
                const depth = 4 + Math.random() * 4;
                
                const walls = new THREE.Mesh(
                    new THREE.BoxGeometry(width, height, depth),
                    new THREE.MeshBasicMaterial({ 
                        color: 0x003300, 
                        wireframe: true,
                        emissive: 0x001100
                    })
                );
                walls.position.y = height / 2;
                
                building.add(walls);
                return building;
            }

            createPlayer() {
                this.player = new THREE.Group();
                const y = this.mode === 'tank' ? 1 : 20;
                this.player.position.set(0, y, 0);
                if (this.mode === 'tank') {
                    this.createTank();
                } else {
                    this.createDrone();
                }
                this.scene.add(this.player);

                this.playerVelocity = new THREE.Vector3();
            }

            createTank() {
                while(this.player.children.length > 0) { 
                    this.player.remove(this.player.children[0]); 
                }
                
                const bodyGeometry = new THREE.BoxGeometry(3, 1.5, 5);
                const bodyMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x444444, 
                    wireframe: true,
                    emissive: 0x222222
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                this.player.add(body);

                const turretGeometry = new THREE.CylinderGeometry(1.2, 1.2, 1, 8);
                const turretMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x555555, 
                    wireframe: true,
                    emissive: 0x333333
                });
                this.turret = new THREE.Mesh(turretGeometry, turretMaterial);
                this.turret.position.y = 1.5;
                this.player.add(this.turret);

                this.gunGroup = new THREE.Group();
                const barrelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 4, 6);
                const barrelMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x666666, 
                    wireframe: true,
                    emissive: 0x444444
                });
                for (let i = 0; i < 6; i++) {
                    const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
                    const angle = i * Math.PI * 2 / 6;
                    barrel.position.set(Math.cos(angle) * 0.5, Math.sin(angle) * 0.5, 2.5);
                    barrel.rotation.x = Math.PI / 2;
                    this.gunGroup.add(barrel);
                }
                this.gunGroup.position.set(0, 1.5, 0);
                this.turret.add(this.gunGroup);

                const treadGeometry = new THREE.BoxGeometry(3.5, 0.5, 5.5);
                const treadMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x222222, 
                    wireframe: true,
                    emissive: 0x111111
                });
                
                const treadLeft = new THREE.Mesh(treadGeometry, treadMaterial);
                treadLeft.position.set(-1.8, -0.5, 0);
                this.player.add(treadLeft);
                
                const treadRight = new THREE.Mesh(treadGeometry, treadMaterial);
                treadRight.position.set(1.8, -0.5, 0);
                this.player.add(treadRight);

                const shieldGeometry = new THREE.SphereGeometry(3, 8, 8);
                const shieldMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.3
                });
                this.shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
                this.shield.visible = false;
                this.player.add(this.shield);

                document.getElementById('vehicleName').textContent = 'TANK';
                document.getElementById('vehicleToggle').textContent = 'SWITCH TO DRONE';
            }

            createDrone() {
                while(this.player.children.length > 0) { 
                    this.player.remove(this.player.children[0]); 
                }
                
                const bodyGeometry = new THREE.BoxGeometry(1.5, 0.5, 1.5);
                const bodyMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x0000ff, 
                    wireframe: true,
                    emissive: 0x000044
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                this.player.add(body);
                
                const rotorGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 6);
                const rotorMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x0000ff, 
                    wireframe: true,
                    emissive: 0x000044
                });
                
                this.rotors = [];
                const positions = [[0.8,0.3,0.8], [-0.8,0.3,0.8], [0.8,0.3,-0.8], [-0.8,0.3,-0.8]];
                positions.forEach(pos => {
                    const rotor = new THREE.Mesh(rotorGeometry, rotorMaterial);
                    rotor.position.set(...pos);
                    this.player.add(rotor);
                    this.rotors.push(rotor);
                });
                
                this.gunGroup = new THREE.Group();
                const barrelGeometry = new THREE.CylinderGeometry(0.15, 0.15, 2, 6);
                const barrelMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x0000ff, 
                    wireframe: true,
                    emissive: 0x000044
                });
                for (let i = 0; i < 4; i++) {
                    const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
                    const angle = i * Math.PI * 2 / 4;
                    barrel.position.set(Math.cos(angle) * 0.3, Math.sin(angle) * 0.3, -1);
                    barrel.rotation.x = Math.PI / 2;
                    this.gunGroup.add(barrel);
                }
                this.gunGroup.position.set(0, -0.5, 0);
                this.player.add(this.gunGroup);

                document.getElementById('vehicleName').textContent = 'DRONE';
                document.getElementById('vehicleToggle').textContent = 'SWITCH TO TANK';
            }

            getPooledEnemy(type) {
                for (let enemy of this.enemyPool) {
                    if (!enemy.userData.active && enemy.userData.baseType === type) {
                        return enemy;
                    }
                }
                return this.createPooledEnemy(type);
            }

            releaseEnemy(enemy) {
                enemy.userData.active = false;
                enemy.visible = false;
                enemy.position.set(0, -100, 0);
            }

            setupControls() {
                this.controls = new PointerLockControls(this.camera, document.body);
                this.scene.add(this.controls.getObject());
                
                this.moveState = {
                    forward: false,
                    backward: false,
                    left: false,
                    right: false,
                    shift: false,
                    space: false,
                    down: false
                };

                this.mouseState = {
                    left: false,
                    right: false
                };

                this.attackCooldown = 0;
            }

            setupLighting() {
                const ambientLight = new THREE.AmbientLight(0x404040);
                this.scene.add(ambientLight);
                
                const redLight = new THREE.PointLight(0xff0000, 0.5, 100);
                redLight.position.set(0, 10, 0);
                this.scene.add(redLight);
                
                const towerLight = new THREE.PointLight(0x00ff00, 1, 50);
                towerLight.position.set(0, 40, 0);
                this.scene.add(towerLight);
            }

            setupParticles() {
                this.particleGeometry = new THREE.BufferGeometry();
                const particleCount = 100;
                const positions = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount * 3; i++) {
                    positions[i] = (Math.random() - 0.5) * 10;
                }
                
                this.particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                this.particleMaterial = new THREE.PointsMaterial({
                    color: 0xffff00,
                    size: 0.1,
                    transparent: true
                });
                
                this.particleSystem = new THREE.Points(this.particleGeometry, this.particleMaterial);
                this.particleSystem.visible = false;
                this.scene.add(this.particleSystem);
            }

            setupEventListeners() {
                document.addEventListener('click', () => {
                    if (!this.gameActive) {
                        if (document.getElementById('menu').style.display !== 'none') {
                            return;
                        } else if (document.getElementById('gameOver').style.display !== 'none') {
                            this.restartGame();
                        }
                        return;
                    }
                    
                    if (!this.controls.isLocked) {
                        this.controls.lock();
                    }
                });

                document.addEventListener('keydown', (event) => {
                    if (!this.gameActive) return;
                    
                    switch (event.code) {
                        case 'KeyW': this.moveState.forward = true; break;
                        case 'KeyA': this.moveState.left = true; break;
                        case 'KeyS': this.moveState.backward = true; break;
                        case 'KeyD': this.moveState.right = true; break;
                        case 'ShiftLeft': this.moveState.shift = true; break;
                        case 'Space': this.moveState.space = true; break;
                        case 'ControlLeft': this.moveState.down = true; break;
                        case 'KeyV': this.switchMode(); break;
                        case 'Escape': this.togglePause(); break;
                        case 'F11': 
                            event.preventDefault();
                            if (!document.fullscreenElement) {
                                document.documentElement.requestFullscreen();
                            } else {
                                document.exitFullscreen();
                            }
                            break;
                    }
                });

                document.addEventListener('keyup', (event) => {
                    if (!this.gameActive) return;
                    
                    switch (event.code) {
                        case 'KeyW': this.moveState.forward = false; break;
                        case 'KeyA': this.moveState.left = false; break;
                        case 'KeyS': this.moveState.backward = false; break;
                        case 'KeyD': this.moveState.right = false; break;
                        case 'ShiftLeft': this.moveState.shift = false; break;
                        case 'Space': this.moveState.space = false; break;
                        case 'ControlLeft': this.moveState.down = false; break;
                    }
                });

                document.addEventListener('mousedown', (event) => {
                    if (!this.gameActive || !this.controls.isLocked) return;
                    
                    if (event.button === 0) {
                        this.mouseState.left = true;
                    } else if (event.button === 2) {
                        this.mouseState.right = true;
                    }
                });

                document.addEventListener('mouseup', (event) => {
                    if (!this.gameActive || !this.controls.isLocked) return;
                    
                    if (event.button === 0) {
                        this.mouseState.left = false;
                    } else if (event.button === 2) {
                        this.mouseState.right = false;
                    }
                });

                document.getElementById('tankMode').addEventListener('click', () => {
                    this.mode = 'tank';
                    this.startGame();
                });

                document.getElementById('droneMode').addEventListener('click', () => {
                    this.mode = 'drone';
                    this.startGame();
                });

                document.getElementById('settingsButton').addEventListener('click', () => {
                    document.getElementById('settings').style.display = 'flex';
                });

                document.getElementById('closeSettings').addEventListener('click', () => {
                    document.getElementById('settings').style.display = 'none';
                });

                document.getElementById('invertY').addEventListener('change', (e) => {
                    this.invertY = e.target.checked;
                });

                document.getElementById('sensitivity').addEventListener('input', (e) => {
                    this.sensitivity = parseFloat(e.target.value);
                });

                document.getElementById('restartButton').addEventListener('click', () => {
                    this.restartGame();
                });

                document.getElementById('vehicleToggle').addEventListener('click', () => {
                    this.switchMode();
                });

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            switchMode() {
                const oldPos = this.player.position.clone();
                if (this.mode === 'tank') {
                    this.mode = 'drone';
                    this.createDrone();
                } else {
                    this.mode = 'tank';
                    this.createTank();
                }
                this.player.position.y = this.mode === 'tank' ? 1 : 20;
                this.playerVelocity.set(0, 0, 0);
                this.controls.getObject().position.copy(this.player.position);
            }

            startGame() {
                document.getElementById('menu').style.display = 'none';
                this.gameActive = true;
                this.controls.lock();
                this.startTime = Date.now();
                this.damageTaken = 0;
                this.damageDone = 0;
                this.createPlayer();
                this.controls.getObject().position.copy(this.player.position);
                this.startWave(1);
            }

            restartGame() {
                document.getElementById('gameOver').style.display = 'none';
                this.gameActive = true;
                
                this.health = 100;
                this.ammo = 100;
                this.towerHealth = 100;
                this.score = 0;
                this.wave = 1;
                this.enemiesKilled = 0;
                this.damageTaken = 0;
                this.damageDone = 0;
                
                this.activeEnemies.forEach(enemy => this.releaseEnemy(enemy));
                this.activeEnemies = [];
                
                this.activeProjectiles.forEach(proj => this.releaseProjectile(proj, false));
                this.activeProjectiles = [];
                
                this.activeEnemyProjectiles.forEach(proj => this.releaseProjectile(proj, true));
                this.activeEnemyProjectiles = [];
                
                this.createPlayer();
                this.controls.getObject().position.copy(this.player.position);
                
                this.startWave(1);
                
                this.controls.lock();
            }

            togglePause() {
                if (this.gameActive) {
                    this.controls.unlock();
                    document.getElementById('menu').style.display = 'flex';
                    this.gameActive = false;
                } else {
                    document.getElementById('menu').style.display = 'none';
                    this.gameActive = true;
                    this.controls.lock();
                }
            }

            fireWeapon() {
                if (this.shieldActive) return;
                if (this.mode === 'tank' && this.ammo <= 0) return;
                
                const proj = this.projectilePool.pop() || this.createPooledProjectile(false);
                const dir = new THREE.Vector3();
                this.camera.getWorldDirection(dir);
                proj.position.copy(this.camera.position);
                proj.userData = { velocity: dir.multiplyScalar(1), damage: this.mode === 'tank' ? 25 : 15, type: 'gatling', active: true };
                proj.visible = true;
                this.scene.add(proj);
                this.activeProjectiles.push(proj);
                
                if (this.mode === 'tank') {
                    this.ammo -= 1;
                    if (this.ammo < 0) this.ammo = 0;
                }
            }

            fireEnemyProjectile(enemy) {
                const proj = this.enemyProjectilePool.pop() || this.createPooledProjectile(true);
                const dir = new THREE.Vector3();
                if (enemy.userData.type === 'drone') {
                    dir.subVectors(this.tower.position, enemy.position).normalize();
                } else {
                    dir.subVectors(this.player.position, enemy.position).normalize();
                }
                proj.position.copy(enemy.position);
                proj.userData = { velocity: dir.multiplyScalar(0.03), damage: enemy.userData.damage, type: 'enemy', active: true };
                proj.visible = true;
                this.scene.add(proj);
                this.activeEnemyProjectiles.push(proj);
            }

            startWave(waveNumber) {
                this.wave = waveNumber;
                this.enemiesKilled = 0;
                
                this.enemiesInWave = 10;
                
                this.activeEnemies.forEach(enemy => this.releaseEnemy(enemy));
                this.activeEnemies = [];
                
                const isTankMode = this.mode === 'tank';
                for (let i = 0; i < this.enemiesInWave; i++) {
                    const type = isTankMode ? 'drone' : 'tank';
                    const enemyType = isTankMode ? (Math.random() < 0.2 ? 'bomber' : Math.random() < 0.4 ? 'assault' : 'scout') : 'tank';
                    const enemy = this.getPooledEnemy(type);
                    
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 100 + Math.random() * 50;
                    enemy.position.set(Math.cos(angle) * distance, isTankMode ? 10 + Math.random() * 20 : 1, Math.sin(angle) * distance);
                    
                    const data = enemy.userData;
                    data.health = isTankMode ? (enemyType === 'bomber' ? 80 : enemyType === 'assault' ? 40 : 20) : 200;
                    data.maxHealth = data.health;
                    data.speed = isTankMode ? (enemyType === 'bomber' ? 0.02 : enemyType === 'assault' ? 0.04 : 0.05) : 0.02;
                    data.damage = isTankMode ? (enemyType === 'bomber' ? 15 : enemyType === 'assault' ? 7 : 3) : 10;
                    data.lastAttack = 0;
                    data.attackCooldown = isTankMode ? 2 : 1;
                    data.subType = enemyType;
                    data.active = true;
                    enemy.visible = true;
                    this.scene.add(enemy);
                    this.activeEnemies.push(enemy);
                }
                
                document.getElementById('waveNumber').textContent = waveNumber;
                document.getElementById('enemiesLeft').textContent = this.enemiesInWave;
            }

            updateSpatialGrid() {
                this.spatialGrid.clear();
                for (const enemy of this.activeEnemies) {
                    const cellX = Math.floor((enemy.position.x + 200) / this.gridSize);
                    const cellZ = Math.floor((enemy.position.z + 200) / this.gridSize);
                    const cellId = cellX + ',' + cellZ;
                    if (!this.spatialGrid.has(cellId)) this.spatialGrid.set(cellId, []);
                    this.spatialGrid.get(cellId).push(enemy);
                }
            }

            updateEnemies(deltaTime) {
                const now = Date.now() / 1000;
                const attackDistance = 20;
                
                for (let i = this.activeEnemies.length - 1; i >= 0; i--) {
                    const enemy = this.activeEnemies[i];
                    const data = enemy.userData;
                    
                    if (data.type === 'drone') {
                        const gx = Math.floor((enemy.position.x + 200) / this.gridSize);
                        const gz = Math.floor((enemy.position.z + 200) / this.gridSize);
                        if (gx < 0 || gx >= this.cellsX || gz < 0 || gz >= this.cellsZ) continue;
                        const fIdx = (gx + gz * this.cellsX) * 3;
                        const dir = new THREE.Vector3(this.flowField[fIdx], 0, this.flowField[fIdx + 2]).normalize();
                        enemy.position.addScaledVector(dir, data.speed);
                    } else {
                        const dir = new THREE.Vector3();
                        dir.subVectors(this.player.position, enemy.position).normalize();
                        enemy.position.addScaledVector(dir, data.speed);
                    }
                    
                    if (data.type === 'drone') {
                        for (let j = 1; j <= 4; j++) {
                            enemy.children[j].rotation.y += 1;
                        }
                    }
                    
                    if (data.type === 'drone' && this.checkCollision(enemy, this.tower, attackDistance) && now - data.lastAttack > data.attackCooldown) {
                        this.towerHealth -= data.damage;
                        data.lastAttack = now;
                        if (this.towerHealth <= 0) {
                            this.towerHealth = 0;
                            this.gameOverScreen();
                        }
                    }
                    
                    if (data.subType !== 'scout' && now - data.lastAttack > data.attackCooldown) {
                        this.fireEnemyProjectile(enemy);
                        data.lastAttack = now;
                    }
                }
            }

            updateProjectiles(deltaTime) {
                this.updateSpatialGrid();
                
                const maxDistSq = 40000;
                
                for (let i = this.activeProjectiles.length - 1; i >= 0; i--) {
                    const proj = this.activeProjectiles[i];
                    const data = proj.userData;
                    proj.position.add(data.velocity);
                    
                    const cellX = Math.floor((proj.position.x + 200) / this.gridSize);
                    const cellZ = Math.floor((proj.position.z + 200) / this.gridSize);
                    
                    let hit = false;
                    for (let dx = -1; dx <= 1; dx++) for (let dz = -1; dz <= 1; dz++) {
                        const checkX = cellX + dx;
                        const checkZ = cellZ + dz;
                        if (checkX < 0 || checkX >= this.cellsX || checkZ < 0 || checkZ >= this.cellsZ) continue;
                        const cellId = checkX + ',' + checkZ;
                        const cellEnemies = this.spatialGrid.get(cellId);
                        if (!cellEnemies) continue;
                        
                        for (const enemy of cellEnemies) {
                            if (this.checkCollision(proj, enemy, 2)) {
                                const dmg = data.damage;
                                enemy.userData.health -= dmg;
                                this.damageDone += dmg;
                                hit = true;
                                if (enemy.userData.health <= 0) this.killEnemy(enemy);
                                break;
                            }
                        }
                        if (hit) break;
                    }
                    
                    if (hit || proj.position.lengthSq() > maxDistSq) {
                        this.releaseProjectile(proj, false);
                        this.activeProjectiles.splice(i, 1);
                    }
                }
                
                for (let i = this.activeEnemyProjectiles.length - 1; i >= 0; i--) {
                    const proj = this.activeEnemyProjectiles[i];
                    const data = proj.userData;
                    proj.position.add(data.velocity);
                    
                    if (this.checkCollision(proj, this.player, 2)) {
                        let dmg = data.damage;
                        if (this.shieldActive) dmg *= 0.5;
                        this.damageTaken += dmg;
                        this.releaseProjectile(proj, true);
                        this.activeEnemyProjectiles.splice(i, 1);
                    } else if (this.checkCollision(proj, this.tower, 5)) {
                        this.towerHealth -= data.damage;
                        this.releaseProjectile(proj, true);
                        this.activeEnemyProjectiles.splice(i, 1);
                        
                        if (this.towerHealth <= 0) {
                            this.towerHealth = 0;
                            this.gameOverScreen();
                        }
                    } else if (proj.position.lengthSq() > maxDistSq) {
                        this.releaseProjectile(proj, true);
                        this.activeEnemyProjectiles.splice(i, 1);
                    }
                }
            }

            updatePlayer(deltaTime) {
                if (!this.controls.isLocked || !this.gameActive) return;

                if (this.mode === 'tank' && this.ammo < 100) {
                    this.ammo += 5 * deltaTime;
                    if (this.ammo > 100) this.ammo = 100;
                }

                if (this.attackCooldown > 0) {
                    this.attackCooldown -= deltaTime;
                }

                if (this.mouseState.left && this.attackCooldown <= 0) {
                    this.fireWeapon();
                    this.attackCooldown = this.mode === 'tank' ? 0.5 : 0.1;
                }

                if (this.mode === 'tank' && this.moveState.space) {
                    this.shieldActive = true;
                    this.shield.visible = true;
                } else {
                    this.shieldActive = false;
                    if (this.shield) this.shield.visible = false;
                }

                const speed = this.moveState.shift ? 15 : 8;
                const moveVector = new THREE.Vector3();

                if (this.moveState.forward) moveVector.z = 1;   // W = forward (positive Z)
                if (this.moveState.backward) moveVector.z = -1; // S = backward (negative Z)
                if (this.moveState.left) moveVector.x = -1;
                if (this.moveState.right) moveVector.x = 1;

                moveVector.normalize();
                moveVector.multiplyScalar(speed * deltaTime);

                const cameraDirection = new THREE.Vector3();
                this.camera.getWorldDirection(cameraDirection);
                
                if (this.mode === 'tank') {
                    cameraDirection.y = 0;
                    cameraDirection.normalize();

                    const rightVector = new THREE.Vector3();
                    rightVector.crossVectors(cameraDirection, new THREE.Vector3(0, 1, 0));

                    const moveX = rightVector.multiplyScalar(moveVector.x);
                    const moveZ = cameraDirection.multiplyScalar(moveVector.z);
                    const totalMove = moveX.add(moveZ);

                    if (this.player.position.y > 1) {
                        this.playerVelocity.y -= 20 * deltaTime;
                    } else {
                        this.player.position.y = 1;
                        this.playerVelocity.y = 0;
                    }

                    totalMove.y = this.playerVelocity.y * deltaTime;
                    const newPosition = this.player.position.clone().add(totalMove);

                    if (newPosition.x > -190 && newPosition.x < 190 && 
                        newPosition.z > -190 && newPosition.z < 190) {
                        this.player.position.copy(newPosition);
                        this.controls.getObject().position.copy(newPosition);
                    }
                } else {
                    const rightVector = new THREE.Vector3();
                    rightVector.crossVectors(cameraDirection, new THREE.Vector3(0, 1, 0));

                    const moveX = rightVector.multiplyScalar(moveVector.x);
                    const moveZ = cameraDirection.multiplyScalar(moveVector.z);
                    let totalMove = moveX.add(moveZ);

                    if (this.moveState.space) {
                        totalMove.y = 5 * deltaTime;
                    } else if (this.moveState.down) {
                        totalMove.y = -5 * deltaTime;
                    } else {
                        totalMove.y = 0;
                    }

                    const newPosition = this.player.position.clone().add(totalMove);
                    if (newPosition.y > 50) newPosition.y = 50;
                    if (newPosition.y < 10) newPosition.y = 10;

                    if (newPosition.x > -190 && newPosition.x < 190 && 
                        newPosition.z > -190 && newPosition.z < 190) {
                        this.player.position.copy(newPosition);
                        this.controls.getObject().position.copy(newPosition);
                    }
                }

                if (this.mode === 'drone') {
                    this.rotors.forEach(r => r.rotation.y += 1);
                }

                if (this.mouseState.right) {
                    this.camera.fov = 75 / 4;
                } else {
                    this.camera.fov = 75;
                }
                this.camera.updateProjectionMatrix();

                document.getElementById('healthValue').textContent = Math.round(this.health);
                document.getElementById('healthFill').style.width = `${this.health}%`;
                document.getElementById('ammoValue').textContent = this.mode === 'drone' ? 'âˆž' : Math.round(this.ammo);
                document.getElementById('ammoFill').style.width = this.mode === 'drone' ? '100%' : `${this.ammo}%`;
                document.getElementById('towerHealthValue').textContent = Math.round(this.towerHealth);
                document.getElementById('towerHealthFill').style.width = `${this.towerHealth}%`;
                document.getElementById('scoreValue').textContent = this.score;
                document.getElementById('enemiesLeft').textContent = this.enemiesInWave - this.enemiesKilled;
                document.getElementById('ammoDisplay').textContent = this.mode === 'drone' ? 'âˆž' : (this.ammo === 100 ? 'âˆž' : Math.round(this.ammo));
                document.getElementById('timeValue').textContent = Math.round((Date.now() - this.startTime) / 1000);
            }

            checkCollision(obj1, obj2, threshold) {
                return obj1.position.distanceTo(obj2.position) < threshold;
            }

            releaseProjectile(proj, isEnemy) {
                proj.userData.active = false;
                proj.visible = false;
                proj.position.set(0, -100, 0);
                if (isEnemy) {
                    this.enemyProjectilePool.push(proj);
                } else {
                    this.projectilePool.push(proj);
                }
            }

            createExplosion(position) {
                const particles = new THREE.Points(
                    this.particleGeometry,
                    this.particleMaterial
                );
                particles.position.copy(position);
                particles.visible = true;
                this.scene.add(particles);
                
                setTimeout(() => {
                    this.scene.remove(particles);
                }, 500);
            }

            killEnemy(enemy) {
                this.createExplosion(enemy.position);
                
                this.releaseEnemy(enemy);
                this.enemiesKilled++;
                this.score += 100;
                
                if (this.enemiesKilled >= this.enemiesInWave) {
                    setTimeout(() => {
                        this.gameWinScreen();
                    }, 2000);
                }
            }

            gameOverScreen() {
                this.gameActive = false;
                this.controls.unlock();
                
                document.getElementById('gameOver').style.display = 'flex';
                document.getElementById('finalScoreValue').textContent = this.score;
                document.getElementById('enemiesClearedValue').textContent = this.enemiesKilled;
                document.getElementById('timeTakenValue').textContent = Math.round((Date.now() - this.startTime) / 1000);
                document.getElementById('damageTakenValue').textContent = Math.round(this.damageTaken);
                document.getElementById('damageDoneValue').textContent = Math.round(this.damageDone);
            }

            gameWinScreen() {
                this.gameActive = false;
                this.controls.unlock();
                
                document.getElementById('gameOver').style.display = 'flex';
                document.getElementById('gameOverTitle').textContent = 'MISSION COMPLETE';
                document.getElementById('finalScoreValue').textContent = this.score;
                document.getElementById('enemiesClearedValue').textContent = this.enemiesKilled;
                document.getElementById('timeTakenValue').textContent = Math.round((Date.now() - this.startTime) / 1000);
                document.getElementById('damageTakenValue').textContent = Math.round(this.damageTaken);
                document.getElementById('damageDoneValue').textContent = Math.round(this.damageDone);
            }

            animate() {
                const deltaTime = Math.min(0.016, this.clock ? this.clock.getDelta() : 0.016);
                
                if (!this.clock) this.clock = new THREE.Clock();
                
                if (this.gameActive && !this.gameOver) {
                    this.updatePlayer(deltaTime);
                    this.updateEnemies(deltaTime);
                    this.updateProjectiles(deltaTime);
                }
                
                this.renderer.render(this.scene, this.camera);
                requestAnimationFrame(() => this.animate());
            }
        }

        window.addEventListener('load', () => {
            new Game();
        });
    </script>
</body>
</html>
