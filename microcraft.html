<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>MICROCRAFT BETA TEST: webXOS 2026</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            overflow: hidden;
            background: #000;
            color: #00ff00;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }

        /* Loading screen */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            background: radial-gradient(circle at center, #002200 0%, #000 70%);
        }

        .loading-container {
            text-align: center;
            animation: pulse 2s infinite;
        }

        .loading-title {
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 64px;
            font-weight: 900;
            text-shadow: 
                0 0 10px #00ff00,
                0 0 20px #00ff00,
                0 0 30px #00ff00,
                3px 3px 0 #000,
                6px 6px 0 rgba(0, 255, 0, 0.5);
            margin-bottom: 30px;
            letter-spacing: 4px;
            background: linear-gradient(to bottom, #00ff00 0%, #00aa00 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(0 0 8px rgba(0, 255, 0, 0.5));
        }

        .loading-subtitle {
            color: #00cc00;
            font-size: 18px;
            margin-bottom: 30px;
            letter-spacing: 2px;
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
        }

        #loading-bar {
            width: 400px;
            height: 6px;
            background: rgba(0, 255, 0, 0.1);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 20px;
            border: 1px solid rgba(0, 255, 0, 0.3);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.2);
        }

        #loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #00aa00 0%, #00ff00 50%, #00aa00 100%);
            width: 0%;
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
        }

        .loading-percent {
            color: #00ff00;
            font-size: 14px;
            margin-top: 10px;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        @keyframes glow {
            0%, 100% { text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00, 0 0 30px #00ff00; }
            50% { text-shadow: 0 0 15px #00ff00, 0 0 25px #00ff00, 0 0 35px #00ff00; }
        }

        .loading-title {
            animation: glow 2s infinite;
        }

        /* Unified Left Panel */
        #main-panel {
            position: absolute;
            top: 20px;
            left: 10px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            z-index: 90;
            width: 140px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            padding-right: 2px;
        }

        .panel-section {
            background: rgba(0, 20, 0, 0.8);
            border: 1px solid rgba(0, 255, 0, 0.3);
            border-radius: 4px;
            padding: 6px;
            margin-bottom: 8px;
            backdrop-filter: blur(5px);
            flex-shrink: 0;
        }

        .section-title {
            color: #00cc00;
            font-size: 10px;
            margin-bottom: 5px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.8;
        }

        .action-button {
            background: rgba(0, 20, 0, 0.8);
            color: #00ff00;
            border: 1px solid rgba(0, 255, 0, 0.3);
            padding: 5px 8px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 10px;
            font-family: 'Courier New', monospace;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
            white-space: nowrap;
            width: 100%;
            text-align: left;
            margin: 2px 0;
            min-height: 28px;
        }

        .action-button:hover {
            background: rgba(0, 40, 0, 0.9);
            border-color: rgba(0, 255, 0, 0.6);
            transform: translateX(2px);
        }

        .action-button:active {
            background: rgba(0, 60, 0, 0.9);
            transform: translateX(0);
        }

        .action-button.active {
            background: rgba(0, 255, 0, 0.2);
            border-color: #00ff00;
            box-shadow: 0 0 8px rgba(0, 255, 0, 0.3);
        }

        .action-button.placement-mode-active {
            background: rgba(255, 255, 0, 0.2) !important;
            border-color: #ffff00 !important;
            box-shadow: 0 0 10px rgba(255, 255, 0, 0.5) !important;
        }

        .button-icon {
            font-size: 12px;
            min-width: 14px;
            text-align: center;
        }

        /* Enhanced Bottom Toolbar */
        #toolbar {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 90;
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 16px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(0, 255, 0, 0.3);
            align-items: center;
        }

        .tool-group {
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-width: auto;
        }

        .tool-group-title {
            color: #00cc00;
            font-size: 9px;
            text-align: center;
            margin-bottom: 2px;
            opacity: 0.7;
            white-space: nowrap;
        }

        .tool-row {
            display: flex;
            gap: 2px;
        }

        .tool-button {
            width: 36px;
            height: 36px;
            border: 1px solid rgba(0, 255, 0, 0.3);
            border-radius: 3px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            background: rgba(0, 20, 0, 0.6);
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .tool-button:hover {
            background: rgba(0, 40, 0, 0.8);
            border-color: rgba(0, 255, 0, 0.6);
            transform: scale(1.1);
        }

        .tool-button.active {
            background: rgba(0, 255, 0, 0.3);
            border-color: #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        /* Editor tools button group */
        .editor-tools-group {
            display: flex;
            flex-direction: column;
            gap: 2px;
            margin-left: 10px;
            padding-left: 10px;
            border-left: 1px solid rgba(0, 255, 0, 0.2);
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border: 1px solid rgba(0, 255, 0, 0.4);
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            z-index: 100;
            backdrop-filter: blur(5px);
            pointer-events: none;
        }

        .hud-item {
            margin: 3px 0;
            display: flex;
            justify-content: space-between;
            min-width: 120px;
        }

        .hud-label {
            color: #00cc00;
            margin-right: 10px;
        }

        .hud-value {
            color: #00ff00;
        }

        /* Jetpack status in HUD */
        .hud-jetpack {
            color: #00aaff;
            font-weight: bold;
        }

        /* Selected object display */
        #selected-object-display {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 6px 10px;
            border: 1px solid rgba(0, 255, 0, 0.4);
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            z-index: 100;
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            gap: 8px;
            opacity: 0.8;
            pointer-events: none;
            white-space: nowrap;
        }

        #object-icon {
            font-size: 16px;
        }

        #object-name {
            font-size: 11px;
            color: #00ff00;
        }

        /* Crosshairs */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 16px;
            height: 16px;
            pointer-events: none;
            z-index: 10;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(0, 255, 0, 0.7);
        }

        #crosshair::before {
            left: 50%;
            top: 0;
            width: 1px;
            height: 100%;
            transform: translateX(-50%);
        }

        #crosshair::after {
            top: 50%;
            left: 0;
            width: 100%;
            height: 1px;
            transform: translateY(-50%);
        }

        /* Editor Crosshair */
        #editor-crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            pointer-events: none;
            z-index: 11;
            display: none;
        }

        #editor-crosshair::before,
        #editor-crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 0, 0.8);
            border: 1px solid rgba(255, 255, 0, 0.5);
        }

        #editor-crosshair::before {
            left: 50%;
            top: 0;
            width: 2px;
            height: 100%;
            transform: translateX(-50%);
        }

        #editor-crosshair::after {
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            transform: translateY(-50%);
        }

        #editor-crosshair .center-dot {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: #ffff00;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(255, 255, 0, 0.8);
        }

        /* Version tag */
        #version {
            position: absolute;
            top: 10px;
            left: 10px;
            color: rgba(0, 255, 0, 0.3);
            font-size: 10px;
            z-index: 100;
            pointer-events: none;
        }

        /* Welcome text */
        #welcome {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Courier New', monospace;
            font-size: 48px;
            font-weight: bold;
            color: #00ff00;
            text-shadow: 3px 3px 0 #000, 6px 6px 0 rgba(0, 255, 0, 0.5);
            pointer-events: none;
            z-index: 1000;
            animation: fadeOut 3s forwards;
            animation-delay: 2s;
            letter-spacing: 2px;
        }

        @keyframes fadeOut {
            to { opacity: 0; }
        }

        /* Color Wheel - MOVED TO BOTTOM TOOLBAR */
        #color-picker-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            margin-left: 10px;
            padding-left: 10px;
            border-left: 1px solid rgba(0, 255, 0, 0.2);
        }

        #color-picker {
            width: 30px;
            height: 30px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            cursor: pointer;
            background: #00ff00;
        }

        #color-picker-label {
            color: #00ff00;
            font-size: 10px;
            white-space: nowrap;
        }

        /* Object Library Panels */
        .library-panel {
            position: absolute;
            top: 20px;
            left: 160px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(0, 255, 0, 0.5);
            border-radius: 6px;
            padding: 8px;
            display: none;
            max-height: 80vh;
            overflow-y: auto;
            width: 200px;
            z-index: 101;
            backdrop-filter: blur(5px);
        }

        .library-section {
            margin-bottom: 10px;
        }

        .library-section-title {
            color: #00cc00;
            font-size: 11px;
            margin-bottom: 5px;
            padding-bottom: 3px;
            border-bottom: 1px solid rgba(0, 255, 0, 0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .object-button {
            width: 100%;
            padding: 5px 8px;
            margin: 3px 0;
            background: rgba(0, 20, 0, 0.6);
            color: #00ff00;
            border: 1px solid rgba(0, 255, 0, 0.3);
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            font-family: 'Courier New', monospace;
            text-align: left;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
        }

        .object-button:hover {
            background: rgba(0, 40, 0, 0.8);
            border-color: rgba(0, 255, 0, 0.4);
            transform: translateX(2px);
        }

        .object-button:active {
            background: rgba(0, 60, 0, 0.8);
        }

        .object-icon {
            font-size: 14px;
            min-width: 16px;
            text-align: center;
        }

        /* Editor Gizmo */
        #editor-gizmo {
            position: absolute;
            pointer-events: none;
            display: none;
            z-index: 1000;
        }

        .gizmo-axis {
            position: absolute;
            width: 100px;
            height: 2px;
            transform-origin: 0 0;
        }

        .gizmo-axis-x {
            background: linear-gradient(to right, rgba(255, 0, 0, 0.8), rgba(255, 0, 0, 0.3));
            box-shadow: 0 0 5px rgba(255, 0, 0, 0.5);
        }

        .gizmo-axis-y {
            background: linear-gradient(to right, rgba(0, 255, 0, 0.8), rgba(0, 255, 0, 0.3));
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
        }

        .gizmo-axis-z {
            background: linear-gradient(to right, rgba(0, 0, 255, 0.8), rgba(0, 0, 255, 0.3));
            box-shadow: 0 0 5px rgba(0, 0, 255, 0.5);
        }

        .gizmo-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            cursor: pointer;
            transform: translate(-50%, -50%);
            pointer-events: all;
        }

        .gizmo-handle-x {
            background: radial-gradient(circle, rgba(255, 0, 0, 1), rgba(255, 0, 0, 0.5));
            left: 100px;
        }

        .gizmo-handle-y {
            background: radial-gradient(circle, rgba(0, 255, 0, 1), rgba(0, 255, 0, 0.5));
            top: 100px;
        }

        .gizmo-handle-z {
            background: radial-gradient(circle, rgba(0, 0, 255, 1), rgba(0, 0, 255, 0.5));
            transform: translate(-50%, -50%) rotate(45deg);
        }

        /* Editor Controls */
        #editor-controls {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(0, 255, 0, 0.5);
            border-radius: 6px;
            padding: 10px;
            display: none;
            gap: 8px;
            z-index: 1001;
            backdrop-filter: blur(5px);
        }

        .editor-control-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .editor-label {
            color: #00ff00;
            font-size: 11px;
            min-width: 60px;
        }

        .editor-input {
            width: 60px;
            padding: 3px 5px;
            background: rgba(0, 20, 0, 0.8);
            border: 1px solid rgba(0, 255, 0, 0.4);
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            border-radius: 3px;
        }

        .editor-button {
            padding: 4px 8px;
            background: rgba(0, 40, 0, 0.8);
            border: 1px solid rgba(0, 255, 0, 0.3);
            color: #00ff00;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            font-family: 'Courier New', monospace;
        }

        .editor-button:hover {
            background: rgba(0, 60, 0, 0.8);
        }

        /* CLI - BOTTOM LEFT CORNER */
        #cli-toggle {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 20, 0, 0.9);
            color: #00ff00;
            border: 1px solid rgba(0, 255, 0, 0.4);
            padding: 4px 8px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 11px;
            z-index: 100;
            backdrop-filter: blur(5px);
            white-space: nowrap;
        }

        #cli-toggle:hover {
            background: rgba(0, 40, 0, 0.9);
            border-color: rgba(0, 255, 0, 0.6);
        }

        #cli-container {
            position: absolute;
            bottom: 40px;
            left: 10px;
            width: 300px;
            background: rgba(0, 10, 0, 0.95);
            border: 1px solid rgba(0, 255, 0, 0.5);
            border-radius: 4px;
            padding: 8px;
            display: none;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        #cli-output {
            height: 150px;
            overflow-y: auto;
            margin-bottom: 8px;
            padding: 5px;
            background: rgba(0, 5, 0, 0.8);
            border: 1px solid rgba(0, 127, 0, 0.3);
            border-radius: 2px;
            font-size: 11px;
        }

        .cli-line {
            margin-bottom: 3px;
            white-space: pre-wrap;
            line-height: 1.2;
        }

        .cli-command {
            color: #00ff00;
        }

        .cli-response {
            color: #00cc00;
        }

        .cli-error {
            color: #ff3333;
        }

        .cli-success {
            color: #33ff33;
        }

        .cli-warning {
            color: #ffff33;
        }

        .cli-info {
            color: #00aaff;
        }

        #cli-input {
            width: 100%;
            padding: 4px 6px;
            background: rgba(0, 20, 0, 0.8);
            border: 1px solid rgba(0, 255, 0, 0.5);
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            border-radius: 2px;
        }

        #cli-input:focus {
            outline: none;
            border-color: #00ff00;
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
        }

        /* HELP PANEL */
        #help-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid rgba(0, 255, 0, 0.6);
            border-radius: 8px;
            padding: 15px;
            display: none;
            width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1001;
            backdrop-filter: blur(10px);
        }

        .help-title {
            color: #00ff00;
            font-size: 18px;
            margin-bottom: 15px;
            text-align: center;
            border-bottom: 1px solid rgba(0, 255, 0, 0.4);
            padding-bottom: 8px;
        }

        .help-section {
            margin-bottom: 15px;
        }

        .help-section-title {
            color: #00cc00;
            font-size: 14px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .help-list {
            list-style: none;
            padding-left: 20px;
        }

        .help-item {
            margin: 4px 0;
            font-size: 12px;
            color: #00ff00;
        }

        .help-key {
            display: inline-block;
            background: rgba(0, 255, 0, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
            margin: 0 2px;
            border: 1px solid rgba(0, 255, 0, 0.4);
        }

        #close-help {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: #00ff00;
            cursor: pointer;
            font-size: 16px;
        }

        #close-help:hover {
            color: #00cc00;
        }

        /* Torch Glow Effect */
        .torch-glow {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 165, 0, 0.6) 0%, rgba(255, 69, 0, 0.2) 50%, transparent 70%);
            pointer-events: none;
            z-index: 5;
            filter: blur(8px);
        }

        /* Scrollbar styling */
        .library-panel::-webkit-scrollbar,
        #cli-output::-webkit-scrollbar,
        #help-panel::-webkit-scrollbar {
            width: 6px;
        }

        .library-panel::-webkit-scrollbar-track,
        #cli-output::-webkit-scrollbar-track,
        #help-panel::-webkit-scrollbar-track {
            background: rgba(0, 20, 0, 0.3);
        }

        .library-panel::-webkit-scrollbar-thumb,
        #cli-output::-webkit-scrollbar-thumb,
        #help-panel::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 0, 0.3);
            border-radius: 3px;
        }

        .library-panel::-webkit-scrollbar-thumb:hover,
        #cli-output::-webkit-scrollbar-thumb:hover,
        #help-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 255, 0, 0.5);
        }

        /* Status notification */
        .status-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(0, 255, 0, 0.6);
            border-radius: 6px;
            padding: 12px 20px;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            z-index: 1002;
            display: none;
            backdrop-filter: blur(10px);
            animation: fadeInOut 2s ease-in-out;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            20%, 80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        /* Ghost object info */
        #ghost-object-info {
            position: absolute;
            bottom: 130px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(0, 255, 0, 0.6);
            border-radius: 4px;
            padding: 6px 10px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: #00ff00;
            z-index: 99;
            backdrop-filter: blur(5px);
            display: none;
            white-space: nowrap;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
        }

        /* Jetpack effect */
        .jetpack-effect {
            position: absolute;
            width: 20px;
            height: 40px;
            background: radial-gradient(circle at center, rgba(0, 200, 255, 0.8) 0%, rgba(0, 100, 255, 0.3) 50%, transparent 70%);
            pointer-events: none;
            z-index: 5;
            filter: blur(5px);
            transform: translate(-50%, 0);
            display: none;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="loading-container">
            <div class="loading-title">MICROCRAFT</div>
            <div class="loading-subtitle">BETA TEST by webXOS</div>
            <div id="loading-bar">
                <div id="loading-progress"></div>
            </div>
            <div class="loading-percent" id="loading-percent">0%</div>
        </div>
    </div>
    
    <div id="container"></div>
    
    <!-- Status notification -->
    <div id="status-notification" class="status-notification"></div>
    
    <!-- Welcome text -->
    <div id="welcome">MICROCRAFT BETA</div>
    
    <!-- Ghost object info -->
    <div id="ghost-object-info">
        <span id="ghost-icon">üëª</span>
        <span id="ghost-name">Preview: Castle Wall</span>
        <span id="ghost-instruction"> (Click to place)</span>
    </div>

    <!-- Jetpack effect -->
    <div id="jetpack-effect" class="jetpack-effect"></div>
    
    <!-- Minimal HUD -->
    <div id="hud">
        <div class="hud-item">
            <span class="hud-label">POS</span>
            <span class="hud-value" id="pos-display">0,0,0</span>
        </div>
        <div class="hud-item">
            <span class="hud-label">BLOCKS</span>
            <span class="hud-value" id="block-count">0</span>
        </div>
        <div class="hud-item">
            <span class="hud-label">MODE</span>
            <span class="hud-value" id="mode-display">BUILD</span>
        </div>
        <div class="hud-item">
            <span class="hud-label">FPS</span>
            <span class="hud-value" id="fps">60</span>
        </div>
        <div class="hud-item">
            <span class="hud-label">JETPACK</span>
            <span class="hud-value hud-jetpack" id="jetpack-status">OFF</span>
        </div>
    </div>

    <!-- Selected object display -->
    <div id="selected-object-display">
        <span id="object-icon">ü™®</span>
        <span id="object-name">Stone</span>
    </div>

    <!-- Crosshairs -->
    <div id="crosshair"></div>
    <div id="editor-crosshair">
        <div class="center-dot"></div>
    </div>

    <!-- Reorganized Left Panel -->
    <div id="main-panel">
        <!-- ACTION SECTION -->
        <div class="panel-section">
            <div class="section-title">Actions</div>
            <button class="action-button" onclick="undoAction()">
                <span class="button-icon">‚Ü∂</span> UNDO
            </button>
            <button class="action-button" onclick="clearWorld()">
                <span class="button-icon">üóëÔ∏è</span> CLEAR
            </button>
            <button class="action-button" onclick="createNewIsland()">
                <span class="button-icon">üèùÔ∏è</span> NEW ISLAND
            </button>
            <button class="action-button" onclick="teleportToSpawn()">
                <span class="button-icon">üè†</span> SPAWN
            </button>
        </div>

        <!-- MODE SECTION -->
        <div class="panel-section">
            <div class="section-title">Mode</div>
            <button class="action-button" onclick="toggleMode('build')" id="build-mode">
                <span class="button-icon">üß±</span> BUILD
            </button>
            <button class="action-button" onclick="toggleMode('edit')" id="edit-mode">
                <span class="button-icon">‚úèÔ∏è</span> EDIT
            </button>
            <button class="action-button" onclick="toggleMode('torch')" id="torch-mode">
                <span class="button-icon">üî•</span> TORCH
            </button>
        </div>

        <!-- LIBRARY SECTION -->
        <div class="panel-section">
            <div class="section-title">Templates</div>
            <button class="action-button" onclick="toggleLibrary('buildings')">
                <span class="button-icon">üèóÔ∏è</span> BUILDINGS
            </button>
            <button class="action-button" onclick="toggleLibrary('interior')">
                <span class="button-icon">üõãÔ∏è</span> INTERIOR
            </button>
        </div>

        <!-- SETTINGS SECTION -->
        <div class="panel-section">
            <div class="section-title">Settings</div>
            <button class="action-button" onclick="toggleLightingMode()" id="lighting-toggle">
                <span class="button-icon">‚òÄÔ∏è</span> DAY
            </button>
            <button class="action-button" onclick="saveWorld('quick_save')">
                <span class="button-icon">üíæ</span> SAVE
            </button>
            <button class="action-button" onclick="loadWorld('quick_save')">
                <span class="button-icon">üìÇ</span> LOAD
            </button>
            <button class="action-button" onclick="toggleJetpack()" id="jetpack-toggle">
                <span class="button-icon">üöÄ</span> JETPACK
            </button>
        </div>

        <!-- HELP SECTION -->
        <div class="panel-section">
            <div class="section-title">Help</div>
            <button class="action-button" onclick="toggleCLI()">
                <span class="button-icon">~</span> CONSOLE
            </button>
            <button class="action-button" onclick="showHelp()">
                <span class="button-icon">‚ùì</span> HELP
            </button>
        </div>
    </div>

    <!-- Enhanced Bottom Toolbar with Single Voxel Blocks -->
    <div id="toolbar">
        <!-- SINGLE BLOCK SELECTION -->
        <div class="tool-group">
            <div class="tool-group-title">SINGLE BLOCKS</div>
            <div class="tool-row">
                <button class="tool-button active" onclick="selectBlock('sand')" data-block="sand" title="Sand (1)">üü®</button>
                <button class="tool-button" onclick="selectBlock('stone')" data-block="stone" title="Stone (2)">ü™®</button>
                <button class="tool-button" onclick="selectBlock('grass')" data-block="grass" title="Grass (3)">üåø</button>
            </div>
            <div class="tool-row">
                <button class="tool-button" onclick="selectBlock('wood')" data-block="wood" title="Wood (4)">ü™µ</button>
                <button class="tool-button" onclick="selectBlock('brick')" data-block="brick" title="Brick (5)">üß±</button>
                <button class="tool-button" onclick="selectBlock('wireframe')" data-block="wireframe" title="Wireframe (6)">üìê</button>
            </div>
        </div>

        <!-- Color Picker integrated into toolbar -->
        <div id="color-picker-container">
            <div id="color-picker-label">COLOR</div>
            <input type="color" id="color-picker" value="#00ff00">
        </div>

        <!-- EDIT TOOLS -->
        <div class="editor-tools-group">
            <div class="tool-group-title">EDIT TOOLS</div>
            <div class="tool-row">
                <button class="tool-button" onclick="selectGizmoMode('translate')" data-gizmo="translate" title="Move (Shift+T)">‚ÜîÔ∏è</button>
                <button class="tool-button" onclick="selectGizmoMode('scale')" data-gizmo="scale" title="Scale (Shift+S)">‚õ∂</button>
                <button class="tool-button" onclick="selectGizmoMode('rotate')" data-gizmo="rotate" title="Rotate (Shift+R)">üîÑ</button>
            </div>
            <div class="tool-row">
                <button class="tool-button" onclick="applyEditorChanges()" title="Apply Changes">‚úì</button>
                <button class="tool-button" onclick="resetEditorChanges()" title="Reset">‚Ü∫</button>
                <button class="tool-button" onclick="exitEditMode()" title="Exit Edit">‚úï</button>
            </div>
        </div>
    </div>

    <!-- Library Panels -->
    <div id="library-buildings" class="library-panel">
        <div class="library-section">
            <div class="library-section-title">üè∞ STONE BUILDINGS</div>
            <button class="object-button" onclick="selectBuildingForPreview('stone_castle_tower')">
                <span class="object-icon">üè∞</span> Stone Castle Tower
            </button>
            <button class="object-button" onclick="selectBuildingForPreview('stone_watchtower')">
                <span class="object-icon">üóº</span> Stone Watchtower
            </button>
            <button class="object-button" onclick="selectBuildingForPreview('stone_keep')">
                <span class="object-icon">üèØ</span> Stone Keep
            </button>
            <button class="object-button" onclick="selectBuildingForPreview('stone_wall')">
                <span class="object-icon">üß±</span> Stone Wall
            </button>
        </div>
        
        <div class="library-section">
            <div class="library-section-title">üèöÔ∏è WOOD BUILDINGS</div>
            <button class="object-button" onclick="selectBuildingForPreview('wood_castle_tower')">
                <span class="object-icon">üèöÔ∏è</span> Wood Castle Tower
            </button>
            <button class="object-button" onclick="selectBuildingForPreview('wood_watchtower')">
                <span class="object-icon">ü™µ</span> Wood Watchtower
            </button>
            <button class="object-button" onclick="selectBuildingForPreview('wood_keep')">
                <span class="object-icon">üõñ</span> Wood Keep
            </button>
            <button class="object-button" onclick="selectBuildingForPreview('wood_wall')">
                <span class="object-icon">ü™µ</span> Wood Wall
            </button>
        </div>
    </div>

    <div id="library-interior" class="library-panel">
        <div class="library-section">
            <div class="library-section-title">ü™ë FURNITURE</div>
            <button class="object-button" onclick="selectInteriorForPreview('chair')">
                <span class="object-icon">ü™ë</span> Chair
            </button>
            <button class="object-button" onclick="selectInteriorForPreview('table')">
                <span class="object-icon">ü™ü</span> Table
            </button>
            <button class="object-button" onclick="selectInteriorForPreview('throne')">
                <span class="object-icon">üëë</span> Throne
            </button>
        </div>
        
        <div class="library-section">
            <div class="library-section-title">üñ•Ô∏è ELECTRONICS</div>
            <button class="object-button" onclick="selectInteriorForPreview('pc_tower')">
                <span class="object-icon">üíª</span> PC Tower
            </button>
            <button class="object-button" onclick="selectInteriorForPreview('monitor')">
                <span class="object-icon">üì∫</span> Monitor
            </button>
        </div>
        
        <div class="library-section">
            <div class="library-section-title">üî• LIGHTS</div>
            <button class="object-button" onclick="selectInteriorForPreview('torch')">
                <span class="object-icon">üî•</span> Torch
            </button>
            <button class="object-button" onclick="selectInteriorForPreview('lantern')">
                <span class="object-icon">üèÆ</span> Lantern
            </button>
        </div>
    </div>

    <!-- Editor Gizmo -->
    <div id="editor-gizmo">
        <div class="gizmo-axis gizmo-axis-x"></div>
        <div class="gizmo-axis gizmo-axis-y"></div>
        <div class="gizmo-axis gizmo-axis-z"></div>
        <div class="gizmo-handle gizmo-handle-x" data-axis="x"></div>
        <div class="gizmo-handle gizmo-handle-y" data-axis="y"></div>
        <div class="gizmo-handle gizmo-handle-z" data-axis="z"></div>
    </div>

    <!-- Editor Controls -->
    <div id="editor-controls">
        <div class="editor-control-group">
            <span class="editor-label">X:</span>
            <input type="number" class="editor-input" id="edit-pos-x" step="0.1">
            <span class="editor-label">Y:</span>
            <input type="number" class="editor-input" id="edit-pos-y" step="0.1">
            <span class="editor-label">Z:</span>
            <input type="number" class="editor-input" id="edit-pos-z" step="0.1">
        </div>
        <div class="editor-control-group">
            <span class="editor-label">SX:</span>
            <input type="number" class="editor-input" id="edit-scale-x" step="0.1" min="0.1" max="5" value="1">
            <span class="editor-label">SY:</span>
            <input type="number" class="editor-input" id="edit-scale-y" step="0.1" min="0.1" max="5" value="1">
            <span class="editor-label">SZ:</span>
            <input type="number" class="editor-input" id="edit-scale-z" step="0.1" min="0.1" max="5" value="1">
        </div>
        <div class="editor-control-group">
            <span class="editor-label">RX:</span>
            <input type="number" class="editor-input" id="edit-rot-x" step="1">
            <span class="editor-label">RY:</span>
            <input type="number" class="editor-input" id="edit-rot-y" step="1">
            <span class="editor-label">RZ:</span>
            <input type="number" class="editor-input" id="edit-rot-z" step="1">
        </div>
    </div>

    <!-- CLI - BOTTOM LEFT CORNER -->
    <div id="cli-toggle" onclick="toggleCLI()">~ CONSOLE</div>
    
    <!-- CLI container -->
    <div id="cli-container">
        <div id="cli-output"></div>
        <input type="text" id="cli-input" placeholder="Type /help for commands">
    </div>

    <!-- HELP PANEL -->
    <div id="help-panel">
        <button id="close-help" onclick="hideHelp()">‚úï</button>
        <div class="help-title">MICROCRAFT ADVANCED BUILDER</div>
        
        <div class="help-section">
            <div class="help-section-title">üéÆ CONTROLS</div>
            <ul class="help-list">
                <li class="help-item"><span class="help-key">WASD</span> - Move</li>
                <li class="help-item"><span class="help-key">SPACE</span> - Jump</li>
                <li class="help-item"><span class="help-key">SHIFT</span> - Jetpack (unlimited height flight)</li>
                <li class="help-item"><span class="help-key">MOUSE</span> - Look around</li>
                <li class="help-item"><span class="help-key">LMB</span> - Place block/Select/Place previewed object</li>
                <li class="help-item"><span class="help-key">RMB</span> - Remove block/Cancel preview</li>
                <li class="help-item"><span class="help-key">1-6</span> - Select single blocks</li>
                <li class="help-item"><span class="help-key">ESC</span> - Release mouse/Cancel preview</li>
                <li class="help-item"><span class="help-key">Q</span> - Cancel ghost preview</li>
                <li class="help-item"><span class="help-key">B</span> - Buildings library</li>
                <li class="help-item"><span class="help-key">I</span> - Interior library</li>
                <li class="help-item"><span class="help-key">L</span> - Toggle day/night lighting</li>
                <li class="help-item"><span class="help-key">J</span> - Toggle jetpack</li>
                <li class="help-item"><span class="help-key">U</span> - Undo</li>
            </ul>
        </div>
        
        <div class="help-section">
            <div class="help-section-title">üß± SINGLE BLOCK TOOLS</div>
            <ul class="help-list">
                <li class="help-item"><span class="help-key">üü® SAND</span> - Sand block</li>
                <li class="help-item"><span class="help-key">ü™® STONE</span> - Stone block</li>
                <li class="help-item"><span class="help-key">üåø GRASS</span> - Grass block</li>
                <li class="help-item"><span class="help-key">ü™µ WOOD</span> - Wood block</li>
                <li class="help-item"><span class="help-key">üß± BRICK</span> - Brick block</li>
                <li class="help-item"><span class="help-key">üìê WIREFRAME</span> - Wireframe block style</li>
                <li class="help-item"><span class="help-key">üé® COLOR WHEEL</span> - Changes color of NEW single blocks only</li>
            </ul>
        </div>
        
        <div class="help-section">
            <div class="help-section-title">üèóÔ∏è TEMPLATE TOOLS</div>
            <ul class="help-list">
                <li class="help-item"><span class="help-key">üèóÔ∏è BUILDINGS</span> - Castle buildings (no wireframe/color)</li>
                <li class="help-item"><span class="help-key">üõãÔ∏è INTERIOR</span> - Furniture and objects (no wireframe/color)</li>
                <li class="help-item"><span class="help-key">üî• TORCH</span> - Special light source objects</li>
            </ul>
        </div>
        
        <div class="help-section">
            <div class="help-section-title">üõ†Ô∏è EDITOR TOOLS</div>
            <ul class="help-list">
                <li class="help-item"><span class="help-key">‚úèÔ∏è EDIT</span> - Edit mode with manipulators</li>
                <li class="help-item"><span class="help-key">‚ÜîÔ∏è MOVE</span> - Move selected object</li>
                <li class="help-item"><span class="help-key">‚õ∂ SCALE</span> - Scale selected object</li>
                <li class="help-item"><span class="help-key">üîÑ ROTATE</span> - Rotate selected object</li>
                <li class="help-item"><span class="help-key">‚úì APPLY</span> - Apply changes</li>
                <li class="help-item"><span class="help-key">‚Ü∫ RESET</span> - Reset changes</li>
                <li class="help-item"><span class="help-key">‚Ü∂ UNDO</span> - Undo last action</li>
            </ul>
        </div>
        
        <div class="help-section">
            <div class="help-section-title">üöÄ JETPACK</div>
            <ul class="help-list">
                <li class="help-item"><span class="help-key">SHIFT</span> - Activate jetpack (when in air)</li>
                <li class="help-item"><span class="help-key">J</span> - Toggle jetpack on/off</li>
                <li class="help-item">Unlimited height, slow glide descent</li>
                <li class="help-item">Perfect for platforming at high altitudes</li>
            </ul>
        </div>
    </div>

    <!-- Version -->
    <div id="version">MICROCRAFT v3.2 - CASTLE BUILDER</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // MICROCRAFT - Castle Builder Edition
        // ========================================
        // UPDATED: Wireframe is now a single block style
        // UPDATED: Color wheel only affects NEW single blocks
        // UPDATED: Jetpack with SHIFT (UNLIMITED height, slow glide)
        // UPDATED: Single block tools reorganized
        // UPDATED: Templates on left sidebar
        // ========================================

        // Core game variables
        let scene, camera, renderer;
        let raycaster;
        let isPointerLocked = false;
        let placedBlocks = new Map();
        let placedObjects = new Map();
        let objectGroups = new Map();
        let selectedBlock = 'stone';
        let cliVisible = false;
        let libraryVisible = null;
        let currentMode = 'build';
        let gizmoMode = 'translate';
        let isNightMode = false;
        let selectedObject = null;
        let selectedGroup = null;
        let currentColor = 0x00ff00;
        let isDraggingGizmo = false;
        let activeGizmoAxis = null;
        let dragStartPosition = null;
        let originalObjectState = null;
        
        // Jetpack variables - UNLIMITED HEIGHT, SLOW GLIDE
        let jetpackActive = false;
        let jetpackEnabled = true; // Enabled by default
        const JETPACK_FORCE = 25; // Reduced for slower ascent
        const JETPACK_GLIDE_FACTOR = 0.3; // Slow descent when not active
        const JETPACK_MAX_HEIGHT = 999999; // Effectively unlimited
        
        // No wireframe mode - wireframe is now a block type
        
        // Ghost object variables
        let ghostObject = null;
        let ghostObjectType = null;
        let ghostObjectName = null;
        let ghostObjectData = null;
        let ghostPlacementValid = false;
        let ghostPreviewEnabled = true;
        let ghostBaseYOffset = 0;
        
        // Block custom colors storage - Only for NEW single blocks
        let blockCustomColors = {
            'sand': 0xF4A460,
            'stone': 0x808080,
            'grass': 0x7CFC00,
            'wood': 0x8B4513,
            'brick': 0xB22222,
            'wireframe': 0x00ff00
        };
        
        // Undo stack
        let undoStack = [];
        const MAX_UNDO_HISTORY = 100;
        
        // World settings
        const BLOCK_SIZE = 0.5;
        const WORLD_SIZE = 32;
        
        // Player state
        const keys = {};
        let verticalVelocity = 0;
        let isOnGround = true;
        let isSprinting = false;
        const MOVE_SPEED = 6;
        const SPRINT_SPEED = 10;
        const JUMP_FORCE = 8;
        const GRAVITY = 20;
        
        // Camera control
        let pitch = 0;
        let yaw = 0;
        const LOOK_SENSITIVITY = 0.002;
        const MAX_PITCH = Math.PI / 2 - 0.1;
        
        // CLI history
        let commandHistory = [];
        let historyIndex = -1;
        
        // Ground plane reference for raycasting
        let groundPlane;
        
        // Lighting references
        let sunLight, ambientLight, torchLights = [];
        
        // Available building blocks with base colors
        const BLOCKS = {
            'sand': { color: 0xF4A460, emoji: 'üü®', name: 'Sand', roughness: 0.9, metalness: 0 },
            'stone': { color: 0x808080, emoji: 'ü™®', name: 'Stone', roughness: 0.8, metalness: 0.1 },
            'grass': { color: 0x7CFC00, emoji: 'üåø', name: 'Grass', roughness: 0.7, metalness: 0 },
            'wood': { color: 0x8B4513, emoji: 'ü™µ', name: 'Wood', roughness: 0.9, metalness: 0 },
            'brick': { color: 0xB22222, emoji: 'üß±', name: 'Brick', roughness: 0.6, metalness: 0.1 },
            'wireframe': { color: 0x00ff00, emoji: 'üìê', name: 'Wireframe', roughness: 0.8, metalness: 0, wireframe: true }
        };

        // ========================================
        // ENHANCED JETPACK SYSTEM (UNLIMITED, SLOW GLIDE)
        // ========================================

        function toggleJetpack() {
            jetpackEnabled = !jetpackEnabled;
            
            if (jetpackEnabled) {
                addToCLI("Jetpack: ENABLED (hold SHIFT in air to fly)", "success");
                showNotification("Jetpack enabled - Hold SHIFT while in air to fly!");
                document.getElementById('jetpack-toggle').innerHTML = '<span class="button-icon">üöÄ</span> JETPACK ON';
                document.getElementById('jetpack-toggle').style.background = 'rgba(0, 255, 255, 0.2)';
                document.getElementById('jetpack-toggle').style.borderColor = '#00ffff';
            } else {
                jetpackActive = false;
                addToCLI("Jetpack: DISABLED", "info");
                showNotification("Jetpack disabled");
                document.getElementById('jetpack-toggle').innerHTML = '<span class="button-icon">üöÄ</span> JETPACK';
                document.getElementById('jetpack-toggle').style.background = '';
                document.getElementById('jetpack-toggle').style.borderColor = '';
            }
            
            updateJetpackStatus();
        }

        function updateJetpackStatus() {
            const statusElement = document.getElementById('jetpack-status');
            if (jetpackActive) {
                statusElement.textContent = 'ACTIVE';
                statusElement.style.color = '#00ffff';
            } else if (jetpackEnabled) {
                statusElement.textContent = 'READY';
                statusElement.style.color = '#00aaff';
            } else {
                statusElement.textContent = 'OFF';
                statusElement.style.color = '#888888';
            }
        }

        function updateJetpack(deltaTime) {
            if (jetpackActive) {
                // Apply jetpack force - UNLIMITED HEIGHT
                verticalVelocity += JETPACK_FORCE * deltaTime;
                
                // Show jetpack effect
                const jetpackEffect = document.getElementById('jetpack-effect');
                jetpackEffect.style.display = 'block';
                jetpackEffect.style.bottom = '10px';
                jetpackEffect.style.left = '50%';
                
                // Update jetpack status
                updateJetpackStatus();
            } else if (jetpackEnabled && !isOnGround && verticalVelocity < 0) {
                // Slow glide descent when not actively using jetpack
                verticalVelocity += GRAVITY * deltaTime * JETPACK_GLIDE_FACTOR;
            }
            
            // Always hide effect if not active
            if (!jetpackActive) {
                document.getElementById('jetpack-effect').style.display = 'none';
            }
        }

        // ========================================
        // COLOR PICKER SYSTEM (ONLY FOR NEW SINGLE BLOCKS)
        // ========================================

        function initColorPicker() {
            const colorPicker = document.getElementById('color-picker');
            
            colorPicker.addEventListener('input', (e) => {
                const colorStr = e.target.value;
                const newColor = parseInt(colorStr.replace('#', '0x'));
                
                // Update current color for NEW single blocks
                currentColor = newColor;
                
                // Update the color for the currently selected block type
                if (BLOCKS[selectedBlock]) {
                    blockCustomColors[selectedBlock] = newColor;
                }
                
                addToCLI(`Color set: ${colorStr} (affects new ${selectedBlock} blocks only)`, "success");
                updateSelectedObjectDisplay();
            });
            
            // Set initial color
            colorPicker.value = '#00ff00';
        }

        // ========================================
        // ENHANCED BLOCK SELECTION WITH COLOR HANDLING
        // ========================================

        function selectBlock(blockType) {
            if (!BLOCKS[blockType]) {
                addToCLI(`Unknown block type: ${blockType}`, "error");
                return;
            }
            
            // Clear ghost object when selecting a regular block
            if (ghostObject) {
                clearGhostObject();
            }
            
            // Force switch to build mode when selecting blocks
            if (currentMode !== 'build') {
                toggleMode('build');
            }
            
            selectedBlock = blockType;
            updateSelectedObjectDisplay();
            updateBlockButtons();
            
            // Update color picker to show current block's color
            const colorHex = '#' + blockCustomColors[blockType].toString(16).padStart(6, '0');
            document.getElementById('color-picker').value = colorHex;
            
            addToCLI(`Selected: ${BLOCKS[blockType].name}`, "success");
        }

        function updateSelectedObjectDisplay() {
            const blockData = BLOCKS[selectedBlock];
            if (blockData) {
                document.getElementById('object-icon').textContent = blockData.emoji;
                document.getElementById('object-name').textContent = blockData.name;
            }
        }

        // ========================================
        // ENHANCED BLOCK CREATION WITH COLOR HANDLING
        // ========================================

        function createBlockAt(type, x, y, z, scale = {x: 1, y: 1, z: 1}, rotation = {x: 0, y: 0, z: 0}) {
            const key = `${Math.round(x*10)/10},${Math.round(y*10)/10},${Math.round(z*10)/10}`;
            
            if (placedBlocks.has(key) || placedObjects.has(key)) return null;
            
            const geometry = new THREE.BoxGeometry(
                BLOCK_SIZE * scale.x, 
                BLOCK_SIZE * scale.y, 
                BLOCK_SIZE * scale.z
            );
            
            // Determine color - use custom color for NEW blocks
            const color = blockCustomColors[type] || BLOCKS[type]?.color || 0x808080;
            
            let material;
            if (type === 'wireframe') {
                material = new THREE.MeshBasicMaterial({ 
                    color: color,
                    wireframe: true
                });
            } else {
                material = new THREE.MeshStandardMaterial({ 
                    color: color,
                    roughness: BLOCKS[type]?.roughness || 0.8,
                    metalness: BLOCKS[type]?.metalness || 0
                });
            }
            
            const block = new THREE.Mesh(geometry, material);
            block.position.set(x * BLOCK_SIZE, y * BLOCK_SIZE, z * BLOCK_SIZE);
            block.rotation.set(rotation.x, rotation.y, rotation.z);
            block.castShadow = true;
            block.receiveShadow = true;
            block.userData = { 
                type: type, 
                x: x, 
                y: y, 
                z: z,
                scale: {x: scale.x, y: scale.y, z: scale.z},
                rotation: {x: rotation.x, y: rotation.y, z: rotation.z},
                key: key,
                color: color,
                isGrouped: false,
                groupId: null
            };
            
            scene.add(block);
            placedBlocks.set(key, block);
            
            updateBlockCount();
            return block;
        }

        // ========================================
        // UNIQUE OBJECT CREATION FUNCTIONS
        // ========================================

        function createChair(x, y, z) {
            const chairGroup = new THREE.Group();
            
            // Chair legs
            const legGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.4, 8);
            const legMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.9,
                metalness: 0.1
            });
            
            for (let i = 0; i < 4; i++) {
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.set(
                    (i % 2 === 0 ? -0.2 : 0.2),
                    0.2,
                    (i < 2 ? -0.15 : 0.15)
                );
                leg.castShadow = true;
                chairGroup.add(leg);
            }
            
            // Seat
            const seatGeometry = new THREE.BoxGeometry(0.5, 0.05, 0.4);
            const seatMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xA0522D,
                roughness: 0.8,
                metalness: 0
            });
            const seat = new THREE.Mesh(seatGeometry, seatMaterial);
            seat.position.set(0, 0.425, 0);
            seat.castShadow = true;
            chairGroup.add(seat);
            
            // Backrest
            const backGeometry = new THREE.BoxGeometry(0.5, 0.4, 0.05);
            const back = new THREE.Mesh(seatGeometry, seatMaterial);
            back.position.set(0, 0.65, -0.225);
            back.castShadow = true;
            chairGroup.add(back);
            
            chairGroup.position.set(x * BLOCK_SIZE, y * BLOCK_SIZE, z * BLOCK_SIZE);
            scene.add(chairGroup);
            
            // Store reference
            const key = `interior_${x},${y},${z}`;
            chairGroup.userData = {
                type: 'chair',
                name: 'Chair',
                x: x,
                y: y,
                z: z,
                key: key,
                isInterior: true
            };
            placedObjects.set(key, chairGroup);
            
            return chairGroup;
        }

        function createTable(x, y, z) {
            const tableGroup = new THREE.Group();
            
            // Table legs
            const legGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.7, 8);
            const legMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.9,
                metalness: 0.1
            });
            
            const legPositions = [
                [-0.3, 0.35, -0.2],
                [0.3, 0.35, -0.2],
                [-0.3, 0.35, 0.2],
                [0.3, 0.35, 0.2]
            ];
            
            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.set(pos[0], pos[1], pos[2]);
                leg.castShadow = true;
                tableGroup.add(leg);
            });
            
            // Table top
            const topGeometry = new THREE.BoxGeometry(0.8, 0.05, 0.5);
            const topMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xD2691E,
                roughness: 0.7,
                metalness: 0
            });
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.set(0, 0.725, 0);
            top.castShadow = true;
            tableGroup.add(top);
            
            tableGroup.position.set(x * BLOCK_SIZE, y * BLOCK_SIZE, z * BLOCK_SIZE);
            scene.add(tableGroup);
            
            // Store reference
            const key = `interior_${x},${y},${z}`;
            tableGroup.userData = {
                type: 'table',
                name: 'Table',
                x: x,
                y: y,
                z: z,
                key: key,
                isInterior: true
            };
            placedObjects.set(key, tableGroup);
            
            return tableGroup;
        }

        function createThrone(x, y, z) {
            const throneGroup = new THREE.Group();
            
            // Throne base
            const baseGeometry = new THREE.BoxGeometry(0.6, 0.4, 0.5);
            const goldMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFD700,
                roughness: 0.3,
                metalness: 0.8
            });
            const base = new THREE.Mesh(baseGeometry, goldMaterial);
            base.position.set(0, 0.2, 0);
            base.castShadow = true;
            throneGroup.add(base);
            
            // Throne back
            const backGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.1);
            const back = new THREE.Mesh(backGeometry, goldMaterial);
            back.position.set(0, 0.8, -0.2);
            back.castShadow = true;
            throneGroup.add(back);
            
            // Armrests
            const armGeometry = new THREE.BoxGeometry(0.1, 0.2, 0.4);
            const leftArm = new THREE.Mesh(armGeometry, goldMaterial);
            leftArm.position.set(-0.35, 0.5, 0);
            leftArm.castShadow = true;
            throneGroup.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, goldMaterial);
            rightArm.position.set(0.35, 0.5, 0);
            rightArm.castShadow = true;
            throneGroup.add(rightArm);
            
            // Jewel
            const jewelGeometry = new THREE.SphereGeometry(0.08, 16, 16);
            const jewelMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFF0000,
                roughness: 0.1,
                metalness: 0.9,
                emissive: 0xFF0000,
                emissiveIntensity: 0.2
            });
            const jewel = new THREE.Mesh(jewelGeometry, jewelMaterial);
            jewel.position.set(0, 1.1, -0.15);
            jewel.castShadow = true;
            throneGroup.add(jewel);
            
            throneGroup.position.set(x * BLOCK_SIZE, y * BLOCK_SIZE, z * BLOCK_SIZE);
            scene.add(throneGroup);
            
            // Store reference
            const key = `interior_${x},${y},${z}`;
            throneGroup.userData = {
                type: 'throne',
                name: 'Throne',
                x: x,
                y: y,
                z: z,
                key: key,
                isInterior: true
            };
            placedObjects.set(key, throneGroup);
            
            return throneGroup;
        }

        function createPCTower(x, y, z) {
            const pcGroup = new THREE.Group();
            
            // Tower case
            const caseGeometry = new THREE.BoxGeometry(0.3, 0.6, 0.2);
            const caseMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.4,
                metalness: 0.6
            });
            const pcCase = new THREE.Mesh(caseGeometry, caseMaterial);
            pcCase.position.set(0, 0.3, 0);
            pcCase.castShadow = true;
            pcGroup.add(pcCase);
            
            // Ventilation slots
            const ventGeometry = new THREE.BoxGeometry(0.25, 0.02, 0.01);
            const ventMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x666666,
                roughness: 0.8,
                metalness: 0.2
            });
            
            for (let i = 0; i < 3; i++) {
                const vent = new THREE.Mesh(ventGeometry, ventMaterial);
                vent.position.set(0, 0.15 + i * 0.1, 0.105);
                pcGroup.add(vent);
            }
            
            // Power button
            const buttonGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.01, 16);
            const buttonMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00FF00,
                roughness: 0.2,
                metalness: 0.8,
                emissive: 0x00FF00,
                emissiveIntensity: 0.5
            });
            const powerButton = new THREE.Mesh(buttonGeometry, buttonMaterial);
            powerButton.position.set(0.1, 0.55, 0.105);
            powerButton.rotation.x = Math.PI / 2;
            pcGroup.add(powerButton);
            
            pcGroup.position.set(x * BLOCK_SIZE, y * BLOCK_SIZE, z * BLOCK_SIZE);
            scene.add(pcGroup);
            
            // Store reference
            const key = `interior_${x},${y},${z}`;
            pcGroup.userData = {
                type: 'pc_tower',
                name: 'PC Tower',
                x: x,
                y: y,
                z: z,
                key: key,
                isInterior: true
            };
            placedObjects.set(key, pcGroup);
            
            return pcGroup;
        }

        function createMonitor(x, y, z) {
            const monitorGroup = new THREE.Group();
            
            // Monitor screen
            const screenGeometry = new THREE.BoxGeometry(0.5, 0.35, 0.05);
            const screenMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x000000,
                roughness: 0.1,
                metalness: 0.2,
                emissive: 0x00AAFF,
                emissiveIntensity: 0.3
            });
            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.set(0, 0.425, 0);
            screen.castShadow = true;
            monitorGroup.add(screen);
            
            // Monitor frame
            const frameGeometry = new THREE.BoxGeometry(0.55, 0.4, 0.07);
            const frameMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x222222,
                roughness: 0.3,
                metalness: 0.4
            });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.set(0, 0.425, 0);
            monitorGroup.add(frame);
            
            // Monitor stand
            const standGeometry = new THREE.CylinderGeometry(0.08, 0.15, 0.2, 8);
            const standMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x444444,
                roughness: 0.5,
                metalness: 0.3
            });
            const stand = new THREE.Mesh(standGeometry, standMaterial);
            stand.position.set(0, 0.1, 0);
            monitorGroup.add(stand);
            
            monitorGroup.position.set(x * BLOCK_SIZE, y * BLOCK_SIZE, z * BLOCK_SIZE);
            scene.add(monitorGroup);
            
            // Store reference
            const key = `interior_${x},${y},${z}`;
            monitorGroup.userData = {
                type: 'monitor',
                name: 'Monitor',
                x: x,
                y: y,
                z: z,
                key: key,
                isInterior: true
            };
            placedObjects.set(key, monitorGroup);
            
            return monitorGroup;
        }

        function createLantern(x, y, z) {
            const lanternGroup = new THREE.Group();
            
            // Lantern body
            const bodyGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.3, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFD700,
                roughness: 0.2,
                metalness: 0.8,
                transparent: true,
                opacity: 0.7
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.set(0, 0.35, 0);
            lanternGroup.add(body);
            
            // Lantern top
            const topGeometry = new THREE.ConeGeometry(0.12, 0.1, 8);
            const top = new THREE.Mesh(topGeometry, bodyMaterial);
            top.position.set(0, 0.55, 0);
            lanternGroup.add(top);
            
            // Lantern hook
            const hookGeometry = new THREE.TorusGeometry(0.05, 0.01, 8, 16);
            const hookMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.8,
                metalness: 0.2
            });
            const hook = new THREE.Mesh(hookGeometry, hookMaterial);
            hook.position.set(0, 0.65, 0);
            hook.rotation.x = Math.PI / 2;
            lanternGroup.add(hook);
            
            // Lantern light
            const lanternLight = new THREE.PointLight(0xFFAA33, 1.2, 8);
            lanternLight.position.set(0, 0.35, 0);
            lanternLight.castShadow = true;
            lanternGroup.add(lanternLight);
            
            // Flame
            const flameGeometry = new THREE.SphereGeometry(0.04, 8, 6);
            const flameMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFF5500,
                transparent: true,
                opacity: 0.9,
                emissive: 0xFF3300,
                emissiveIntensity: 2.0
            });
            const flame = new THREE.Mesh(flameGeometry, flameMaterial);
            flame.position.set(0, 0.35, 0);
            lanternGroup.add(flame);
            
            lanternGroup.position.set(x * BLOCK_SIZE, y * BLOCK_SIZE, z * BLOCK_SIZE);
            scene.add(lanternGroup);
            
            // Store reference
            const key = `interior_${x},${y},${z}`;
            lanternGroup.userData = {
                type: 'lantern',
                name: 'Lantern',
                x: x,
                y: y,
                z: z,
                key: key,
                isInterior: true
            };
            placedObjects.set(key, lanternGroup);
            
            // Animate flame
            let flameTime = 0;
            function animateFlame() {
                if (!scene || !flame) return;
                
                flameTime += 0.1;
                const scale = 0.8 + Math.sin(flameTime) * 0.2;
                flame.scale.set(scale, scale, scale);
                
                // Flicker light
                lanternLight.intensity = 1.0 + Math.sin(flameTime * 2) * 0.2;
                
                requestAnimationFrame(animateFlame);
            }
            animateFlame();
            
            return lanternGroup;
        }

        // ========================================
        // ENHANCED TORCH FUNCTION
        // ========================================

        function createTorch(x, y, z) {
            const torchGroup = new THREE.Group();
            
            // Torch stand
            const poleGeometry = new THREE.CylinderGeometry(0.03, 0.04, 0.6, 8);
            const poleMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.9,
                metalness: 0.1
            });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.set(0, 0.3, 0);
            pole.castShadow = true;
            torchGroup.add(pole);
            
            // Torch head
            const headGeometry = new THREE.SphereGeometry(0.06, 8, 6);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x654321,
                roughness: 0.8,
                metalness: 0
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 0.65, 0);
            torchGroup.add(head);
            
            // Flame
            const flameGeometry = new THREE.ConeGeometry(0.05, 0.15, 8);
            const flameMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff5500,
                transparent: true,
                opacity: 0.9,
                emissive: 0xff3300,
                emissiveIntensity: 2.0
            });
            const flame = new THREE.Mesh(flameGeometry, flameMaterial);
            flame.position.set(0, 0.75, 0);
            torchGroup.add(flame);
            
            // Torch light
            const torchLight = new THREE.PointLight(0xffaa55, 1.5, 10);
            torchLight.position.set(0, 0.75, 0);
            torchLight.castShadow = true;
            torchLight.shadow.mapSize.width = 512;
            torchLight.shadow.mapSize.height = 512;
            torchLight.shadow.camera.near = 0.1;
            torchLight.shadow.camera.far = 15;
            torchGroup.add(torchLight);
            
            torchGroup.position.set(x * BLOCK_SIZE, y * BLOCK_SIZE, z * BLOCK_SIZE);
            scene.add(torchGroup);
            
            // Store reference
            const key = `interior_${x},${y},${z}`;
            torchGroup.userData = {
                type: 'torch',
                name: 'Torch',
                x: x,
                y: y,
                z: z,
                key: key,
                isInterior: true,
                isTorch: true
            };
            placedObjects.set(key, torchGroup);
            
            // Animate flame
            let time = 0;
            function animateTorch() {
                if (!scene || !flame) return;
                
                time += 0.15;
                const scale = 0.8 + Math.sin(time) * 0.2;
                flame.scale.set(scale, scale, scale);
                torchLight.intensity = 1.2 + Math.sin(time * 2.5) * 0.3;
                flame.rotation.y = time * 0.5;
                
                requestAnimationFrame(animateTorch);
            }
            animateTorch();
            
            return torchGroup;
        }

        // ========================================
        // ENHANCED BUILDING TEMPLATES
        // ========================================

        const BUILDINGS = {
            // Stone Buildings
            'stone_castle_tower': {
                name: "Stone Castle Tower",
                type: 'building',
                blocks: [
                    // Foundation 3x3
                    {type: 'stone', x:0, y:0, z:0}, {type: 'stone', x:1, y:0, z:0}, {type: 'stone', x:2, y:0, z:0},
                    {type: 'stone', x:0, y:0, z:1}, {type: 'stone', x:1, y:0, z:1}, {type: 'stone', x:2, y:0, z:1},
                    {type: 'stone', x:0, y:0, z:2}, {type: 'stone', x:1, y:0, z:2}, {type: 'stone', x:2, y:0, z:2},
                    // Walls
                    {type: 'stone', x:0, y:1, z:0}, {type: 'stone', x:2, y:1, z:0},
                    {type: 'stone', x:0, y:1, z:2}, {type: 'stone', x:2, y:1, z:2},
                    {type: 'stone', x:0, y:2, z:0}, {type: 'stone', x:2, y:2, z:0},
                    {type: 'stone', x:0, y:2, z:2}, {type: 'stone', x:2, y:2, z:2},
                    {type: 'stone', x:0, y:3, z:0}, {type: 'stone', x:2, y:3, z:0},
                    {type: 'stone', x:0, y:3, z:2}, {type: 'stone', x:2, y:3, z:2},
                    // Top platform
                    {type: 'stone', x:0, y:4, z:0}, {type: 'stone', x:1, y:4, z:0}, {type: 'stone', x:2, y:4, z:0},
                    {type: 'stone', x:0, y:4, z:1}, {type: 'stone', x:2, y:4, z:1},
                    {type: 'stone', x:0, y:4, z:2}, {type: 'stone', x:1, y:4, z:2}, {type: 'stone', x:2, y:4, z:2}
                ]
            },
            'stone_watchtower': {
                name: "Stone Watchtower",
                type: 'building',
                blocks: [
                    // Base
                    {type: 'stone', x:0, y:0, z:0}, {type: 'stone', x:2, y:0, z:0},
                    {type: 'stone', x:0, y:0, z:2}, {type: 'stone', x:2, y:0, z:2},
                    // Pillars
                    {type: 'stone', x:0, y:1, z:0}, {type: 'stone', x:0, y:2, z:0}, {type: 'stone', x:0, y:3, z:0},
                    {type: 'stone', x:2, y:1, z:0}, {type: 'stone', x:2, y:2, z:0}, {type: 'stone', x:2, y:3, z:0},
                    {type: 'stone', x:0, y:1, z:2}, {type: 'stone', x:0, y:2, z:2}, {type: 'stone', x:0, y:3, z:2},
                    {type: 'stone', x:2, y:1, z:2}, {type: 'stone', x:2, y:2, z:2}, {type: 'stone', x:2, y:3, z:2},
                    // Platform
                    {type: 'stone', x:0, y:4, z:0}, {type: 'stone', x:1, y:4, z:0}, {type: 'stone', x:2, y:4, z:0},
                    {type: 'stone', x:0, y:4, z:1}, {type: 'stone', x:1, y:4, z:1}, {type: 'stone', x:2, y:4, z:1},
                    {type: 'stone', x:0, y:4, z:2}, {type: 'stone', x:1, y:4, z:2}, {type: 'stone', x:2, y:4, z:2}
                ]
            },
            'stone_keep': {
                name: "Stone Keep",
                type: 'building',
                blocks: [
                    // Base 4x4
                    {type: 'stone', x:0, y:0, z:0}, {type: 'stone', x:1, y:0, z:0}, {type: 'stone', x:2, y:0, z:0}, {type: 'stone', x:3, y:0, z:0},
                    {type: 'stone', x:0, y:0, z:1}, {type: 'stone', x:3, y:0, z:1},
                    {type: 'stone', x:0, y:0, z:2}, {type: 'stone', x:3, y:0, z:2},
                    {type: 'stone', x:0, y:0, z:3}, {type: 'stone', x:1, y:0, z:3}, {type: 'stone', x:2, y:0, z:3}, {type: 'stone', x:3, y:0, z:3},
                    // Walls
                    {type: 'stone', x:0, y:1, z:0}, {type: 'stone', x:3, y:1, z:0},
                    {type: 'stone', x:0, y:1, z:3}, {type: 'stone', x:3, y:1, z:3},
                    {type: 'stone', x:0, y:2, z:0}, {type: 'stone', x:3, y:2, z:0},
                    {type: 'stone', x:0, y:2, z:3}, {type: 'stone', x:3, y:2, z:3},
                    // Roof
                    {type: 'stone', x:0, y:3, z:0}, {type: 'stone', x:1, y:3, z:0}, {type: 'stone', x:2, y:3, z:0}, {type: 'stone', x:3, y:3, z:0},
                    {type: 'stone', x:0, y:3, z:1}, {type: 'stone', x:3, y:3, z:1},
                    {type: 'stone', x:0, y:3, z:2}, {type: 'stone', x:3, y:3, z:2},
                    {type: 'stone', x:0, y:3, z:3}, {type: 'stone', x:1, y:3, z:3}, {type: 'stone', x:2, y:3, z:3}, {type: 'stone', x:3, y:3, z:3}
                ]
            },
            'stone_wall': {
                name: "Stone Wall",
                type: 'building',
                blocks: [
                    // Wall segment
                    {type: 'stone', x:0, y:0, z:0}, {type: 'stone', x:1, y:0, z:0}, {type: 'stone', x:2, y:0, z:0},
                    {type: 'stone', x:3, y:0, z:0}, {type: 'stone', x:4, y:0, z:0},
                    {type: 'stone', x:0, y:1, z:0}, {type: 'stone', x:1, y:1, z:0}, {type: 'stone', x:2, y:1, z:0},
                    {type: 'stone', x:3, y:1, z:0}, {type: 'stone', x:4, y:1, z:0},
                    {type: 'stone', x:0, y:2, z:0}, {type: 'stone', x:1, y:2, z:0}, {type: 'stone', x:2, y:2, z:0},
                    {type: 'stone', x:3, y:2, z:0}, {type: 'stone', x:4, y:2, z:0},
                    // Battlements
                    {type: 'stone', x:0, y:3, z:0}, {type: 'stone', x:2, y:3, z:0}, {type: 'stone', x:4, y:3, z:0}
                ]
            },
            
            // Wood Buildings
            'wood_castle_tower': {
                name: "Wood Castle Tower",
                type: 'building',
                blocks: [
                    // Foundation 3x3
                    {type: 'wood', x:0, y:0, z:0}, {type: 'wood', x:1, y:0, z:0}, {type: 'wood', x:2, y:0, z:0},
                    {type: 'wood', x:0, y:0, z:1}, {type: 'wood', x:1, y:0, z:1}, {type: 'wood', x:2, y:0, z:1},
                    {type: 'wood', x:0, y:0, z:2}, {type: 'wood', x:1, y:0, z:2}, {type: 'wood', x:2, y:0, z:2},
                    // Walls
                    {type: 'wood', x:0, y:1, z:0}, {type: 'wood', x:2, y:1, z:0},
                    {type: 'wood', x:0, y:1, z:2}, {type: 'wood', x:2, y:1, z:2},
                    {type: 'wood', x:0, y:2, z:0}, {type: 'wood', x:2, y:2, z:0},
                    {type: 'wood', x:0, y:2, z:2}, {type: 'wood', x:2, y:2, z:2},
                    {type: 'wood', x:0, y:3, z:0}, {type: 'wood', x:2, y:3, z:0},
                    {type: 'wood', x:0, y:3, z:2}, {type: 'wood', x:2, y:3, z:2},
                    // Top platform
                    {type: 'wood', x:0, y:4, z:0}, {type: 'wood', x:1, y:4, z:0}, {type: 'wood', x:2, y:4, z:0},
                    {type: 'wood', x:0, y:4, z:1}, {type: 'wood', x:2, y:4, z:1},
                    {type: 'wood', x:0, y:4, z:2}, {type: 'wood', x:1, y:4, z:2}, {type: 'wood', x:2, y:4, z:2}
                ]
            },
            'wood_watchtower': {
                name: "Wood Watchtower",
                type: 'building',
                blocks: [
                    // Base
                    {type: 'wood', x:0, y:0, z:0}, {type: 'wood', x:2, y:0, z:0},
                    {type: 'wood', x:0, y:0, z:2}, {type: 'wood', x:2, y:0, z:2},
                    // Pillars
                    {type: 'wood', x:0, y:1, z:0}, {type: 'wood', x:0, y:2, z:0}, {type: 'wood', x:0, y:3, z:0},
                    {type: 'wood', x:2, y:1, z:0}, {type: 'wood', x:2, y:2, z:0}, {type: 'wood', x:2, y:3, z:0},
                    {type: 'wood', x:0, y:1, z:2}, {type: 'wood', x:0, y:2, z:2}, {type: 'wood', x:0, y:3, z:2},
                    {type: 'wood', x:2, y:1, z:2}, {type: 'wood', x:2, y:2, z:2}, {type: 'wood', x:2, y:3, z:2},
                    // Platform
                    {type: 'wood', x:0, y:4, z:0}, {type: 'wood', x:1, y:4, z:0}, {type: 'wood', x:2, y:4, z:0},
                    {type: 'wood', x:0, y:4, z:1}, {type: 'wood', x:1, y:4, z:1}, {type: 'wood', x:2, y:4, z:1},
                    {type: 'wood', x:0, y:4, z:2}, {type: 'wood', x:1, y:4, z:2}, {type: 'wood', x:2, y:4, z:2}
                ]
            },
            'wood_keep': {
                name: "Wood Keep",
                type: 'building',
                blocks: [
                    // Base 4x4
                    {type: 'wood', x:0, y:0, z:0}, {type: 'wood', x:1, y:0, z:0}, {type: 'wood', x:2, y:0, z:0}, {type: 'wood', x:3, y:0, z:0},
                    {type: 'wood', x:0, y:0, z:1}, {type: 'wood', x:3, y:0, z:1},
                    {type: 'wood', x:0, y:0, z:2}, {type: 'wood', x:3, y:0, z:2},
                    {type: 'wood', x:0, y:0, z:3}, {type: 'wood', x:1, y:0, z:3}, {type: 'wood', x:2, y:0, z:3}, {type: 'wood', x:3, y:0, z:3},
                    // Walls
                    {type: 'wood', x:0, y:1, z:0}, {type: 'wood', x:3, y:1, z:0},
                    {type: 'wood', x:0, y:1, z:3}, {type: 'wood', x:3, y:1, z:3},
                    {type: 'wood', x:0, y:2, z:0}, {type: 'wood', x:3, y:2, z:0},
                    {type: 'wood', x:0, y:2, z:3}, {type: 'wood', x:3, y:2, z:3},
                    // Roof
                    {type: 'wood', x:0, y:3, z:0}, {type: 'wood', x:1, y:3, z:0}, {type: 'wood', x:2, y:3, z:0}, {type: 'wood', x:3, y:3, z:0},
                    {type: 'wood', x:0, y:3, z:1}, {type: 'wood', x:3, y:3, z:1},
                    {type: 'wood', x:0, y:3, z:2}, {type: 'wood', x:3, y:3, z:2},
                    {type: 'wood', x:0, y:3, z:3}, {type: 'wood', x:1, y:3, z:3}, {type: 'wood', x:2, y:3, z:3}, {type: 'wood', x:3, y:3, z:3}
                ]
            },
            'wood_wall': {
                name: "Wood Wall",
                type: 'building',
                blocks: [
                    // Wall segment
                    {type: 'wood', x:0, y:0, z:0}, {type: 'wood', x:1, y:0, z:0}, {type: 'wood', x:2, y:0, z:0},
                    {type: 'wood', x:3, y:0, z:0}, {type: 'wood', x:4, y:0, z:0},
                    {type: 'wood', x:0, y:1, z:0}, {type: 'wood', x:1, y:1, z:0}, {type: 'wood', x:2, y:1, z:0},
                    {type: 'wood', x:3, y:1, z:0}, {type: 'wood', x:4, y:1, z:0},
                    {type: 'wood', x:0, y:2, z:0}, {type: 'wood', x:1, y:2, z:0}, {type: 'wood', x:2, y:2, z:0},
                    {type: 'wood', x:3, y:2, z:0}, {type: 'wood', x:4, y:2, z:0}
                ]
            }
        };

        // ========================================
        // UNIQUE INTERIOR OBJECT MODELS
        // ========================================

        const INTERIOR_OBJECTS = {
            'torch': {
                name: "Torch",
                type: 'interior',
                create: function(x, y, z) {
                    return createTorch(x, y, z);
                }
            },
            'chair': {
                name: "Chair",
                type: 'interior',
                create: function(x, y, z) {
                    return createChair(x, y, z);
                }
            },
            'table': {
                name: "Table",
                type: 'interior',
                create: function(x, y, z) {
                    return createTable(x, y, z);
                }
            },
            'throne': {
                name: "Throne",
                type: 'interior',
                create: function(x, y, z) {
                    return createThrone(x, y, z);
                }
            },
            'pc_tower': {
                name: "PC Tower",
                type: 'interior',
                create: function(x, y, z) {
                    return createPCTower(x, y, z);
                }
            },
            'monitor': {
                name: "Monitor",
                type: 'interior',
                create: function(x, y, z) {
                    return createMonitor(x, y, z);
                }
            },
            'lantern': {
                name: "Lantern",
                type: 'interior',
                create: function(x, y, z) {
                    return createLantern(x, y, z);
                }
            }
        };

        // ========================================
        // INITIALIZATION FUNCTIONS
        // ========================================

        let lastProgressUpdate = 0;
        function updateLoading(text, percent) {
            const now = Date.now();
            if (now - lastProgressUpdate > 50 || percent % 25 === 0 || percent === 100) {
                document.getElementById('loading-progress').style.width = percent + '%';
                document.getElementById('loading-percent').textContent = `${Math.round(percent)}%`;
                
                if (percent % 25 === 0 || percent === 100) {
                    document.querySelector('.loading-subtitle').textContent = text;
                }
                lastProgressUpdate = now;
            }
        }

        async function init() {
            console.log("Initializing MICROCRAFT Castle Builder...");
            updateLoading("Starting Engine...", 10);
            
            try {
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    powerPreference: "high-performance"
                });
                
                const gl = renderer.getContext();
                if (!gl) throw new Error("WebGL not supported");
                
                console.log("WebGL initialized");
                updateLoading("Setting up scene...", 30);
                
            } catch (e) {
                console.error("WebGL failed:", e);
                showNotification("WebGL not supported. Try Chrome/Firefox with hardware acceleration enabled.");
                return;
            }
            
            // Setup scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 10, 50);
            
            // Setup camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(8, 10, 8);
            
            // Setup renderer
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);
            
            updateLoading("Creating world...", 50);
            
            // Setup lighting
            setupLighting();
            
            // Create simple sand island world
            createSimpleIsland();
            
            updateLoading("Setting up controls...", 80);
            
            // Setup event listeners
            setupEventListeners();
            
            // Setup raycaster
            raycaster = new THREE.Raycaster();
            
            // Initialize systems
            initCLI();
            initColorPicker();
            initEditorControls();
            
            // Initialize UI
            updateBlockButtons();
            updateModeButtons();
            updateJetpackStatus();
            updateSelectedObjectDisplay();
            
            // Start animation
            animate();
            
            updateLoading("Ready!", 100);
            
            // Hide loading and show welcome
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
                addToCLI("=== MICROCRAFT CASTLE BUILDER v3.2 ===", "success");
                addToCLI("FEATURES: Unlimited Jetpack, Castle Templates, Unique Interior Objects", "success");
                addToCLI("Single Blocks: Sand, Stone, Grass, Wood, Brick, Wireframe", "info");
                addToCLI("Color wheel: Only affects NEW single blocks", "info");
                addToCLI("Type /help for commands or click ‚ùì HELP button", "response");
                
                // Set initial lighting mode
                updateLightingButton();
                
                // Enable jetpack by default
                updateJetpackStatus();
            }, 500);
            
            console.log("MICROCRAFT Castle Builder initialized!");
        }

        function setupLighting() {
            // Directional light (sun)
            sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 500;
            sunLight.shadow.camera.left = -100;
            sunLight.shadow.camera.right = 100;
            sunLight.shadow.camera.top = 100;
            sunLight.shadow.camera.bottom = -100;
            scene.add(sunLight);
            
            // Ambient light
            ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            // Add some initial torches for testing
            createTorch(5, 2, 5);
            createTorch(-5, 2, 5);
        }

        function createSimpleIsland() {
            // Create water plane
            const waterGeometry = new THREE.PlaneGeometry(WORLD_SIZE * BLOCK_SIZE * 2, WORLD_SIZE * BLOCK_SIZE * 2);
            const waterMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1E90FF,
                transparent: true,
                opacity: 0.7,
                roughness: 0.1
            });
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.y = -BLOCK_SIZE * 2;
            water.receiveShadow = true;
            scene.add(water);
            
            // Store ground plane reference for raycasting
            groundPlane = water;
            
            // Create simple circular sand island
            const islandRadius = 5;
            for (let x = -islandRadius; x <= islandRadius; x++) {
                for (let z = -islandRadius; z <= islandRadius; z++) {
                    const distance = Math.sqrt(x*x + z*z);
                    
                    if (distance <= islandRadius) {
                        createBlockAt('sand', x, 0, z);
                        
                        if (distance < islandRadius - 1 && Math.random() < 0.3) {
                            createBlockAt('grass', x, 1, z);
                        }
                    }
                }
            }
            
            // Add starter blocks
            createBlockAt('stone', 0, 1, 0);
            createBlockAt('stone', 1, 1, 0);
            createBlockAt('wood', 2, 1, 0);
            createBlockAt('brick', -1, 1, 0);
            createBlockAt('wireframe', 3, 1, 0);
            
            updateBlockCount();
        }

        // ========================================
        // UI FUNCTIONS
        // ========================================

        function updateBlockButtons() {
            document.querySelectorAll('.tool-button[data-block]').forEach(button => {
                const blockType = button.getAttribute('data-block');
                if (blockType === selectedBlock) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        function updateBlockCount() {
            document.getElementById('block-count').textContent = placedBlocks.size;
        }

        function updatePositionDisplay() {
            const x = Math.round(camera.position.x / BLOCK_SIZE);
            const y = Math.round(camera.position.y / BLOCK_SIZE);
            const z = Math.round(camera.position.z / BLOCK_SIZE);
            document.getElementById('pos-display').textContent = `${x},${y},${z}`;
        }

        function updateModeDisplay() {
            const modeText = currentMode.toUpperCase() + (isNightMode ? ' (NIGHT)' : '');
            document.getElementById('mode-display').textContent = modeText;
        }

        function updateModeButtons() {
            document.querySelectorAll('#main-panel .action-button').forEach(btn => {
                if (btn.id.endsWith('-mode')) {
                    btn.classList.remove('active');
                }
            });
            const activeButton = document.getElementById(`${currentMode}-mode`);
            if (activeButton) {
                activeButton.classList.add('active');
            }
        }

        function updateCrosshairs() {
            if (currentMode === 'edit' && selectedObject) {
                document.getElementById('crosshair').style.display = 'none';
                document.getElementById('editor-crosshair').style.display = 'block';
            } else {
                document.getElementById('crosshair').style.display = 'block';
                document.getElementById('editor-crosshair').style.display = 'none';
            }
        }

        function updateLightingButton() {
            const button = document.getElementById('lighting-toggle');
            if (isNightMode) {
                button.innerHTML = '<span class="button-icon">üåô</span> NIGHT';
            } else {
                button.innerHTML = '<span class="button-icon">‚òÄÔ∏è</span> DAY';
            }
        }

        function toggleLightingMode() {
            isNightMode = !isNightMode;
            
            if (isNightMode) {
                sunLight.intensity = 0.1;
                ambientLight.intensity = 0.1;
                scene.fog = new THREE.Fog(0x0a0a2a, 5, 30);
                scene.background = new THREE.Color(0x0a0a2a);
                addToCLI("Switched to NIGHT mode", "success");
                showNotification("Night mode activated!");
            } else {
                sunLight.intensity = 1.0;
                ambientLight.intensity = 0.4;
                scene.fog = new THREE.Fog(0x87CEEB, 10, 50);
                scene.background = new THREE.Color(0x87CEEB);
                addToCLI("Switched to DAY mode", "success");
                showNotification("Day mode activated!");
            }
            
            updateLightingButton();
            updateModeDisplay();
        }

        // ========================================
        // NOTIFICATION SYSTEM
        // ========================================

        function showNotification(message, duration = 2000) {
            const notification = document.getElementById('status-notification');
            notification.textContent = message;
            notification.style.display = 'block';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, duration);
        }

        // ========================================
        // GHOST OBJECT SYSTEM
        // ========================================

        function createGhostObject(objectData, objectName, type) {
            clearGhostObject();
            
            ghostObjectData = objectData;
            ghostObjectName = objectName;
            ghostObjectType = type;
            ghostBaseYOffset = 0;
            
            ghostObject = new THREE.Group();
            
            objectData.blocks.forEach(block => {
                const geometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                const color = BLOCKS[block.type]?.color || 0x808080;
                
                let material = new THREE.MeshStandardMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.4,
                    roughness: 0.8,
                    metalness: 0,
                    depthWrite: false
                });
                
                const ghostBlock = new THREE.Mesh(geometry, material);
                ghostBlock.position.set(
                    block.x * BLOCK_SIZE,
                    block.y * BLOCK_SIZE,
                    block.z * BLOCK_SIZE
                );
                
                ghostBlock.userData = { isGhost: true };
                ghostObject.add(ghostBlock);
            });
            
            ghostObject.visible = false;
            scene.add(ghostObject);
            
            updateGhostObjectInfo(0, 0, 0, false);
            
            addToCLI(`Ghost preview: ${objectData.name}`, "success");
            showNotification(`Previewing ${objectData.name}. LMB to place, RMB/Q/ESC to cancel.`);
        }

        function updateGhostObjectPosition() {
            if (!ghostObject) return;
            
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(camera.quaternion);
            raycaster.set(camera.position, direction);
            
            const intersectableObjects = Array.from(placedBlocks.values());
            intersectableObjects.push(groundPlane);
            
            const intersects = raycaster.intersectObjects(intersectableObjects);
            
            if (intersects.length === 0) {
                ghostObject.visible = false;
                ghostPlacementValid = false;
                return;
            }
            
            const intersect = intersects[0];
            let baseX, baseY, baseZ;
            
            if (intersect.object === groundPlane) {
                const point = intersect.point;
                baseX = Math.round(point.x / BLOCK_SIZE);
                baseY = Math.round(point.y / BLOCK_SIZE);
                baseZ = Math.round(point.z / BLOCK_SIZE);
                baseY = Math.max(baseY, 0);
            } else {
                const normal = intersect.face.normal.clone();
                const block = intersect.object;
                const blockData = block.userData;
                
                baseX = blockData.x + Math.round(normal.x);
                baseY = blockData.y + Math.round(normal.y);
                baseZ = blockData.z + Math.round(normal.z);
                
                if (normal.y > 0) {
                    baseY = blockData.y + Math.ceil(blockData.scale.y);
                }
            }
            
            baseY += ghostBaseYOffset;
            
            let canPlace = true;
            const occupiedPositions = [];
            
            ghostObjectData.blocks.forEach(block => {
                const x = baseX + block.x;
                const y = baseY + block.y;
                const z = baseZ + block.z;
                const key = `${x},${y},${z}`;
                
                if (placedBlocks.has(key) || placedObjects.has(key)) {
                    canPlace = false;
                    occupiedPositions.push({x, y, z});
                }
            });
            
            ghostObject.position.set(
                baseX * BLOCK_SIZE,
                baseY * BLOCK_SIZE,
                baseZ * BLOCK_SIZE
            );
            
            ghostObject.children.forEach((child, index) => {
                if (child.userData.isGhost) {
                    const blockType = ghostObjectData.blocks[index].type;
                    const pos = {
                        x: baseX + ghostObjectData.blocks[index].x,
                        y: baseY + ghostObjectData.blocks[index].y,
                        z: baseZ + ghostObjectData.blocks[index].z
                    };
                    const key = `${pos.x},${pos.y},${pos.z}`;
                    
                    if (placedBlocks.has(key) || placedObjects.has(key)) {
                        child.material.color.set(0xff0000);
                        child.material.opacity = 0.6;
                    } else {
                        const originalColor = BLOCKS[blockType]?.color || 0x808080;
                        child.material.color.set(originalColor);
                        child.material.opacity = 0.4;
                    }
                }
            });
            
            ghostObject.visible = true;
            ghostPlacementValid = canPlace;
            
            updateGhostObjectInfo(baseX, baseY, baseZ, canPlace, occupiedPositions);
        }

        function updateGhostObjectInfo(baseX, baseY, baseZ, isValid, occupiedPositions = []) {
            const infoElement = document.getElementById('ghost-object-info');
            const nameElement = document.getElementById('ghost-name');
            const iconElement = document.getElementById('ghost-icon');
            
            if (ghostObjectData) {
                const posText = ` at ${baseX},${baseY},${baseZ}`;
                const statusText = isValid ? 
                    ` (READY - Click to place)` : 
                    ` (BLOCKED - ${occupiedPositions.length} space(s) occupied)`;
                
                nameElement.textContent = `${ghostObjectData.name}${posText}${statusText}`;
                iconElement.textContent = isValid ? 'üëª' : '‚ùå';
                
                infoElement.style.display = 'block';
                infoElement.style.borderColor = isValid ? 
                    'rgba(0, 255, 0, 0.6)' : 'rgba(255, 0, 0, 0.6)';
                infoElement.style.background = isValid ? 
                    'rgba(0, 0, 0, 0.8)' : 'rgba(50, 0, 0, 0.8)';
            } else {
                infoElement.style.display = 'none';
            }
        }

        function placeGhostObject() {
            if (!ghostObject || !ghostPlacementValid) return false;
            
            const baseX = Math.round(ghostObject.position.x / BLOCK_SIZE);
            const baseY = Math.round(ghostObject.position.y / BLOCK_SIZE);
            const baseZ = Math.round(ghostObject.position.z / BLOCK_SIZE);
            
            let success = false;
            if (ghostObjectType === 'building') {
                success = placeBuildingInternal(ghostObjectName, baseX, baseY, baseZ);
            } else if (ghostObjectType === 'interior') {
                success = placeInteriorInternal(ghostObjectName, baseX, baseY, baseZ);
            }
            
            if (success) {
                ghostBaseYOffset = 0;
                updateGhostObjectPosition();
                
                setTimeout(() => {
                    selectBlock('stone');
                }, 100);
                
                return true;
            }
            
            return false;
        }

        function clearGhostObject() {
            if (ghostObject) {
                scene.remove(ghostObject);
                ghostObject = null;
            }
            
            ghostObjectData = null;
            ghostObjectName = null;
            ghostObjectType = null;
            ghostPlacementValid = false;
            ghostBaseYOffset = 0;
            
            document.getElementById('ghost-object-info').style.display = 'none';
        }

        // ========================================
        // INTERIOR OBJECT PLACEMENT
        // ========================================

        function placeInteriorInternal(objectName, baseX, baseY, baseZ) {
            const interior = INTERIOR_OBJECTS[objectName];
            if (!interior) {
                addToCLI(`Interior object not found: ${objectName}`, "error");
                return false;
            }
            
            const key = `interior_${baseX},${baseY},${baseZ}`;
            if (placedBlocks.has(key) || placedObjects.has(key)) {
                addToCLI("Space occupied!", "error");
                return false;
            }
            
            const interiorObject = interior.create(baseX, baseY, baseZ);
            if (interiorObject) {
                interiorObject.userData = {
                    type: objectName,
                    name: interior.name,
                    x: baseX,
                    y: baseY,
                    z: baseZ,
                    key: key,
                    isInterior: true
                };
                
                placedObjects.set(key, interiorObject);
                
                addToUndoStack({
                    type: 'place_interior',
                    object: {
                        type: objectName,
                        x: baseX,
                        y: baseY,
                        z: baseZ,
                        key: key
                    }
                });
                
                addToCLI(`Placed ${interior.name}`, "success");
                showNotification(`${interior.name} placed!`);
                return true;
            }
            
            return false;
        }

        // ========================================
        // MINING FUNCTION
        // ========================================

        function mineBlock() {
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(camera.quaternion);
            raycaster.set(camera.position, direction);
            
            // Check interior objects first
            const interiorObjects = Array.from(placedObjects.values());
            const interiorIntersects = raycaster.intersectObjects(interiorObjects, true);
            
            if (interiorIntersects.length > 0) {
                const interior = interiorIntersects[0].object.parent;
                const interiorData = interior.userData;
                
                if (interiorData) {
                    scene.remove(interior);
                    placedObjects.delete(interiorData.key);
                    
                    addToUndoStack({
                        type: 'mine_interior',
                        object: {
                            type: interiorData.type,
                            x: interiorData.x,
                            y: interiorData.y,
                            z: interiorData.z,
                            key: interiorData.key
                        }
                    });
                    
                    addToCLI(`Removed ${interiorData.name || interiorData.type}`, "success");
                    return interiorData.type;
                }
            }
            
            // Check regular blocks
            const blocks = Array.from(placedBlocks.values());
            const blockIntersects = raycaster.intersectObjects(blocks);
            
            if (blockIntersects.length > 0) {
                const block = blockIntersects[0].object;
                const blockData = block.userData;
                
                // Remove from group if applicable
                if (blockData.groupId) {
                    const group = objectGroups.get(blockData.groupId);
                    if (group) {
                        group.members = group.members.filter(key => key !== blockData.key);
                        if (group.members.length === 0) {
                            objectGroups.delete(blockData.groupId);
                        }
                    }
                }
                
                addToUndoStack({
                    type: 'mine',
                    block: {
                        type: blockData.type,
                        x: blockData.x,
                        y: blockData.y,
                        z: blockData.z,
                        key: blockData.key,
                        groupId: blockData.groupId
                    }
                });
                
                scene.remove(block);
                placedBlocks.delete(blockData.key);
                updateBlockCount();
                
                // If this was the selected object, clear selection
                if (selectedObject === block) {
                    hideEditorGizmo();
                    selectedObject = null;
                    selectedGroup = null;
                }
                
                return blockData.type;
            }
            return null;
        }

        // ========================================
        // LIBRARY FUNCTIONS
        // ========================================

        function selectBuildingForPreview(buildingName) {
            if (!BUILDINGS[buildingName]) {
                addToCLI(`Building not found: ${buildingName}`, "error");
                showNotification(`Building "${buildingName}" not found!`);
                return false;
            }

            const building = BUILDINGS[buildingName];
            createGhostObject(building, buildingName, 'building');
            
            toggleMode('build');
            toggleLibrary(null);
            
            addToCLI(`Previewing: ${building.name}. Click to place, Q/ESC to cancel.`, "success");
            return true;
        }

        function selectInteriorForPreview(objectName) {
            if (!INTERIOR_OBJECTS[objectName]) {
                addToCLI(`Interior object not found: ${objectName}`, "error");
                showNotification(`Interior object "${objectName}" not found!`);
                return false;
            }

            const interior = INTERIOR_OBJECTS[objectName];
            
            toggleMode('build');
            toggleLibrary(null);
            
            addToCLI(`Selected: ${interior.name}. Click to place.`, "success");
            return true;
        }

        function toggleLibrary(library) {
            const buildingsPanel = document.getElementById('library-buildings');
            const interiorPanel = document.getElementById('library-interior');
            
            if (libraryVisible === library) {
                buildingsPanel.style.display = 'none';
                interiorPanel.style.display = 'none';
                libraryVisible = null;
            } else {
                if (library === 'buildings') {
                    buildingsPanel.style.display = 'block';
                    interiorPanel.style.display = 'none';
                } else if (library === 'interior') {
                    buildingsPanel.style.display = 'none';
                    interiorPanel.style.display = 'block';
                }
                libraryVisible = library;
                
                toggleCLI(false);
                hideHelp();
            }
        }

        function placeBuildingInternal(buildingName, baseX, baseY, baseZ) {
            const building = BUILDINGS[buildingName];
            return placeObjectGroup(building, buildingName, baseX, baseY, baseZ);
        }

        function placeObjectGroup(objectData, groupName, baseX, baseY, baseZ) {
            const groupId = `group_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            const placedBlocksList = [];
            let successCount = 0;
            
            const positionsToCheck = [];
            objectData.blocks.forEach(block => {
                const x = baseX + block.x;
                const y = baseY + block.y;
                const z = baseZ + block.z;
                const key = `${x},${y},${z}`;
                positionsToCheck.push({key: key, block: block, x: x, y: y, z: z});
            });
            
            const occupiedPositions = positionsToCheck.filter(pos => placedBlocks.has(pos.key) || placedObjects.has(pos.key));
            if (occupiedPositions.length > 0) {
                addToCLI(`Cannot place ${objectData.name}: ${occupiedPositions.length} positions occupied`, "error");
                showNotification("Space occupied! Cannot place.");
                return false;
            }
            
            positionsToCheck.forEach(pos => {
                const newBlock = createBlockAt(pos.block.type, pos.x, pos.y, pos.z);
                if (newBlock) {
                    newBlock.userData.isGrouped = true;
                    newBlock.userData.groupId = groupId;
                    placedBlocksList.push({
                        type: pos.block.type,
                        x: pos.x,
                        y: pos.y,
                        z: pos.z,
                        key: pos.key
                    });
                    successCount++;
                }
            });
            
            if (successCount > 0) {
                objectGroups.set(groupId, {
                    id: groupId,
                    name: groupName,
                    type: objectData.type,
                    base: {x: baseX, y: baseY, z: baseZ},
                    members: placedBlocksList.map(b => b.key)
                });
                
                addToUndoStack({
                    type: 'group',
                    groupId: groupId,
                    groupData: objectData,
                    blocks: placedBlocksList,
                    base: {x: baseX, y: baseY, z: baseZ}
                });
                
                addToCLI(`Placed ${objectData.name} (${successCount} blocks)`, "success");
                showNotification(`${objectData.name} placed!`);
                return true;
            } else {
                addToCLI("Failed to place object", "error");
                showNotification("Failed to place object");
                return false;
            }
        }

        // ========================================
        // EDITOR FUNCTIONS
        // ========================================

        function selectObject() {
            if (currentMode !== 'edit') return null;
            
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(camera.quaternion);
            raycaster.set(camera.position, direction);
            
            const interiorObjects = Array.from(placedObjects.values());
            const interiorIntersects = raycaster.intersectObjects(interiorObjects, true);
            
            if (interiorIntersects.length > 0) {
                selectedObject = interiorIntersects[0].object.parent;
                showEditorGizmo();
                updateEditorControls();
                updateCrosshairs();
                
                originalObjectState = {
                    position: {x: selectedObject.position.x, y: selectedObject.position.y, z: selectedObject.position.z},
                    scale: {x: selectedObject.scale.x, y: selectedObject.scale.y, z: selectedObject.scale.z},
                    rotation: {x: selectedObject.rotation.x, y: selectedObject.rotation.y, z: selectedObject.rotation.z}
                };
                
                selectedGroup = null;
                
                addToCLI(`Selected: ${selectedObject.userData.name || selectedObject.userData.type}`, "success");
                return selectedObject;
            }
            
            const blocks = Array.from(placedBlocks.values());
            const blockIntersects = raycaster.intersectObjects(blocks);
            
            if (blockIntersects.length > 0) {
                selectedObject = blockIntersects[0].object;
                showEditorGizmo();
                updateEditorControls();
                updateCrosshairs();
                
                originalObjectState = {
                    position: {x: selectedObject.position.x, y: selectedObject.position.y, z: selectedObject.position.z},
                    scale: {x: selectedObject.scale.x, y: selectedObject.scale.y, z: selectedObject.scale.z},
                    rotation: {x: selectedObject.rotation.x, y: selectedObject.rotation.y, z: selectedObject.rotation.z}
                };
                
                if (selectedObject.userData.groupId) {
                    selectedGroup = objectGroups.get(selectedObject.userData.groupId);
                } else {
                    selectedGroup = null;
                }
                
                addToCLI(`Selected: ${selectedObject.userData.type}`, "success");
                return selectedObject;
            }
            
            hideEditorGizmo();
            selectedObject = null;
            selectedGroup = null;
            return null;
        }

        function showEditorGizmo() {
            if (!selectedObject) return;
            
            const gizmo = document.getElementById('editor-gizmo');
            gizmo.style.display = 'block';
            updateGizmoPosition();
            
            document.getElementById('editor-controls').style.display = 'flex';
        }

        function hideEditorGizmo() {
            const gizmo = document.getElementById('editor-gizmo');
            gizmo.style.display = 'none';
            const controls = document.getElementById('editor-controls');
            controls.style.display = 'none';
        }

        function updateGizmoPosition() {
            if (!selectedObject) return;
            
            const gizmo = document.getElementById('editor-gizmo');
            const vector = new THREE.Vector3();
            
            vector.copy(selectedObject.position);
            vector.project(camera);
            
            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
            
            gizmo.style.left = (x - 50) + 'px';
            gizmo.style.top = (y - 50) + 'px';
        }

        function selectGizmoMode(mode) {
            gizmoMode = mode;
            document.querySelectorAll('[data-gizmo]').forEach(btn => btn.classList.remove('active'));
            const button = document.querySelector(`[data-gizmo="${mode}"]`);
            if (button) button.classList.add('active');
            addToCLI(`Gizmo mode: ${mode}`, "response");
        }

        function initEditorControls() {
            ['edit-pos-x', 'edit-pos-y', 'edit-pos-z'].forEach(id => {
                document.getElementById(id).addEventListener('change', function() {
                    if (selectedObject) {
                        const x = parseFloat(document.getElementById('edit-pos-x').value) * BLOCK_SIZE;
                        const y = parseFloat(document.getElementById('edit-pos-y').value) * BLOCK_SIZE;
                        const z = parseFloat(document.getElementById('edit-pos-z').value) * BLOCK_SIZE;
                        
                        if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                            selectedObject.position.set(x, y, z);
                            updateGizmoPosition();
                        }
                    }
                });
            });

            ['edit-scale-x', 'edit-scale-y', 'edit-scale-z'].forEach(id => {
                document.getElementById(id).addEventListener('change', function() {
                    if (selectedObject) {
                        const sx = parseFloat(document.getElementById('edit-scale-x').value);
                        const sy = parseFloat(document.getElementById('edit-scale-y').value);
                        const sz = parseFloat(document.getElementById('edit-scale-z').value);
                        
                        if (!isNaN(sx) && !isNaN(sy) && !isNaN(sz) && sx > 0 && sy > 0 && sz > 0) {
                            selectedObject.scale.set(sx, sy, sz);
                        }
                    }
                });
            });

            ['edit-rot-x', 'edit-rot-y', 'edit-rot-z'].forEach(id => {
                document.getElementById(id).addEventListener('change', function() {
                    if (selectedObject) {
                        const rx = parseFloat(document.getElementById('edit-rot-x').value) * (Math.PI / 180);
                        const ry = parseFloat(document.getElementById('edit-rot-y').value) * (Math.PI / 180);
                        const rz = parseFloat(document.getElementById('edit-rot-z').value) * (Math.PI / 180);
                        
                        if (!isNaN(rx) && !isNaN(ry) && !isNaN(rz)) {
                            selectedObject.rotation.set(rx, ry, rz);
                        }
                    }
                });
            });
        }

        function updateEditorControls() {
            if (!selectedObject) return;

            document.getElementById('edit-pos-x').value = (selectedObject.position.x / BLOCK_SIZE).toFixed(1);
            document.getElementById('edit-pos-y').value = (selectedObject.position.y / BLOCK_SIZE).toFixed(1);
            document.getElementById('edit-pos-z').value = (selectedObject.position.z / BLOCK_SIZE).toFixed(1);
            
            document.getElementById('edit-scale-x').value = selectedObject.scale.x.toFixed(1);
            document.getElementById('edit-scale-y').value = selectedObject.scale.y.toFixed(1);
            document.getElementById('edit-scale-z').value = selectedObject.scale.z.toFixed(1);
            
            document.getElementById('edit-rot-x').value = (selectedObject.rotation.x * (180/Math.PI)).toFixed(0);
            document.getElementById('edit-rot-y').value = (selectedObject.rotation.y * (180/Math.PI)).toFixed(0);
            document.getElementById('edit-rot-z').value = (selectedObject.rotation.z * (180/Math.PI)).toFixed(0);
        }

        function applyEditorChanges() {
            if (!selectedObject) {
                addToCLI("No object selected to apply changes", "error");
                showNotification("No object selected!");
                return;
            }

            const originalState = {
                position: {x: selectedObject.position.x, y: selectedObject.position.y, z: selectedObject.position.z},
                scale: {x: selectedObject.scale.x, y: selectedObject.scale.y, z: selectedObject.scale.z},
                rotation: {x: selectedObject.rotation.x, y: selectedObject.rotation.y, z: selectedObject.rotation.z}
            };

            const newX = parseFloat(document.getElementById('edit-pos-x').value) * BLOCK_SIZE;
            const newY = parseFloat(document.getElementById('edit-pos-y').value) * BLOCK_SIZE;
            const newZ = parseFloat(document.getElementById('edit-pos-z').value) * BLOCK_SIZE;
            
            const newScaleX = parseFloat(document.getElementById('edit-scale-x').value);
            const newScaleY = parseFloat(document.getElementById('edit-scale-y').value);
            const newScaleZ = parseFloat(document.getElementById('edit-scale-z').value);
            
            const newRotX = parseFloat(document.getElementById('edit-rot-x').value) * (Math.PI / 180);
            const newRotY = parseFloat(document.getElementById('edit-rot-y').value) * (Math.PI / 180);
            const newRotZ = parseFloat(document.getElementById('edit-rot-z').value) * (Math.PI / 180);

            selectedObject.position.set(
                !isNaN(newX) ? newX : selectedObject.position.x,
                !isNaN(newY) ? newY : selectedObject.position.y,
                !isNaN(newZ) ? newZ : selectedObject.position.z
            );
            
            selectedObject.scale.set(
                !isNaN(newScaleX) ? newScaleX : selectedObject.scale.x,
                !isNaN(newScaleY) ? newScaleY : selectedObject.scale.y,
                !isNaN(newScaleZ) ? newScaleZ : selectedObject.scale.z
            );
            
            selectedObject.rotation.set(
                !isNaN(newRotX) ? newRotX : selectedObject.rotation.x,
                !isNaN(newRotY) ? newRotY : selectedObject.rotation.y,
                !isNaN(newRotZ) ? newRotZ : selectedObject.rotation.z
            );

            selectedObject.userData.scale = {
                x: selectedObject.scale.x,
                y: selectedObject.scale.y,
                z: selectedObject.scale.z
            };
            
            selectedObject.userData.rotation = {
                x: selectedObject.rotation.x,
                y: selectedObject.rotation.y,
                z: selectedObject.rotation.z
            };

            addToUndoStack({
                type: 'edit',
                objectKey: selectedObject.userData.key,
                originalState: originalState,
                newState: {
                    position: {x: selectedObject.position.x, y: selectedObject.position.y, z: selectedObject.position.z},
                    scale: {x: selectedObject.scale.x, y: selectedObject.scale.y, z: selectedObject.scale.z},
                    rotation: {x: selectedObject.rotation.x, y: selectedObject.rotation.y, z: selectedObject.rotation.z}
                }
            });

            addToCLI("Changes applied to selected object", "success");
            showNotification("Changes applied!");
            updateGizmoPosition();
        }

        function resetEditorChanges() {
            if (!selectedObject || !originalObjectState) {
                addToCLI("No changes to reset", "error");
                showNotification("Nothing to reset!");
                return;
            }

            selectedObject.position.copy(originalObjectState.position);
            selectedObject.scale.copy(originalObjectState.scale);
            selectedObject.rotation.copy(originalObjectState.rotation);
            
            updateEditorControls();
            updateGizmoPosition();
            
            addToCLI("Changes reset to original state", "success");
            showNotification("Changes reset!");
        }

        function exitEditMode() {
            if (currentMode === 'edit') {
                toggleMode('build');
                addToCLI("Exited edit mode", "success");
                showNotification("Exited edit mode");
            }
        }

        // ========================================
        // UNDO FUNCTIONALITY
        // ========================================

        function addToUndoStack(action) {
            undoStack.push(action);
            if (undoStack.length > MAX_UNDO_HISTORY) {
                undoStack.shift();
            }
        }

        function undoAction() {
            if (undoStack.length === 0) {
                addToCLI("Nothing to undo", "response");
                showNotification("Nothing to undo!");
                return;
            }
            
            const lastAction = undoStack.pop();
            
            if (lastAction.type === 'place_interior') {
                const interior = placedObjects.get(lastAction.object.key);
                if (interior) {
                    scene.remove(interior);
                    placedObjects.delete(lastAction.object.key);
                    addToCLI(`Undo: Removed ${lastAction.object.type}`, "response");
                    showNotification("Undo: Interior object removed");
                }
            } else if (lastAction.type === 'mine_interior') {
                const interior = INTERIOR_OBJECTS[lastAction.object.type];
                if (interior) {
                    interior.create(lastAction.object.x, lastAction.object.y, lastAction.object.z);
                    addToCLI(`Undo: Restored ${lastAction.object.type}`, "response");
                    showNotification("Undo: Interior object restored");
                }
            } else if (lastAction.type === 'place') {
                const block = placedBlocks.get(lastAction.block.key);
                if (block) {
                    scene.remove(block);
                    placedBlocks.delete(lastAction.block.key);
                    updateBlockCount();
                    addToCLI(`Undo: Removed ${lastAction.block.type}`, "response");
                    showNotification("Undo: Block removed");
                }
            } else if (lastAction.type === 'mine') {
                createBlockAt(
                    lastAction.block.type,
                    lastAction.block.x,
                    lastAction.block.y,
                    lastAction.block.z
                );
                addToCLI(`Undo: Restored ${lastAction.block.type}`, "response");
                showNotification("Undo: Block restored");
            } else if (lastAction.type === 'group') {
                let removedCount = 0;
                lastAction.blocks.forEach(blockData => {
                    const block = placedBlocks.get(blockData.key);
                    if (block) {
                        scene.remove(block);
                        placedBlocks.delete(blockData.key);
                        removedCount++;
                    }
                });
                updateBlockCount();
                objectGroups.delete(lastAction.groupId);
                addToCLI(`Undo: Removed ${lastAction.groupData.name} (${removedCount} blocks)`, "response");
                showNotification(`Undo: ${lastAction.groupData.name} removed`);
            } else if (lastAction.type === 'edit') {
                const block = placedBlocks.get(lastAction.objectKey);
                if (block && lastAction.originalState) {
                    block.position.copy(lastAction.originalState.position);
                    block.scale.copy(lastAction.originalState.scale);
                    block.rotation.copy(lastAction.originalState.rotation);
                    if (selectedObject === block) {
                        updateEditorControls();
                        updateGizmoPosition();
                    }
                    addToCLI(`Undo: Reverted edit`, "response");
                    showNotification("Undo: Edit reverted");
                }
            }
        }

        // ========================================
        // ENHANCED EVENT LISTENERS WITH JETPACK FIX
        // ========================================

        function setupEventListeners() {
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                
                // JETPACK FIX: SHIFT activates jetpack when in air AND enabled
                if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                    if (!isOnGround && jetpackEnabled) {
                        jetpackActive = true;
                        updateJetpackStatus();
                        addToCLI("Jetpack: ACTIVATED (hold SHIFT to fly)", "info");
                    }
                    isSprinting = true;
                }
                
                if (e.code === 'Space' && isOnGround) {
                    verticalVelocity = JUMP_FORCE;
                    isOnGround = false;
                }
                
                // Tilde key toggles CLI
                if (e.code === 'Backquote') {
                    e.preventDefault();
                    toggleCLI();
                }
                
                // B key toggles building panel
                if (e.code === 'KeyB') {
                    e.preventDefault();
                    toggleLibrary('buildings');
                }
                
                // I key toggles interior panel
                if (e.code === 'KeyI') {
                    e.preventDefault();
                    toggleLibrary('interior');
                }
                
                // U key for undo
                if (e.code === 'KeyU') {
                    e.preventDefault();
                    undoAction();
                }
                
                // H key for help
                if (e.code === 'KeyH') {
                    e.preventDefault();
                    showHelp();
                }
                
                // L key for lighting toggle
                if (e.code === 'KeyL') {
                    e.preventDefault();
                    toggleLightingMode();
                }
                
                // E key for edit mode
                if (e.code === 'KeyE') {
                    e.preventDefault();
                    toggleMode('edit');
                }
                
                // T key for torch mode
                if (e.code === 'KeyT') {
                    e.preventDefault();
                    toggleMode('torch');
                }
                
                // J key for jetpack toggle
                if (e.code === 'KeyJ') {
                    e.preventDefault();
                    toggleJetpack();
                }
                
                // Q key to cancel ghost preview
                if (e.code === 'KeyQ') {
                    e.preventDefault();
                    if (ghostObject) {
                        clearGhostObject();
                        addToCLI("Ghost preview cancelled", "response");
                        showNotification("Preview cancelled - Switched to block mode");
                        toggleMode('build');
                        selectBlock('stone');
                    }
                }
                
                // Escape key
                if (e.code === 'Escape') {
                    if (isPointerLocked) {
                        unlockPointer();
                    } else {
                        if (ghostObject) {
                            clearGhostObject();
                            showNotification("Preview cancelled - Switched to block mode");
                            toggleMode('build');
                            selectBlock('stone');
                        }
                        hideHelp();
                        toggleLibrary(null);
                        toggleCLI(false);
                        if (currentMode === 'edit') {
                            exitEditMode();
                        }
                        // Deactivate jetpack
                        if (jetpackActive) {
                            jetpackActive = false;
                            updateJetpackStatus();
                        }
                    }
                }
                
                // Number keys for block selection (1-6)
                if (e.code >= 'Digit1' && e.code <= 'Digit6') {
                    const blocks = Object.keys(BLOCKS);
                    const index = parseInt(e.code[5]) - 1;
                    if (blocks[index]) {
                        selectBlock(blocks[index]);
                    }
                }
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
                
                // JETPACK FIX: Release SHIFT deactivates jetpack
                if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                    jetpackActive = false;
                    isSprinting = false;
                    updateJetpackStatus();
                    if (!isOnGround) {
                        addToCLI("Jetpack: DEACTIVATED", "info");
                    }
                }
            });
            
            // Mouse controls
            document.addEventListener('mousedown', (e) => {
                if (!isPointerLocked) return;
                
                if (e.button === 0) { // Left click
                    switch(currentMode) {
                        case 'build':
                            placeBlock();
                            break;
                        case 'edit':
                            selectObject();
                            break;
                        case 'torch':
                            placeTorch();
                            break;
                    }
                } else if (e.button === 2) { // Right click
                    switch(currentMode) {
                        case 'build':
                        case 'edit':
                            if (ghostObject) {
                                clearGhostObject();
                                addToCLI("Ghost preview cancelled", "response");
                                showNotification("Preview cancelled - Switched to block mode");
                                toggleMode('build');
                                selectBlock('stone');
                            } else {
                                mineBlock();
                            }
                            break;
                    }
                }
            });
            
            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
            
            // Mouse movement
            document.addEventListener('mousemove', (e) => {
                if (!isPointerLocked) return;
                
                const movementX = e.movementX || 0;
                const movementY = e.movementY || 0;
                
                yaw -= movementX * LOOK_SENSITIVITY;
                pitch -= movementY * LOOK_SENSITIVITY;
                pitch = Math.max(-MAX_PITCH, Math.min(MAX_PITCH, pitch));
                
                if (selectedObject) {
                    updateGizmoPosition();
                }
            });
            
            // Mouse wheel
            document.addEventListener('wheel', (e) => {
                if (!isPointerLocked) return;
                
                e.preventDefault();
                
                if (ghostObject) {
                    const delta = e.deltaY > 0 ? -1 : 1;
                    ghostBaseYOffset += delta;
                    updateGhostObjectPosition();
                } else if (currentMode === 'build') {
                    const blocks = Object.keys(BLOCKS);
                    let currentIndex = blocks.indexOf(selectedBlock);
                    
                    if (e.deltaY > 0) {
                        currentIndex = (currentIndex + 1) % blocks.length;
                    } else {
                        currentIndex = (currentIndex - 1 + blocks.length) % blocks.length;
                    }
                    
                    selectBlock(blocks[currentIndex]);
                }
            });
            
            // Pointer lock
            const container = document.getElementById('container');
            container.addEventListener('click', () => {
                if (!isPointerLocked) {
                    lockPointer();
                }
            });
            
            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === container;
                document.body.style.cursor = isPointerLocked ? 'none' : 'auto';
            });
            
            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                if (selectedObject) {
                    updateGizmoPosition();
                }
            });
        }

        function lockPointer() {
            const container = document.getElementById('container');
            container.requestPointerLock();
        }

        function unlockPointer() {
            document.exitPointerLock();
        }

        // ========================================
        // ENHANCED MOVEMENT AND PHYSICS WITH JETPACK
        // ========================================

        function updateMovement(deltaTime) {
            if (!isPointerLocked) return;
            
            camera.rotation.order = 'YXZ';
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;
            
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(camera.quaternion);
            forward.y = 0;
            forward.normalize();
            
            const right = new THREE.Vector3(1, 0, 0);
            right.applyQuaternion(camera.quaternion);
            right.y = 0;
            right.normalize();
            
            const move = new THREE.Vector3();
            
            if (keys['KeyW']) {
                move.add(forward);
            }
            if (keys['KeyS']) {
                move.sub(forward);
            }
            if (keys['KeyA']) {
                move.sub(right);
            }
            if (keys['KeyD']) {
                move.add(right);
            }
            
            if (move.length() > 0) {
                move.normalize();
                
                const speed = isSprinting ? SPRINT_SPEED : MOVE_SPEED;
                const moveDistance = speed * deltaTime;
                
                camera.position.add(move.multiplyScalar(moveDistance));
            }
            
            // Apply gravity
            verticalVelocity -= GRAVITY * deltaTime;
            
            // Update jetpack
            updateJetpack(deltaTime);
            
            const playerHeight = 1.8;
            const playerRadius = 0.3;
            const nextY = camera.position.y + verticalVelocity * deltaTime;
            
            let canMoveDown = true;
            const playerBottom = nextY - playerHeight/2;
            
            // Check collision with blocks
            placedBlocks.forEach(block => {
                const blockPos = block.position;
                const blockSize = BLOCK_SIZE * Math.max(block.scale.x, block.scale.y, block.scale.z);
                
                if (Math.abs(camera.position.x - blockPos.x) < playerRadius + blockSize/2 &&
                    Math.abs(camera.position.z - blockPos.z) < playerRadius + blockSize/2) {
                    
                    const blockTop = blockPos.y + blockSize/2;
                    const blockBottom = blockPos.y - blockSize/2;
                    
                    if (playerBottom <= blockTop && camera.position.y >= blockBottom) {
                        if (verticalVelocity < 0 && playerBottom > blockBottom) {
                            camera.position.y = blockTop + playerHeight/2;
                            verticalVelocity = 0;
                            isOnGround = true;
                            canMoveDown = false;
                            
                            // Deactivate jetpack when landing
                            if (jetpackActive) {
                                jetpackActive = false;
                                updateJetpackStatus();
                            }
                        } else if (verticalVelocity > 0 && camera.position.y < blockTop) {
                            verticalVelocity = 0;
                        }
                    }
                }
            });
            
            // Check collision with interior objects
            placedObjects.forEach(object => {
                const objectPos = object.position;
                const objectSize = 0.5;
                
                if (Math.abs(camera.position.x - objectPos.x) < playerRadius + objectSize/2 &&
                    Math.abs(camera.position.z - objectPos.z) < playerRadius + objectSize/2) {
                    
                    const objectTop = objectPos.y + objectSize/2;
                    const objectBottom = objectPos.y - objectSize/2;
                    
                    if (playerBottom <= objectTop && camera.position.y >= objectBottom) {
                        if (verticalVelocity < 0 && playerBottom > objectBottom) {
                            camera.position.y = objectTop + playerHeight/2;
                            verticalVelocity = 0;
                            isOnGround = true;
                            canMoveDown = false;
                            
                            if (jetpackActive) {
                                jetpackActive = false;
                                updateJetpackStatus();
                            }
                        } else if (verticalVelocity > 0 && camera.position.y < objectTop) {
                            verticalVelocity = 0;
                        }
                    }
                }
            });
            
            if (canMoveDown) {
                camera.position.y = nextY;
                isOnGround = false;
            }
            
            if (camera.position.y < 1.0) {
                camera.position.y = 1.0;
                verticalVelocity = 0;
                isOnGround = true;
                
                if (jetpackActive) {
                    jetpackActive = false;
                    updateJetpackStatus();
                }
            }
            
            updatePositionDisplay();
        }

        // ========================================
        // BLOCK PLACEMENT FUNCTION
        // ========================================

        function placeBlock() {
            // If we have a ghost object, place it instead
            if (ghostObject && ghostPlacementValid) {
                return placeGhostObject();
            }
            
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(camera.quaternion);
            raycaster.set(camera.position, direction);
            
            const intersectableObjects = Array.from(placedBlocks.values());
            intersectableObjects.push(groundPlane);
            
            const intersects = raycaster.intersectObjects(intersectableObjects);
            
            if (intersects.length > 0) {
                const intersect = intersects[0];
                let x, y, z;
                
                if (intersect.object === groundPlane) {
                    const point = intersect.point;
                    x = Math.round(point.x / BLOCK_SIZE);
                    y = Math.round(point.y / BLOCK_SIZE);
                    z = Math.round(point.z / BLOCK_SIZE);
                    y = Math.max(y, 0);
                } else {
                    const normal = intersect.face.normal.clone();
                    const block = intersect.object;
                    const blockData = block.userData;
                    
                    x = blockData.x + Math.round(normal.x);
                    y = blockData.y + Math.round(normal.y);
                    z = blockData.z + Math.round(normal.z);
                }
                
                const key = `${x},${y},${z}`;
                if (!placedBlocks.has(key) && !placedObjects.has(key)) {
                    const newBlock = createBlockAt(selectedBlock, x, y, z);
                    
                    if (newBlock) {
                        addToUndoStack({
                            type: 'place',
                            block: {
                                type: selectedBlock,
                                x: x,
                                y: y,
                                z: z,
                                key: key
                            }
                        });
                        
                        return true;
                    }
                }
            }
            return false;
        }

        // ========================================
        // TORCH PLACEMENT FUNCTION
        // ========================================

        function placeTorch() {
            if (currentMode !== 'torch') return;
            
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(camera.quaternion);
            raycaster.set(camera.position, direction);
            
            const intersectableObjects = Array.from(placedBlocks.values());
            intersectableObjects.push(groundPlane);
            
            const intersects = raycaster.intersectObjects(intersectableObjects);
            
            if (intersects.length > 0) {
                const intersect = intersects[0];
                let x, y, z;
                
                if (intersect.object === groundPlane) {
                    const point = intersect.point;
                    x = Math.round(point.x / BLOCK_SIZE);
                    y = Math.round(point.y / BLOCK_SIZE);
                    z = Math.round(point.z / BLOCK_SIZE);
                    y = Math.max(y, 1);
                } else {
                    const normal = intersect.face.normal.clone();
                    const block = intersect.object;
                    const blockData = block.userData;
                    
                    x = blockData.x + Math.round(normal.x);
                    y = blockData.y + Math.round(normal.y);
                    z = blockData.z + Math.round(normal.z);
                }
                
                const blockKey = `${x},${y},${z}`;
                const torchKey = `interior_${x},${y},${z}`;
                
                if (!placedBlocks.has(blockKey) && !placedObjects.has(torchKey)) {
                    createTorch(x, y, z);
                    addToCLI("Torch placed", "success");
                    showNotification("Torch placed!");
                } else {
                    addToCLI("Cannot place torch here. Space is occupied.", "error");
                    showNotification("Space occupied!");
                }
            }
        }

        // ========================================
        // MODE SWITCHING FUNCTION
        // ========================================

        function toggleMode(mode) {
            // Clear ghost object when switching ANY mode
            if (ghostObject && currentMode !== mode) {
                clearGhostObject();
            }
            
            currentMode = mode;
            updateModeDisplay();
            updateCrosshairs();
            
            if (mode !== 'edit') {
                hideEditorGizmo();
                selectedObject = null;
                selectedGroup = null;
            }
            
            // Update UI buttons
            updateModeButtons();
            
            // Hide library panels when switching modes
            if (libraryVisible) {
                toggleLibrary(libraryVisible);
            }
            
            // Auto-select stone block when entering build mode
            if (mode === 'build' && selectedBlock === null) {
                selectBlock('stone');
            }
            
            addToCLI(`Mode: ${mode.toUpperCase()}`, "success");
        }

        // ========================================
        // CLI FUNCTIONS
        // ========================================

        function initCLI() {
            const cliInput = document.getElementById('cli-input');
            
            cliInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    const command = cliInput.value.trim();
                    if (command) {
                        addToCLI(`> ${command}`, "command");
                        processCommand(command);
                        commandHistory.push(command);
                        historyIndex = commandHistory.length;
                        cliInput.value = '';
                    }
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    if (commandHistory.length > 0) {
                        historyIndex = Math.max(0, historyIndex - 1);
                        cliInput.value = commandHistory[historyIndex] || '';
                    }
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    if (commandHistory.length > 0) {
                        historyIndex = Math.min(commandHistory.length, historyIndex + 1);
                        cliInput.value = commandHistory[historyIndex] || '';
                    }
                } else if (e.key === 'Escape') {
                    toggleCLI(false);
                    e.preventDefault();
                }
            });
        }

        function addToCLI(text, type = "response") {
            const cliOutput = document.getElementById('cli-output');
            const line = document.createElement('div');
            line.className = `cli-line cli-${type}`;
            line.textContent = text;
            cliOutput.appendChild(line);
            
            cliOutput.scrollTop = cliOutput.scrollHeight;
        }

        function toggleCLI(forceState = null) {
            const cli = document.getElementById('cli-container');
            const input = document.getElementById('cli-input');
            
            if (forceState !== null) {
                cliVisible = forceState;
            } else {
                cliVisible = !cliVisible;
            }
            
            cli.style.display = cliVisible ? 'block' : 'none';
            
            if (cliVisible) {
                input.focus();
                toggleLibrary(null);
                hideHelp();
            } else {
                input.blur();
            }
        }

        function processCommand(command) {
            const parts = command.toLowerCase().split(' ');
            const cmd = parts[0];
            const args = parts.slice(1);
            
            switch(cmd) {
                case '/help':
                case '/?':
                    showHelp();
                    break;
                    
                case '/block':
                    if (args.length > 0) {
                        const blockName = args[0];
                        if (BLOCKS[blockName]) {
                            selectBlock(blockName);
                            if (ghostObject) {
                                clearGhostObject();
                                addToCLI("Cleared ghost preview", "response");
                            }
                        } else {
                            addToCLI(`Unknown block: ${blockName}`, "error");
                            addToCLI("Available: sand, stone, grass, wood, brick, wireframe", "response");
                        }
                    } else {
                        addToCLI("Usage: /block [name]", "error");
                    }
                    break;
                    
                case '/clearpreview':
                case '/cancel':
                    if (ghostObject) {
                        clearGhostObject();
                        addToCLI("Ghost preview cleared", "success");
                        toggleMode('build');
                        selectBlock('stone');
                    } else {
                        addToCLI("No active preview to clear", "response");
                    }
                    break;
                    
                case '/mode':
                    if (args.length > 0) {
                        const mode = args[0];
                        if (['build', 'edit', 'torch'].includes(mode)) {
                            toggleMode(mode);
                        } else {
                            addToCLI("Invalid mode. Use: build, edit, torch", "error");
                        }
                    }
                    break;
                    
                case '/edit':
                    toggleMode('edit');
                    break;
                    
                case '/torch':
                    toggleMode('torch');
                    break;
                    
                case '/jetpack':
                    toggleJetpack();
                    break;
                    
                case '/building':
                    if (args.length > 0 && args[0] === 'list') {
                        listBuildings();
                    } else if (args.length > 0) {
                        const buildingName = args[0];
                        if (BUILDINGS[buildingName]) {
                            selectBuildingForPreview(buildingName);
                        } else {
                            addToCLI(`Building not found: ${buildingName}`, "error");
                        }
                    } else {
                        addToCLI("Usage: /building [name] -or- /building list", "error");
                    }
                    break;
                    
                case '/interior':
                    if (args.length > 0 && args[0] === 'list') {
                        listInterior();
                    } else if (args.length > 0) {
                        const objectName = args[0];
                        if (INTERIOR_OBJECTS[objectName]) {
                            selectInteriorForPreview(objectName);
                        } else {
                            addToCLI(`Interior object not found: ${objectName}`, "error");
                        }
                    } else {
                        addToCLI("Usage: /interior [name] -or- /interior list", "error");
                    }
                    break;
                    
                case '/lighting':
                    toggleLightingMode();
                    break;
                    
                case '/clear':
                    clearWorld();
                    break;
                    
                case '/save':
                    saveWorld(args[0] || 'default');
                    break;
                    
                case '/load':
                    loadWorld(args[0] || 'default');
                    break;
                    
                case '/spawn':
                    teleportToSpawn();
                    break;
                    
                case '/undo':
                    undoAction();
                    break;
                    
                case '/color':
                    if (args.length > 0) {
                        const colorStr = args[0];
                        if (colorStr.startsWith('#') && colorStr.length === 7) {
                            const newColor = parseInt(colorStr.replace('#', '0x'));
                            document.getElementById('color-picker').value = colorStr;
                            
                            currentColor = newColor;
                            if (selectedBlock && BLOCKS[selectedBlock]) {
                                blockCustomColors[selectedBlock] = newColor;
                            }
                            
                            addToCLI(`Color set to ${colorStr} (affects new ${selectedBlock} blocks)`, "success");
                        } else {
                            addToCLI("Usage: /color #RRGGBB", "error");
                        }
                    }
                    break;
                    
                default:
                    addToCLI(`Unknown command: ${cmd}`, "error");
                    addToCLI("Type /help for commands", "response");
            }
        }

        function listBuildings() {
            addToCLI("=== AVAILABLE BUILDINGS ===", "success");
            for (const [name, building] of Object.entries(BUILDINGS)) {
                addToCLI(`${name}: ${building.name} (${building.blocks.length} blocks)`, "response");
            }
            addToCLI("===========================", "response");
        }

        function listInterior() {
            addToCLI("=== AVAILABLE INTERIOR OBJECTS ===", "success");
            for (const [name, object] of Object.entries(INTERIOR_OBJECTS)) {
                addToCLI(`${name}: ${object.name}`, "response");
            }
            addToCLI("===========================", "response");
        }

        // ========================================
        // HELPER FUNCTIONS
        // ========================================

        function showHelp() {
            const helpPanel = document.getElementById('help-panel');
            helpPanel.style.display = 'block';
        }

        function hideHelp() {
            const helpPanel = document.getElementById('help-panel');
            helpPanel.style.display = 'none';
        }

        function clearWorld() {
            createNewIsland();
        }

        function createNewIsland() {
            if (confirm("Create new island? Current world will be cleared.")) {
                placedBlocks.forEach(block => {
                    scene.remove(block);
                });
                placedBlocks.clear();
                
                placedObjects.forEach(object => {
                    scene.remove(object);
                });
                placedObjects.clear();
                
                objectGroups.clear();
                
                clearGhostObject();
                
                createSimpleIsland();
                
                undoStack = [];
                
                selectedObject = null;
                selectedGroup = null;
                hideEditorGizmo();
                
                jetpackActive = false;
                updateJetpackStatus();
                
                addToCLI("Created new island", "success");
                showNotification("New island created!");
            }
        }

        function teleportToSpawn() {
            camera.position.set(8, 10, 8);
            pitch = 0;
            yaw = 0;
            
            jetpackActive = false;
            updateJetpackStatus();
            
            addToCLI("Teleported to spawn", "success");
            showNotification("Teleported to spawn!");
        }

        function saveWorld(name) {
            const worldData = {
                blocks: Array.from(placedBlocks.values()).map(block => ({
                    type: block.userData.type,
                    x: block.userData.x,
                    y: block.userData.y,
                    z: block.userData.z,
                    color: block.userData.color || null,
                    scale: block.userData.scale,
                    rotation: block.userData.rotation,
                    isGrouped: block.userData.isGrouped,
                    groupId: block.userData.groupId
                })),
                interiors: Array.from(placedObjects.values()).map(obj => ({
                    type: obj.userData.type,
                    x: obj.userData.x,
                    y: obj.userData.y,
                    z: obj.userData.z
                })),
                playerPosition: {
                    x: camera.position.x,
                    y: camera.position.y,
                    z: camera.position.z
                },
                objectGroups: Array.from(objectGroups.entries()),
                blockCustomColors: blockCustomColors,
                currentColor: currentColor,
                selectedBlock: selectedBlock,
                isNightMode: isNightMode,
                jetpackEnabled: jetpackEnabled,
                timestamp: new Date().toISOString()
            };
            
            localStorage.setItem(`mc_world_${name}`, JSON.stringify(worldData));
            addToCLI(`World saved: ${name}`, "success");
            showNotification(`World "${name}" saved!`);
        }

        function loadWorld(name) {
            const savedData = localStorage.getItem(`mc_world_${name}`);
            if (savedData) {
                try {
                    const worldData = JSON.parse(savedData);
                    
                    placedBlocks.forEach(block => scene.remove(block));
                    placedBlocks.clear();
                    placedObjects.forEach(object => scene.remove(object));
                    placedObjects.clear();
                    objectGroups.clear();
                    clearGhostObject();
                    
                    worldData.blocks.forEach(blockData => {
                        createBlockAt(
                            blockData.type, 
                            blockData.x, 
                            blockData.y, 
                            blockData.z, 
                            blockData.scale,
                            blockData.rotation
                        );
                    });
                    
                    if (worldData.interiors) {
                        worldData.interiors.forEach(objData => {
                            const interior = INTERIOR_OBJECTS[objData.type];
                            if (interior) {
                                interior.create(objData.x, objData.y, objData.z);
                            }
                        });
                    }
                    
                    if (worldData.objectGroups) {
                        worldData.objectGroups.forEach(([groupId, groupData]) => {
                            objectGroups.set(groupId, groupData);
                        });
                    }
                    
                    if (worldData.playerPosition) {
                        camera.position.set(
                            worldData.playerPosition.x,
                            worldData.playerPosition.y,
                            worldData.playerPosition.z
                        );
                    }
                    
                    if (worldData.blockCustomColors) {
                        blockCustomColors = worldData.blockCustomColors;
                    }
                    
                    if (worldData.currentColor) {
                        currentColor = worldData.currentColor;
                        document.getElementById('color-picker').value = `#${currentColor.toString(16).padStart(6, '0')}`;
                    }
                    
                    if (worldData.selectedBlock) {
                        selectBlock(worldData.selectedBlock);
                    }
                    
                    if (worldData.isNightMode) {
                        isNightMode = worldData.isNightMode;
                        toggleLightingMode();
                    }
                    
                    if (worldData.jetpackEnabled !== undefined) {
                        jetpackEnabled = worldData.jetpackEnabled;
                        if (jetpackEnabled) {
                            document.getElementById('jetpack-toggle').innerHTML = '<span class="button-icon">üöÄ</span> JETPACK ON';
                            document.getElementById('jetpack-toggle').style.background = 'rgba(0, 255, 255, 0.2)';
                            document.getElementById('jetpack-toggle').style.borderColor = '#00ffff';
                        }
                        updateJetpackStatus();
                    }
                    
                    addToCLI(`Loaded world: ${name}`, "success");
                    showNotification(`World "${name}" loaded!`);
                } catch (e) {
                    addToCLI(`Error loading world: ${e.message}`, "error");
                    showNotification(`Error loading "${name}"!`);
                }
            } else {
                addToCLI(`World not found: ${name}`, "error");
                showNotification(`World "${name}" not found!`);
            }
        }

        // ========================================
        // ANIMATION LOOP
        // ========================================

        let lastTime = 0;
        let frameCount = 0;
        let lastFpsUpdate = 0;
        
        function animate(time) {
            requestAnimationFrame(animate);
            
            const deltaTime = (time - lastTime) / 1000;
            lastTime = time;
            
            frameCount++;
            if (time - lastFpsUpdate >= 1000) {
                const fps = Math.round(frameCount);
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                lastFpsUpdate = time;
            }
            
            if (ghostObject) {
                updateGhostObjectPosition();
            }
            
            updateMovement(deltaTime);
            renderer.render(scene, camera);
        }

        // ========================================
        // INITIALIZATION
        // ========================================

        window.addEventListener('DOMContentLoaded', () => {
            console.log("Starting MICROCRAFT Castle Builder v3.2...");
            try {
                init();
                updateSelectedObjectDisplay();
                updateModeDisplay();
                selectGizmoMode('translate');
            } catch (error) {
                console.error("Failed to initialize:", error);
                document.body.innerHTML = `
                    <div style="color: #ff0000; padding: 50px; text-align: center; font-family: monospace;">
                        <h1>‚ùå MICROCRAFT FAILED TO LOAD</h1>
                        <p>Error: ${error.message}</p>
                        <p>Please ensure your browser supports WebGL.</p>
                        <p>Try Chrome/Firefox with hardware acceleration enabled.</p>
                    </div>
                `;
            }
        });

        // ========================================
        // PUBLIC FUNCTIONS FOR UI BUTTONS
        // ========================================

        window.undoAction = undoAction;
        window.clearWorld = clearWorld;
        window.createNewIsland = createNewIsland;
        window.teleportToSpawn = teleportToSpawn;
        window.toggleMode = toggleMode;
        window.toggleLibrary = toggleLibrary;
        window.toggleLightingMode = toggleLightingMode;
        window.toggleJetpack = toggleJetpack;
        window.saveWorld = saveWorld;
        window.loadWorld = loadWorld;
        window.toggleCLI = toggleCLI;
        window.showHelp = showHelp;
        window.hideHelp = hideHelp;
        window.selectBlock = selectBlock;
        window.selectGizmoMode = selectGizmoMode;
        window.applyEditorChanges = applyEditorChanges;
        window.resetEditorChanges = resetEditorChanges;
        window.exitEditMode = exitEditMode;
        window.selectBuildingForPreview = selectBuildingForPreview;
        window.selectInteriorForPreview = selectInteriorForPreview;
        window.clearGhostObject = clearGhostObject;
    </script>
</body>
</html>
