<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GeoDrive - WebXOS 2025</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/idb/7.1.1/umd.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Courier New', monospace;
    }
    body {
      background: #000;
      color: #00ff00;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
      text-align: center;
    }
    h1 {
      font-size: 2em;
      text-shadow: 0 0 15px #00ff00;
      margin-bottom: 20px;
    }
    .container {
      max-width: 600px;
      width: 100%;
      padding: 20px;
      border: 2px solid #00ff00;
      border-radius: 10px;
      box-shadow: 0 0 20px #00ff00;
      background: rgba(0, 255, 0, 0.1);
    }
    h2 {
      font-size: 1.5em;
      margin: 15px 0;
      text-shadow: 0 0 10px #00ff00;
    }
    input, button, textarea {
      width: 100%;
      margin: 10px 0;
      padding: 10px;
      background: #111;
      color: #00ff00;
      border: 1px solid #00ff00;
      border-radius: 5px;
      font-size: 1em;
    }
    button {
      cursor: pointer;
      background: #00ff00;
      color: #000;
      font-weight: bold;
      transition: all 0.3s;
    }
    button:hover {
      background: #000;
      color: #00ff00;
      box-shadow: 0 0 10px #00ff00;
    }
    textarea {
      resize: vertical;
      min-height: 100px;
    }
    #output, #storageInfo {
      margin-top: 10px;
      font-size: 0.9em;
      word-wrap: break-word;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 10px 0;
    }
    th, td {
      border: 1px solid #00ff00;
      padding: 8px;
      text-align: left;
      font-size: 0.9em;
    }
    th {
      background: #00ff00;
      color: #000;
    }
    footer {
      margin-top: 20px;
      font-size: 0.8em;
      text-shadow: 0 0 5px #00ff00;
    }
    @media (max-width: 600px) {
      h1 {
        font-size: 1.6em;
      }
      .container {
        padding: 15px;
      }
      input, button, textarea, th, td {
        font-size: 0.85em;
      }
    }
  </style>
</head>
<body>
  <h1>GeoDrive - WebXOS 2025</h1>
  <div class="container">
    <h2>Create Profile</h2>
    <button onclick="createProfile()">Generate Profile Key</button>
    <textarea id="profileKey" readonly placeholder="Your profile key..."></textarea>
    <button onclick="copyProfileKey()">Copy Profile Key</button>

    <h2>Access GeoDrive</h2>
    <textarea id="profileInput" placeholder="Paste profile key to access drive..."></textarea>
    <button onclick="openGeoDrive()">Open GeoDrive</button>

    <h2>Store Data</h2>
    <textarea id="textInput" placeholder="Enter text to store..."></textarea>
    <input type="file" id="fileInput" accept="*/*">
    <button onclick="storeData()">Store Text/File</button>
    <textarea id="dataKey" readonly placeholder="Generated data key..."></textarea>
    <button onclick="copyDataKey()">Copy Data Key</button>

    <h2>Manage Keys</h2>
    <div id="storageInfo"></div>
    <table id="keyTable">
      <thead>
        <tr>
          <th>Type</th>
          <th>Key</th>
          <th>Size (MB)</th>
          <th>Action</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
    <button onclick="regenerateDB()">Regenerate Database</button>
    <div id="output"></div>
  </div>
  <footer>© 2025 WebXOS. All rights reserved.</footer>

  <script>
    // Browser detection for storage limits
    const ua = navigator.userAgent.toLowerCase();
    const browser = {
      chrome: /chrome|chromium|crios/.test(ua),
      firefox: /firefox|fxios/.test(ua),
      safari: /safari/.test(ua) && !/chrome|chromium|crios/.test(ua),
    };
    const MAX_PER_KEY_MB = browser.chrome || browser.firefox ? 1000 : browser.safari ? 500 : 500; // MB per key
    const MAX_TOTAL_MB = 1000000; // 1TB = 1,000,000MB
    let totalUsedMB = 0;

    // Initialize IndexedDB
    const dbPromise = idb.openDB('GeoDriveDB', 1, {
      upgrade(db) {
        db.createObjectStore('profiles', { keyPath: 'profileKey' });
        db.createObjectStore('data', { keyPath: 'dataKey' });
      }
    });

    // Update storage info and key table
    async function updateStorageInfo() {
      const db = await dbPromise;
      const profiles = await db.getAll('profiles');
      const dataItems = await db.getAll('data');
      totalUsedMB = 0;
      const tbody = document.querySelector('#keyTable tbody');
      tbody.innerHTML = '';

      profiles.forEach(p => {
        const sizeMB = (p.size || 0.001).toFixed(3); // Profile size is negligible
        totalUsedMB += parseFloat(sizeMB);
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>Profile</td>
          <td>${p.profileKey}</td>
          <td>${sizeMB}</td>
          <td><button onclick="deleteKey('profiles', '${p.profileKey}')">Delete</button></td>
        `;
        tbody.appendChild(row);
      });

      dataItems.forEach(d => {
        const sizeMB = (d.size || 0).toFixed(3);
        totalUsedMB += parseFloat(sizeMB);
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>Data</td>
          <td>${d.dataKey}</td>
          <td>${sizeMB}</td>
          <td><button onclick="deleteKey('data', '${d.dataKey}')">Delete</button></td>
        `;
        tbody.appendChild(row);
      });

      const remainingMB = Math.max(0, MAX_TOTAL_MB - totalUsedMB).toFixed(3);
      document.getElementById('storageInfo').innerHTML = `
        Browser: ${browser.chrome ? 'Chrome' : browser.firefox ? 'Firefox' : browser.safari ? 'Safari' : 'Unknown'}<br>
        Max per key: ${MAX_PER_KEY_MB} MB<br>
        Total used: ${totalUsedMB.toFixed(3)} MB<br>
        Remaining: ${remainingMB} MB of ${MAX_TOTAL_MB} MB
      `;
    }

    // Create profile key
    async function createProfile() {
      const profileKeyOutput = document.getElementById('profileKey');
      const output = document.getElementById('output');
      if (totalUsedMB >= MAX_TOTAL_MB) {
        output.textContent = 'Error: Total storage limit (1TB) reached.';
        return;
      }

      try {
        const randomStr = CryptoJS.lib.WordArray.random(16).toString();
        const profileKey = `GEO_${randomStr.slice(0, 8)}-${randomStr.slice(8, 16)}-${randomStr.slice(16, 24)}`;
        const db = await dbPromise;
        await db.put('profiles', { profileKey, size: 0.001 }); // Negligible size
        profileKeyOutput.value = profileKey;
        output.textContent = 'Profile key generated!';
        await updateStorageInfo();
      } catch (err) {
        output.textContent = `Error: ${err.message}`;
      }
    }

    // Copy profile key
    function copyProfileKey() {
      const profileKey = document.getElementById('profileKey').value;
      const output = document.getElementById('output');
      if (!profileKey) {
        output.textContent = 'Error: No profile key to copy.';
        return;
      }
      navigator.clipboard.writeText(profileKey).then(() => {
        output.textContent = 'Profile key copied to clipboard!';
      }).catch(err => {
        output.textContent = `Error: ${err.message}`;
      });
    }

    // Store text or file
    async function storeData() {
      const textInput = document.getElementById('textInput').value;
      const fileInput = document.getElementById('fileInput').files[0];
      const dataKeyOutput = document.getElementById('dataKey');
      const output = document.getElementById('output');
      const profileKey = document.getElementById('profileInput').value.trim();

      if (!profileKey) {
        output.textContent = 'Error: Please enter a profile key.';
        return;
      }
      if (!textInput && !fileInput) {
        output.textContent = 'Error: Please enter text or select a file.';
        return;
      }
      if (totalUsedMB >= MAX_TOTAL_MB) {
        output.textContent = 'Error: Total storage limit (1TB) reached.';
        return;
      }

      try {
        const db = await dbPromise;
        const profile = await db.get('profiles', profileKey);
        if (!profile) {
          output.textContent = 'Error: Invalid profile key.';
          return;
        }

        let data, sizeMB, fileName = 'text.txt';
        if (fileInput) {
          data = await fileInput.arrayBuffer();
          sizeMB = data.byteLength / (1024 * 1024); // MB
          fileName = fileInput.name;
        } else {
          data = new TextEncoder().encode(textInput).buffer;
          sizeMB = data.byteLength / (1024 * 1024); // MB
        }

        if (sizeMB > MAX_PER_KEY_MB) {
          output.textContent = `Error: Data size (${sizeMB.toFixed(3)} MB) exceeds per-key limit (${MAX_PER_KEY_MB} MB).`;
          return;
        }
        if (totalUsedMB + sizeMB > MAX_TOTAL_MB) {
          output.textContent = `Error: Not enough remaining storage (${(MAX_TOTAL_MB - totalUsedMB).toFixed(3)} MB left).`;
          return;
        }

        // Encrypt data
        const aesKey = CryptoJS.SHA256(profileKey).toString();
        const wordArray = CryptoJS.lib.WordArray.create(data);
        const encrypted = CryptoJS.AES.encrypt(wordArray, aesKey).toString();

        // Generate data key
        const dataHash = CryptoJS.SHA256(encrypted).toString();
        const dataKey = `GEO_${dataHash.slice(0, 8)}-${dataHash.slice(8, 16)}-${dataHash.slice(16, 24)}`;

        // Store in IndexedDB
        await db.put('data', {
          dataKey,
          profileKey,
          fileName,
          size: sizeMB,
          encryptedData: encrypted,
          isText: !fileInput
        });

        dataKeyOutput.value = dataKey;
        output.textContent = `Data stored! Key: ${dataKey}`;
        await updateStorageInfo();
      } catch (err) {
        output.textContent = `Error: ${err.message}`;
      }
    }

    // Copy data key
    function copyDataKey() {
      const dataKey = document.getElementById('dataKey').value;
      const output = document.getElementById('output');
      if (!dataKey) {
        output.textContent = 'Error: No data key to copy.';
        return;
      }
      navigator.clipboard.writeText(dataKey).then(() => {
        output.textContent = 'Data key copied to clipboard!';
      }).catch(err => {
        output.textContent = `Error: ${err.message}`;
      });
    }

    // Delete key
    async function deleteKey(store, key) {
      const output = document.getElementById('output');
      try {
        const db = await dbPromise;
        await db.delete(store, key);
        output.textContent = `Key ${key} deleted.`;
        await updateStorageInfo();
      } catch (err) {
        output.textContent = `Error: ${err.message}`;
      }
    }

    // Regenerate database
    async function regenerateDB() {
      const output = document.getElementById('output');
      try {
        await idb.deleteDB('GeoDriveDB');
        const db = await idb.openDB('GeoDriveDB', 1, {
          upgrade(db) {
            db.createObjectStore('profiles', { keyPath: 'profileKey' });
            db.createObjectStore('data', { keyPath: 'dataKey' });
          }
        });
        totalUsedMB = 0;
        output.textContent = 'Database regenerated!';
        await updateStorageInfo();
      } catch (err) {
        output.textContent = `Error: ${err.message}`;
      }
    }

    // Open GeoDrive popup
    async function openGeoDrive() {
      const profileKey = document.getElementById('profileInput').value.trim();
      const output = document.getElementById('output');
      if (!profileKey) {
        output.textContent = 'Error: Please enter a profile key.';
        return;
      }

      try {
        const db = await dbPromise;
        const profile = await db.get('profiles', profileKey);
        if (!profile) {
          output.textContent = 'Error: Invalid profile key.';
          return;
        }

        const dataItems = await db.getAll('data');
        const userData = dataItems.filter(d => d.profileKey === profileKey);

        // Create popup HTML
        const popupHTML = `
          <!DOCTYPE html>
          <html>
          <head>
            <title>GeoDrive - Your Data</title>
            <style>
              body { background: #000; color: #00ff00; font-family: 'Courier New', monospace; padding: 20px; }
              h1 { text-shadow: 0 0 10px #00ff00; }
              table { width: 100%; border-collapse: collapse; }
              th, td { border: 1px solid #00ff00; padding: 8px; }
              th { background: #00ff00; color: #000; }
              button { background: #00ff00; color: #000; border: 1px solid #00ff00; padding: 5px; cursor: pointer; }
              button:hover { background: #000; color: #00ff00; }
              pre { background: #111; padding: 10px; border: 1px solid #00ff00; }
            </style>
          </head>
          <body>
            <h1>GeoDrive - Your Data</h1>
            <table>
              <thead>
                <tr><th>Key</th><th>Name</th><th>Size (MB)</th><th>Action</th></tr>
              </thead>
              <tbody>
                ${userData.map(d => `
                  <tr>
                    <td>${d.dataKey}</td>
                    <td>${d.fileName}</td>
                    <td>${d.size.toFixed(3)}</td>
                    <td>
                      ${d.isText ?
                        `<button onclick="document.getElementById('text-${d.dataKey}').style.display='block'">View</button>
                         <pre id="text-${d.dataKey}" style="display:none">${decryptData(d.encryptedData, profileKey)}</pre>` :
                        `<button onclick="downloadFile('${d.dataKey}', '${d.fileName}', '${profileKey}')">Download</button>`}
                    </td>
                  </tr>
                `).join('')}
              </tbody>
            </table>
            <script>
              function decryptData(encrypted, profileKey) {
                const aesKey = CryptoJS.SHA256(profileKey).toString();
                return CryptoJS.AES.decrypt(encrypted, aesKey).toString(CryptoJS.enc.Utf8);
              }
              function downloadFile(dataKey, fileName, profileKey) {
                fetch('data Anggota DPR dari Partai Demokrat, Didik Mukrianto, mengatakan pihaknya akan menyiapkan data untuk melaporkan dugaan pelanggaran Pemilu oleh Gibran Rakabuming Raka, yang diduga menggunakan fasilitas negara untuk kampanye. Didik menegaskan pihaknya memiliki bukti yang cukup untuk melaporkan putra sulung Presiden Joko Widodo itu ke Badan Pengawas Pemilu (Bawaslu). Namun, Didik mengaku masih akan menganalisis data-data tersebut sebelum memutuskan waktu pelaporan ke Bawaslu.“Kami sudah memiliki data yang cukup untuk melaporkan dugaan pelanggaran yang dilakukan Mas Gibran. Tapi, karena ini menyangkut putra Presiden, kami harus berhati-hati,” kata Didik di Jakarta, Rabu (24/1).Didik menjelaskan, pelaporan ini dilakukan untuk menjaga integritas Pemilu. Menurutnya, dugaan pelanggaran yang dilakukan Gibran bukan hanya pelanggaran administratif, tetapi juga pelanggaran etik. Gibran, lanjut Didik, diduga menggunakan fasilitas negara, seperti kunjungan ke daerah-daerah, untuk kepentingan kampanye.“Ini adalah hal yang sangat serius. Kami tidak ingin ada persepsi bahwa anak Presiden kebal hukum,” ujarnya.Selain itu, Didik juga menyinggung soal netralitas Aparatur Sipil Negara (ASN) yang mendampingi Gibran dalam kunjungan-kunjungan tersebut. Menurutnya, hal ini perlu diselidiki lebih lanjut untuk memastikan apakah ada pelanggaran netralitas ASN atau tidak.“Kami akan kaji secara mendalam. Kalau memang terbukti ada pelanggaran, kami akan laporkan ke Bawaslu,” tegasnya.Sementara itu, Ketua Bawaslu RI, Rahmat Bagja, mengatakan pihaknya siap menerima laporan dari siapa pun, termasuk dari anggota DPR, terkait dugaan pelanggaran Pemilu. Namun, ia meminta agar laporan tersebut dilengkapi dengan bukti yang kuat.“Kami terbuka untuk menerima laporan. Tapi, harus ada bukti yang jelas, seperti foto, video, atau saksi yang bisa membuktikan adanya pelanggaran,” kata Bagja.Menanggapi hal ini, Gibran Rakabuming Raka enggan berkomentar banyak. Saat dikonfirmasi wartawan di Solo, Jawa Tengah, ia hanya mengatakan bahwa semua kegiatannya sebagai Wali Kota Solo dilakukan sesuai aturan.“Semua sesuai aturan. Silakan dicek,” ujar Gibran singkat.Sebelumnya, Gibran juga sempat menuai sorotan karena diduga melakukan kampanye terselubung saat membagikan susu gratis di Jakarta. Kegiatan tersebut dinilai beberapa pihak sebagai bentuk kampanye yang tidak sesuai dengan aturan, karena dilakukan di luar jadwal kampanye resmi yang ditetapkan Komisi Pemilihan Umum (KPU).Namun, Gibran membantah tuduhan tersebut. Ia mengatakan kegiatan bagi-bagi susu itu merupakan bagian dari program Wali Kota Solo untuk meningkatkan gizi anak-anak.“Itu program saya sebagai Wali Kota, bukan kampanye,” kilah Gibran.Terkait hal ini, pengamat politik dari Universitas Indonesia, Cecep Hidayat, menilai bahwa dugaan pelanggaran yang dilakukan Gibran perlu ditelusuri lebih lanjut. Menurutnya, penggunaan fasilitas negara untuk kepentingan kampanye merupakan pelanggaran serius yang bisa merusak integritas Pemilu.“Jika terbukti, ini bisa menjadi preseden buruk bagi demokrasi kita. Anak Presiden tidak boleh mendapat privilese khusus,” ujar Cecep.Ia juga menyarankan agar Bawaslu lebih proaktif dalam mengawasi potensi pelanggaran, terutama yang melibatkan pejabat publik. “Bawaslu harus tegas dan tidak pandang bulu,” tambahnya.Hingga kini, Bawaslu masih menunggu laporan resmi dari pihak mana pun terkait dugaan pelanggaran Gibran. Rahmat Bagja menegaskan bahwa setiap laporan akan diproses sesuai prosedur, asalkan memenuhi syarat formil dan materil.“Kami tidak akan tebang pilih. Semua laporan akan kami tindaklanjuti jika buktinya cukup,” pungkasnya.
          </body>
          </html>
        `;
        const popup = window.open('', 'GeoDrive', 'width=600,height=400');
        popup.document.write(popupHTML);
      } catch (err) {
        output.textContent = `Error: ${err.message}`;
      }
    }

    // Initialize
    updateStorageInfo();
  </script>
</body>
</html>
