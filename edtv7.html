<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>edTV: CHANNEL 7 SAM 3 + Three.js Wireframe Face AR</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body { margin:0; overflow:hidden; background:#000; font-family:sans-serif; }
    #ui { position:absolute; top:10px; left:10px; z-index:100; color:white; }
    input { padding:8px; font-size:16px; width:200px; }
    canvas { position:absolute; top:0; left:0; }
  </style>
</head>
<body>

<div id="ui">
  Prompt: <input id="prompt" value="face" placeholder="try: face, eyes, person...">
</div>
<video id="video" autoplay playsinline muted style="display:none;"></video>

<script src="https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.0.0-alpha.9/dist/transformers.min.js"></script>
<script type="module">
  // === 1. Three.js scene (wireframe head) ===
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100);
  const renderer = new THREE.WebGLRenderer({antialias:false, alpha:true});
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  document.body.appendChild(renderer.domElement);

  const wireMat = new THREE.MeshBasicMaterial({color:0x00ffff, wireframe:true});
  const headGeo = new THREE.IcosahedronGeometry(1.2, 2); // looks great as face proxy
  const headMesh = new THREE.Mesh(headGeo, wireMat);
  scene.add(headMesh);

  const light = new THREE.HemisphereLight(0xffffff, 0x4444ff, 1);
  scene.add(light);

  // === 2. Webcam ===
  const video = document.getElementById('video');
  navigator.mediaDevices.getUserMedia({video:{facingMode:"user"}}).then(s=>{
    video.srcObject = s;
  });

  // === 3. SAM 3 Tracker (lightweight WASM version by HF) ===
  console.log("Loading SAM 3 tracker (WASM)...");
  const tracker = await tracker = await sam3.load({
    model: "zkang/sam3-tracker-wasm", // tiny distilled version that runs in browser
    device: "wasm"
  });

  let currentPrompt = "face";

  document.getElementById("prompt").addEventListener("change", e=>{
    currentPrompt = e.target.value;
  });

  // === 4. Main loop ===
  const tempCanvas = document.createElement('canvas');
  const ctx = tempCanvas.getContext('2d');

  async function tick() {
    if (video.readyState < 2) { requestAnimationFrame(tick); return; }

    tempCanvas.width = video.videoWidth;
    tempCanvas.height = video.videoHeight;
    ctx.drawImage(video, 0, 0);

    // Run SAM 3 tracker with text prompt
    const result = await tracker.track(tempCanvas, {
      prompt: currentPrompt,
      multimask_output: false
    });

    // Use the first (and usually only) mask that matches the prompt
    if (result.masks.length > 0) {
      const mask = result.masks[0]; // {data: Uint8Array, width, height}

      // Simple centroid + bounding box to position the 3D head
      let sumX=0, sumY=0, count=0;
      let minX=Infinity, minY=Infinity, maxX=0, maxY=0;

      for (let y=0; y<mask.height; y++) {
        for (let x=0; x<mask.width; x++) {
          if (mask.data[y*mask.width + x]) {
            sumX += x; sumY += y; count++;
            minX = Math.min(minX,x); maxX = Math.max(maxX,x);
            minY = Math.min(minY,y); maxY = Math.max(maxY,y);
          }
        }
      }

      if (count > 500) { // reasonable face size
        const cx = sumX/count / mask.width  * 2 - 1;
        const cy = -(sumY/count / mask.height * 2 - 1);
        const size = (maxX-minX)/mask.width * 3;

        headMesh.position.set(cx * 5, cy * 5, -3);
        headMesh.scale.setScalar(size);
        headMesh.visible = true;
      } else {
        headMesh.visible = false;
      }
    } else {
      headMesh.visible = false;
    }

    renderer.render(scene, camera);
    requestAnimationFrame(tick);
  }

  video.addEventListener('loadedmetadata', ()=>{
    camera.position.z = 5;
    tick();
  });

  window.addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });
</script>
</body>
</html>
