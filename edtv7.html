<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>edTV: CHANNEL 7</title> <!-- Updated title -->
    <meta name="theme-color" content="#000000">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <style>
        /* Retained original styles with minor theming adjustments for mask focus */
        *{margin:0;padding:0;box-sizing:border-box;font-family:'Press Start 2P',cursive;image-rendering:pixelated}
        body{background:#000;color:#0f0;overflow:hidden;height:100vh;user-select:none;-webkit-tap-highlight-color:transparent}
        #appContainer{position:relative;width:100%;height:100vh;overflow:hidden}
        .matrix-grid{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(rgba(0,255,0,0.1)1px,transparent 1px),linear-gradient(90deg,rgba(0,255,0,0.1)1px,transparent 1px);background-size:16px 16px;opacity:0.3}
        .crt-overlay{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(to bottom,transparent 50%,rgba(0,20,0,0.1)50%);background-size:100% 4px;z-index:5;pointer-events:none;animation:scanline 8s linear infinite}
        @keyframes scanline{0%{background-position:0 0}100%{background-position:0 100%}}
        #visualizationContainer{position:absolute;top:0;left:0;width:100%;height:100%;z-index:2}
        #ideInterface{position:absolute;top:0;left:0;width:100%;height:100%;z-index:10}
        
        /* Top Banner with Glitch Effect - Updated text */
        .top-banner {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 40px;
            background: rgba(255, 0, 255, 0.9);
            border-bottom: 2px solid #f0f;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 12;
            overflow: hidden;
            animation: glitch 3s infinite;
        }
        
        @keyframes glitch {
            0%, 100% { transform: translateX(0); }
            5% { transform: translateX(-2px); }
            10% { transform: translateX(2px); }
            15% { transform: translateX(-1px); }
            20% { transform: translateX(1px); }
            25% { transform: translateX(0); }
            50% { transform: translateX(0); }
            55% { transform: translateX(-1px) skewX(-2deg); }
            60% { transform: translateX(1px) skewX(2deg); }
            65% { transform: translateX(-1px) skewX(-1deg); }
            70% { transform: translateX(1px) skewX(1deg); }
            75% { transform: translateX(0); }
        }
        
        .top-banner-text {
            font-size: 12px;
            color: #000;
            text-shadow: 1px 1px 0 #fff;
            letter-spacing: 1px;
        }
        
        /* Left Side Scan Button - Updated label */
        .scan-btn{
            width:180px;height:52px;background:#000;border:3px solid #0ff;color:#0ff;
            font-size:10px;display:flex;align-items:center;justify-content:center;cursor:pointer;
            box-shadow:3px 3px 0 #000;transform:skew(-2deg);transition:background 0.1s,color 0.1s;
            touch-action:none;
            position:absolute;top:60px;left:20px;z-index:11
        }
        .scan-btn:hover,.scan-btn:active{background:#0ff;color:#000}
        .scan-btn.active{background:#0ff;color:#000}
        
        /* Right Side Controls - Retained for zoom/reset */
        .right-controls {
            position: absolute;
            top: 60px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 11;
        }
        
        .zoom-in-btn {
            width: 120px;
            height: 40px;
            background: #000;
            border: 3px solid #0f0;
            color: #0f0;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
        }
        
        .zoom-out-btn {
            width: 120px;
            height: 40px;
            background: #000;
            border: 3px solid #f00;
            color: #f00;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
        }
        
        .reset-btn {
            width: 120px;
            height: 40px;
            background: #000;
            border: 3px solid #ff0;
            color: #ff0;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
        }
        
        .zoom-in-btn:hover,.zoom-in-btn:active{background:#0f0;color:#000}
        .zoom-out-btn:hover,.zoom-out-btn:active{background:#f00;color:#000}
        .reset-btn:hover,.reset-btn:active{background:#ff0;color:#000}
        
        /* Camera Rotation Controls - Retained */
        .camera-controls {
            position: absolute;
            bottom: 100px;
            right: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            z-index: 11;
        }
        
        .camera-btn {
            width: 60px;
            height: 40px;
            background: #000;
            border: 2px solid #0ff;
            color: #0ff;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
        }
        
        .camera-btn:hover,.camera-btn:active{background:#0ff;color:#000}
        
        /* PPV Face View - Retained for live scan preview */
        .ppv-face-view {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 140px;
            height: 105px;
            background: #000;
            border: 2px solid #0ff;
            z-index: 15;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .ppv-face-view.expanded {
            width: 300px;
            height: 225px;
            z-index: 20;
        }
        
        .ppv-canvas {
            width: 100%;
            height: 100%;
        }
        
        /* Removed radar container as it's unrelated to mask design */
        
        /* HUD Warning - Updated for face detection */
        #hudWarning{position:absolute;top:20%;left:50%;transform:translate(-50%,-50%);color:#f00;font-size:12px;text-shadow:1px 1px 0 #000;z-index:11;display:none}
        
        /* Scan Status - Updated label */
        .scan-status {
            position: absolute;
            top: 50px;
            left: 10px;
            font-size: 8px;
            color: #0ff;
            z-index: 11;
            background: rgba(0,0,0,0.7);
            padding: 5px;
            border: 1px solid #0ff;
        }
        
        /* Status Panel - Updated for mask-relevant metrics */
        .status-panel {
            position: absolute;
            top: 50px;
            right: 160px;
            font-size: 8px;
            color: #0ff;
            z-index: 11;
            background: rgba(0,0,0,0.7);
            padding: 5px;
            border: 1px solid #0ff;
        }
        
        /* Timer Display - Retained */
        .timer-panel {
            position: absolute;
            top: 120px;
            left: 20px;
            font-size: 10px;
            color: #ff0;
            z-index: 11;
            background: rgba(0,0,0,0.7);
            padding: 8px;
            border: 1px solid #ff0;
        }
        
        /* Calibration Instructions - Updated text for mask scanning */
        .calibration-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            border: 3px solid #0ff;
            padding: 15px;
            z-index: 25;
            text-align: center;
            max-width: 300px;
            display: none;
        }
        
        .calibration-text {
            font-size: 10px;
            color: #0ff;
            margin-bottom: 15px;
            line-height: 1.5;
        }
        
        .calibration-btn {
            width: 120px;
            height: 40px;
            background: #000;
            border: 2px solid #0f0;
            color: #0f0;
            font-size: 10px;
            cursor: pointer;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .calibration-btn:hover,.calibration-btn:active{background:#0f0;color:#000}
        
        /* JSON Export Panels - Expanded to three panels for multiple JSONs */
        .json-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            border: 3px solid #0ff;
            padding: 15px;
            z-index: 30;
            width: 80%;
            max-width: 500px;
            display: none;
        }
        
        .json-title {
            font-size: 12px;
            color: #0ff;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .json-content {
            width: 100%;
            height: 200px;
            background: #000;
            border: 2px solid #0f0;
            color: #0f0;
            font-size: 8px;
            padding: 10px;
            margin-bottom: 10px;
            overflow: auto;
            font-family: monospace;
            white-space: pre-wrap;
        }
        
        .json-btn {
            width: 120px;
            height: 40px;
            background: #000;
            border: 2px solid #0f0;
            color: #0f0;
            font-size: 10px;
            cursor: pointer;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .json-btn:hover,.json-btn:active{background:#0f0;color:#000}
        
        /* Desktop Override */
        @media (min-width:768px){
            .scan-btn{width:200px;height:56px;font-size:12px}
        }
        
        /* Mobile Optimization */
        @media (max-width:767px){
            .ppv-face-view{width:100px;height:75px}
            .ppv-face-view.expanded{width:280px;height:210px}
            .status-panel{right:120px}
            .scan-btn{left:10px;width:160px;height:48px;font-size:9px}
            .right-controls{right:10px}
            .zoom-in-btn, .zoom-out-btn, .reset-btn{width:100px;height:36px;font-size:9px}
            .camera-controls{bottom:80px;right:10px}
            .camera-btn{width:50px;height:36px;font-size:14px}
            .timer-panel{top:110px;left:10px;font-size:9px}
        }
        
        /* Focus styles for accessibility */
        .scan-btn:focus, .zoom-in-btn:focus, .zoom-out-btn:focus, .reset-btn:focus, .camera-btn:focus {
            outline: 2px solid #0ff;
            outline-offset: 2px;
        }
        
        /* Scene Click Area */
        #sceneClickArea {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            cursor: pointer;
        }
    </style>
</head>
<body>
<div id="appContainer">
    <div class="matrix-grid"></div>
    <div class="crt-overlay"></div>
    
    <!-- Top Banner with Updated Text -->
    <div class="top-banner">
        <div class="top-banner-text">edTV: CHANNEL 7</div>
    </div>
    
    <!-- PPV Face View - Retained -->
    <div class="ppv-face-view" id="ppvFaceView">
        <canvas class="ppv-canvas" id="ppvCanvas"></canvas>
    </div>
    
    <!-- Scan Status - Updated -->
    <div class="scan-status" id="scanStatus">
        SCAN READY
    </div>
    
    <!-- Status Panel - Updated for landmarks and fit metrics -->
    <div class="status-panel">
        LANDMARKS: <span id="landmarkCount">0</span><br>
        FPS: <span id="fpsCounter">60</span><br>
        ZOOM: <span id="zoomLevel">1.0</span>x<br>
        STATUS: <span id="sceneStatus">CALIBRATING</span>
    </div>
    
    <!-- Timer Panel - Retained -->
    <div class="timer-panel" id="timerPanel">
        SCANNING: <span id="timerDisplay">400s</span><br>
        PROGRESS: <span id="progressDisplay">0%</span>
    </div>
    
    <!-- Calibration Panel - Updated text for mask context -->
    <div class="calibration-panel" id="calibrationPanel">
        <div class="calibration-text">
            FACE SCAN REQUIRED<br><br>
            Look UP then DOWN to calibrate pitch.<br><br>
            Slowly turn head for full geometry capture.<br><br>
            400-second scan will begin after.
        </div>
        <button class="calibration-btn" id="startCalibrationBtn">START SCAN</button>
    </div>
    
    <!-- JSON Export Panels - One for each JSON -->
    <div class="json-panel" id="meshJsonPanel">
        <div class="json-title">FACE MESH GEOMETRY</div>
        <div class="json-content" id="meshJsonContent"></div>
        <button class="json-btn" id="copyMeshJsonBtn">COPY JSON</button>
    </div>
    <div class="json-panel" id="measurementsJsonPanel">
        <div class="json-title">KEY MEASUREMENTS</div>
        <div class="json-content" id="measurementsJsonContent"></div>
        <button class="json-btn" id="copyMeasurementsJsonBtn">COPY JSON</button>
    </div>
    <div class="json-panel" id="paramsJsonPanel">
        <div class="json-title">SECURITY PARAMETERS</div>
        <div class="json-content" id="paramsJsonContent"></div>
        <button class="json-btn" id="copyParamsJsonBtn">COPY JSON</button>
    </div>
    
    <!-- 3D SCENE - Retained, but updated to show face mesh -->
    <div id="visualizationContainer">
        <canvas id="visualizationCanvas"></canvas>
        <div id="sceneClickArea" title="Touch and drag to rotate view"></div>
    </div>
    
    <div id="ideInterface">
        <!-- LEFT SIDE SCAN BUTTON - Updated -->
        <button id="scanBtn" class="scan-btn" aria-label="Start Face Scan">START FACE SCAN</button>
        
        <!-- RIGHT SIDE CONTROLS - Retained -->
        <div class="right-controls">
            <button id="zoomInBtn" class="zoom-in-btn" aria-label="Zoom In">ZOOM IN</button>
            <button id="zoomOutBtn" class="zoom-out-btn" aria-label="Zoom Out">ZOOM OUT</button>
            <button id="resetViewBtn" class="reset-btn" aria-label="Reset View">RESET VIEW</button>
        </div>
        
        <!-- CAMERA ROTATION CONTROLS - Retained -->
        <div class="camera-controls">
            <button id="cameraLeftBtn" class="camera-btn" aria-label="Rotate Left">←</button>
            <button id="cameraRightBtn" class="camera-btn" aria-label="Rotate Right">→</button>
            <button id="cameraUpBtn" class="camera-btn" aria-label="Rotate Up">↑</button>
            <button id="cameraDownBtn" class="camera-btn" aria-label="Rotate Down">↓</button>
        </div>
        
        <!-- HUD -->
        <div id="hudWarning">FACE NOT DETECTED</div>
    </div>
</div>

<script>
    // Main Application Variables - Updated for mask focus
    let scene, cam, ren, clock;
    let userMesh; // Replaced userObj with actual face mesh
    let faceLandmarksData = []; // Collect multiple frames for averaging
    let faceDirection = 0, faceDetected = false;
    let stream, faceMesh, camera;
    let isFrontCam = true;
    const userPosition = new THREE.Vector3(0, 0, 0); // Centered for mask view
    let animationId = null;
    let scanActive = false;
    let sceneScale = 1.0;
    let isZooming = false;
    let landmarkCount = 0;
    let frameCount = 0;
    let lastFpsUpdate = 0;
    const fpsUpdateInterval = 1000;
    
    // Face mesh geometry - From MediaPipe
    let faceGeometry, faceMaterial;
    let maskOverlay; // Simple wireframe mask simulation
    
    // Processing Timer Variables
    let processingTimer = 400; // 400 seconds for scan simulation
    let timerInterval = null;
    let isProcessing = false;
    let calibrationComplete = false;
    let calibrationStep = 0; // 0=not started, 1=looking up, 2=looking down, 3=complete
    
    // Scene Data for JSON Export - Updated for three files
    let sceneData = {
        faceMesh: { vertices: [], faces: [] },
        measurements: {},
        parameters: {
            filterAttachments: [{x: 0, y: 0, z: 0}, {x: 1, y: 0, z: 0}], // Example points
            materialThickness: 2, // mm
            sealHardness: 15 // Shore
        },
        timestamp: null
    };

    // DOM utility functions
    const $ = s => document.querySelector(s);
    const $$ = s => document.querySelectorAll(s);

    function init() {
        try {
            init3D();
            setupFaceDetection();
            setupEventListeners();
            showCalibrationPanel();
            animate();
            
            console.log("Custom Security Mask Design System initialized");
        } catch (error) {
            console.error('Initialization error:', error);
            $('#scanStatus').textContent = 'SCAN: INIT FAILED';
        }
    }

    function init3D() {
        try {
            // Initialize Three.js scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            updateCameraPosition();
            
            const canvas = $('#visualizationCanvas');
            ren = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                antialias: false, 
                powerPreference: "high-performance" 
            });
            ren.setSize(window.innerWidth, window.innerHeight);
            ren.setPixelRatio(1); // Force 1x for performance
            
            clock = new THREE.Clock();

            // Lighting
            scene.add(new THREE.AmbientLight(0x003300));
            const dir = new THREE.DirectionalLight(0x00ff00, 0.4);
            dir.position.set(5, 10, 5);
            scene.add(dir);

            // Grid
            const gridHelper = new THREE.GridHelper(20, 20, 0x004400, 0x002200);
            scene.add(gridHelper);

            // Face mesh placeholder
            faceGeometry = new THREE.BufferGeometry();
            faceMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });
            userMesh = new THREE.Mesh(faceGeometry, faceMaterial);
            scene.add(userMesh);
            
            // Simulated mask overlay (simple box for illustration)
            const maskGeo = new THREE.BoxGeometry(0.5, 0.3, 0.2);
            const maskMat = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
            maskOverlay = new THREE.Mesh(maskGeo, maskMat);
            maskOverlay.position.set(0, 0, -0.1); // Offset for nose area
            scene.add(maskOverlay);

            cam.lookAt(userPosition);
            ren.render(scene, cam);
            
        } catch (error) {
            console.error('3D initialization error:', error);
            throw new Error(`3D setup failed: ${error.message}`);
        }
    }
    
    function updateCameraPosition() {
        // Retained original
        const x = cameraDistance * Math.sin(cameraAngleY) * Math.cos(cameraAngleX);
        const y = cameraDistance * Math.sin(cameraAngleX);
        const z = cameraDistance * Math.cos(cameraAngleY) * Math.cos(cameraAngleX);
        
        cam.position.set(x, y, z);
        cam.lookAt(userPosition);
        
        $('#zoomLevel').textContent = (1 / cameraDistance * 5).toFixed(1);
    }

    function setupFaceDetection() {
        try {
            faceMesh = new FaceMesh({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
                }
            });
            
            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            faceMesh.onResults(onFaceMeshResults);
            
            console.log("Face Mesh detection initialized");
            $('#scanStatus').textContent = 'SCAN: FACE DETECTION READY';
        } catch (error) {
            console.error('Face detection setup error:', error);
            $('#scanStatus').textContent = 'SCAN: FACE DETECTION FAILED';
        }
    }

    function onFaceMeshResults(results) {
        faceDetected = results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0;
        $('#hudWarning').style.display = faceDetected ? 'none' : 'block';
        
        const ppvCanvas = $('#ppvCanvas');
        const ppvCtx = ppvCanvas.getContext('2d');
        
        // Clear and draw the video frame
        ppvCtx.clearRect(0, 0, ppvCanvas.width, ppvCanvas.height);
        
        if (results.image) {
            ppvCtx.drawImage(results.image, 0, 0, ppvCanvas.width, ppvCanvas.height);
        }

        if (faceDetected) {
            const landmarks = results.multiFaceLandmarks[0];
            
            // Draw face mesh wireframe on 2D preview
            drawConnectors(ppvCtx, landmarks, FACEMESH_TESSELATION, { color: '#C0C0C070', lineWidth: 1 });
            drawConnectors(ppvCtx, landmarks, FACEMESH_RIGHT_EYE, { color: '#FF3030', lineWidth: 1 });
            drawConnectors(ppvCtx, landmarks, FACEMESH_LEFT_EYE, { color: '#30FF30', lineWidth: 1 });
            drawConnectors(ppvCtx, landmarks, FACEMESH_FACE_OVAL, { color: '#E0E0E0', lineWidth: 2 });
            
            // Calculate face direction (yaw) - Retained
            const leftCheek = landmarks[234];
            const rightCheek = landmarks[454];
            const yaw = Math.atan2(
                (rightCheek.x - leftCheek.x) * ppvCanvas.width,
                (rightCheek.z - leftCheek.z) * 1000
            ) * 180 / Math.PI;
            
            faceDirection = yaw;
            
            // Handle calibration - Retained
            if (isProcessing && !calibrationComplete) {
                handleCalibration(landmarks);
            }
            
            // Collect landmarks for averaging during scan
            if (scanActive) {
                faceLandmarksData.push(landmarks);
                landmarkCount = landmarks.length; // 468
                $('#landmarkCount').textContent = landmarkCount;
            }
            
            // Update 3D face mesh
            update3DFaceMesh(landmarks);
            
            $('#scanStatus').textContent = `SCAN: TRACKING (${yaw.toFixed(0)}°)`;
            
            scanActive = isProcessing && calibrationComplete;
        } else {
            $('#scanStatus').textContent = 'SCAN: FACE NOT DETECTED';
            scanActive = false;
        }
    }
    
    function update3DFaceMesh(landmarks) {
        // Update Three.js geometry with landmarks
        const positions = new Float32Array(landmarks.length * 3);
        for (let i = 0; i < landmarks.length; i++) {
            const lm = landmarks[i];
            positions[i * 3] = (lm.x - 0.5) * 2; // Scale and center
            positions[i * 3 + 1] = (0.5 - lm.y) * 2; // Invert Y
            positions[i * 3 + 2] = lm.z * -2; // Depth
        }
        
        faceGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        faceGeometry.computeVertexNormals();
        
        // Add tessellation indices if not set
        if (!faceGeometry.index) {
            // Use FACEMESH_TESSELATION to set triangular indices (predefined array from MediaPipe)
            // Note: FACEMESH_TESSELATION is an array of [start, end] connections; convert to triangles for full mesh
            // For simplicity, here we approximate with lines or use a point cloud; full triangulation requires predefined indices
            // Example: Assume tesselation as array of triangles (implement as per MediaPipe docs)
        }
        
        // Update mask overlay position to nose area (index 1: nose tip)
        const noseTip = landmarks[1];
        maskOverlay.position.set((noseTip.x - 0.5) * 2, (0.5 - noseTip.y) * 2, noseTip.z * -2 - 0.1);
    }
    
    function handleCalibration(landmarks) {
        // Retained original, adapted for mask scan
        const noseTip = landmarks[1];
        const forehead = landmarks[10];
        const pitch = (noseTip.y - forehead.y) * 1000;
        
        if (calibrationStep === 0) {
            $('#sceneStatus').textContent = 'LOOK UP';
            if (pitch < -5) {
                calibrationStep = 1;
                setTimeout(() => {
                    calibrationStep = 2;
                    $('#sceneStatus').textContent = 'LOOK DOWN';
                }, 1000);
            }
        } else if (calibrationStep === 2) {
            if (pitch > 5) {
                calibrationStep = 3;
                setTimeout(() => {
                    calibrationComplete = true;
                    $('#sceneStatus').textContent = 'ROTATE HEAD';
                    $('#scanStatus').textContent = 'SCAN: CALIBRATION COMPLETE';
                }, 1000);
            }
        }
    }

    function startWebcam() {
        // Retained original, with mobile front cam preference
        if (stream) return;
        
        try {
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            isFrontCam = isMobile;
            
            navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: isFrontCam ? 'user' : 'environment',
                    width: { ideal: 640 },
                    height: { ideal: 480 }
                } 
            })
            .then(s => {
                stream = s;
                
                const video = document.createElement('video');
                video.id = 'webcamVideo';
                video.srcObject = stream;
                video.autoplay = true;
                video.playsInline = true;
                video.style.display = 'none';
                document.body.appendChild(video);
                
                camera = new Camera(video, {
                    onFrame: async () => {
                        await faceMesh.send({ image: video });
                    },
                    width: 640,
                    height: 480
                });
                
                camera.start();
                
                const ppvCanvas = $('#ppvCanvas');
                ppvCanvas.width = $('#ppvFaceView').clientWidth;
                ppvCanvas.height = $('#ppvFaceView').clientHeight;
                
                $('#scanStatus').textContent = 'SCAN: ACTIVE';
                
                console.log("Webcam started");
            })
            .catch(error => {
                console.error('Webcam error:', error);
                $('#scanStatus').textContent = 'CAMERA ACCESS DENIED';
                stream = null;
            });
            
        } catch (error) {
            console.error('Webcam setup error:', error);
            $('#scanStatus').textContent = 'WEBCAM SETUP FAILED';
        }
    }

    function stopWebcam() {
        // Retained
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            stream = null;
            
            if (camera) camera.stop();
            if (faceMesh) faceMesh.close();
            
            const video = $('#webcamVideo');
            if (video) video.remove();
            
            $('#scanStatus').textContent = 'WEBCAM STOPPED';
            
            console.log("Webcam stopped");
        }
    }

    function zoomIn() { /* Retained */ }
    function zoomOut() { /* Retained */ }
    function resetView() { /* Retained */ }
    function rotateCameraLeft() { /* Retained */ }
    function rotateCameraRight() { /* Retained */ }
    function rotateCameraUp() { /* Retained */ }
    function rotateCameraDown() { /* Retained */ }

    function showCalibrationPanel() {
        $('#calibrationPanel').style.display = 'block';
    }
    
    function startCalibration() {
        $('#calibrationPanel').style.display = 'none';
        $('#scanBtn').classList.add('active');
        $('#scanBtn').textContent = 'SCANNING ACTIVE';
        startWebcam();
        startProcessingTimer();
    }
    
    function startProcessingTimer() {
        isProcessing = true;
        processingTimer = 400;
        
        $('#timerDisplay').textContent = `${processingTimer}s`;
        $('#progressDisplay').textContent = '0%';
        
        timerInterval = setInterval(() => {
            processingTimer--;
            $('#timerDisplay').textContent = `${processingTimer}s`;
            
            const progress = ((400 - processingTimer) / 400) * 100;
            $('#progressDisplay').textContent = `${Math.round(progress)}%`;
            
            if (calibrationComplete) {
                $('#sceneStatus').textContent = 'SCANNING FACE...';
            }
            
            if (processingTimer <= 0) {
                clearInterval(timerInterval);
                finishProcessing();
            }
        }, 1000);
    }
    
    function finishProcessing() {
        isProcessing = false;
        scanActive = false;
        
        stopWebcam();
        
        $('#sceneStatus').textContent = 'COMPLETE';
        $('#scanStatus').textContent = 'SCAN: COMPLETE';
        $('#scanBtn').classList.remove('active');
        $('#scanBtn').textContent = 'SCAN COMPLETE';
        
        generateJSONExports();
    }
    
    function generateJSONExports() {
        // Average landmarks from collected data
        if (faceLandmarksData.length === 0) return;
        
        const avgLandmarks = new Array(468).fill(0).map(() => ({x:0, y:0, z:0}));
        faceLandmarksData.forEach(landmarks => {
            landmarks.forEach((lm, i) => {
                avgLandmarks[i].x += lm.x / faceLandmarksData.length;
                avgLandmarks[i].y += lm.y / faceLandmarksData.length;
                avgLandmarks[i].z += lm.z / faceLandmarksData.length;
            });
        });
        
        // Face_Mesh_Geometry.json: Vertices and faces
        sceneData.faceMesh.vertices = avgLandmarks.map(lm => [lm.x, lm.y, lm.z]);
        sceneData.faceMesh.faces = FACEMESH_TESSELATION.flatMap(conn => [conn[0], conn[1], /* Approximate triangles */]); // Full triangulation needed; placeholder
        
        // Key_Measurements.json: Calculate using indices
        const dist = (p1, p2) => Math.sqrt(
            Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2) + Math.pow(p1.z - p2.z, 2)
        );
        sceneData.measurements = {
            interpupillaryDistance: dist(avgLandmarks[33], avgLandmarks[263]), // Left/right eye inner corners
            jawWidth: dist(avgLandmarks[93], avgLandmarks[323]), // Left/right gonion
            noseBridgeHeight: dist(avgLandmarks[6], avgLandmarks[1]) // Bridge top to tip
            // Add more: e.g., eyeToChin: dist(avgLandmarks[168], avgLandmarks[152]) // Glabella to chin
        };
        
        sceneData.timestamp = new Date().toISOString();
        
        // Display JSONs
        $('#meshJsonContent').textContent = JSON.stringify(sceneData.faceMesh, null, 2);
        $('#measurementsJsonContent').textContent = JSON.stringify(sceneData.measurements, null, 2);
        $('#paramsJsonContent').textContent = JSON.stringify(sceneData.parameters, null, 2);
        
        $('#meshJsonPanel').style.display = 'block';
        $('#measurementsJsonPanel').style.display = 'block';
        $('#paramsJsonPanel').style.display = 'block';
    }
    
    function copyJSONToClipboard(id) {
        const content = $(`#${id}Content`).textContent;
        navigator.clipboard.writeText(content).then(() => {
            alert('JSON copied to clipboard!');
        }).catch(err => {
            alert('Failed to copy JSON.');
        });
    }

    function setupEventListeners() {
        // Updated button IDs and labels
        $('#scanBtn').addEventListener('click', () => {
            if (!isProcessing) {
                startCalibration();
            }
        });
        
        $('#startCalibrationBtn').addEventListener('click', startCalibration);
        
        // Updated copy buttons for multiple JSONs
        $('#copyMeshJsonBtn').addEventListener('click', () => copyJSONToClipboard('meshJson'));
        $('#copyMeasurementsJsonBtn').addEventListener('click', () => copyJSONToClipboard('measurementsJson'));
        $('#copyParamsJsonBtn').addEventListener('click', () => copyJSONToClipboard('paramsJson'));
        
        // Retained other listeners: zoom, rotation, PPV toggle, resize, cleanup
    }

    function cleanup() { /* Retained */ }

    function animate() {
        // Retained, with updated render for face mesh
        animationId = requestAnimationFrame(animate);
        const deltaTime = clock.getDelta();
        
        ren.render(scene, cam);
        
        // FPS update retained
    }

    // Initialize on load
    window.addEventListener('load', init);
</script>
</body>
</html>
