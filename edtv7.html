<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>DA3 MASK: CLOUD POINT FACE</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
  *{margin:0;padding:0;box-sizing:border-box;font-family:'Press Start 2P',cursive;image-rendering:pixelated}
  body{background:#000;color:#0f0;overflow:hidden;height:100dvh;user-select:none;touch-action:none}
  canvas{display:block}
  
  /* Header */
  .banner{
    position:absolute;
    top:0;
    left:0;
    right:0;
    background:rgba(0,20,0,0.95);
    border-bottom:2px solid #0f0;
    padding:8px;
    font-size:11px;
    text-align:center;
    z-index:10;
    text-shadow:0 0 10px #0f0;
  }
  
  /* Status bar */
  .status{
    position:absolute;
    bottom:8px;
    left:8px;
    right:8px;
    display:flex;
    gap:8px;
    z-index:10;
  }
  .ind{
    padding:4px 8px;
    font-size:8px;
    background:rgba(0,50,0,0.9);
    border:1px solid #0f0;
    border-radius:4px;
    flex:1;
    text-align:center;
  }
  .locked{background:rgba(0,255,0,0.9);box-shadow:0 0 12px #0f0;animation:p 1.5s infinite}
  @keyframes p{0%,100%{opacity:1}50%{opacity:0.6}}
  
  /* Control Panel */
  .control-panel {
    position: absolute;
    top: 50px;
    right: 8px;
    width: 140px;
    background: rgba(0, 20, 0, 0.85);
    border: 2px solid #0f0;
    border-radius: 8px;
    padding: 12px;
    display: flex;
    flex-direction: column;
    gap: 12px;
    z-index: 10;
  }
  
  .control-group {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }
  
  .control-label {
    font-size: 8px;
    color: #0f0;
    margin-bottom: 4px;
  }
  
  .slider {
    -webkit-appearance: none;
    width: 100%;
    height: 12px;
    background: rgba(0, 50, 0, 0.9);
    border-radius: 6px;
    outline: none;
    border: 1px solid #0f0;
  }
  
  .slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: #0f0;
    cursor: pointer;
    box-shadow: 0 0 5px #0f0;
  }
  
  .value-display {
    font-size: 8px;
    text-align: center;
    margin-top: 4px;
  }
  
  /* Camera Button */
  .camera-button {
    background: rgba(0, 50, 0, 0.9);
    border: 2px solid #0f0;
    border-radius: 8px;
    color: #0f0;
    font-size: 10px;
    padding: 8px;
    cursor: pointer;
    text-align: center;
    transition: all 0.3s;
    box-shadow: 0 0 5px rgba(0, 255, 0, 0.3);
  }
  
  .camera-button:active {
    background: rgba(0, 255, 0, 0.3);
    transform: scale(0.95);
  }
  
  /* Mobile-specific adjustments */
  @media (max-width: 768px) {
    .banner {
      font-size: 9px;
      padding: 6px;
    }
    
    .control-panel {
      width: 130px;
      top: 40px;
      right: 6px;
      padding: 10px;
    }
    
    .ind {
      font-size: 7px;
      padding: 3px 6px;
    }
    
    .camera-button {
      font-size: 9px;
      padding: 6px;
    }
  }
  
  @media (max-width: 480px) {
    .control-panel {
      width: 120px;
      padding: 8px;
    }
    
    .control-label, .value-display {
      font-size: 7px;
    }
    
    .slider {
      height: 10px;
    }
    
    .slider::-webkit-slider-thumb {
      width: 14px;
      height: 14px;
    }
  }

  /* Error message */
  .error-message {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(255, 0, 0, 0.8);
    color: white;
    padding: 12px;
    border-radius: 8px;
    font-size: 10px;
    text-align: center;
    z-index: 20;
    display: none;
  }
</style>
</head>
<body>
<div class="banner">DA3 MASK: REAL-TIME CLOUD POINT FACE</div>

<canvas id="c"></canvas>

<div class="control-panel">
  <div class="control-group">
    <div class="control-label">DEPTH SCALE</div>
    <input type="range" min="0.1" max="2.0" step="0.1" value="1.0" class="slider" id="depthScale" 
           aria-label="Adjust depth scale for 3D effect">
    <div class="value-display" id="depthValue">1.0</div>
  </div>
  
  <div class="control-group">
    <div class="control-label">POINT SIZE</div>
    <input type="range" min="0.001" max="0.02" step="0.001" value="0.004" class="slider" id="pointSize"
           aria-label="Adjust point size in the cloud">
    <div class="value-display" id="sizeValue">0.004</div>
  </div>
  
  <button class="camera-button" id="camButton" aria-label="Switch between front and rear camera">CAM: FRONT</button>
</div>

<div class="status">
  <div class="ind" id="status">DA3: OFFLINE</div>
</div>

<div class="error-message" id="errorMessage"></div>

<script type="module">
// Updated to latest versions as of 2025
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.181.2/build/three.module.js';
import '@tensorflow/tfjs-backend-webgl';
import * as faceLandmarksDetection from 'https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection@1.0.6/dist/face-landmarks-detection.js';

const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
renderer.setPixelRatio(devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 10);
camera.position.set(0,0,0.8);

const light = new THREE.HemisphereLight(0x00ff88, 0x0088ff, 2);
scene.add(light);

let detector, pointsGeo, pointsMat, points;
let currentPoints = new Float32Array(478*3); // Updated for refined landmarks
let depthScale = 1.0;
let pointSize = 0.004;
let useFrontCamera = true;
let lastFaceTime = 0;
const FACE_TIMEOUT = 1000; // Clear points after 1 second of no detection

// Initialize UI elements
const depthScaleSlider = document.getElementById('depthScale');
const pointSizeSlider = document.getElementById('pointSize');
const depthValueDisplay = document.getElementById('depthValue');
const sizeValueDisplay = document.getElementById('sizeValue');
const camButton = document.getElementById('camButton');
const errorMessage = document.getElementById('errorMessage');

// Performance optimization: throttle buffer updates
let needsBufferUpdate = false;
let lastUpdateTime = 0;
const UPDATE_INTERVAL = 16; // ~60fps

// Update slider displays
depthScaleSlider.addEventListener('input', (e) => {
  depthScale = parseFloat(e.target.value);
  depthValueDisplay.textContent = depthScale.toFixed(1);
});

pointSizeSlider.addEventListener('input', (e) => {
  pointSize = parseFloat(e.target.value);
  sizeValueDisplay.textContent = pointSize.toFixed(3);
  if (pointsMat) pointsMat.size = pointSize;
});

// Camera toggle
camButton.addEventListener('click', async () => {
  useFrontCamera = !useFrontCamera;
  camButton.textContent = useFrontCamera ? 'CAM: FRONT' : 'CAM: BACK';
  camButton.setAttribute('aria-label', 
    useFrontCamera ? 'Switch to rear camera' : 'Switch to front camera');
  await initCamera();
});

pointsMat = new THREE.PointsMaterial({color:0x00ff88, size:pointSize, sizeAttenuation:true});
pointsGeo = new THREE.BufferGeometry();
points = new THREE.Points(pointsGeo, pointsMat);
scene.add(points);

let video;

function showError(message) {
  errorMessage.textContent = message;
  errorMessage.style.display = 'block';
  setTimeout(() => {
    errorMessage.style.display = 'none';
  }, 5000);
}

async function initCamera() {
  if (video) {
    video.srcObject.getTracks().forEach(track => track.stop());
  }
  
  const constraints = {
    video: {
      facingMode: useFrontCamera ? 'user' : 'environment',
      width: { ideal: 640 },
      height: { ideal: 480 }
    }
  };
  
  try {
    video = document.createElement('video');
    video.width = 640;
    video.height = 480;
    video.autoplay = true;
    video.playsInline = true;
    
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    
    return new Promise((resolve) => {
      video.onloadedmetadata = () => {
        resolve(video);
      };
    });
  } catch (err) {
    console.error('Error accessing camera:', err);
    showError('Camera access denied. Please allow camera permissions.');
    document.getElementById('status').textContent = 'DA3: CAM ERROR';
    return null;
  }
}

async function init() {
  document.getElementById('status').textContent = 'DA3: LOADING';
  
  try {
    // Initialize camera
    await initCamera();
    
    // Load face detection model with updated API
    detector = await faceLandmarksDetection.createDetector(
      faceLandmarksDetection.SupportedModels.MediaPipeFaceMesh,
      {
        runtime: 'tfjs',
        refineLandmarks: true,
        maxFaces: 1
      }
    );
    
    document.getElementById('status').textContent = 'DA3: ONLINE';
    document.getElementById('status').classList.add('locked');
    requestAnimationFrame(loop);
  } catch (error) {
    console.error('Initialization error:', error);
    showError('Failed to initialize face detection. Please refresh the page.');
    document.getElementById('status').textContent = 'DA3: ERROR';
  }
}

function clearPoints() {
  // Fill with zeros to clear the points
  currentPoints.fill(0);
  pointsGeo.setAttribute('position', new THREE.BufferAttribute(currentPoints, 3));
  needsBufferUpdate = false;
}

async function processFaceDetection() {
  if (!detector || !video) return;

  try {
    const faces = await detector.estimateFaces(video, { flipHorizontal: false });
    
    if (faces.length > 0) {
      lastFaceTime = Date.now();
      const landmarks = faces[0].keypoints;
      const numPoints = landmarks.length;
      
      // Update currentPoints array size if needed
      if (currentPoints.length !== numPoints * 3) {
        currentPoints = new Float32Array(numPoints * 3);
      }
      
      for (let i = 0; i < numPoints; i++) {
        const p = landmarks[i];
        currentPoints[i*3]   = (p.x / video.videoWidth - 0.5) * 0.6;
        currentPoints[i*3+1] = -(p.y / video.videoHeight - 0.5) * 0.6;
        currentPoints[i*3+2] = (p.z * 0.001 || 0) * depthScale;
      }
      needsBufferUpdate = true;
    } else {
      // No face detected - clear points after timeout
      if (Date.now() - lastFaceTime > FACE_TIMEOUT) {
        clearPoints();
      }
    }
  } catch (error) {
    console.error('Face detection error:', error);
    // Don't show error for every frame, just log it
  }
}

function loop() {
  const currentTime = Date.now();
  
  // Process face detection
  processFaceDetection();
  
  // Update buffer only when needed and at controlled intervals
  if (needsBufferUpdate && currentTime - lastUpdateTime > UPDATE_INTERVAL) {
    pointsGeo.setAttribute('position', new THREE.BufferAttribute(currentPoints, 3));
    pointsGeo.attributes.position.needsUpdate = true;
    needsBufferUpdate = false;
    lastUpdateTime = currentTime;
  }
  
  renderer.render(scene, camera);
  requestAnimationFrame(loop);
}

window.addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// Handle page visibility changes to pause/resume processing
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    // Page is hidden, could pause processing here if needed
  } else {
    // Page is visible again
    lastFaceTime = Date.now(); // Reset face timeout
  }
});

init();
</script>

<script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('data:application/javascript;basecode64,' + btoa(`
    self.addEventListener('install', e => self.skipWaiting());
    self.addEventListener('activate', e => e.waitUntil(self.clients.claim()));
    self.addEventListener('fetch', e => e.respondWith(fetch(e.request)));
  `));
}
</script>
</body>
</html>
