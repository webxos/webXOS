<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>webXOS ANYTHING | DA3 lightweight blender</title>
  <style>
    :root {
      --bg: #0b0f1a;
      --panel: #111827;
      --text: #e5e7eb;
      --muted: #94a3b8;
      --accent: #22d3ee;
      --accent2: #8a2be2;
      --border: rgba(148,163,184,0.2);
    }
    * { box-sizing: border-box }
    html, body { height: 100% }
    body {
      margin: 0;
      background:
        radial-gradient(1200px 600px at 8% -10%, rgba(34,211,238,0.12), transparent 60%),
        radial-gradient(900px 700px at 100% 110%, rgba(138,43,226,0.08), transparent 60%),
        var(--bg);
      color: var(--text);
      font: 14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
    }
    .app {
      display: grid;
      grid-template-columns: 300px 1fr 320px;
      grid-template-rows: auto 1fr auto;
      gap: 8px;
      height: 100vh;
    }
    header {
      grid-column: 1 / -1;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 14px;
      border-bottom: 1px solid var(--border);
      background: color-mix(in srgb, var(--panel), transparent 15%);
      backdrop-filter: blur(6px);
    }
    .brand { display:flex; align-items:center; gap:10px; font-weight:700 }
    .brand svg { filter: drop-shadow(0 0 6px rgba(34,211,238,0.5)) }
    .toolbar { display:flex; gap:8px; flex-wrap:wrap }
    .btn {
      background: linear-gradient(90deg, var(--accent), #06b6d4);
      color: #061924; border: none; border-radius: 8px;
      padding: 8px 12px; font-weight: 700; cursor: pointer;
    }
    .btn.secondary {
      background: transparent; color: var(--accent); border: 1px solid var(--border);
    }
    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px; padding: 12px; overflow: auto;
    }
    .left { grid-row: 2; }
    .center { grid-row: 2; position: relative; min-height: 0; }
    .right { grid-row: 2; }
    footer {
      grid-column: 1 / -1;
      padding: 10px 14px; border-top: 1px solid var(--border);
      color: var(--muted); font-size: 12px;
    }
    #threeCanvas { width: 100%; height: 100%; display: block; }
    .group { margin-bottom: 16px }
    .group h3 { margin: 0 0 10px 0; font-size: 13px; color: var(--accent) }
    .field { display:flex; align-items:center; justify-content:space-between; gap:8px; margin: 8px 0 }
    .field label { color: var(--muted) }
    .field input[type="range"] { width: 140px }
    .stack { display:flex; gap:6px; flex-wrap: wrap }
    .list { display:flex; flex-direction:column; gap:6px; }
    .list-item {
      display:flex; align-items:center; justify-content:space-between;
      background: rgba(255,255,255,0.03); border: 1px solid var(--border); border-radius:6px;
      padding: 8px;
    }
    .list-item.active { border-color: var(--accent); box-shadow: 0 0 12px rgba(34,211,238,0.15) }
    .inline { display:flex; gap:8px; align-items:center; flex-wrap:wrap }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size: 12px; background: rgba(255,255,255,0.05); padding: 2px 6px; border-radius: 6px; border: 1px solid var(--border) }
    .muted { color: var(--muted) }
    .divider { border-top: 1px solid var(--border); margin: 12px 0 }
    .danger { color: #ff6666 }
    .select, .text {
      width: 100%; padding: 8px; border-radius: 8px; border: 1px solid var(--border);
      background: #0d1324; color: var(--text);
    }
    .thumb {
      width: 100%; height: 120px; border-radius:8px; border:1px solid var(--border);
      background: #0d1324 center/cover no-repeat;
    }
    .overlay-hint {
      position:absolute; top:8px; left:8px; display:flex; gap:8px;
      background: rgba(0,0,0,0.4); border:1px solid var(--border); border-radius:8px; padding:6px 8px;
      font-size:12px; color: var(--muted);
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="brand">
        <svg width="28" height="28" viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <circle cx="12" cy="12" r="10" stroke="#22d3ee" stroke-width="2"/>
          <path d="M12 6v6l4 4" stroke="#22d3ee" stroke-width="2" stroke-linecap="round"/>
        </svg>
        <span>webXOS ANYTHING • DA3 lightweight blender</span>
      </div>
      <div class="toolbar">
        <label class="btn secondary" for="imageInput">Import image</label>
        <input id="imageInput" type="file" accept="image/*" style="display:none"/>
        <button id="addAsPointCloud" class="btn secondary">Add as point cloud</button>
        <button id="addAsDisplacedMesh" class="btn secondary">Add as displaced mesh</button>
        <button id="duplicateObject" class="btn secondary">Duplicate</button>
        <button id="deleteObject" class="btn secondary"><span class="danger">Delete</span></button>
        <button id="exportGLTF" class="btn">Export glTF</button>
      </div>
    </header>

    <section class="panel left" id="leftPanel">
      <div class="group">
        <h3>Outliner</h3>
        <div id="outliner" class="list"></div>
      </div>

      <div class="group">
        <h3>Transform</h3>
        <div class="inline">
          <button class="btn secondary" id="modeTranslate">Move (G)</button>
          <button class="btn secondary" id="modeRotate">Rotate (R)</button>
          <button class="btn secondary" id="modeScale">Scale (S)</button>
        </div>
        <div class="field"><label>Snap</label><input id="snapToggle" type="checkbox"><span class="muted">grid</span></div>
        <div class="field"><label>Snap increment</label><input id="snapIncrement" type="range" min="0.01" max="1" step="0.01" value="0.1"></div>
        <div class="divider"></div>
        <div class="field"><label>X</label><input id="posX" class="text" type="number" step="0.01" value="0"></div>
        <div class="field"><label>Y</label><input id="posY" class="text" type="number" step="0.01" value="0"></div>
        <div class="field"><label>Z</label><input id="posZ" class="text" type="number" step="0.01" value="0"></div>
      </div>

      <div class="group">
        <h3>Material</h3>
        <div class="field"><label>Metalness</label><input id="metal" type="range" min="0" max="1" step="0.01" value="0"></div>
        <div class="field"><label>Roughness</label><input id="rough" type="range" min="0" max="1" step="0.01" value="1"></div>
        <div class="field"><label>Opacity</label><input id="opacity" type="range" min="0.1" max="1" step="0.05" value="1"></div>
        <div class="field"><label>Point size</label><input id="pointSize" type="range" min="0.005" max="0.05" step="0.002" value="0.012"></div>
      </div>

      <div class="group">
        <h3>DA3 calibration (display-only)</h3>
        <div class="field"><label>Metric scale</label><input id="metricScale" type="range" min="0.5" max="1.5" step="0.01" value="1.00"></div>
        <div class="field"><label>Edge precision</label><input id="edgePrecision" type="range" min="0" max="1" step="0.01" value="0.92"></div>
        <div class="field"><label>Point density</label><input id="pointDensity" type="range" min="1" max="12" step="1" value="4"></div>
      </div>
    </section>

    <section class="panel center" id="centerPanel">
      <div class="overlay-hint">
        <span class="kbd">Mouse</span><span>Orbit</span>
        <span class="kbd">Shift + Mouse</span><span>Pan</span>
        <span class="kbd">Wheel</span><span>Zoom</span>
      </div>
      <canvas id="threeCanvas"></canvas>
    </section>

    <section class="panel right" id="rightPanel">
      <div class="group">
        <h3>Import preview</h3>
        <div id="thumb" class="thumb"></div>
        <div class="field"><label>Crop square</label><input id="cropSquare" type="checkbox" checked></div>
        <div class="field"><label>Target side</label><input id="targetSide" type="range" min="256" max="1024" step="64" value="512"></div>
      </div>

      <div class="group">
        <h3>Scene tools</h3>
        <div class="stack">
          <button id="recenter" class="btn secondary">Recenter camera</button>
          <button id="clearScene" class="btn secondary">Clear scene</button>
          <button id="fitSelected" class="btn secondary">Frame selected</button>
        </div>
      </div>

      <div class="group">
        <h3>Export</h3>
        <select id="exportFormat" class="select">
          <option value="gltf">glTF (scene)</option>
          <option value="ply">PLY (selected point cloud)</option>
          <option value="obj">OBJ (selected mesh)</option>
        </select>
        <div class="stack" style="margin-top:8px">
          <button id="exportBtn" class="btn">Export</button>
        </div>
      </div>

      <div class="group">
        <h3>Status</h3>
        <div class="inline"><span class="muted">FPS:</span><span id="fps">0</span></div>
        <div class="inline"><span class="muted">Resolution:</span><span id="resolution">—</span></div>
        <div class="inline"><span class="muted">Objects:</span><span id="objectCount">0</span></div>
      </div>
    </section>

    <footer>
      <span>Depth Anything 3 visualization sandbox • No webcam. Import images to generate point clouds or displaced meshes, then edit with gizmos. Export your scene.</span>
    </footer>
  </div>

  <!-- Three.js and controls -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r155/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r155/examples/js/controls/OrbitControls.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r155/examples/js/controls/TransformControls.min.js"></script>
  <!-- glTF exporter -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r155/examples/js/exporters/GLTFExporter.min.js"></script>

  <script>
    // Config
    const TARGET_DEFAULT = 512;

    // State
    const S = {
      objects: [],
      selected: null,
      metricScale: 1.0,
      edgePrecision: 0.92,
      pointSize: 0.012,
      pointDensity: 4,
      targetSide: TARGET_DEFAULT,
      cropSquare: true,
    };

    // DOM
    const dom = {
      canvas: document.getElementById('threeCanvas'),
      fps: document.getElementById('fps'),
      resolution: document.getElementById('resolution'),
      objectCount: document.getElementById('objectCount'),
      imageInput: document.getElementById('imageInput'),
      addPC: document.getElementById('addAsPointCloud'),
      addMesh: document.getElementById('addAsDisplacedMesh'),
      duplicate: document.getElementById('duplicateObject'),
      del: document.getElementById('deleteObject'),
      exportGLTF: document.getElementById('exportGLTF'),
      outliner: document.getElementById('outliner'),
      thumb: document.getElementById('thumb'),
      cropSquare: document.getElementById('cropSquare'),
      targetSide: document.getElementById('targetSide'),
      recenter: document.getElementById('recenter'),
      clearScene: document.getElementById('clearScene'),
      fitSelected: document.getElementById('fitSelected'),
      exportFormat: document.getElementById('exportFormat'),
      exportBtn: document.getElementById('exportBtn'),
      // transforms
      modeTranslate: document.getElementById('modeTranslate'),
      modeRotate: document.getElementById('modeRotate'),
      modeScale: document.getElementById('modeScale'),
      snapToggle: document.getElementById('snapToggle'),
      snapIncrement: document.getElementById('snapIncrement'),
      posX: document.getElementById('posX'),
      posY: document.getElementById('posY'),
      posZ: document.getElementById('posZ'),
      // material
      metal: document.getElementById('metal'),
      rough: document.getElementById('rough'),
      opacity: document.getElementById('opacity'),
      pointSize: document.getElementById('pointSize'),
      // DA3
      metricScale: document.getElementById('metricScale'),
      edgePrecision: document.getElementById('edgePrecision'),
      pointDensity: document.getElementById('pointDensity'),
    };

    // Three.js
    let scene, camera, renderer, orbit, transform;
    initThree();

    function initThree() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0c1224);

      const w = dom.canvas.clientWidth || 800;
      const h = dom.canvas.clientHeight || 600;

      camera = new THREE.PerspectiveCamera(60, w / h, 0.01, 1000);
      camera.position.set(0.6, 0.6, 2.6);

      renderer = new THREE.WebGLRenderer({ canvas: dom.canvas, antialias: true });
      renderer.setSize(w, h);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      orbit = new THREE.OrbitControls(camera, dom.canvas);
      orbit.enableDamping = true;

      transform = new THREE.TransformControls(camera, dom.canvas);
      transform.addEventListener('dragging-changed', e => { orbit.enabled = !e.value; updateTransformInputs(); });
      transform.setMode('translate');
      scene.add(transform);

      // Lights + helpers
      const ambient = new THREE.AmbientLight(0xffffff, 0.35); scene.add(ambient);
      const key = new THREE.DirectionalLight(0xffffff, 0.85); key.position.set(1, 1, 2); scene.add(key);
      const rim = new THREE.DirectionalLight(0x22d3ee, 0.4); rim.position.set(-2, 1, -1); scene.add(rim);

      const grid = new THREE.GridHelper(10, 10, 0x004466, 0x001a33); grid.rotation.x = Math.PI/2; scene.add(grid);
      const axes = new THREE.AxesHelper(0.5); scene.add(axes);

      window.addEventListener('resize', onResize);
      dom.canvas.addEventListener('pointerdown', pickObject);

      requestAnimationFrame(loop);
    }

    function onResize() {
      const w = dom.canvas.clientWidth || 800;
      const h = dom.canvas.clientHeight || 600;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    }

    // Render loop
    let lastTime = performance.now(), frameCount = 0;
    function loop(now) {
      requestAnimationFrame(loop);
      orbit.update();
      renderer.render(scene, camera);

      frameCount++;
      if (now - lastTime >= 1000) {
        dom.fps.textContent = frameCount;
        frameCount = 0;
        lastTime = now;
      }
    }

    // Image pipeline
    let lastImageBitmap = null;
    dom.imageInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const url = URL.createObjectURL(file);
      dom.thumb.style.backgroundImage = `url(${url})`;
      lastImageBitmap = await createImageBitmap(file);
    });
    dom.targetSide.addEventListener('input', () => {
      S.targetSide = Number(dom.targetSide.value);
      dom.resolution.textContent = `${S.targetSide}×${S.targetSide}`;
    });
    dom.cropSquare.addEventListener('change', () => { S.cropSquare = dom.cropSquare.checked; });

    dom.addPC.addEventListener('click', async () => {
      if (!lastImageBitmap) return;
      const { imageData, w, h } = rasterize(lastImageBitmap, S.targetSide, S.cropSquare);
      const depth = simulatedDepth(w, h, S.edgePrecision);
      const obj = buildPointCloud(depth, w, h, imageData, S.pointDensity, S.pointSize, S.metricScale);
      obj.name = suggestName('PointCloud');
      attachObject(obj);
    });

    dom.addMesh.addEventListener('click', async () => {
      if (!lastImageBitmap) return;
      const { imageData, w, h } = rasterize(lastImageBitmap, S.targetSide, S.cropSquare);
      const depth = simulatedDepth(w, h, S.edgePrecision);
      const obj = buildDisplacedMesh(depth, w, h, imageData, S.metricScale);
      obj.name = suggestName('Mesh');
      attachObject(obj);
    });

    function rasterize(bitmap, targetSide, cropSquare) {
      const srcW = bitmap.width, srcH = bitmap.height;
      const canvas = document.createElement('canvas');
      canvas.width = targetSide; canvas.height = targetSide;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });

      let sx = 0, sy = 0, sw = srcW, sh = srcH;
      if (cropSquare) {
        const s = Math.min(srcW, srcH);
        sx = Math.floor((srcW - s) / 2);
        sy = Math.floor((srcH - s) / 2);
        sw = s; sh = s;
      }
      ctx.drawImage(bitmap, sx, sy, sw, sh, 0, 0, targetSide, targetSide);
      const imageData = ctx.getImageData(0, 0, targetSide, targetSide);
      dom.resolution.textContent = `${targetSide}×${targetSide}`;
      return { imageData, w: targetSide, h: targetSide };
    }

    // Depth simulator (replace with DA3 if desired)
    function simulatedDepth(w, h, edgePrecision=0.92) {
      const d = new Float32Array(w*h);
      const k = 0.08 * (1.0 - edgePrecision); // lower precision => more noise
      for (let y=0; y<h; y++) {
        for (let x=0; x<w; x++) {
          const dx = (x - w/2) / (w/2);
          const dy = (y - h/2) / (h/2);
          const dist = Math.sqrt(dx*dx + dy*dy);
          const noise = k * Math.sin(x * 0.11) * Math.cos(y * 0.07);
          d[y*w + x] = Math.max(0.01, 1.0 - Math.min(1.0, dist) + noise);
        }
      }
      return d;
    }

    // Builders
    function buildPointCloud(depth, w, h, imageData, density, pointSize, metricScale) {
      const stride = Math.max(1, Math.floor(density));
      const sampleCount = Math.ceil((w*h) / stride);

      const positions = new Float32Array(sampleCount * 3);
      const colors = new Float32Array(sampleCount * 3);

      const fx = w, fy = w, cx = w/2, cy = h/2;
      let pi = 0, ci = 0;

      for (let i=0; i<w*h; i+=stride) {
        const y = (i / w) | 0, x = i - y * w;
        const z = depth[i] * metricScale;
        if (z <= 0) continue;

        const X = (x - cx) * z / fx;
        const Y = (y - cy) * z / fy;
        const Z = z;

        positions[pi++] = X;
        positions[pi++] = -Y;
        positions[pi++] = -Z;

        const p4 = i * 4;
        colors[ci++] = imageData.data[p4] / 255;
        colors[ci++] = imageData.data[p4+1] / 255;
        colors[ci++] = imageData.data[p4+2] / 255;
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(positions.subarray(0, pi), 3));
      geo.setAttribute('color', new THREE.BufferAttribute(colors.subarray(0, ci), 3));
      geo.computeBoundingBox();
      const center = new THREE.Vector3(); geo.boundingBox.getCenter(center);

      const mat = new THREE.PointsMaterial({
        size: pointSize, vertexColors: true, sizeAttenuation: true, transparent: true, opacity: Number(dom.opacity.value)
      });

      const points = new THREE.Points(geo, mat);
      points.position.sub(center);
      points.userData.type = 'pointcloud';
      return points;
    }

    function buildDisplacedMesh(depth, w, h, imageData, metricScale) {
      const geo = new THREE.PlaneGeometry(1, 1, w-1, h-1);
      const pos = geo.attributes.position.array;

      for (let i=0; i<depth.length; i++) {
        const z = -depth[i] * metricScale;
        const vi = i*3;
        pos[vi+2] = z;
      }
      geo.computeVertexNormals();

      const texCanvas = document.createElement('canvas'); texCanvas.width = w; texCanvas.height = h;
      const ctx = texCanvas.getContext('2d'); const imgData = ctx.createImageData(w, h);
      imgData.data.set(imageData.data); ctx.putImageData(imgData, 0, 0);
      const texture = new THREE.CanvasTexture(texCanvas);
      texture.flipY = true;

      const mat = new THREE.MeshStandardMaterial({
        map: texture, metalness: Number(dom.metal.value), roughness: Number(dom.rough.value),
        transparent: true, opacity: Number(dom.opacity.value)
      });

      const mesh = new THREE.Mesh(geo, mat);
      mesh.scale.set(1.8, 1.8, 1);
      mesh.position.set(0, 0, -0.4);
      mesh.userData.type = 'mesh';
      return mesh;
    }

    // Scene management
    function attachObject(obj) {
      scene.add(obj);
      S.objects.push(obj);
      dom.objectCount.textContent = S.objects.length;
      selectObject(obj);
      refreshOutliner();
    }

    function selectObject(obj) {
      S.selected = obj;
      transform.attach(obj);
      updateTransformInputs();
      highlightOutliner(obj);
    }

    function detachSelected() {
      transform.detach();
      S.selected = null;
      updateTransformInputs();
      refreshOutliner();
    }

    function refreshOutliner() {
      dom.outliner.innerHTML = '';
      S.objects.forEach((o, idx) => {
        const li = document.createElement('div');
        li.className = 'list-item' + (S.selected === o ? ' active' : '');
        li.innerHTML = `
          <span>${o.name || (o.userData.type === 'pointcloud' ? 'PointCloud' : 'Mesh')} <span class="muted">#${idx}</span></span>
          <div class="inline">
            <span class="kbd">${o.userData.type}</span>
            <button class="btn secondary" data-idx="${idx}">Select</button>
          </div>
        `;
        li.querySelector('button').addEventListener('click', () => selectObject(S.objects[idx]));
        dom.outliner.appendChild(li);
      });
    }

    function highlightOutliner(obj) {
      Array.from(dom.outliner.children).forEach((el, i) => {
        el.classList.toggle('active', S.objects[i] === obj);
      });
    }

    function suggestName(base) {
      const n = S.objects.filter(o => (o.userData.type === (base.toLowerCase().includes('mesh') ? 'mesh' : 'pointcloud'))).length;
      return `${base} ${n+1}`;
    }

    // Picking
    function pickObject(ev) {
      const rect = dom.canvas.getBoundingClientRect();
      const x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
      const y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
      const mouse = new THREE.Vector2(x, y);
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObjects(S.objects, true);
      if (hits.length) selectObject(hits[0].object.type === 'Mesh' ? hits[0].object : hits[0].object.parent || hits[0].object);
    }

    // Toolbar actions
    dom.modeTranslate.addEventListener('click', () => transform.setMode('translate'));
    dom.modeRotate.addEventListener('click', () => transform.setMode('rotate'));
    dom.modeScale.addEventListener('click', () => transform.setMode('scale'));

    dom.snapToggle.addEventListener('change', () => {
      const s = dom.snapToggle.checked ? Number(dom.snapIncrement.value) : null;
      transform.setTranslationSnap(s);
      transform.setRotationSnap(s ? s * Math.PI : null);
      transform.setScaleSnap(s);
    });
    dom.snapIncrement.addEventListener('input', () => {
      if (!dom.snapToggle.checked) return;
      const s = Number(dom.snapIncrement.value);
      transform.setTranslationSnap(s);
      transform.setRotationSnap(s * Math.PI);
      transform.setScaleSnap(s);
    });

    dom.posX.addEventListener('input', () => { if (S.selected) { S.selected.position.x = Number(dom.posX.value); }});
    dom.posY.addEventListener('input', () => { if (S.selected) { S.selected.position.y = Number(dom.posY.value); }});
    dom.posZ.addEventListener('input', () => { if (S.selected) { S.selected.position.z = Number(dom.posZ.value); }});

    dom.metal.addEventListener('input', () => applyMaterial());
    dom.rough.addEventListener('input', () => applyMaterial());
    dom.opacity.addEventListener('input', () => applyMaterial());
    dom.pointSize.addEventListener('input', () => {
      S.pointSize = Number(dom.pointSize.value);
      if (S.selected && S.selected.userData.type === 'pointcloud') {
        S.selected.material.size = S.pointSize;
      }
    });

    dom.metricScale.addEventListener('input', () => { S.metricScale = Number(dom.metricScale.value); /* apply on next build */ });
    dom.edgePrecision.addEventListener('input', () => { S.edgePrecision = Number(dom.edgePrecision.value); });
    dom.pointDensity.addEventListener('input', () => { S.pointDensity = Number(dom.pointDensity.value); });

    dom.recenter.addEventListener('click', () => {
      orbit.reset();
      camera.position.set(0.6, 0.6, 2.6);
    });

    dom.clearScene.addEventListener('click', () => {
      S.objects.forEach(o => {
        o.geometry && o.geometry.dispose();
        o.material && o.material.dispose();
        scene.remove(o);
      });
      S.objects = [];
      detachSelected();
      dom.objectCount.textContent = '0';
      refreshOutliner();
    });

    dom.fitSelected.addEventListener('click', () => {
      if (!S.selected) return;
      const box = new THREE.Box3().setFromObject(S.selected);
      const size = new THREE.Vector3(); box.getSize(size);
      const center = new THREE.Vector3(); box.getCenter(center);
      const maxDim = Math.max(size.x, size.y, size.z);
      const dist = maxDim / (2 * Math.tan((camera.fov * Math.PI/180)/2)) + 0.5;
      const dir = new THREE.Vector3(0, 0, 1);
      camera.position.copy(center.clone().add(dir.multiplyScalar(dist)));
      camera.lookAt(center);
      orbit.target.copy(center);
    });

    dom.duplicate.addEventListener('click', () => {
      if (!S.selected) return;
      const clone = S.selected.clone(true);
      clone.name = (S.selected.name || 'Object') + ' (copy)';
      clone.position.x += 0.1;
      attachObject(clone);
    });

    dom.del.addEventListener('click', () => {
      if (!S.selected) return;
      scene.remove(S.selected);
      S.selected.geometry && S.selected.geometry.dispose();
      S.selected.material && S.selected.material.dispose();
      S.objects = S.objects.filter(o => o !== S.selected);
      detachSelected();
      dom.objectCount.textContent = S.objects.length;
      refreshOutliner();
    });

    dom.exportGLTF.addEventListener('click', () => exportSceneGLTF());
    dom.exportBtn.addEventListener('click', () => {
      const fmt = dom.exportFormat.value;
      if (!S.selected && fmt !== 'gltf') return;
      if (fmt === 'gltf') exportSceneGLTF();
      else if (fmt === 'ply' && S.selected?.userData.type === 'pointcloud') exportPLY(S.selected);
      else if (fmt === 'obj' && S.selected?.userData.type === 'mesh') exportOBJ(S.selected);
    });

    function applyMaterial() {
      if (!S.selected) return;
      const op = Number(dom.opacity.value);
      if (S.selected.userData.type === 'mesh') {
        S.selected.material.metalness = Number(dom.metal.value);
        S.selected.material.roughness = Number(dom.rough.value);
        S.selected.material.opacity = op;
        S.selected.material.transparent = op < 1;
        S.selected.material.needsUpdate = true;
      } else if (S.selected.userData.type === 'pointcloud') {
        S.selected.material.opacity = op;
        S.selected.material.transparent = op < 1;
        S.selected.material.needsUpdate = true;
      }
    }

    function updateTransformInputs() {
      if (!S.selected) {
        dom.posX.value = 0; dom.posY.value = 0; dom.posZ.value = 0;
        return;
      }
      dom.posX.value = Number(S.selected.position.x.toFixed(3));
      dom.posY.value = Number(S.selected.position.y.toFixed(3));
      dom.posZ.value = Number(S.selected.position.z.toFixed(3));
    }

    // Exporters
    function exportSceneGLTF() {
      const exporter = new THREE.GLTFExporter();
      exporter.parse(scene, (gltf) => {
        const blob = new Blob([JSON.stringify(gltf)], { type: 'application/json' });
        downloadBlob(blob, 'scene.glb.json');
      }, { binary: false });
    }

    function exportPLY(pointsObj) {
      const pos = pointsObj.geometry.getAttribute('position');
      const col = pointsObj.geometry.getAttribute('color');
      const n = pos.count;
      let header = `ply
format ascii 1.0
element vertex ${n}
property float x
property float y
property float z
property uchar red
property uchar green
property uchar blue
end_header
`;
      let body = '';
      for (let i=0; i<n; i++) {
        const x = pos.getX(i), y = pos.getY(i), z = pos.getZ(i);
        const r = Math.round((col.getX(i) || 0) * 255);
        const g = Math.round((col.getY(i) || 0) * 255);
        const b = Math.round((col.getZ(i) || 0) * 255);
        body += `${x} ${y} ${z} ${r} ${g} ${b}\n`;
      }
      const blob = new Blob([header + body], { type: 'text/plain' });
      downloadBlob(blob, `${sanitizeName(pointsObj.name || 'pointcloud')}.ply`);
    }

    function exportOBJ(meshObj) {
      const geo = meshObj.geometry;
      geo.computeVertexNormals();
      const pos = geo.getAttribute('position');
      const uv = geo.getAttribute('uv');
      const idx = geo.getIndex();
      let obj = `o ${sanitizeName(meshObj.name || 'mesh')}\n`;
      for (let i=0; i<pos.count; i++) obj += `v ${pos.getX(i)} ${pos.getY(i)} ${pos.getZ(i)}\n`;
      if (uv) for (let i=0; i<uv.count; i++) obj += `vt ${uv.getX(i)} ${uv.getY(i)}\n`;
      if (idx) {
        for (let i=0; i<idx.count; i+=3) {
          const a = idx.getX(i)+1, b = idx.getX(i+1)+1, c = idx.getX(i+2)+1;
          obj += `f ${a}/${a} ${b}/${b} ${c}/${c}\n`;
        }
      }
      const blob = new Blob([obj], { type: 'text/plain' });
      downloadBlob(blob, `${sanitizeName(meshObj.name || 'mesh')}.obj`);
    }

    function downloadBlob(blob, filename) {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      a.click();
      setTimeout(() => URL.revokeObjectURL(a.href), 1000);
    }

    function sanitizeName(s) {
      return s.replace(/[^\w\-]+/g, '_');
    }

    // Keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'g') transform.setMode('translate');
      if (e.key.toLowerCase() === 'r') transform.setMode('rotate');
      if (e.key.toLowerCase() === 's') transform.setMode('scale');
      if (e.key === 'Delete' || e.key === 'Backspace') dom.del.click();
      if (e.key === 'f') dom.fitSelected.click();
    });
  </script>
</body>
</html>

