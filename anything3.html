<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>webXOS | ANYTHING3 - Point Cloud Converter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
        }

        body {
            background-color: #000;
            color: #0f0;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background-color: #111;
            padding: 10px;
            border-bottom: 1px solid #0f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 1.5rem;
            color: #0f0;
            text-shadow: 0 0 5px #0f0;
        }

        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .sidebar {
            width: 300px;
            background-color: #111;
            border-right: 1px solid #0f0;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .viewer {
            flex: 1;
            background-color: #000;
            position: relative;
            overflow: hidden;
        }

        #pointCloudViewer {
            width: 100%;
            height: 100%;
        }

        .terminal {
            height: 60px;
            background-color: #000;
            border-top: 1px solid #0f0;
            padding: 5px 10px;
            overflow: hidden;
            font-size: 0.8rem;
        }

        .terminal-line {
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .terminal-prompt {
            color: #0f0;
        }

        .terminal-output {
            color: #fff;
        }

        .terminal-info {
            color: #0af;
        }

        .terminal-error {
            color: #f00;
        }

        .panel {
            background-color: #111;
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 10px;
        }

        .panel-title {
            font-size: 1rem;
            margin-bottom: 10px;
            color: #0f0;
            text-shadow: 0 0 5px #0f0;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .slider {
            width: 100%;
            height: 5px;
            background: #333;
            outline: none;
            border-radius: 5px;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            background: #0f0;
            border-radius: 50%;
            cursor: pointer;
        }

        .slider-value {
            display: inline-block;
            width: 50px;
            text-align: right;
            font-size: 0.8rem;
        }

        .resolution-display {
            font-size: 0.8rem;
            text-align: center;
            margin-top: 5px;
            color: #0af;
        }

        .btn {
            background-color: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s;
            border-radius: 3px;
        }

        .btn:hover {
            background-color: #0f0;
            color: #000;
            box-shadow: 0 0 10px #0f0;
        }

        .btn:disabled {
            background-color: #333;
            color: #666;
            border-color: #666;
            cursor: not-allowed;
            box-shadow: none;
        }

        .btn-group {
            display: flex;
            gap: 5px;
        }

        .btn-group .btn {
            flex: 1;
        }

        .file-cabinet {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .drop-zone {
            border: 2px dashed #0f0;
            border-radius: 5px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .drop-zone:hover, .drop-zone.active {
            background-color: #0f0;
            color: #000;
        }

        .frames-container {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            max-height: 150px;
            overflow-y: auto;
        }

        .frame-thumb {
            width: 60px;
            height: 40px;
            background-color: #222;
            border: 1px solid #0f0;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            text-align: center;
            overflow: hidden;
        }

        .frame-thumb img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .progress-container {
            margin-top: 10px;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background-color: #333;
            border-radius: 5px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background-color: #0f0;
            width: 0%;
            transition: width 0.3s;
        }

        .progress-text {
            text-align: center;
            font-size: 0.8rem;
            margin-top: 5px;
        }

        .status-bar {
            background-color: #111;
            border-top: 1px solid #0f0;
            padding: 5px 10px;
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
        }

        #matrixCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.3;
            z-index: 1;
        }

        #hiddenVideo, #exportCanvas {
            display: none;
        }

        .conversion-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: #111;
            border: 2px solid #0f0;
            border-radius: 10px;
            padding: 20px;
            width: 80%;
            max-width: 500px;
            text-align: center;
        }

        .conversion-details {
            margin-top: 15px;
            font-size: 0.9rem;
        }
        
        .current-settings {
            font-size: 0.8rem;
            margin-top: 10px;
            color: #0af;
        }
        
        .quality-indicator {
            font-size: 0.7rem;
            color: #0f0;
            text-align: center;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>webXOS | ANYTHING3 - Point Cloud Converter</h1>
        <div class="btn-group">
            <button id="helpBtn" class="btn">Help</button>
        </div>
    </div>

    <div class="container">
        <div class="sidebar">
            <div class="panel">
                <div class="panel-title">File Cabinet</div>
                <div class="file-cabinet">
                    <div id="dropZone" class="drop-zone">
                        Drop video file here or click to upload
                    </div>
                    <input type="file" id="fileInput" style="display: none;" accept="video/*">
                    <div class="btn-group">
                        <button id="uploadFileBtn" class="btn">Upload Video</button>
                        <button id="clearFilesBtn" class="btn">Clear</button>
                    </div>
                    <div class="frames-container" id="framesContainer">
                        <!-- Frame thumbnails will appear here -->
                    </div>
                </div>
            </div>

            <div class="panel">
                <div class="panel-title">Conversion Controls</div>
                <div class="current-settings" id="currentSettings">
                    Resolution: 200x200 | Points: 30% | Depth: 50%
                </div>
                <div class="control-group">
                    <label class="control-label">Resolution: <span id="resolutionValue" class="slider-value">200</span></label>
                    <input type="range" min="200" max="600" step="100" value="200" class="slider" id="resolution">
                    <div class="resolution-display" id="resolutionDisplay">200x200 pixels</div>
                    <div class="quality-indicator">Higher = More Detail</div>
                </div>
                <div class="control-group">
                    <label class="control-label">Point Density: <span id="pointDensityValue" class="slider-value">30</span>%</label>
                    <input type="range" min="10" max="80" value="30" class="slider" id="pointDensity">
                    <div class="quality-indicator">Higher = More Points</div>
                </div>
                <div class="control-group">
                    <label class="control-label">Depth Intensity: <span id="depthIntensityValue" class="slider-value">50</span>%</label>
                    <input type="range" min="10" max="100" value="50" class="slider" id="depthIntensity">
                    <div class="quality-indicator">Higher = More 3D Effect</div>
                </div>
                
                <div class="btn-group">
                    <button id="convertBtn" class="btn">Convert to Point Cloud</button>
                    <button id="downloadBtn" class="btn" disabled>Export</button>
                </div>
                <div class="progress-container" id="progressContainer">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressBar"></div>
                    </div>
                    <div class="progress-text" id="progressText">0%</div>
                </div>
            </div>

            <div class="panel">
                <div class="panel-title">Playback Controls</div>
                <div class="btn-group">
                    <button id="playBtn" class="btn">Play</button>
                    <button id="stopBtn" class="btn">Stop</button>
                </div>
            </div>

            <div class="panel">
                <div class="panel-title">Scene Controls</div>
                <div class="btn-group">
                    <button id="resetViewBtn" class="btn">Reset View</button>
                    <button id="clearSceneBtn" class="btn">Clear Scene</button>
                </div>
            </div>
        </div>

        <div class="main-content">
            <div class="viewer">
                <canvas id="matrixCanvas"></canvas>
                <div id="pointCloudViewer"></div>
            </div>
            <div class="terminal">
                <div id="terminal">
                    <div class="terminal-line">
                        <span class="terminal-prompt">system@webXOS:~$ </span>
                        <span class="terminal-output">Point Cloud Converter Ready</span>
                    </div>
                    <div class="terminal-line">
                        <span class="terminal-prompt">system@webXOS:~$ </span>
                        <span class="terminal-output">Upload video to begin conversion</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="status-bar">
        <div id="statusObjects">Points: 0 | Frames: 0 | Resolution: 200x200</div>
        <div>Optimized for 8MB Laptops</div>
    </div>

    <video id="hiddenVideo" controls style="display: none;"></video>
    <canvas id="exportCanvas" style="display: none;"></canvas>

    <!-- Conversion Modal -->
    <div class="conversion-modal" id="conversionModal">
        <div class="modal-content">
            <h3>Converting Video to Point Cloud</h3>
            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="modalProgressBar"></div>
                </div>
                <div class="progress-text" id="modalProgressText">0%</div>
            </div>
            <div class="conversion-details" id="conversionDetails">
                Processing frame 0 of 0
            </div>
            <p id="conversionResolution">Converting to 200x200 point cloud resolution...</p>
            <div class="current-settings" id="modalSettings">
                Resolution: 200x200 | Points: 30% | Depth: 50%
            </div>
            <p class="quality-indicator">Auto-adjusting brightness for optimal quality</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>

    <script>
        // Global variables
        let scene, camera, renderer, controls, pointCloud, pointMaterial;
        let uploadedVideo = null;
        let convertedFrames = [];
        let isPlaying = false;
        let isConverting = false;
        let currentFrameIndex = 0;
        let frameInterval = null;
        let originalFile = null;
        let videoDuration = 0;
        let videoFPS = 0;
        let totalFramesToConvert = 0;
        let convertedFrameCount = 0;
        
        // Resolution for point cloud (optimized for 8MB laptops)
        let pointCloudWidth = 200;
        let pointCloudHeight = 200;
        
        // DOM elements
        const terminal = document.getElementById('terminal');
        const framesContainer = document.getElementById('framesContainer');
        const dropZone = document.getElementById('dropZone');
        const uploadFileBtn = document.getElementById('uploadFileBtn');
        const clearFilesBtn = document.getElementById('clearFilesBtn');
        const helpBtn = document.getElementById('helpBtn');
        const convertBtn = document.getElementById('convertBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const playBtn = document.getElementById('playBtn');
        const stopBtn = document.getElementById('stopBtn');
        const resetViewBtn = document.getElementById('resetViewBtn');
        const clearSceneBtn = document.getElementById('clearSceneBtn');
        const resolutionSlider = document.getElementById('resolution');
        const pointDensitySlider = document.getElementById('pointDensity');
        const depthIntensitySlider = document.getElementById('depthIntensity');
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const statusObjects = document.getElementById('statusObjects');
        const fileInput = document.getElementById('fileInput');
        const hiddenVideo = document.getElementById('hiddenVideo');
        const matrixCanvas = document.getElementById('matrixCanvas');
        const conversionModal = document.getElementById('conversionModal');
        const modalProgressBar = document.getElementById('modalProgressBar');
        const modalProgressText = document.getElementById('modalProgressText');
        const conversionDetails = document.getElementById('conversionDetails');
        const conversionResolution = document.getElementById('conversionResolution');
        const resolutionDisplay = document.getElementById('resolutionDisplay');
        const currentSettings = document.getElementById('currentSettings');
        const modalSettings = document.getElementById('modalSettings');
        
        // Slider value displays
        const resolutionValue = document.getElementById('resolutionValue');
        const pointDensityValue = document.getElementById('pointDensityValue');
        const depthIntensityValue = document.getElementById('depthIntensityValue');
        
        // Global functions
        function addTerminalLine(text, type = 'output') {
            const lineDiv = document.createElement('div');
            lineDiv.className = 'terminal-line';
            
            const promptSpan = document.createElement('span');
            promptSpan.className = 'terminal-prompt';
            promptSpan.textContent = 'system@webXOS:~$ ';
            
            const outputSpan = document.createElement('span');
            outputSpan.className = `terminal-${type}`;
            outputSpan.textContent = text;
            
            lineDiv.appendChild(promptSpan);
            lineDiv.appendChild(outputSpan);
            
            // Keep only 3 lines in terminal
            const lines = terminal.querySelectorAll('.terminal-line');
            if (lines.length >= 3) {
                terminal.removeChild(lines[0]);
            }
            
            terminal.appendChild(lineDiv);
            terminal.scrollTop = terminal.scrollHeight;
        }
        
        function updateCurrentSettings() {
            const resolution = `${pointCloudWidth}x${pointCloudHeight}`;
            const density = `${pointDensitySlider.value}%`;
            const depth = `${depthIntensitySlider.value}%`;
            
            currentSettings.textContent = `Resolution: ${resolution} | Points: ${density} | Depth: ${depth}`;
            
            // Update modal settings too
            modalSettings.textContent = `Resolution: ${resolution} | Points: ${density} | Depth: ${depth}`;
        }
        
        function initThreeJS() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            
            // Renderer setup (optimized for performance)
            renderer = new THREE.WebGLRenderer({ 
                antialias: false, 
                preserveDrawingBuffer: true,
                powerPreference: "low-power"
            });
            renderer.setSize(document.getElementById('pointCloudViewer').offsetWidth, 
                            document.getElementById('pointCloudViewer').offsetHeight);
            document.getElementById('pointCloudViewer').appendChild(renderer.domElement);
            
            // Controls setup
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Add some ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            // Add a directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
            
            // Start animation loop
            animate();
            
            addTerminalLine('3D environment initialized', 'info');
            addTerminalLine(`Point cloud resolution: ${pointCloudWidth}x${pointCloudHeight}`, 'info');
            
            // Update settings display
            updateCurrentSettings();
        }
        
        function onWindowResize() {
            camera.aspect = document.getElementById('pointCloudViewer').offsetWidth / 
                           document.getElementById('pointCloudViewer').offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(document.getElementById('pointCloudViewer').offsetWidth, 
                            document.getElementById('pointCloudViewer').offsetHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        function initMatrixEffect() {
            const canvas = matrixCanvas;
            const ctx = canvas.getContext('2d');
            
            // Set canvas size
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Matrix characters
            const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$+-*/=%\"'#&_(),.;:?!\\|{}<>[]^~";
            const charArray = chars.split("");
            const fontSize = 14;
            const columns = canvas.width / fontSize;
            
            // Array to track the y position of each column
            const drops = [];
            for (let i = 0; i < columns; i++) {
                drops[i] = 1;
            }
            
            function draw() {
                // Semi-transparent black background for trail effect
                ctx.fillStyle = "rgba(0, 0, 0, 0.04)";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = "#0F0"; // Green text
                ctx.font = fontSize + "px monospace";
                
                // Loop over drops
                for (let i = 0; i < drops.length; i++) {
                    // Random character to print
                    const text = charArray[Math.floor(Math.random() * charArray.length)];
                    
                    // x = i * fontSize, y = value of drops[i] * fontSize
                    ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                    
                    // Sending the drop back to the top after it has crossed the screen
                    // Adding randomness to the reset
                    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    
                    // Incrementing Y coordinate
                    drops[i]++;
                }
            }
            
            // Update matrix effect every 33ms (~30fps)
            setInterval(draw, 33);
        }
        
        // File cabinet functionality
        function initFileCabinet() {
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('active');
            });
            
            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('active');
            });
            
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('active');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFileUpload({ target: { files } });
                }
            });
            
            uploadFileBtn.addEventListener('click', () => {
                fileInput.click();
            });
            
            fileInput.addEventListener('change', handleFileUpload);
            
            clearFilesBtn.addEventListener('click', () => {
                framesContainer.innerHTML = '';
                uploadedVideo = null;
                convertedFrames = [];
                if (hiddenVideo.src) {
                    hiddenVideo.src = '';
                }
                stopPointCloud();
                addTerminalLine('File cabinet cleared', 'info');
                statusObjects.textContent = `Points: 0 | Frames: 0 | Resolution: ${pointCloudWidth}x${pointCloudHeight}`;
            });
        }
        
        function handleFileUpload(event) {
            const files = event.target.files;
            if (files.length === 0) return;
            
            const file = files[0];
            if (!file.type.startsWith('video/')) {
                addTerminalLine('Please upload a video file', 'error');
                return;
            }
            
            originalFile = file;
            uploadedVideo = URL.createObjectURL(file);
            hiddenVideo.src = uploadedVideo;
            
            // Create a thumbnail
            const video = document.createElement('video');
            video.src = uploadedVideo;
            video.addEventListener('loadeddata', () => {
                video.currentTime = 1; // Get a frame at 1 second
            });
            
            video.addEventListener('seeked', () => {
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                const frameThumb = document.createElement('div');
                frameThumb.className = 'frame-thumb';
                
                const img = document.createElement('img');
                img.src = canvas.toDataURL();
                frameThumb.appendChild(img);
                
                framesContainer.innerHTML = '';
                framesContainer.appendChild(frameThumb);
                
                addTerminalLine(`Video loaded: ${file.name}`, 'info');
                addTerminalLine(`Will convert to: ${pointCloudWidth}x${pointCloudHeight}`, 'info');
                
                // Get video duration
                videoDuration = video.duration;
                videoFPS = 8; // Lower FPS for 8MB laptops
                totalFramesToConvert = Math.min(Math.floor(videoDuration * videoFPS), 60); // Limit to 60 frames max
                addTerminalLine(`Duration: ${videoDuration.toFixed(1)}s, Frames: ${totalFramesToConvert}`, 'info');
            });
        }
        
        function initEditorControls() {
            // Update slider value displays
            resolutionSlider.addEventListener('input', () => {
                const resolution = parseInt(resolutionSlider.value);
                resolutionValue.textContent = resolution;
                pointCloudWidth = resolution;
                pointCloudHeight = resolution;
                resolutionDisplay.textContent = `${resolution}x${resolution} pixels`;
                statusObjects.textContent = `Points: 0 | Frames: 0 | Resolution: ${pointCloudWidth}x${pointCloudHeight}`;
                
                // Update conversion resolution text
                conversionResolution.textContent = `Converting to ${pointCloudWidth}x${pointCloudHeight} point cloud resolution...`;
                
                // Update settings display
                updateCurrentSettings();
            });
            
            pointDensitySlider.addEventListener('input', () => {
                pointDensityValue.textContent = pointDensitySlider.value;
                updateCurrentSettings();
                
                // Update preview if we have converted frames
                if (convertedFrames.length > 0 && !isConverting) {
                    updatePointCloudPreview();
                }
            });
            
            depthIntensitySlider.addEventListener('input', () => {
                depthIntensityValue.textContent = depthIntensitySlider.value;
                updateCurrentSettings();
                
                // Update preview if we have converted frames
                if (convertedFrames.length > 0 && !isConverting) {
                    updatePointCloudPreview();
                }
            });
            
            convertBtn.addEventListener('click', () => {
                if (uploadedVideo) {
                    convertToPointCloud();
                } else {
                    addTerminalLine('No video uploaded. Please upload a video first.', 'error');
                }
            });
            
            downloadBtn.addEventListener('click', () => {
                if (convertedFrames.length > 0) {
                    exportPointCloudVideo();
                } else {
                    addTerminalLine('No point cloud data to export', 'error');
                }
            });
            
            playBtn.addEventListener('click', playPointCloud);
            stopBtn.addEventListener('click', stopPointCloud);
            
            resetViewBtn.addEventListener('click', () => {
                camera.position.set(0, 0, 5);
                controls.reset();
                addTerminalLine('View reset', 'info');
            });
            
            clearSceneBtn.addEventListener('click', () => {
                if (pointCloud) {
                    scene.remove(pointCloud);
                    pointCloud = null;
                }
                convertedFrames = [];
                stopPointCloud();
                addTerminalLine('Scene cleared', 'info');
                statusObjects.textContent = `Points: 0 | Frames: 0 | Resolution: ${pointCloudWidth}x${pointCloudHeight}`;
                downloadBtn.disabled = true;
            });
            
            helpBtn.addEventListener('click', () => {
                addTerminalLine('Point Cloud Video Editor Help:', 'info');
                addTerminalLine('1. Upload a video using the file cabinet', 'info');
                addTerminalLine('2. Adjust conversion settings', 'info');
                addTerminalLine('3. Click "Convert to Point Cloud"', 'info');
                addTerminalLine('4. Use play/stop to view the result', 'info');
                addTerminalLine('5. Export when satisfied', 'info');
            });
        }
        
        function convertToPointCloud() {
            if (!uploadedVideo) {
                addTerminalLine('No video uploaded', 'error');
                return;
            }
            
            if (isConverting) {
                addTerminalLine('Conversion already in progress', 'error');
                return;
            }
            
            isConverting = true;
            convertedFrames = [];
            convertedFrameCount = 0;
            
            // Show conversion modal
            conversionModal.style.display = 'flex';
            modalProgressBar.style.width = '0%';
            modalProgressText.textContent = '0%';
            
            // Update modal with current settings
            updateCurrentSettings();
            
            addTerminalLine('Starting point cloud conversion...', 'info');
            addTerminalLine(`Converting ${totalFramesToConvert} frames`, 'info');
            addTerminalLine(`Resolution: ${pointCloudWidth}x${pointCloudHeight}`, 'info');
            
            // Start conversion process
            convertNextFrame();
        }
        
        function convertNextFrame() {
            if (convertedFrameCount >= totalFramesToConvert) {
                // Conversion complete
                isConverting = false;
                conversionModal.style.display = 'none';
                downloadBtn.disabled = false;
                addTerminalLine('Point cloud conversion complete!', 'info');
                addTerminalLine(`Converted ${convertedFrames.length} frames`, 'info');
                
                // Display the first frame
                if (convertedFrames.length > 0) {
                    displayPointCloud(convertedFrames[0]);
                    statusObjects.textContent = `Points: ${convertedFrames[0].length} | Frames: ${convertedFrames.length} | Resolution: ${pointCloudWidth}x${pointCloudHeight}`;
                }
                return;
            }
            
            // Calculate the time for this frame
            const time = (convertedFrameCount / videoFPS);
            
            // Set video to this time
            hiddenVideo.currentTime = time;
            
            // Wait for video to seek to the correct time
            hiddenVideo.onseeked = () => {
                // Convert this frame to point cloud
                const points = convertFrameToPointCloud();
                convertedFrames.push(points);
                convertedFrameCount++;
                
                // Update progress
                const progress = Math.floor((convertedFrameCount / totalFramesToConvert) * 100);
                modalProgressBar.style.width = `${progress}%`;
                modalProgressText.textContent = `${progress}%`;
                conversionDetails.textContent = `Processing frame ${convertedFrameCount} of ${totalFramesToConvert}`;
                
                // Process next frame with a delay to prevent UI freezing
                setTimeout(convertNextFrame, 50);
            };
        }
        
        function convertFrameToPointCloud() {
            const video = hiddenVideo;
            const canvas = document.createElement('canvas');
            // Use selected resolution for point cloud
            canvas.width = pointCloudWidth;
            canvas.height = pointCloudHeight;
            const ctx = canvas.getContext('2d');
            
            // Draw video frame scaled to our selected resolution
            ctx.drawImage(video, 0, 0, pointCloudWidth, pointCloudHeight);
            
            const imageData = ctx.getImageData(0, 0, pointCloudWidth, pointCloudHeight);
            const data = imageData.data;
            
            const points = [];
            const density = pointDensitySlider.value / 100;
            const depthIntensity = depthIntensitySlider.value / 100;
            
            // Auto-adjust brightness by calculating average brightness
            let totalBrightness = 0;
            let pixelCount = 0;
            
            for (let y = 0; y < pointCloudHeight; y++) {
                for (let x = 0; x < pointCloudWidth; x++) {
                    const i = (y * pointCloudWidth + x) * 4;
                    const r = data[i] / 255;
                    const g = data[i + 1] / 255;
                    const b = data[i + 2] / 255;
                    totalBrightness += (r + g + b) / 3;
                    pixelCount++;
                }
            }
            
            const avgBrightness = totalBrightness / pixelCount;
            const brightnessAdjustment = 0.5 - avgBrightness; // Auto-adjust to middle brightness
            
            // Sample pixels based on density
            for (let y = 0; y < pointCloudHeight; y++) {
                for (let x = 0; x < pointCloudWidth; x++) {
                    // Skip pixels based on density
                    if (Math.random() > density) continue;
                    
                    const i = (y * pointCloudWidth + x) * 4;
                    
                    // Get RGB values
                    let r = data[i] / 255;
                    let g = data[i + 1] / 255;
                    let b = data[i + 2] / 255;
                    
                    // Auto-adjust brightness
                    r = Math.max(0, Math.min(1, r + brightnessAdjustment));
                    g = Math.max(0, Math.min(1, g + brightnessAdjustment));
                    b = Math.max(0, Math.min(1, b + brightnessAdjustment));
                    
                    // Calculate brightness for depth
                    const pixelBrightness = (r + g + b) / 3;
                    
                    // Create 3D point
                    points.push({
                        x: (x / pointCloudWidth - 0.5) * 10,
                        y: (0.5 - y / pointCloudHeight) * 10,
                        z: (pixelBrightness - 0.5) * depthIntensity * 5,
                        r: r,
                        g: g,
                        b: b
                    });
                }
            }
            
            return points;
        }
        
        function displayPointCloud(points) {
            // Clear existing point cloud
            if (pointCloud) {
                scene.remove(pointCloud);
            }
            
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(points.length * 3);
            const colors = new Float32Array(points.length * 3);
            
            for (let i = 0; i < points.length; i++) {
                positions[i * 3] = points[i].x;
                positions[i * 3 + 1] = points[i].y;
                positions[i * 3 + 2] = points[i].z;
                
                colors[i * 3] = points[i].r;
                colors[i * 3 + 1] = points[i].g;
                colors[i * 3 + 2] = points[i].b;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // Fixed point size for preview
            pointMaterial = new THREE.PointsMaterial({
                size: 0.05,
                vertexColors: true,
                sizeAttenuation: true
            });
            
            pointCloud = new THREE.Points(geometry, pointMaterial);
            scene.add(pointCloud);
        }
        
        function updatePointCloudPreview() {
            // Re-render the current frame with updated slider values
            if (convertedFrames.length > 0 && currentFrameIndex < convertedFrames.length) {
                displayPointCloud(convertedFrames[currentFrameIndex]);
            }
        }
        
        function playPointCloud() {
            if (convertedFrames.length === 0) {
                addTerminalLine('No point cloud data to play', 'error');
                return;
            }
            
            if (isPlaying) return;
            
            isPlaying = true;
            currentFrameIndex = 0;
            
            frameInterval = setInterval(() => {
                displayPointCloud(convertedFrames[currentFrameIndex]);
                currentFrameIndex = (currentFrameIndex + 1) % convertedFrames.length;
            }, 1000 / 8); // 8 FPS for 8MB laptops
            
            addTerminalLine('Playing point cloud animation', 'info');
        }
        
        function stopPointCloud() {
            if (frameInterval) {
                clearInterval(frameInterval);
                frameInterval = null;
            }
            isPlaying = false;
            currentFrameIndex = 0;
            if (convertedFrames.length > 0) {
                displayPointCloud(convertedFrames[0]);
            }
            addTerminalLine('Point cloud animation stopped', 'info');
        }
        
        function exportPointCloudVideo() {
            addTerminalLine('Exporting point cloud video...', 'info');
            
            // Create a canvas for recording
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = 640;
            exportCanvas.height = 480;
            const exportCtx = exportCanvas.getContext('2d');
            
            // Create a temporary renderer for recording
            const tempRenderer = new THREE.WebGLRenderer({ 
                preserveDrawingBuffer: true,
                antialias: false,
                powerPreference: "low-power"
            });
            tempRenderer.setSize(exportCanvas.width, exportCanvas.height);
            
            // Record frames
            const frames = [];
            const fps = 8;
            
            for (let i = 0; i < convertedFrames.length; i++) {
                // Display the frame
                displayPointCloud(convertedFrames[i]);
                
                // Render to temp renderer
                tempRenderer.render(scene, camera);
                
                // Convert to image data
                frames.push(tempRenderer.domElement.toDataURL('image/jpeg', 0.8));
            }
            
            // Create a video from frames (simplified - in a real app, you'd use MediaRecorder)
            addTerminalLine('Video export complete (simulated)', 'info');
            
            // Create a fake download link
            const link = document.createElement('a');
            link.download = 'pointcloud_video.mp4';
            link.href = '#';
            link.click();
            
            // Clean up
            tempRenderer.dispose();
        }
        
        // Initialize everything
        window.addEventListener('load', () => {
            initThreeJS();
            initMatrixEffect();
            initFileCabinet();
            initEditorControls();
        });
    </script>
</body>
</html>