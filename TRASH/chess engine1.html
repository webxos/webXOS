<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CYBER NEON CHESS - Quantum Training</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
        }

        body {
            background: #000;
            color: #39ff14;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Scanlines effect */
        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 100;
        }

        .header {
            background: rgba(0, 0, 0, 0.9);
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #39ff14;
            box-shadow: 0 0 10px #39ff14;
            z-index: 100;
            height: 60px;
            flex-shrink: 0;
        }

        .logo {
            display: flex;
            align-items: center;
        }

        .logo h1 {
            font-size: 20px;
            font-weight: 700;
            text-shadow: 0 0 10px #39ff14;
            margin-right: 10px;
        }

        .version {
            background: rgba(57, 255, 20, 0.2);
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 10px;
            color: #39ff14;
            text-shadow: 0 0 5px #39ff14;
        }

        .nav-buttons {
            display: flex;
            gap: 10px;
        }

        .nav-btn {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #39ff14;
            color: #39ff14;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
            text-shadow: 0 0 5px #39ff14;
            box-shadow: 0 0 5px rgba(57, 255, 20, 0.5);
        }

        .nav-btn:hover {
            background: rgba(57, 255, 20, 0.2);
            box-shadow: 0 0 10px #39ff14;
        }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
            height: calc(100vh - 210px);
        }

        .game-container {
            flex: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
            height: 100%;
        }

        #chessboard-3d {
            width: 90%;
            height: 90%;
            position: relative;
        }

        .ui-sidebar {
            width: 350px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            border-left: 1px solid #39ff14;
            box-shadow: -5px 0 20px rgba(57, 255, 20, 0.3);
            overflow-y: auto;
            position: relative;
            height: 100%;
            flex-shrink: 0;
        }

        /* UI Panel Styles */
        .game-info, .settings-panel, .training-controls, .agent-management {
            background: rgba(10, 15, 10, 0.8);
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #39ff14;
            box-shadow: 0 0 10px rgba(57, 255, 20, 0.3);
            flex-shrink: 0;
        }

        .game-info h2, .settings-panel h2, .training-controls h2, .agent-management h2 {
            font-size: 16px;
            margin-bottom: 10px;
            color: #39ff14;
            text-shadow: 0 0 5px #39ff14;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .game-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .stat {
            display: flex;
            flex-direction: column;
        }

        .stat-label {
            font-size: 10px;
            color: #88ff88;
            margin-bottom: 2px;
            text-shadow: 0 0 3px #88ff88;
        }

        .stat-value {
            font-size: 14px;
            font-weight: 600;
            color: #39ff14;
            text-shadow: 0 0 5px #39ff14;
        }

        /* Training Controls */
        .training-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .training-buttons {
            display: flex;
            gap: 10px;
        }

        .training-btn {
            flex: 1;
            background: linear-gradient(135deg, #000, #0a2a0a);
            border: 1px solid #39ff14;
            color: #39ff14;
            padding: 12px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 10px rgba(57, 255, 20, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            text-shadow: 0 0 5px #39ff14;
        }

        .training-btn:hover {
            background: rgba(57, 255, 20, 0.2);
            box-shadow: 0 0 15px #39ff14;
        }

        .training-btn.active {
            background: rgba(57, 255, 20, 0.3);
            box-shadow: 0 0 20px #39ff14;
        }

        .training-btn.start {
            border-color: #39ff14;
            color: #39ff14;
        }

        .training-btn.stop {
            border-color: #ff3333;
            color: #ff3333;
        }

        .training-btn.stop.active {
            background: rgba(255, 51, 51, 0.3);
            box-shadow: 0 0 15px #ff3333;
        }

        /* Agent Management */
        .agent-management {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .agent-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .agent-btn {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #39ff14;
            color: #39ff14;
            padding: 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
            text-shadow: 0 0 3px #39ff14;
            box-shadow: 0 0 5px rgba(57, 255, 20, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .agent-btn:hover {
            background: rgba(57, 255, 20, 0.2);
            box-shadow: 0 0 8px #39ff14;
        }

        .scoreboard-btn {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #ffff00;
            color: #ffff00;
            padding: 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 0 0 3px #ffff00;
            box-shadow: 0 0 5px rgba(255, 255, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 10px;
        }

        .scoreboard-btn:hover {
            background: rgba(255, 255, 0, 0.2);
            box-shadow: 0 0 10px #ffff00;
        }

        /* Settings */
        .setting-group {
            margin-bottom: 12px;
        }

        .setting-label {
            display: block;
            font-size: 12px;
            margin-bottom: 6px;
            color: #88ff88;
            text-shadow: 0 0 3px #88ff88;
        }

        .slider {
            width: 100%;
            height: 6px;
            background: rgba(57, 255, 20, 0.2);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #39ff14;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(57, 255, 20, 0.8);
        }

        /* Footer with QNN Grids */
        .footer {
            background: rgba(0, 0, 0, 0.95);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 1px solid #39ff14;
            box-shadow: 0 0 10px #39ff14;
            height: 150px;
            flex-shrink: 0;
        }

        /* QNN Parameter Grids */
        .qnn-grids {
            display: flex;
            gap: 20px;
            width: 100%;
            height: 100%;
        }

        .qnn-grid {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: rgba(10, 15, 10, 0.8);
            border: 1px solid #39ff14;
            border-radius: 4px;
            padding: 10px;
            box-shadow: 0 0 10px rgba(57, 255, 20, 0.3);
            height: 120px;
        }

        .qnn-header {
            text-align: center;
            margin-bottom: 10px;
            font-size: 14px;
            text-shadow: 0 0 5px #39ff14;
            height: 20px;
        }

        .qnn-canvas-container {
            flex: 1;
            position: relative;
            border: 1px solid #39ff14;
            background: #000;
            height: 70px;
        }

        .qnn-canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .qnn-values {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 10px;
            height: 15px;
        }

        /* Loading Screen */
        .loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }

        .loading-logo {
            font-size: 36px;
            font-weight: 700;
            background: linear-gradient(90deg, #39ff14, #88ff88);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: 15px;
            text-shadow: 0 0 10px #39ff14;
        }

        .loading-bar-container {
            width: 250px;
            height: 5px;
            background: rgba(57, 255, 20, 0.2);
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #39ff14, #88ff88);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px #39ff14;
        }

        .loading-text {
            font-size: 14px;
            color: #88ff88;
            text-shadow: 0 0 5px #88ff88;
        }

        /* AI Thinking Indicator */
        .ai-thinking {
            display: none;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: rgba(20, 30, 20, 0.6);
            border-radius: 4px;
            margin-top: 8px;
            border: 1px solid #39ff14;
            box-shadow: 0 0 5px rgba(57, 255, 20, 0.3);
            height: 30px;
        }

        .ai-thinking.active {
            display: flex;
        }

        .thinking-dots {
            display: flex;
            gap: 3px;
        }

        .thinking-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #39ff14;
            animation: pulse 1.5s infinite ease-in-out;
            box-shadow: 0 0 5px #39ff14;
        }

        .thinking-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .thinking-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.2); opacity: 1; }
        }

        /* Scoreboard Popup */
        .scoreboard-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            height: 300px;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #ffff00;
            border-radius: 8px;
            box-shadow: 0 0 20px #ffff00;
            z-index: 1000;
            overflow: hidden;
        }

        .scoreboard-popup.active {
            display: flex;
            flex-direction: column;
        }

        .scoreboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: rgba(20, 20, 10, 0.8);
            border-bottom: 1px solid #ffff00;
        }

        .scoreboard-title {
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 5px #ffff00;
            color: #ffff00;
        }

        .scoreboard-close {
            background: none;
            border: none;
            color: #ff3333;
            font-size: 20px;
            cursor: pointer;
            text-shadow: 0 0 5px #ff3333;
            transition: all 0.3s ease;
        }

        .scoreboard-close:hover {
            transform: scale(1.2);
        }

        .scoreboard-content {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .agent-score {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: rgba(30, 30, 15, 0.6);
            border-radius: 4px;
            border: 1px solid #39ff14;
        }

        .agent-name {
            font-size: 16px;
            font-weight: bold;
        }

        .agent-stats {
            display: flex;
            gap: 15px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-value {
            font-size: 18px;
            font-weight: bold;
        }

        .stat-label {
            font-size: 10px;
            color: #88ff88;
        }

        .recommendation {
            text-align: center;
            padding: 10px;
            background: rgba(57, 255, 20, 0.2);
            border-radius: 4px;
            border: 1px solid #39ff14;
            margin-top: 10px;
        }

        .overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
        }

        .overlay.active {
            display: block;
        }

        /* Instructions */
        .instructions {
            background: rgba(10, 15, 10, 0.8);
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #39ff14;
            box-shadow: 0 0 10px rgba(57, 255, 20, 0.3);
            font-size: 11px;
            line-height: 1.4;
        }

        .instructions p {
            margin-bottom: 8px;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(20, 30, 20, 0.3);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(57, 255, 20, 0.5);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(57, 255, 20, 0.7);
        }
    </style>
</head>
<body>
    <div class="overlay" id="overlay"></div>
    
    <div class="scoreboard-popup" id="scoreboardPopup">
        <div class="scoreboard-header">
            <div class="scoreboard-title">QUANTUM AGENT SCOREBOARD</div>
            <button class="scoreboard-close" id="closeScoreboard">✕</button>
        </div>
        <div class="scoreboard-content">
            <div class="agent-score">
                <div class="agent-name">GREEN QNN</div>
                <div class="agent-stats">
                    <div class="stat-item">
                        <div class="stat-value" id="greenWins">12</div>
                        <div class="stat-label">WINS</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="greenLosses">8</div>
                        <div class="stat-label">LOSSES</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="greenScore">64%</div>
                        <div class="stat-label">SCORE</div>
                    </div>
                </div>
            </div>
            <div class="agent-score">
                <div class="agent-name">BLACK QNN</div>
                <div class="agent-stats">
                    <div class="stat-item">
                        <div class="stat-value" id="blackWins">8</div>
                        <div class="stat-label">WINS</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="blackLosses">12</div>
                        <div class="stat-label">LOSSES</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="blackScore">36%</div>
                        <div class="stat-label">SCORE</div>
                    </div>
                </div>
            </div>
            <div class="recommendation" id="recommendation">
                <strong>RECOMMENDATION:</strong> Export the GREEN QNN agent for best performance
            </div>
        </div>
    </div>

    <div class="loading-screen" id="loadingScreen">
        <div class="loading-logo">CYBER NEON CHESS</div>
        <div class="loading-bar-container">
            <div class="loading-bar" id="loadingBar"></div>
        </div>
        <div class="loading-text" id="loadingText">Initializing Quantum Neural Networks...</div>
    </div>

    <div class="header">
        <div class="logo">
            <h1>CYBER NEON CHESS</h1>
            <span class="version">QNN v4.0</span>
        </div>
        <div class="nav-buttons">
            <button class="nav-btn" id="infoBtn">QUANTUM MANUAL</button>
        </div>
    </div>

    <div class="main-container">
        <div class="game-container">
            <div id="chessboard-3d">
                <!-- 3D chessboard will be rendered here -->
            </div>
        </div>
        <div class="ui-sidebar">
            <div class="game-info">
                <h2>QUANTUM TRAINING STATUS</h2>
                <div class="game-stats">
                    <div class="stat">
                        <span class="stat-label">Training Mode</span>
                        <span class="stat-value" id="gameMode">QNN vs QNN</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Training Iterations</span>
                        <span class="stat-value" id="moveCount">0</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Training Status</span>
                        <span class="stat-value" id="gameStatus">READY</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Active Agent</span>
                        <span class="stat-value" id="currentPlayer">-</span>
                    </div>
                </div>
            </div>

            <div class="training-controls">
                <h2>QUANTUM TRAINING CONTROLS</h2>
                <div class="training-buttons">
                    <button class="training-btn start" id="startBtn">START TRAINING</button>
                    <button class="training-btn stop" id="stopBtn">STOP TRAINING</button>
                </div>
                <div class="ai-thinking" id="aiThinking">
                    <span>QNN Processing:</span>
                    <div class="thinking-dots">
                        <div class="thinking-dot"></div>
                        <div class="thinking-dot"></div>
                        <div class="thinking-dot"></div>
                    </div>
                    <span id="thinkingAI">Quantum AI</span>
                </div>
            </div>

            <div class="agent-management">
                <h2>AGENT MANAGEMENT</h2>
                <div class="agent-buttons">
                    <button class="agent-btn" id="saveGreenBtn">EXPORT GREEN</button>
                    <button class="agent-btn" id="saveBlackBtn">EXPORT BLACK</button>
                    <button class="agent-btn" id="uploadAgent1">IMPORT AGENT 1</button>
                    <button class="agent-btn" id="uploadAgent2">IMPORT AGENT 2</button>
                </div>
                <button class="scoreboard-btn" id="scoreboardBtn">
                    <span>🏆</span> VIEW SCOREBOARD
                </button>
            </div>

            <div class="settings-panel">
                <h2>QUANTUM PARAMETERS</h2>
                <div class="setting-group">
                    <label class="setting-label">QNN Learning Rate</label>
                    <input type="range" min="1" max="10" value="7" class="slider" id="aiStrength">
                </div>
                <div class="setting-group">
                    <label class="setting-label">Training Speed</label>
                    <input type="range" min="1" max="10" value="8" class="slider" id="gameSpeed">
                </div>
                <div class="setting-group">
                    <label class="setting-label">Training Sessions</label>
                    <input type="range" min="10" max="500" value="250" class="slider" id="trainingGames">
                </div>
            </div>

            <div class="instructions">
                <p><strong>QUANTUM TRAINING INSTRUCTIONS:</strong></p>
                <p>1. Click START to begin continuous quantum training</p>
                <p>2. Let the system run for extended periods to maximize learning</p>
                <p>3. Use the XY grids below to adjust QNN parameters in real-time</p>
                <p>4. Check the scoreboard to see which agent is performing better</p>
                <p>5. Export the best-performing agent for future use</p>
            </div>
        </div>
    </div>

    <div class="footer">
        <div class="qnn-grids">
            <div class="qnn-grid">
                <div class="qnn-header">GREEN QNN PARAMETERS</div>
                <div class="qnn-canvas-container">
                    <canvas class="qnn-canvas" id="greenQnnCanvas" width="200" height="100"></canvas>
                </div>
                <div class="qnn-values">
                    <span>Entanglement: <span id="greenEntanglement">0.73</span></span>
                    <span>Superposition: <span id="greenSuperposition">0.61</span></span>
                </div>
            </div>
            <div class="qnn-grid">
                <div class="qnn-header">BLACK QNN PARAMETERS</div>
                <div class="qnn-canvas-container">
                    <canvas class="qnn-canvas" id="blackQnnCanvas" width="200" height="100"></canvas>
                </div>
                <div class="qnn-values">
                    <span>Entanglement: <span id="blackEntanglement">0.68</span></span>
                    <span>Superposition: <span id="blackSuperposition">0.55</span></span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Game state variables
        let gameMode = 'ai-vs-ai';
        let currentPlayer = 'green';
        let moveCount = 0;
        let gameActive = false;
        let boardState = [];
        let autoPlayInterval = null;
        let aiStrength = 7;
        let gameSpeed = 8;
        let trainingGames = 250;
        let gamesCompleted = 0;
        let isTraining = false;
        let trainingInterval = null;
        let trainingLog = [];
        
        // Agent performance tracking
        let agentPerformance = {
            green: { wins: 0, losses: 0, score: 0 },
            black: { wins: 0, losses: 0, score: 0 }
        };
        
        // Three.js variables
        let scene, camera, renderer, controls;
        let chessboard, pieces = [];
        let selectedPiece = null;
        let possibleMoves = [];

        // QNN Parameters
        let greenQnnParams = { entanglement: 0.73, superposition: 0.61 };
        let blackQnnParams = { entanglement: 0.68, superposition: 0.55 };
        let greenCanvas, blackCanvas;
        let greenCtx, blackCtx;

        // Initialize the application
        function init() {
            updateLoading("Initializing Quantum Processors...", 30);
            
            // Initialize 3D chessboard
            init3DChessboard();
            
            updateLoading("Calibrating QNN Parameters...", 60);
            setupQnnCanvases();
            setupEventListeners();
            
            updateLoading("Preparing Quantum Training...", 90);
            initializeBoard();
            
            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loadingScreen').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.display = 'none';
                    updateGameInfo();
                }, 500);
            }, 1000);
        }

        function updateLoading(text, progress) {
            document.getElementById('loadingText').textContent = text;
            document.getElementById('loadingBar').style.width = `${progress}%`;
        }

        // Initialize 3D chessboard with Three.js
        function init3DChessboard() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 15);
            camera.lookAt(0, 0, 0);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(document.getElementById('chessboard-3d').clientWidth, 
                            document.getElementById('chessboard-3d').clientHeight);
            document.getElementById('chessboard-3d').appendChild(renderer.domElement);
            
            // Add orbit controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x222222, 1);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0x39ff14, 0.8);
            directionalLight.position.set(10, 20, 10);
            scene.add(directionalLight);
            
            const pointLight = new THREE.PointLight(0x39ff14, 0.5, 100);
            pointLight.position.set(0, 10, 0);
            scene.add(pointLight);
            
            // Create chessboard
            createChessboard3D();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Start animation loop
            animate();
        }
        
        function createChessboard3D() {
            // Create board base
            const boardGeometry = new THREE.BoxGeometry(18, 0.5, 18);
            const boardMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x111111,
                roughness: 0.8,
                metalness: 0.2
            });
            chessboard = new THREE.Mesh(boardGeometry, boardMaterial);
            chessboard.position.y = -0.25;
            scene.add(chessboard);
            
            // Create squares
            const squareGeometry = new THREE.BoxGeometry(2, 0.1, 2);
            const lightMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a3d1a,
                roughness: 0.6,
                metalness: 0.3,
                emissive: 0x0a2a0a
            });
            const darkMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x000000,
                roughness: 0.6,
                metalness: 0.3,
                emissive: 0x061006
            });
            
            for (let x = 0; x < 8; x++) {
                for (let z = 0; z < 8; z++) {
                    const isLight = (x + z) % 2 === 0;
                    const material = isLight ? lightMaterial : darkMaterial;
                    const square = new THREE.Mesh(squareGeometry, material);
                    square.position.set((x - 3.5) * 2, 0, (z - 3.5) * 2);
                    square.userData = { x: x, z: z, isSquare: true };
                    scene.add(square);
                }
            }
            
            // Add board border with neon effect
            const borderGeometry = new THREE.BoxGeometry(18.2, 0.6, 18.2);
            const borderMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x39ff14,
                roughness: 0.3,
                metalness: 0.7,
                emissive: 0x0a3a0a
            });
            const border = new THREE.Mesh(borderGeometry, borderMaterial);
            border.position.y = -0.3;
            scene.add(border);
            
            // Create initial pieces
            createPieces3D();
        }
        
        function createPieces3D() {
            // Define piece geometries
            const pieceGeometries = {
                pawn: new THREE.CylinderGeometry(0.6, 0.8, 1.6, 16),
                rook: new THREE.CylinderGeometry(0.8, 0.8, 1.6, 16),
                knight: new THREE.ConeGeometry(0.8, 1.6, 16),
                bishop: new THREE.ConeGeometry(0.6, 1.6, 16),
                queen: new THREE.SphereGeometry(0.8, 16, 16),
                king: new THREE.CylinderGeometry(0.6, 0.8, 2, 16)
            };
            
            // Define materials for green and black pieces
            const greenMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x39ff14,
                roughness: 0.2,
                metalness: 0.8,
                emissive: 0x0a3a0a
            });
            
            const blackMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x111111,
                roughness: 0.2,
                metalness: 0.8,
                emissive: 0x050505
            });
            
            // Set up initial piece positions
            const initialPositions = [
                // Black pieces (back row)
                { type: 'rook', color: 'black', x: 0, z: 0 },
                { type: 'knight', color: 'black', x: 1, z: 0 },
                { type: 'bishop', color: 'black', x: 2, z: 0 },
                { type: 'queen', color: 'black', x: 3, z: 0 },
                { type: 'king', color: 'black', x: 4, z: 0 },
                { type: 'bishop', color: 'black', x: 5, z: 0 },
                { type: 'knight', color: 'black', x: 6, z: 0 },
                { type: 'rook', color: 'black', x: 7, z: 0 },
                
                // Black pawns
                { type: 'pawn', color: 'black', x: 0, z: 1 },
                { type: 'pawn', color: 'black', x: 1, z: 1 },
                { type: 'pawn', color: 'black', x: 2, z: 1 },
                { type: 'pawn', color: 'black', x: 3, z: 1 },
                { type: 'pawn', color: 'black', x: 4, z: 1 },
                { type: 'pawn', color: 'black', x: 5, z: 1 },
                { type: 'pawn', color: 'black', x: 6, z: 1 },
                { type: 'pawn', color: 'black', x: 7, z: 1 },
                
                // Green pieces (back row)
                { type: 'rook', color: 'green', x: 0, z: 7 },
                { type: 'knight', color: 'green', x: 1, z: 7 },
                { type: 'bishop', color: 'green', x: 2, z: 7 },
                { type: 'queen', color: 'green', x: 3, z: 7 },
                { type: 'king', color: 'green', x: 4, z: 7 },
                { type: 'bishop', color: 'green', x: 5, z: 7 },
                { type: 'knight', color: 'green', x: 6, z: 7 },
                { type: 'rook', color: 'green', x: 7, z: 7 },
                
                // Green pawns
                { type: 'pawn', color: 'green', x: 0, z: 6 },
                { type: 'pawn', color: 'green', x: 1, z: 6 },
                { type: 'pawn', color: 'green', x: 2, z: 6 },
                { type: 'pawn', color: 'green', x: 3, z: 6 },
                { type: 'pawn', color: 'green', x: 4, z: 6 },
                { type: 'pawn', color: 'green', x: 5, z: 6 },
                { type: 'pawn', color: 'green', x: 6, z: 6 },
                { type: 'pawn', color: 'green', x: 7, z: 6 }
            ];
            
            // Create pieces
            initialPositions.forEach(pos => {
                const geometry = pieceGeometries[pos.type];
                const material = pos.color === 'green' ? greenMaterial : blackMaterial;
                const piece = new THREE.Mesh(geometry, material);
                
                piece.position.set((pos.x - 3.5) * 2, 1, (pos.z - 3.5) * 2);
                piece.userData = { 
                    type: pos.type, 
                    color: pos.color, 
                    x: pos.x, 
                    z: pos.z,
                    isPiece: true
                };
                
                scene.add(piece);
                pieces.push(piece);
            });
        }
        
        function onWindowResize() {
            camera.aspect = document.getElementById('chessboard-3d').clientWidth / 
                           document.getElementById('chessboard-3d').clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(document.getElementById('chessboard-3d').clientWidth, 
                           document.getElementById('chessboard-3d').clientHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            
            // Update QNN parameter displays
            updateQnnDisplays();
        }

        // Setup QNN parameter canvases
        function setupQnnCanvases() {
            greenCanvas = document.getElementById('greenQnnCanvas');
            blackCanvas = document.getElementById('blackQnnCanvas');
            greenCtx = greenCanvas.getContext('2d');
            blackCtx = blackCanvas.getContext('2d');
            
            // Set canvas size to match container
            greenCanvas.width = greenCanvas.parentElement.clientWidth;
            greenCanvas.height = greenCanvas.parentElement.clientHeight;
            blackCanvas.width = blackCanvas.parentElement.clientWidth;
            blackCanvas.height = blackCanvas.parentElement.clientHeight;
            
            // Add click handlers for parameter adjustment
            greenCanvas.addEventListener('click', (e) => adjustQnnParams(e, 'green'));
            blackCanvas.addEventListener('click', (e) => adjustQnnParams(e, 'black'));
            
            // Draw initial parameter grids
            drawQnnGrid(greenCtx, greenCanvas, 'green');
            drawQnnGrid(blackCtx, blackCanvas, 'black');
        }
        
        function drawQnnGrid(ctx, canvas, color) {
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            
            // Draw grid
            ctx.strokeStyle = color === 'green' ? '#39ff14' : '#39ff14';
            ctx.lineWidth = 1;
            
            // Vertical lines
            for (let x = 0; x <= width; x += width / 10) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let y = 0; y <= height; y += height / 10) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            // Draw current parameter point
            const params = color === 'green' ? greenQnnParams : blackQnnParams;
            const pointX = params.entanglement * width;
            const pointY = height - (params.superposition * height);
            
            ctx.fillStyle = color === 'green' ? '#39ff14' : '#39ff14';
            ctx.beginPath();
            ctx.arc(pointX, pointY, 5, 0, Math.PI * 2);
            ctx.fill();
            
            // Add glow effect
            ctx.shadowColor = color === 'green' ? '#39ff14' : '#39ff14';
            ctx.shadowBlur = 10;
            ctx.fill();
            ctx.shadowBlur = 0;
        }
        
        function adjustQnnParams(event, color) {
            const canvas = color === 'green' ? greenCanvas : blackCanvas;
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            const params = color === 'green' ? greenQnnParams : blackQnnParams;
            params.entanglement = Math.max(0, Math.min(1, x / canvas.width));
            params.superposition = Math.max(0, Math.min(1, 1 - (y / canvas.height)));
            
            // Update display
            document.getElementById(`${color}Entanglement`).textContent = params.entanglement.toFixed(2);
            document.getElementById(`${color}Superposition`).textContent = params.superposition.toFixed(2);
            
            // Redraw grid
            const ctx = color === 'green' ? greenCtx : blackCtx;
            drawQnnGrid(ctx, canvas, color);
            
            // Log parameter change
            addToLog(`${color.toUpperCase()} QNN parameters updated: Entanglement=${params.entanglement.toFixed(2)}, Superposition=${params.superposition.toFixed(2)}`);
        }
        
        function updateQnnDisplays() {
            // Randomly fluctuate parameters slightly to simulate quantum behavior
            if (Math.random() < 0.05) {
                greenQnnParams.entanglement += (Math.random() - 0.5) * 0.02;
                greenQnnParams.entanglement = Math.max(0, Math.min(1, greenQnnParams.entanglement));
                greenQnnParams.superposition += (Math.random() - 0.5) * 0.02;
                greenQnnParams.superposition = Math.max(0, Math.min(1, greenQnnParams.superposition));
                
                document.getElementById('greenEntanglement').textContent = greenQnnParams.entanglement.toFixed(2);
                document.getElementById('greenSuperposition').textContent = greenQnnParams.superposition.toFixed(2);
                drawQnnGrid(greenCtx, greenCanvas, 'green');
            }
            
            if (Math.random() < 0.05) {
                blackQnnParams.entanglement += (Math.random() - 0.5) * 0.02;
                blackQnnParams.entanglement = Math.max(0, Math.min(1, blackQnnParams.entanglement));
                blackQnnParams.superposition += (Math.random() - 0.5) * 0.02;
                blackQnnParams.superposition = Math.max(0, Math.min(1, blackQnnParams.superposition));
                
                document.getElementById('blackEntanglement').textContent = blackQnnParams.entanglement.toFixed(2);
                document.getElementById('blackSuperposition').textContent = blackQnnParams.superposition.toFixed(2);
                drawQnnGrid(blackCtx, blackCanvas, 'black');
            }
        }

        function initializeBoard() {
            // Initialize an 8x8 board
            boardState = Array(8).fill().map(() => Array(8).fill(null));
            
            // Set up pawns
            for (let i = 0; i < 8; i++) {
                boardState[i][1] = { type: 'pawn', color: 'black' };
                boardState[i][6] = { type: 'pawn', color: 'green' };
            }
            
            // Set up other pieces
            const backRow = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
            for (let i = 0; i < 8; i++) {
                boardState[i][0] = { type: backRow[i], color: 'black' };
                boardState[i][7] = { type: backRow[i], color: 'green' };
            }
        }

        function setupEventListeners() {
            // Training buttons
            document.getElementById('startBtn').addEventListener('click', startTraining);
            document.getElementById('stopBtn').addEventListener('click', pauseTraining);
            
            // Agent management buttons
            document.getElementById('saveGreenBtn').addEventListener('click', () => saveAgent('green'));
            document.getElementById('saveBlackBtn').addEventListener('click', () => saveAgent('black'));
            document.getElementById('uploadAgent1').addEventListener('click', () => uploadAgent(1));
            document.getElementById('uploadAgent2').addEventListener('click', () => uploadAgent(2));
            
            // Scoreboard button
            document.getElementById('scoreboardBtn').addEventListener('click', showScoreboard);
            document.getElementById('closeScoreboard').addEventListener('click', hideScoreboard);
            document.getElementById('overlay').addEventListener('click', hideScoreboard);
            
            // Settings sliders
            document.getElementById('aiStrength').addEventListener('input', updateAISettings);
            document.getElementById('gameSpeed').addEventListener('input', updateGameSpeed);
            document.getElementById('trainingGames').addEventListener('input', updateTrainingGames);
            
            // Add click handler for 3D board
            renderer.domElement.addEventListener('click', onCanvasClick, false);
        }
        
        function showScoreboard() {
            // Update scoreboard with current data
            document.getElementById('greenWins').textContent = agentPerformance.green.wins;
            document.getElementById('greenLosses').textContent = agentPerformance.green.losses;
            document.getElementById('greenScore').textContent = agentPerformance.green.score + '%';
            
            document.getElementById('blackWins').textContent = agentPerformance.black.wins;
            document.getElementById('blackLosses').textContent = agentPerformance.black.losses;
            document.getElementById('blackScore').textContent = agentPerformance.black.score + '%';
            
            // Update recommendation
            let recommendation = document.getElementById('recommendation');
            if (agentPerformance.green.score > agentPerformance.black.score) {
                recommendation.innerHTML = '<strong>RECOMMENDATION:</strong> Export the GREEN QNN agent for best performance';
            } else {
                recommendation.innerHTML = '<strong>RECOMMENDATION:</strong> Export the BLACK QNN agent for best performance';
            }
            
            document.getElementById('scoreboardPopup').classList.add('active');
            document.getElementById('overlay').classList.add('active');
        }
        
        function hideScoreboard() {
            document.getElementById('scoreboardPopup').classList.remove('active');
            document.getElementById('overlay').classList.remove('active');
        }
        
        function saveAgent(color) {
            const agentData = {
                params: color === 'green' ? greenQnnParams : blackQnnParams,
                performance: agentPerformance[color],
                trainingLog: trainingLog,
                gamesCompleted: gamesCompleted,
                timestamp: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(agentData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `quantum_chess_${color}_agent_${new Date().toISOString().slice(0, 10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            addToLog(`${color.toUpperCase()} agent exported`);
        }
        
        function uploadAgent(agentNumber) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const agentData = JSON.parse(event.target.result);
                        
                        if (agentNumber === 1) {
                            greenQnnParams = agentData.params;
                            document.getElementById('greenEntanglement').textContent = greenQnnParams.entanglement.toFixed(2);
                            document.getElementById('greenSuperposition').textContent = greenQnnParams.superposition.toFixed(2);
                            drawQnnGrid(greenCtx, greenCanvas, 'green');
                        } else {
                            blackQnnParams = agentData.params;
                            document.getElementById('blackEntanglement').textContent = blackQnnParams.entanglement.toFixed(2);
                            document.getElementById('blackSuperposition').textContent = blackQnnParams.superposition.toFixed(2);
                            drawQnnGrid(blackCtx, blackCanvas, 'black');
                        }
                        
                        // Reset training data and start new game
                        trainingLog = [];
                        gamesCompleted = 0;
                        moveCount = 0;
                        reset3DBoard();
                        startTraining();
                        
                        addToLog(`Agent ${agentNumber} uploaded and training reset`);
                    } catch (error) {
                        alert('Invalid agent file');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }
        
        function onCanvasClick(event) {
            if (!gameActive || gameMode === 'ai-vs-ai') return;
            
            // Calculate mouse position in normalized device coordinates
            const mouse = new THREE.Vector2();
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Create raycaster
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            // Check for intersections
            const intersects = raycaster.intersectObjects(scene.children);
            
            if (intersects.length > 0) {
                const object = intersects[0].object;
                
                if (object.userData.isPiece) {
                    // If it's a piece of the current player's color
                    if (object.userData.color === currentPlayer) {
                        selectPiece(object);
                    }
                } else if (object.userData.isSquare && selectedPiece) {
                    // If it's a square and we have a selected piece
                    movePiece(object.userData.x, object.userData.z);
                }
            }
        }
        
        function selectPiece(piece) {
            // Deselect previous piece
            if (selectedPiece) {
                selectedPiece.material.emissive.setHex(0x000000);
            }
            
            // Select new piece
            selectedPiece = piece;
            selectedPiece.material.emissive.setHex(0x333333);
            
            // Calculate possible moves (simplified)
            calculatePossibleMoves(piece.userData.x, piece.userData.z);
            
            // Highlight possible moves
            highlightPossibleMoves();
        }
        
        function calculatePossibleMoves(x, z) {
            // Simplified move calculation
            possibleMoves = [];
            
            // For pawns
            if (selectedPiece.userData.type === 'pawn') {
                const direction = selectedPiece.userData.color === 'green' ? -1 : 1;
                
                // Forward move
                if (z + direction >= 0 && z + direction < 8 && !boardState[x][z + direction]) {
                    possibleMoves.push({ x: x, z: z + direction });
                }
                
                // Capture moves
                if (x > 0 && z + direction >= 0 && z + direction < 8 && 
                    boardState[x-1][z + direction] && 
                    boardState[x-1][z + direction].color !== selectedPiece.userData.color) {
                    possibleMoves.push({ x: x-1, z: z + direction });
                }
                
                if (x < 7 && z + direction >= 0 && z + direction < 8 && 
                    boardState[x+1][z + direction] && 
                    boardState[x+1][z + direction].color !== selectedPiece.userData.color) {
                    possibleMoves.push({ x: x+1, z: z + direction });
                }
            }
            
            // For other pieces, we'd implement more complex logic
            // This is a simplified version for demonstration
        }
        
        function highlightPossibleMoves() {
            // Remove previous highlights
            clearHighlights();
            
            // Add highlights for possible moves
            possibleMoves.forEach(move => {
                const squareGeometry = new THREE.PlaneGeometry(1.8, 1.8);
                const highlightMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x39ff14, 
                    transparent: true, 
                    opacity: 0.5,
                    side: THREE.DoubleSide
                });
                const highlight = new THREE.Mesh(squareGeometry, highlightMaterial);
                highlight.rotation.x = -Math.PI / 2;
                highlight.position.set((move.x - 3.5) * 2, 0.1, (move.z - 3.5) * 2);
                highlight.userData.isHighlight = true;
                scene.add(highlight);
            });
        }
        
        function clearHighlights() {
            scene.children.forEach(child => {
                if (child.userData.isHighlight) {
                    scene.remove(child);
                }
            });
        }
        
        function movePiece(x, z) {
            // Check if the move is valid
            const isValidMove = possibleMoves.some(move => move.x === x && move.z === z);
            
            if (isValidMove) {
                // Update board state
                const fromX = selectedPiece.userData.x;
                const fromZ = selectedPiece.userData.z;
                
                boardState[x][z] = {
                    type: selectedPiece.userData.type,
                    color: selectedPiece.userData.color
                };
                boardState[fromX][fromZ] = null;
                
                // Update piece position
                selectedPiece.position.set((x - 3.5) * 2, 1, (z - 3.5) * 2);
                selectedPiece.userData.x = x;
                selectedPiece.userData.z = z;
                
                // Switch player
                currentPlayer = currentPlayer === 'green' ? 'black' : 'green';
                moveCount++;
                
                // Update UI
                updateGameInfo();
                
                // Deselect piece and clear highlights
                selectedPiece.material.emissive.setHex(0x000000);
                selectedPiece = null;
                clearHighlights();
                
                // If in AI mode, trigger AI move
                if (gameMode === 'ai-vs-ai' && gameActive) {
                    setTimeout(makeAIMove, 500);
                }
            }
        }
        
        function addToLog(message) {
            const timestamp = new Date().toISOString();
            trainingLog.push(`${timestamp}: ${message}`);
            
            // Keep log from growing too large
            if (trainingLog.length > 1000) {
                trainingLog = trainingLog.slice(-500);
            }
        }

        function startTraining() {
            if (isTraining) return;
            
            isTraining = true;
            gameActive = true;
            gamesCompleted = 0;
            
            // Show training indicator
            document.getElementById('startBtn').classList.add('active');
            document.getElementById('stopBtn').classList.remove('active');
            
            // Start auto-play
            startAutoPlay();
            
            // Start training session counter
            trainingInterval = setInterval(() => {
                if (gamesCompleted < trainingGames) {
                    gamesCompleted++;
                    
                    // Update UI to show training progress
                    document.getElementById('gameStatus').textContent = 
                        `TRAINING: ${gamesCompleted}/${trainingGames}`;
                    
                    // Update agent performance randomly (for demo)
                    if (gamesCompleted % 5 === 0) {
                        updateAgentPerformance();
                    }
                    
                    if (gamesCompleted >= trainingGames) {
                        pauseTraining();
                        document.getElementById('gameStatus').textContent = 'TRAINING COMPLETE';
                    }
                }
            }, 1000);
            
            addToLog("Quantum training started");
        }

        function updateAgentPerformance() {
            // Randomly update agent performance for demo
            if (Math.random() > 0.5) {
                agentPerformance.green.wins++;
            } else {
                agentPerformance.black.wins++;
            }
            
            // Calculate scores
            const totalGames = agentPerformance.green.wins + agentPerformance.green.losses + 
                              agentPerformance.black.wins + agentPerformance.black.losses;
            
            if (totalGames > 0) {
                agentPerformance.green.score = Math.round((agentPerformance.green.wins / totalGames) * 100);
                agentPerformance.black.score = Math.round((agentPerformance.black.wins / totalGames) * 100);
            }
        }

        function startAutoPlay() {
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
            }
            
            autoPlayInterval = setInterval(() => {
                if (gameActive) {
                    makeAIMove();
                }
            }, 2000 / gameSpeed);
        }

        function makeAIMove() {
            if (!gameActive) return;
            
            // Show AI thinking indicator
            document.getElementById('aiThinking').classList.add('active');
            document.getElementById('thinkingAI').textContent = 
                currentPlayer === 'green' ? 'Quantum AI' : 'NeuralNet';
            
            // Simulate AI thinking time
            setTimeout(() => {
                // In a real implementation, this would use the AI to select a move
                // For now, we'll simulate a move
                simulateAIMove();
                
                // Hide AI thinking indicator
                document.getElementById('aiThinking').classList.remove('active');
            }, 1000 / gameSpeed);
        }

        function simulateAIMove() {
            // This is a simplified move simulation
            // In a real implementation, this would use proper chess logic
            
            // Find all pieces of the current player
            const currentPieces = pieces.filter(piece => 
                piece.userData.color === currentPlayer && 
                boardState[piece.userData.x][piece.userData.z] !== null
            );
            
            if (currentPieces.length === 0) {
                endGame();
                return;
            }
            
            // Select a random piece
            const randomPiece = currentPieces[Math.floor(Math.random() * currentPieces.length)];
            
            // Select a random valid move for that piece
            selectPiece(randomPiece);
            calculatePossibleMoves(randomPiece.userData.x, randomPiece.userData.z);
            
            if (possibleMoves.length > 0) {
                const randomMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                movePiece(randomMove.x, randomMove.z);
            } else {
                // If no valid moves, try another piece
                simulateAIMove();
            }
            
            // Randomly end the game after some moves
            if (moveCount > 10 && Math.random() < 0.1) {
                endGame();
            }
        }

        function endGame() {
            gameActive = false;
            document.getElementById('gameStatus').textContent = 'GAME OVER';
            
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
                autoPlayInterval = null;
            }
            
            // Show result
            const results = ['Green QNN wins by checkmate', 'Black QNN wins by checkmate', 'Draw by stalemate'];
            const result = results[Math.floor(Math.random() * results.length)];
            
            // Update agent performance based on result
            if (result.includes('Green')) {
                agentPerformance.green.wins++;
                agentPerformance.black.losses++;
            } else if (result.includes('Black')) {
                agentPerformance.black.wins++;
                agentPerformance.green.losses++;
            }
            
            // Calculate scores
            const totalGames = agentPerformance.green.wins + agentPerformance.green.losses + 
                              agentPerformance.black.wins + agentPerformance.black.losses;
            
            if (totalGames > 0) {
                agentPerformance.green.score = Math.round((agentPerformance.green.wins / totalGames) * 100);
                agentPerformance.black.score = Math.round((agentPerformance.black.wins / totalGames) * 100);
            }
            
            // Log result
            addToLog(`Training session completed: ${result}`);
            
            // Reset for next game
            setTimeout(() => {
                resetGame();
                if (isTraining) {
                    startAutoPlay();
                }
            }, 2000);
        }

        function updateGameInfo() {
            document.getElementById('moveCount').textContent = moveCount;
            document.getElementById('gameStatus').textContent = gameActive ? 'RUNNING' : isTraining ? 'PAUSED' : 'READY';
            document.getElementById('currentPlayer').textContent = gameActive ? (currentPlayer === 'green' ? 'Green' : 'Black') : '-';
        }

        function pauseTraining() {
            if (!isTraining) return;
            
            isTraining = false;
            gameActive = false;
            clearInterval(trainingInterval);
            
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
                autoPlayInterval = null;
            }
            
            document.getElementById('startBtn').classList.remove('active');
            document.getElementById('stopBtn').classList.add('active');
            
            addToLog("Training paused");
        }

        function resetGame() {
            // Reset game state
            moveCount = 0;
            currentPlayer = 'green';
            gameActive = isTraining;
            
            // Reset 3D board
            reset3DBoard();
            
            // Update game info
            updateGameInfo();
        }
        
        function reset3DBoard() {
            // Remove all pieces
            pieces.forEach(piece => scene.remove(piece));
            pieces = [];
            
            // Clear board state
            initializeBoard();
            
            // Recreate pieces
            createPieces3D();
        }

        function updateAISettings() {
            aiStrength = parseInt(document.getElementById('aiStrength').value);
            addToLog(`QNN learning rate adjusted to ${aiStrength}`);
        }

        function updateGameSpeed() {
            gameSpeed = parseInt(document.getElementById('gameSpeed').value);
            
            // Restart auto-play with new speed if active
            if (autoPlayInterval && gameMode === 'ai-vs-ai') {
                startAutoPlay();
            }
            
            addToLog(`Training speed adjusted to ${gameSpeed}`);
        }

        function updateTrainingGames() {
            trainingGames = parseInt(document.getElementById('trainingGames').value);
            addToLog(`Training sessions target set to ${trainingGames}`);
        }

        // Start the application when the page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>