<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GalaxyCraft - StarFox Mode</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
  <style>
    *{margin:0;padding:0;box-sizing:border-box;font-family:'Orbitron','Roboto',sans-serif}
    body{background:#000;color:#fff;overflow:hidden;height:100vh;display:flex;flex-direction:column;background-image:url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiPjxkZWZzPjxwYXR0ZXJuIGlkPSJwYXR0ZXJuIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgcGF0dGVyblVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgcGF0dGVyblRyYW5zZm9ybT0icm90YXRlKDApIj48Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSIxIiBmaWxsPSIjMzMzMzMzIiBvcGFjaXR5PSIwLjMiLz48L3BhdHRlcm4+PC9kZWZzPjxyZWN0IHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbGw9InVybCgjcGF0dGVybikiLz48L3N2Zz4=')}
    #cosmicCanvas{flex:1;width:100%;touch-action:none;position:relative}
    
    /* StarFox-style HUD */
    .hud{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;opacity:0.8;z-index:1}
    .hud::before{content:'';position:absolute;top:10%;left:10%;right:10%;bottom:10%;border:2px solid rgba(0,255,0,0.5);border-radius:20px;box-shadow:0 0 20px rgba(0,255,0,0.3)}
    .hud::after{content:'+';position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#0f0;font-size:24px;text-shadow:0 0 10px #0f0}
    
    /* StarFox style targeting reticle */
    .crosshair{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:40px;height:40px;pointer-events:none;z-index:10}
    .crosshair::before, .crosshair::after{content:'';position:absolute;background:#0f0;box-shadow:0 0 10px #0f0}
    .crosshair::before{width:40px;height:2px;top:19px;left:0}
    .crosshair::after{width:2px;height:40px;left:19px;top:0}
    .crosshair .inner{position:absolute;width:10px;height:10px;border:2px solid #0f0;border-radius:50%;top:15px;left:15px;box-shadow:0 0 10px #0f0}
    .crosshair.active .inner{background:#f00;border-color:#f00;box-shadow:0 0 15px #f00}
    
    /* Status overlay with StarFox styling */
    .status-overlay{position:absolute;top:0;width:100%;background:rgba(0,0,0,0.3);padding:5px 10px;font-size:12px;text-align:left;color:#0f0;text-shadow:0 0 2px #000;z-index:5;pointer-events:none;border-bottom:1px solid #0f0}
    
    /* Window Styles */
    .window{position:absolute;background:rgba(0,20,40,0.95);border:2px solid #0f0;border-radius:8px;z-index:20;display:flex;flex-direction:column;overflow:hidden;box-shadow:0 0 20px rgba(0,255,0,0.7);min-width:250px;min-height:150px;resize:both;overflow:auto}
    .window-header{background:rgba(0,100,0,0.7);padding:8px;display:flex;justify-content:space-between;align-items:center;cursor:move;user-select:none}
    .window-title{font-size:14px;font-weight:bold;color:#0f0}
    .window-controls{display:flex;gap:5px}
    .window-btn{background:none;border:none;color:#0f0;cursor:pointer;font-size:16px;width:20px;height:20px;display:flex;align-items:center;justify-content:center;border-radius:3px}
    .window-btn:hover{background:rgba(0,255,0,0.2)}
    .window-content{padding:10px;flex:1;overflow:auto;font-size:12px;color:#0f0}
    
    /* Specific Window Styles */
    #statsWindow{top:50px;right:10px;width:250px;height:300px}
    #chatWindow{bottom:60px;right:10px;width:300px;height:200px}
    #dronesWindow{top:50px;left:10px;width:300px;height:350px}
    #planetWindow{bottom:60px;left:10px;width:300px;height:250px}
    #craftWindow{top:150px;left:50%;transform:translateX(-50%);width:400px;height:400px;display:none}
    #auctionWindow{top:150px;left:50%;transform:translateX(-50%);width:450px;height:450px;display:none}
    #settingsWindow{top:150px;left:50%;transform:translateX(-50%);width:400px;height:400px;display:none}
    #controlWindow{bottom:150px;right:150px;width:250px;height:250px;display:none}
    #lightspeedWindow{top:50%;left:50%;transform:translate(-50%,-50%);width:300px;height:150px;display:none;text-align:center}
    
    /* Content Styles */
    .stats-resource{margin-bottom:5px;display:flex;justify-content:space-between;color:#0f0}
    .stats-bar{height:5px;background:#333;border-radius:3px;margin:2px 0;overflow:hidden}
    .stats-fill{height:100%;background:#0f0}
    
    .mining-overlay{position:absolute;bottom:150px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.7);padding:10px;border-radius:10px;display:none;z-index:15;border:1px solid #0f0}
    .mining-overlay.active{display:block}
    .mining-progress{width:200px;height:10px;background:#333;border-radius:5px;overflow:hidden;margin:5px 0}
    .mining-progress-bar{height:100%;background:#0f0;width:0%;transition:width 0.3s}
    
    .chat-messages{flex:1;overflow-y:auto;padding:4px;font-size:11px}
    .chat-input{border:none;border-top:1px solid #0f0;background:rgba(0,255,0,0.1);color:#0f0;padding:4px;outline:none;font-size:11px;width:100%}
    
    .mining-path{position:absolute;background:rgba(0,255,0,0.3);z-index:4;pointer-events:none}
    .mining-node{position:absolute;width:10px;height:10px;background:red;border-radius:50%;box-shadow:0 0 10px red;z-index:5;pointer-events:none;animation:pulse 1s infinite}
    @keyframes pulse{0%{opacity:0.3}50%{opacity:1}100%{opacity:0.3}}
    
    .controls-help{position:absolute;bottom:40px;left:10px;background:rgba(0,0,0,0.7);padding:8px;border-radius:8px;z-index:15;font-size:11px;width:200px;border:1px solid #0f0}
    
    /* Control Grid */
    .control-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:5px;margin-top:10px}
    .control-cell{background:rgba(0,100,0,0.3);border:1px solid #0f0;border-radius:5px;height:30px;display:flex;align-items:center;justify-content:center;cursor:pointer;user-select:none;color:#0f0}
    .control-cell.active{background:rgba(0,255,0,0.7)}
    .control-cell:hover{background:rgba(0,255,0,0.5)}
    .control-center{grid-column:2;grid-row:2}
    
    /* Button Styles */
    .btn{background:rgba(0,100,0,0.7);border:1px solid #0f0;padding:6px 12px;color:#0f0;border-radius:4px;cursor:pointer;font-size:12px;transition:background 0.2s;margin:2px;text-shadow:0 0 5px #0f0}
    .btn:hover{background:rgba(0,255,0,0.5)}
    .btn.active{background:rgba(255,0,0,0.7);border-color:#f00;color:#f00;text-shadow:0 0 5px #f00}
    .btn:disabled{background:#555;cursor:not-allowed}
    
    /* List Styles */
    .item-list{max-height:200px;overflow-y:auto;border:1px solid #0f0;border-radius:4px;margin:5px 0}
    .list-item{padding:5px;border-bottom:1px solid rgba(0,255,0,0.3);cursor:pointer;color:#0f0}
    .list-item:hover{background:rgba(0,255,0,0.2)}
    .list-item:last-child{border-bottom:none}
    
    /* Progress Bars */
    .progress-container{width:100%;height:10px;background:#333;border-radius:5px;overflow:hidden;margin:5px 0}
    .progress-bar{height:100%;background:#0f0;width:0%}
    
    /* Overlay for dimming background when menu is open */
    .overlay{position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);z-index:19;display:none}
    
    /* Controls Bar */
    .controls{position:fixed;bottom:0;width:100%;background:rgba(20,50,20,0.9);padding:8px;display:flex;flex-wrap:wrap;gap:8px;justify-content:center;backdrop-filter:blur(5px);z-index:10;border-top:1px solid #0f0}
    .control-item{flex:1;min-width:70px;text-align:center}
    
    /* Tab Styles */
    .tabs{display:flex;border-bottom:1px solid #0f0;margin-bottom:10px}
    .tab{padding:5px 10px;cursor:pointer;border:1px solid transparent;border-bottom:none;border-radius:4px 4px 0 0;color:#0f0}
    .tab.active{background:rgba(0,255,0,0.3);border-color:#0f0;border-bottom-color:transparent}
    
    /* Lightspeed Effect */
    .lightspeed-effect{position:absolute;top:0;left:0;width:100%;height:100%;background:radial-gradient(circle, rgba(0,195,255,0.5) 0%, rgba(0,83,255,0.8) 100%);z-index:25;display:none;pointer-events:none;animation:lightspeed 10s linear}
    @keyframes lightspeed{0%{opacity:0;transform:scale(1)}10%{opacity:1;transform:scale(1.5)}90%{opacity:1;transform:scale(5)}100%{opacity:0;transform:scale(10)}}
    
    /* Checkbox Styles */
    .checkbox-container{display:flex;align-items:center;margin:5px 0;color:#0f0}
    .checkbox-container input{margin-right:8px}
    
    /* StarFox style radar */
    .radar-display {
      position: absolute;
      bottom: 100px;
      right: 20px;
      width: 150px;
      height: 150px;
      background: rgba(0, 30, 0, 0.7);
      border: 2px solid #0f0;
      border-radius: 50%;
      z-index: 5;
      overflow: hidden;
    }
    .radar-sweep {
      position: absolute;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent 0%, rgba(0, 255, 0, 0.2) 50%, transparent 100%);
      animation: radarSweep 3s infinite linear;
      transform-origin: center;
    }
    @keyframes radarSweep {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    .radar-blip {
      position: absolute;
      width: 6px;
      height: 6px;
      background: #0f0;
      border-radius: 50%;
      transform: translate(-50%, -50%);
    }
    
    /* Speed lines effect for StarFox feel */
    .speed-lines {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 2;
      opacity: 0;
      transition: opacity 0.5s;
    }
    .speed-line {
      position: absolute;
      width: 2px;
      height: 100px;
      background: linear-gradient(to bottom, transparent, #0f0, transparent);
      opacity: 0.3;
    }
  </style>
</head>
<body>
  <div id="cosmicCanvas">
    <div class="hud"></div>
    <div class="crosshair"><div class="inner"></div></div>
    <div id="statusOverlay" class="status-overlay"></div>
    
    <!-- Radar Display -->
    <div class="radar-display">
      <div class="radar-sweep"></div>
      <div id="radarBlips"></div>
    </div>
    
    <!-- Speed Lines Effect -->
    <div id="speedLines" class="speed-lines"></div>
    
    <!-- Windows -->
    <div class="window" id="statsWindow">
      <div class="window-header">
        <div class="window-title">Arwing Status</div>
        <div class="window-controls">
          <button class="window-btn" onclick="minimizeWindow('statsWindow')">−</button>
          <button class="window-btn" onclick="closeWindow('statsWindow')">×</button>
        </div>
      </div>
      <div class="window-content">
        <div class="stats-resource">Credits: <span id="creditsValue">1000</span></div>
        <div class="stats-resource">Energy: <span id="energyValue">100</span>/100</div>
        <div class="stats-bar"><div id="energyBar" class="stats-fill" style="width:100%"></div></div>
        <div class="stats-resource">Fuel: <span id="fuelValue">1000</span>/1000</div>
        <div class="stats-bar"><div id="fuelBar" class="stats-fill" style="width:100%"></div></div>
        <div class="stats-resource">Speed: <span id="speedValue">0</span> km/s</div>
        <div class="stats-bar"><div id="speedBar" class="stats-fill" style="width:0%"></div></div>
        <div class="stats-resource">Targets: <span id="targetsValue">0</span> locked</div>
        <div class="stats-resource">Lives: <span id="livesValue">3</span></div>
      </div>
    </div>
    
    <div class="window" id="chatWindow">
      <div class="window-header">
        <div class="window-title">Team StarFox</div>
        <div class="window-controls">
          <button class="window-btn" onclick="minimizeWindow('chatWindow')">−</button>
          <button class="window-btn" onclick="closeWindow('chatWindow')">×</button>
        </div>
      </div>
      <div id="chatMessages" class="chat-messages">
        <p><span style="color: #0f0;">Fox:</span> Use the control stick to move your Arwing!</p>
        <p><span style="color: #ff0;">Falco:</span> Watch out for enemy fire!</p>
        <p><span style="color: #0ff;">Slippy:</span> I'm detecting energy readings ahead!</p>
        <p><span style="color: #f80;">Peppy:</span> Do a barrel roll!</p>
      </div>
      <input id="chatInput" class="chat-input" type="text" placeholder="Transmit to team..." autocomplete="off">
    </div>
    
    <div class="controls-help">
      <div>CONTROLS: WASD/Arrows = Steer</div>
      <div>SHIFT = Boost, SPACE = Fire Lasers</div>
      <div>Z = Barrel Roll, X = Bomb</div>
      <div>R = Target Enemy, C = Camera View</div>
    </div>
    
    <div id="miningOverlay" class="mining-overlay">
      <div>Target Locked: <span id="miningResource">Unknown</span></div>
      <div class="mining-progress">
        <div id="miningProgress" class="mining-progress-bar"></div>
      </div>
      <div>Damage: <span id="miningYield">0</span>%</div>
    </div>
    
    <!-- Lightspeed Effect -->
    <div id="lightspeedEffect" class="lightspeed-effect"></div>
    
    <!-- Overlay for dimming background when menu is open -->
    <div class="overlay" id="menuOverlay"></div>
  </div>
  
  <div class="controls">
    <div class="control-item"><button id="throttleBtn" class="btn">Boost</button></div>
    <div class="control-item"><button id="fireBtn" class="btn">Fire</button></div>
    <div class="control-item"><button id="targetBtn" class="btn">Target</button></div>
    <div class="control-item"><button id="bombBtn" class="btn">Bomb</button></div>
    <div class="control-item"><button id="rollBtn" class="btn" onclick="doBarrelRoll()">Barrel Roll</button></div>
    <div class="control-item"><button id="viewBtn" class="btn" onclick="toggleViewMode()">Camera</button></div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
    // Game state
    let scene, camera, renderer;
    let resources = [], planets = [], particles = [], enemies = [], enemyProjectiles = [];
    let resourceCount = 0, throttle = 0;
    let rotation = { pitch: 0, yaw: 0, roll: 0 };
    let rotationVelocity = { pitch: 0, yaw: 0, roll: 0 };
    let velocity = new THREE.Vector3(0, 0, 0);
    let lastTime = performance.now();
    let miningActive = false, miningTarget = null;
    let miningProgress = 0, miningYield = 0, isScanning = false, scanEndTime = 0;
    let selectedPlanet = null;
    let controlSensitivity = 3;
    let invertControls = false;
    let lightspeedActive = false;
    let lightspeedCooldown = false;
    let viewMode = 'first-person'; // 'first-person' or 'third-person'
    let playerLives = 3;
    let playerSpeed = 0;
    let lockedTargets = 0;
    
    // Player resources
    let playerResources = {
      credits: 1000,
      fuel: 1000
    };
    
    let playerEnergy = 100;
    
    // Console and status
    let logMessages = [];
    const maxLogMessages = 50;
    
    // Window management
    let minimizedWindows = {};
    let closedWindows = {};
    
    // Create speed lines effect
    function createSpeedLines() {
      const speedLines = document.getElementById('speedLines');
      speedLines.innerHTML = '';
      
      for (let i = 0; i < 30; i++) {
        const line = document.createElement('div');
        line.className = 'speed-line';
        line.style.left = `${Math.random() * 100}%`;
        line.style.top = `${-100 + Math.random() * 200}%`;
        line.style.transform = `rotate(${Math.random() * 360}deg)`;
        speedLines.appendChild(line);
      }
    }
    
    // Update speed lines based on velocity
    function updateSpeedLines() {
      const speedLines = document.getElementById('speedLines');
      const speed = velocity.length();
      
      if (speed > 50) {
        speedLines.style.opacity = Math.min(1, (speed - 50) / 100);
      } else {
        speedLines.style.opacity = 0;
      }
    }
    
    // Create radar blips for enemies and resources
    function updateRadar() {
      const radarBlips = document.getElementById('radarBlips');
      radarBlips.innerHTML = '';
      
      // Add player position (center)
      const playerBlip = document.createElement('div');
      playerBlip.className = 'radar-blip';
      playerBlip.style.left = '50%';
      playerBlip.style.top = '50%';
      playerBlip.style.background = '#0f0';
      radarBlips.appendChild(playerBlip);
      
      // Add enemy blips
      enemies.forEach(enemy => {
        const direction = new THREE.Vector3().subVectors(enemy.position, camera.position);
        const distance = direction.length();
        
        if (distance < 2000) {
          const blip = document.createElement('div');
          blip.className = 'radar-blip';
          blip.style.left = `${50 + (direction.x / 2000) * 45}%`;
          blip.style.top = `${50 + (direction.z / 2000) * 45}%`;
          blip.style.background = '#f00';
          radarBlips.appendChild(blip);
        }
      });
      
      // Add resource blips
      resources.forEach(resource => {
        if (resource.userData.collected) return;
        
        const direction = new THREE.Vector3().subVectors(resource.position, camera.position);
        const distance = direction.length();
        
        if (distance < 2000) {
          const blip = document.createElement('div');
          blip.className = 'radar-blip';
          blip.style.left = `${50 + (direction.x / 2000) * 45}%`;
          blip.style.top = `${50 + (direction.z / 2000) * 45}%`;
          blip.style.background = '#ff0';
          radarBlips.appendChild(blip);
        }
      });
    }
    
    // Initialize the game with StarFox-style FPV
    function initGame() {
      try {
        // Scene setup
        scene = new THREE.Scene();
        
        // Camera setup - First Person View like StarFox
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 1);
        document.getElementById('cosmicCanvas').appendChild(renderer.domElement);

        // Position camera for first-person view
        camera.position.set(0, 0, 0);

        // Create starfield background
        createStarfield();
        
        // Create speed lines
        createSpeedLines();

        // Resource materials
        const sharedMaterials = {
          ore: new THREE.MeshBasicMaterial({ color: 0xcccccc }),
          crystal: new THREE.MeshBasicMaterial({ color: 0x8844ff, emissive: 0x4422aa }),
          water: new THREE.MeshBasicMaterial({ color: 0x3399ff, transparent: true, opacity: 0.8 }),
          planet: new THREE.MeshBasicMaterial({ color: 0x3399ff }),
          claimedPlanet: new THREE.MeshBasicMaterial({ color: 0x00ff00, emissive: 0x00aa00 }),
          particle: new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.6 }),
          darkMatter: new THREE.MeshBasicMaterial({ color: 0x330066, emissive: 0x220044, transparent: true, opacity: 0.8 }),
          quantumUranium: new THREE.MeshBasicMaterial({ color: 0x00ffcc, emissive: 0x00aa88 }),
          fuel: new THREE.MeshBasicMaterial({ color: 0xff9900, emissive: 0xff5500, transparent: true, opacity: 0.7 }),
          enemy: new THREE.MeshBasicMaterial({ color: 0xff0000, emissive: 0xaa0000 }),
          enemyProjectile: new THREE.MeshBasicMaterial({ color: 0xff3333, emissive: 0xff0000 })
        };

        // Resource geometries
        const sharedGeometries = {
          resource: new THREE.SphereGeometry(8, 12, 12),
          planet: new THREE.SphereGeometry(40, 14, 14),
          claimedPlanet: new THREE.SphereGeometry(50, 16, 16),
          particle: new THREE.SphereGeometry(1, 6, 6),
          rareResource: new THREE.SphereGeometry(6, 10, 10),
          enemy: new THREE.ConeGeometry(10, 30, 8),
          enemyProjectile: new THREE.SphereGeometry(3, 8, 8)
        };
        
        // Create starfield background
        function createStarfield() {
          const starGeometry = new THREE.BufferGeometry();
          const starCount = 1000;
          const positions = new Float32Array(starCount * 3);
          
          for (let i = 0; i < starCount * 3; i += 3) {
            positions[i] = (Math.random() - 0.5) * 2000;
            positions[i + 1] = (Math.random() - 0.5) * 2000;
            positions[i + 2] = (Math.random() - 0.5) * 2000 - 1000;
          }
          
          starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          
          const starMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 2,
            transparent: true
          });
          
          const stars = new THREE.Points(starGeometry, starMaterial);
          scene.add(stars);
        }

        // Generate resources in clusters
        function generateResourceClusters() {
          const resourceTypes = [
            { type: 'ore', material: sharedMaterials.ore, rarity: 0.5, clusterSize: 5 },
            { type: 'crystal', material: sharedMaterials.crystal, rarity: 0.3, clusterSize: 3 },
            { type: 'water', material: sharedMaterials.water, rarity: 0.1, clusterSize: 2 },
            { type: 'fuel', material: sharedMaterials.fuel, rarity: 0.4, clusterSize: 4 },
            { type: 'darkMatter', material: sharedMaterials.darkMatter, rarity: 0.02, clusterSize: 1 },
            { type: 'quantumUranium', material: sharedMaterials.quantumUranium, rarity: 0.05, clusterSize: 1 }
          ];
          
          // Create 15 clusters spread out
          for (let c = 0; c < 15; c++) {
            const clusterX = (Math.random() - 0.5) * 2000;
            const clusterY = (Math.random() - 0.5) * 2000;
            const clusterZ = (Math.random() - 0.5) * 2000 - 500;
            
            const clusterType = weightedRandom(resourceTypes);
            const geometry = clusterType.type.includes('darkMatter') || clusterType.type.includes('quantumUranium') 
              ? sharedGeometries.rareResource 
              : sharedGeometries.resource;
            
            for (let i = 0; i < clusterType.clusterSize; i++) {
              const resource = new THREE.Mesh(geometry, clusterType.material);
              
              // Position within cluster
              const radius = 100 + Math.random() * 150;
              const theta = Math.random() * Math.PI * 2;
              const phi = Math.acos((Math.random() * 2) - 1);
              
              resource.position.set(
                clusterX + radius * Math.sin(phi) * Math.cos(theta),
                clusterY + radius * Math.sin(phi) * Math.sin(theta),
                clusterZ + radius * Math.cos(phi)
              );
              
              // Higher value for rare resources
              let value = Math.floor(Math.random() * 50) + 20;
              if (clusterType.type === 'darkMatter') value = Math.floor(Math.random() * 10) + 5;
              if (clusterType.type === 'quantumUranium') value = Math.floor(Math.random() * 20) + 10;
              if (clusterType.type === 'fuel') value = Math.floor(Math.random() * 30) + 15;
              
              resource.userData = { 
                type: 'resource', 
                resourceType: clusterType.type, 
                value: value, 
                collected: false 
              };
              
              scene.add(resource);
              resources.push(resource);
              resourceCount++;
            }
          }
        }
        
        // Generate enemies (StarFox style)
        function generateEnemies() {
          for (let i = 0; i < 20; i++) {
            const enemy = new THREE.Mesh(sharedGeometries.enemy, sharedMaterials.enemy);
            
            // Position enemies in front of the player
            enemy.position.set(
              (Math.random() - 0.5) * 1000,
              (Math.random() - 0.5) * 1000,
              -500 - Math.random() * 1500
            );
            
            // Rotate to face player
            enemy.rotation.x = Math.PI / 2;
            
            enemy.userData = {
              type: 'enemy',
              health: 30,
              speed: 20 + Math.random() * 30,
              fireRate: 1 + Math.random() * 2,
              fireCooldown: 0,
              worth: 50
            };
            
            scene.add(enemy);
            enemies.push(enemy);
          }
        }

        function weightedRandom(options) {
          let weights = options.map(opt => opt.rarity);
          let total = weights.reduce((a, b) => a + b, 0);
          let random = Math.random() * total;
          
          for (let i = 0; i < weights.length; i++) {
            if (random < weights[i]) return options[i];
            random -= weights[i];
          }
          
          return options[0];
        }

        // Generate planets
        function generatePlanets(count) {
          for (let i = 0; i < count; i++) {
            const planet = new THREE.Mesh(sharedGeometries.planet, sharedMaterials.planet);
            const radius = 800 + Math.random() * 1200;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            
            planet.position.set(radius * Math.sin(phi) * Math.cos(theta), radius * Math.sin(phi) * Math.sin(theta), radius * Math.cos(phi) - 1000);
            planet.userData = {
              type: 'planet', 
              discovered: false, 
              claimed: false
            };
            
            scene.add(planet);
            planets.push(planet);
          }
        }

        // Generate particle fields (asteroids, comets)
        function generateParticles() {
          for (let i = 0; i < 100; i++) {
            const particle = new THREE.Mesh(sharedGeometries.particle, sharedMaterials.particle);
            
            const radius = 300 + Math.random() * 1500;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            
            particle.position.set(radius * Math.sin(phi) * Math.cos(theta), radius * Math.sin(phi) * Math.sin(theta), radius * Math.cos(phi) - 800);
            particle.userData = { 
              type: 'particle',
              velocity: new THREE.Vector3(
                (Math.random() - 0.5) * 0.5,
                (Math.random() - 0.5) * 0.5,
                (Math.random() - 0.5) * 0.5
              )
            };
            
            scene.add(particle);
            particles.push(particle);
          }
        }

        // Console functions
        function addConsoleMessage(message) {
          const timestamp = new Date().toLocaleTimeString();
          logMessages.push(`[${timestamp}] ${message}`);
          if (logMessages.length > maxLogMessages) logMessages.shift();
          
          const consoleLog = document.getElementById('consoleLog');
          if (consoleLog) {
            consoleLog.innerHTML = logMessages.map(msg => `<p>${msg}</p>`).join('');
            consoleLog.scrollTop = consoleLog.scrollHeight;
          }
        }

        function updateStatusOverlay() {
          const statusOverlay = document.getElementById('statusOverlay');
          if (statusOverlay) {
            statusOverlay.textContent = `Speed: ${Math.floor(playerSpeed)} km/s | Energy: ${Math.floor(playerEnergy)}% | Targets: ${lockedTargets}`;
          }
        }
        
        function updateResourceDisplay() {
          document.getElementById('creditsValue').textContent = playerResources.credits;
          document.getElementById('fuelValue').textContent = playerResources.fuel;
          document.getElementById('fuelBar').style.width = `${(playerResources.fuel / 1000) * 100}%`;
          document.getElementById('energyValue').textContent = Math.floor(playerEnergy);
          document.getElementById('energyBar').style.width = `${playerEnergy}%`;
          document.getElementById('speedValue').textContent = Math.floor(playerSpeed);
          document.getElementById('speedBar').style.width = `${Math.min(100, playerSpeed / 2)}%`;
          document.getElementById('targetsValue').textContent = lockedTargets;
          document.getElementById('livesValue').textContent = playerLives;
        }

        // Keyboard controls - StarFox style
        const activeKeys = {};
        
        window.addEventListener('keydown', e => {
          if (lightspeedActive) return;
          
          activeKeys[e.code] = true;
          e.preventDefault();
          
          // Handle special keys
          if (e.code === 'ShiftLeft') {
            toggleThrottle();
          }
          else if (e.code === 'Space') {
            fireLaser();
          }
          else if (e.code === 'KeyZ') {
            doBarrelRoll();
          }
          else if (e.code === 'KeyX') {
            fireBomb();
          }
          else if (e.code === 'KeyR') {
            targetEnemy();
          }
          else if (e.code === 'KeyC') {
            toggleViewMode();
          }
        });
        
        window.addEventListener('keyup', e => { 
          activeKeys[e.code] = false; 
        });

        // Toggle between first-person and third-person views
        function toggleViewMode() {
          if (viewMode === 'first-person') {
            viewMode = 'third-person';
            addConsoleMessage("Third-person view activated");
          } else {
            viewMode = 'first-person';
            addConsoleMessage("First-person view activated");
          }
        }

        // Fire laser function
        function fireLaser() {
          if (playerEnergy < 5) {
            addConsoleMessage("Insufficient energy for lasers");
            return;
          }
          
          playerEnergy -= 5;
          updateResourceDisplay();
          
          // Create laser projectile
          const laserGeometry = new THREE.CylinderGeometry(1, 1, 50, 8);
          const laserMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, emissive: 0x00ff00 });
          const laser = new THREE.Mesh(laserGeometry, laserMaterial);
          
          // Position laser at camera position
          laser.position.copy(camera.position);
          
          // Orient laser in camera direction
          const direction = new THREE.Vector3(0, 0, -1);
          direction.applyQuaternion(camera.quaternion);
          laser.quaternion.copy(camera.quaternion);
          laser.rotateX(Math.PI / 2); // Adjust rotation for cylinder
          
          laser.userData = {
            type: 'laser',
            velocity: direction.multiplyScalar(300),
            damage: 10,
            lifespan: 1000 // milliseconds
          };
          
          scene.add(laser);
          
          // Add to projectiles array for tracking
          if (!window.projectiles) window.projectiles = [];
          window.projectiles.push({
            mesh: laser,
            createdAt: Date.now()
          });
          
          addConsoleMessage("Laser fired!");
        }
        
        // Fire bomb function
        function fireBomb() {
          if (playerResources.credits < 100) {
            addConsoleMessage("Insufficient credits for bomb (100 needed)");
            return;
          }
          
          playerResources.credits -= 100;
          updateResourceDisplay();
          
          // Create bomb projectile
          const bombGeometry = new THREE.SphereGeometry(15, 16, 16);
          const bombMaterial = new THREE.MeshBasicMaterial({ color: 0xff5500, emissive: 0xff0000 });
          const bomb = new THREE.Mesh(bombGeometry, bombMaterial);
          
          // Position bomb at camera position
          bomb.position.copy(camera.position);
          
          // Move slightly forward
          const direction = new THREE.Vector3(0, 0, -1);
          direction.applyQuaternion(camera.quaternion);
          bomb.position.add(direction.multiplyScalar(20));
          
          bomb.userData = {
            type: 'bomb',
            velocity: new THREE.Vector3(0, 0, -50),
            damage: 100,
            radius: 200,
            lifespan: 3000 // milliseconds
          };
          
          scene.add(bomb);
          
          // Add to projectiles array for tracking
          if (!window.projectiles) window.projectiles = [];
          window.projectiles.push({
            mesh: bomb,
            createdAt: Date.now()
          });
          
          addConsoleMessage("Bomb deployed! Clear the area!");
        }
        
        // Target enemy function
        function targetEnemy() {
          // Find closest enemy
          let closestEnemy = null;
          let closestDistance = Infinity;
          
          enemies.forEach(enemy => {
            const distance = camera.position.distanceTo(enemy.position);
            if (distance < 500 && distance < closestDistance) {
              closestDistance = distance;
              closestEnemy = enemy;
            }
          });
          
          if (!closestEnemy) {
            addConsoleMessage("No enemies in targeting range");
            return;
          }
          
          // Mark enemy as targeted
          if (!closestEnemy.userData.targeted) {
            closestEnemy.userData.targeted = true;
            closestEnemy.material.emissive.set(0xffff00);
            lockedTargets++;
            addConsoleMessage("Enemy targeted!");
          } else {
            closestEnemy.userData.targeted = false;
            closestEnemy.material.emissive.set(0xaa0000);
            lockedTargets--;
            addConsoleMessage("Target lock released");
          }
          
          updateResourceDisplay();
        }
        
        // Barrel roll function
        function doBarrelRoll() {
          if (window.isBarrelRolling) return;
          
          window.isBarrelRolling = true;
          const originalRoll = rotation.roll;
          
          addConsoleMessage("Doing a barrel roll!");
          
          // Animate the barrel roll
          const startTime = Date.now();
          const duration = 1000; // 1 second
          
          function animateBarrelRoll() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(1, elapsed / duration);
            
            // Complete two full rotations
            rotation.roll = originalRoll + progress * Math.PI * 4;
            
            if (progress < 1) {
              requestAnimationFrame(animateBarrelRoll);
            } else {
              rotation.roll = originalRoll;
              window.isBarrelRolling = false;
            }
          }
          
          animateBarrelRoll();
        }

        // Throttle control
        function toggleThrottle() {
          throttle = throttle === 0 ? 200 : 0;
          const throttleBtn = document.getElementById('throttleBtn');
          if (throttleBtn) throttleBtn.classList.toggle('active', throttle > 0);
          
          addConsoleMessage(throttle > 0 ? 'Boost engaged!' : 'Boost disengaged.');
          updateStatusOverlay();
        }

        // Generate game content
        generateResourceClusters();
        generateEnemies();
        generatePlanets(4);
        generateParticles();
        updateResourceDisplay();
        addConsoleMessage('StarFox mode activated! Good luck, Fox!');
        
        // Initialize UI event listeners
        document.getElementById('throttleBtn').addEventListener('click', toggleThrottle);
        document.getElementById('fireBtn').addEventListener('click', fireLaser);
        document.getElementById('targetBtn').addEventListener('click', targetEnemy);
        document.getElementById('bombBtn').addEventListener('click', fireBomb);

        // Animation loop - StarFox style
        function animate() {
          requestAnimationFrame(animate);
          
          const currentTime = performance.now();
          const deltaTime = (currentTime - lastTime) / 1000;
          lastTime = currentTime;
          
          // Calculate player speed for display
          playerSpeed = velocity.length();
          
          // Handle controls - StarFox style movement
          const rotationSpeed = 1.5 * deltaTime * (controlSensitivity / 5);
          const acceleration = 50 * deltaTime;
          
          // Pitch (up/down)
          if (activeKeys['ArrowUp'] || activeKeys['KeyW']) {
            rotationVelocity.pitch -= rotationSpeed;
          }
          if (activeKeys['ArrowDown'] || activeKeys['KeyS']) {
            rotationVelocity.pitch += rotationSpeed;
          }
          
          // Yaw (left/right)
          if (activeKeys['ArrowLeft'] || activeKeys['KeyA']) {
            rotationVelocity.yaw -= rotationSpeed;
          }
          if (activeKeys['ArrowRight'] || activeKeys['KeyD']) {
            rotationVelocity.yaw += rotationSpeed;
          }
          
          // Apply rotation
          rotation.pitch += rotationVelocity.pitch;
          rotation.yaw += rotationVelocity.yaw;
          rotation.roll += rotationVelocity.roll;
          
          // Apply damping to rotation
          rotationVelocity.pitch *= 0.85;
          rotationVelocity.yaw *= 0.85;
          rotationVelocity.roll *= 0.85;
          
          // Limit rotation
          rotation.pitch = Math.max(-Math.PI/3, Math.min(Math.PI/3, rotation.pitch));
          rotation.yaw = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotation.yaw));
          
          // Apply rotation to camera
          camera.rotation.set(rotation.pitch, rotation.yaw, rotation.roll, 'YXZ');
          
          // Handle movement - always moving forward in StarFox style
          const moveVector = new THREE.Vector3(0, 0, -1);
          
          if (throttle > 0) {
            moveVector.z = -1.5; // Boost multiplier
          }
          
          // Apply movement
          if (moveVector.length() > 0) {
            moveVector.normalize();
            moveVector.applyEuler(camera.rotation);
            moveVector.multiplyScalar(acceleration * (throttle > 0 ? throttle : 100));
            velocity.add(moveVector);
          }
          
          // Apply velocity damping
          velocity.multiplyScalar(0.97);
          
          // Limit velocity
          const maxVelocity = throttle > 0 ? 300 : 200;
          if (velocity.length() > maxVelocity) {
            velocity.normalize().multiplyScalar(maxVelocity);
          }
          
          // Update camera position
          camera.position.add(velocity.clone().multiplyScalar(deltaTime));
          
          // Update particle positions
          particles.forEach(particle => {
            particle.position.add(particle.userData.velocity);
            
            // Wrap around if too far
            if (particle.position.distanceTo(camera.position) > 2000) {
              particle.position.set(
                camera.position.x + (Math.random() - 0.5) * 1000,
                camera.position.y + (Math.random() - 0.5) * 1000,
                camera.position.z - 800 - Math.random() * 400
              );
            }
          });
          
          // Update enemy positions and behavior
          enemies.forEach((enemy, index) => {
            // Move toward player
            const direction = new THREE.Vector3().subVectors(camera.position, enemy.position).normalize();
            enemy.position.add(direction.multiplyScalar(enemy.userData.speed * deltaTime));
            
            // Face player
            enemy.lookAt(camera.position);
            enemy.rotateX(Math.PI / 2);
            
            // Enemy firing logic
            if (enemy.userData.fireCooldown <= 0) {
              // Fire at player
              const projectile = new THREE.Mesh(sharedGeometries.enemyProjectile, sharedMaterials.enemyProjectile);
              projectile.position.copy(enemy.position);
              
              const fireDirection = new THREE.Vector3().subVectors(camera.position, enemy.position).normalize();
              projectile.userData = {
                type: 'enemyProjectile',
                velocity: fireDirection.multiplyScalar(100),
                damage: 10,
                lifespan: 2000
              };
              
              scene.add(projectile);
              enemyProjectiles.push({
                mesh: projectile,
                createdAt: Date.now()
              });
              
              enemy.userData.fireCooldown = 60 / enemy.userData.fireRate;
            } else {
              enemy.userData.fireCooldown -= deltaTime;
            }
            
            // Check for collision with player
            if (enemy.position.distanceTo(camera.position) < 30) {
              // Player hit!
              playerLives--;
              updateResourceDisplay();
              
              if (playerLives <= 0) {
                addConsoleMessage("Mission failed! Return to base.");
                playerLives = 0;
              } else {
                addConsoleMessage(`Hit! ${playerLives} lives remaining.`);
              }
              
              // Remove enemy
              scene.remove(enemy);
              enemies.splice(index, 1);
            }
          });
          
          // Update projectiles
          if (window.projectiles) {
            for (let i = window.projectiles.length - 1; i >= 0; i--) {
              const projectile = window.projectiles[i];
              projectile.mesh.position.add(projectile.mesh.userData.velocity.clone().multiplyScalar(deltaTime));
              
              // Check lifespan
              if (Date.now() - projectile.createdAt > projectile.mesh.userData.lifespan) {
                scene.remove(projectile.mesh);
                window.projectiles.splice(i, 1);
                continue;
              }
              
              // Check for collisions with enemies
              for (let j = enemies.length - 1; j >= 0; j--) {
                const enemy = enemies[j];
                if (projectile.mesh.position.distanceTo(enemy.position) < 20) {
                  // Hit enemy!
                  enemy.userData.health -= projectile.mesh.userData.damage;
                  
                  if (enemy.userData.health <= 0) {
                    // Enemy destroyed
                    playerResources.credits += enemy.userData.worth;
                    if (enemy.userData.targeted) lockedTargets--;
                    
                    scene.remove(enemy);
                    enemies.splice(j, 1);
                    addConsoleMessage(`Enemy destroyed! +${enemy.userData.worth} credits`);
                  }
                  
                  // Remove projectile
                  scene.remove(projectile.mesh);
                  window.projectiles.splice(i, 1);
                  break;
                }
              }
            }
          }
          
          // Update enemy projectiles
          for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
            const projectile = enemyProjectiles[i];
            projectile.mesh.position.add(projectile.mesh.userData.velocity.clone().multiplyScalar(deltaTime));
            
            // Check lifespan
            if (Date.now() - projectile.createdAt > projectile.mesh.userData.lifespan) {
              scene.remove(projectile.mesh);
              enemyProjectiles.splice(i, 1);
              continue;
            }
            
            // Check for collision with player
            if (projectile.mesh.position.distanceTo(camera.position) < 20) {
              // Player hit!
              playerLives--;
              updateResourceDisplay();
              
              if (playerLives <= 0) {
                addConsoleMessage("Mission failed! Return to base.");
                playerLives = 0;
              } else {
                addConsoleMessage(`Hit! ${playerLives} lives remaining.`);
              }
              
              // Remove projectile
              scene.remove(projectile.mesh);
              enemyProjectiles.splice(i, 1);
            }
          }
          
          // Energy regeneration
          if (playerEnergy < 100) {
            playerEnergy += 10 * deltaTime;
            if (playerEnergy > 100) playerEnergy = 100;
            updateResourceDisplay();
          }
          
          // Fuel consumption
          if (throttle > 0) {
            playerResources.fuel -= 5 * deltaTime;
            if (playerResources.fuel < 0) playerResources.fuel = 0;
            updateResourceDisplay();
          }
          
          // Update radar
          updateRadar();
          
          // Update speed lines
          updateSpeedLines();
          
          // Update display
          updateResourceDisplay();
          updateStatusOverlay();
          
          renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start animation
        animate();
      } catch (error) {
        console.error('Error initializing game:', error);
        alert('Failed to initialize the game. Please check the console for details.');
      }
    }

    // Start the game when the page loads
    window.addEventListener('load', initGame);
  </script>
</body>
</html>