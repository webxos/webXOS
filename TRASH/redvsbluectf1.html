<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>GALAXYQUEST: RED VS BLUE | Enhanced Combat</title>
  <meta name="description" content="Experience GALAXYQUEST: RED VS BLUE - a fast-paced paintball battle on Mars with enhanced weapons and jetpacks.">
  <meta name="keywords" content="GalaxyQuest, Red vs Blue, paintball, Mars, team combat, jetpack">
  <meta name="author" content="WebXOS">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Orbitron', 'Courier New', monospace;
    }
    body {
      background: #000;
      color: #f55;
      height: 100vh;
      overflow: hidden;
      touch-action: none;
    }
    #gameCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }
    
    /* FPS HUD Elements */
    .hud-container {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 20;
    }
    
    .health-armor-display {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
    }
    
    .health-bar, .armor-bar, .energy-bar {
      width: 200px;
      height: 20px;
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid #f55;
      border-radius: 5px;
      overflow: hidden;
    }
    
    .health-fill {
      height: 100%;
      background: linear-gradient(90deg, #f00, #ff3300);
      transition: width 0.3s ease;
    }
    
    .armor-fill {
      height: 100%;
      background: linear-gradient(90deg, #f55, #f33);
      transition: width 0.3s ease;
    }
    
    .energy-fill {
      height: 100%;
      background: linear-gradient(90deg, #0f0, #0a0);
      transition: width 0.3s ease;
    }
    
    .ammo-display {
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border: 2px solid #f55;
      border-radius: 5px;
      font-size: 18px;
      color: #f55;
    }
    
    .weapon-display {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border: 2px solid #f55;
      border-radius: 5px;
      font-size: 18px;
      color: #f55;
      text-align: right;
      z-index: 20;
    }
    
    .team-score {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 50px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 20px;
      border: 2px solid #f55;
      border-radius: 5px;
      font-size: 18px;
      color: #f55;
      z-index: 20;
    }
    
    .team-blue, .team-red {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .team-blue { color: #55f; }
    .team-red { color: #f55; }
    
    .kill-feed {
      position: fixed;
      top: 80px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border: 2px solid #f55;
      border-radius: 5px;
      font-size: 14px;
      color: #fff;
      z-index: 20;
      display: flex;
      flex-direction: column;
      gap: 5px;
      max-height: 200px;
      overflow-y: auto;
    }
    
    .kill-event {
      display: flex;
      gap: 10px;
    }
    
    .kill-event .killer {
      color: #55f;
    }
    
    .kill-event .victim {
      color: #f55;
    }
    
    .respawn-timer {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      padding: 30px;
      border: 4px solid #f00;
      border-radius: 10px;
      font-size: 36px;
      color: #f00;
      z-index: 100;
      text-align: center;
      display: none;
    }
    
    .performance-display {
      position: fixed;
      top: 20px;
      right: 20px;
      color: #f00;
      font-size: 14px;
      z-index: 20;
      background: rgba(0, 0, 0, 0.7);
      padding: 5px 10px;
      border-radius: 5px;
    }
    
    /* Crosshair */
    .crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      z-index: 10;
      pointer-events: none;
    }
    
    .crosshair::before, .crosshair::after {
      content: '';
      position: absolute;
      background: #0f0;
    }
    
    .crosshair::before {
      top: 50%;
      left: 0;
      width: 100%;
      height: 2px;
      transform: translateY(-50%);
    }
    
    .crosshair::after {
      left: 50%;
      top: 0;
      height: 100%;
      width: 2px;
      transform: translateX(-50%);
    }
    
    /* Main Menu */
    .main-menu {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(20, 10, 0, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      color: #f55;
    }
    
    .game-title {
      font-size: 60px;
      margin-bottom: 40px;
      text-shadow: 0 0 20px rgba(255, 85, 85, 0.8);
      letter-spacing: 4px;
      color: #f55;
    }
    
    .menu-options {
      display: flex;
      flex-direction: column;
      gap: 20px;
      width: 300px;
    }
    
    .menu-btn {
      padding: 15px 30px;
      background: linear-gradient(145deg, #332211, #221100);
      border: 2px solid #f55;
      color: #f55;
      font-size: 20px;
      text-align: center;
      cursor: pointer;
      border-radius: 10px;
      transition: all 0.3s ease;
    }
    
    .menu-btn:hover {
      background: linear-gradient(145deg, #443322, #332211);
      box-shadow: 0 0 20px rgba(255, 85, 85, 0.8);
      transform: translateY(-3px);
    }
    
    /* Console Messages */
    .console-message {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 10px 20px;
      border: 2px solid #f55;
      border-radius: 10px;
      color: #f55;
      font-size: 18px;
      opacity: 0;
      transition: opacity 0.5s ease;
      z-index: 25;
    }
    
    .console-message.active {
      opacity: 1;
    }
    
    /* Weapon Selector */
    .weapon-selector {
      position: fixed;
      bottom: 80px;
      right: 20px;
      display: flex;
      gap: 10px;
      z-index: 20;
    }
    
    .weapon-icon {
      width: 50px;
      height: 50px;
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid #555;
      border-radius: 5px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: #555;
      font-size: 12px;
      text-align: center;
    }
    
    .weapon-icon.active {
      border-color: #f55;
      color: #f55;
      box-shadow: 0 0 10px rgba(255, 85, 85, 0.8);
    }
    
    /* Flag Status */
    .flag-status {
      position: fixed;
      top: 120px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border: 2px solid #f55;
      border-radius: 5px;
      font-size: 14px;
      color: #f55;
      z-index: 20;
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      .game-title {
        font-size: 40px;
      }
      
      .menu-btn {
        padding: 12px 24px;
        font-size: 18px;
      }
      
      .health-bar, .armor-bar, .energy-bar {
        width: 150px;
      }
      
      .weapon-selector {
        bottom: 70px;
      }
      
      .weapon-icon {
        width: 40px;
        height: 40px;
        font-size: 10px;
      }
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    
    <!-- FPS HUD -->
    <div class="hud-container">
      <div class="health-armor-display">
        <div class="health-bar">
          <div class="health-fill" id="healthFill" style="width: 100%"></div>
        </div>
        <div class="armor-bar">
          <div class="armor-fill" id="armorFill" style="width: 100%"></div>
        </div>
        <div class="energy-bar">
          <div class="energy-fill" id="energyFill" style="width: 100%"></div>
        </div>
      </div>
      <div class="ammo-display">
        AMMO: <span id="ammoCount">200</span>/400
      </div>
    </div>
    
    <div class="weapon-display">
      WEAPON: <span id="weaponName">PLASMA GATLING</span>
    </div>
    
    <div class="weapon-selector">
      <div class="weapon-icon active" data-weapon="gatling">GATLING</div>
      <div class="weapon-icon" data-weapon="shotgun">SHOTGUN</div>
      <div class="weapon-icon" data-weapon="grenade">GRENADE</div>
    </div>
    
    <div class="team-score">
      <div class="team-blue">
        <div>BLUE TEAM</div>
        <div id="blueScore">0</div>
      </div>
      <div class="team-red">
        <div>RED TEAM</div>
        <div id="redScore">0</div>
      </div>
    </div>
    
    <div class="kill-feed" id="killFeed"></div>
    
    <div class="respawn-timer" id="respawnTimer">
      RESPAWNING IN: <span id="respawnCount">3</span>
    </div>
    
    <div class="performance-display" id="performanceDisplay">
      FPS: 0 | ENEMIES: 0
    </div>
    
    <div class="crosshair"></div>
    
    <!-- Flag Status -->
    <div class="flag-status" id="flagStatus">
      RED FLAG: AT BASE | BLUE FLAG: AT BASE
    </div>
    
    <!-- Console Messages -->
    <div class="console-message" id="consoleMessage"></div>
    
    <!-- Main Menu -->
    <div class="main-menu" id="mainMenu">
      <h1 class="game-title">GALAXYQUEST: RED VS BLUE</h1>
      <div class="menu-options">
        <div class="menu-btn" id="startBtn">JOIN BATTLE</div>
        <div class="menu-btn" id="settingsBtn">SETTINGS</div>
        <div class="menu-btn" id="quitBtn">QUIT</div>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
    // Game state and configuration
    const GameState = {
      MENU: 0,
      PLAYING: 1,
      COMBAT: 2,
      DEAD: 3
    };
    
    const Team = {
      BLUE: 0,
      RED: 1
    };
    
    const WeaponType = {
      GATLING: 0,
      SHOTGUN: 1,
      GRENADE: 2,
      ROCKET: 3
    };
    
    let currentState = GameState.MENU;
    let mouseSensitivity = 0.0025;
    let invertYAxis = false;
    
    // Initialize Three.js
    let scene, camera, renderer;
    let player, enemies = [], projectiles = [], bases = [], particles = [], flags = [];
    let clock = new THREE.Clock();
    let fps = 0;
    let frameCount = 0;
    let lastFpsUpdate = 0;
    
    // Player controls state
    const controls = {
      moveForward: false,
      moveBackward: false,
      moveLeft: false,
      moveRight: false,
      jump: false,
      jetpack: false,
      fire: false,
      altFire: false,
      isGrounded: false,
      tiltLeft: false,
      tiltRight: false,
      rollLeft: false,
      rollRight: false,
      capture: false
    };
    
    // Player stats - MAKE PLAYER INVINCIBLE
    const playerStats = {
      health: 10000,  // Very high health to make player effectively invincible
      armor: 10000,   // Very high armor to make player effectively invincible
      energy: 100,
      ammo: 200,
      maxAmmo: 400,
      kills: 0,
      deaths: 0,
      team: Team.BLUE,
      score: 0,
      respawnTime: 0,
      speed: 8.0,
      jetpackForce: 25.0,
      jumpForce: 10.0,
      gravity: 15.0,
      velocity: new THREE.Vector3(),
      weapon: 'PLASMA GATLING',
      weaponType: WeaponType.GATLING,
      weaponCooldown: 0,
      grenades: 3,
      rockets: 5,
      hasFlag: false,
      flag: null,
      tiltAngle: 0,
      rollAngle: 0
    };
    
    // Game stats
    const gameStats = {
      blueScore: 0,
      redScore: 0,
      enemyCount: 10,
      respawnDelay: 10.0,  // 10 second respawn as requested
      lastBlueDroneSpawn: 0,
      lastRedDroneSpawn: 0,
      droneRespawnTime: 10.0,
      redFlagAtBase: true,
      blueFlagAtBase: true,
      redFlagCarrier: null,
      blueFlagCarrier: null,
      winCondition: 100 // Score needed to win
    };
    
    // Initialize the game
    function init() {
      // Set up scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x220c0c);
      scene.fog = new THREE.Fog(0x331111, 50, 500);
      
      // Set up camera (first-person view)
      camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2, 0);
      
      // Set up renderer
      renderer = new THREE.WebGLRenderer({ 
        canvas: document.getElementById('gameCanvas'),
        antialias: true,
        powerPreference: "high-performance"
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      
      // Add lighting
      const ambientLight = new THREE.AmbientLight(0x774444);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffddcc, 1);
      directionalLight.position.set(50, 50, 50);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 1024;
      directionalLight.shadow.mapSize.height = 1024;
      scene.add(directionalLight);
      
      // Create terrain
      createTerrain();
      
      // Create bases
      createBases();
      
      // Create flags
      createFlags();
      
      // Create player
      createPlayer();
      
      // Create initial enemies
      spawnEnemies();
      
      // Set up event listeners
      setupEventListeners();
      
      // Start animation loop
      animate();
      
      // Show console message
      showConsoleMessage("GALAXYQUEST: RED VS BLUE initialized. Enhanced weapons and jetpacks enabled!");
    }
    
    // Create Mars terrain
    function createTerrain() {
      // Create a large ground plane with Mars-like colors
      const groundGeometry = new THREE.PlaneGeometry(500, 500, 20, 20);
      const groundMaterial = new THREE.MeshPhongMaterial({ 
        color: 0xaa5533,
        shininess: 10,
        wireframe: false
      });
      
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      ground.receiveShadow = true;
      scene.add(ground);
      
      // Add Mars mountains on the edges
      for (let i = 0; i < 30; i++) {
        const hillGeometry = new THREE.ConeGeometry(15 + Math.random() * 25, 10 + Math.random() * 20, 8);
        const hillMaterial = new THREE.MeshPhongMaterial({ 
          color: 0x8c3e2a,
          shininess: 15
        });
        
        const hill = new THREE.Mesh(hillGeometry, hillMaterial);
        
        // Position mountains mostly around the edges
        if (i < 10) {
          // North edge
          hill.position.set(Math.random() * 400 - 200, 0, -200 + Math.random() * 30);
        } else if (i < 20) {
          // South edge
          hill.position.set(Math.random() * 400 - 200, 0, 200 - Math.random() * 30);
        } else if (i < 25) {
          // East edge
          hill.position.set(200 - Math.random() * 30, 0, Math.random() * 400 - 200);
        } else {
          // West edge
          hill.position.set(-200 + Math.random() * 30, 0, Math.random() * 400 - 200);
        }
        
        hill.rotation.x = -Math.PI / 2;
        hill.position.y = hill.geometry.parameters.height / 2;
        hill.castShadow = true;
        hill.receiveShadow = true;
        scene.add(hill);
      }
      
      // Add some Mars rocks scattered around
      for (let i = 0; i < 50; i++) {
        const rockGeometry = new THREE.DodecahedronGeometry(1 + Math.random() * 3, 0);
        const rockMaterial = new THREE.MeshPhongMaterial({ 
          color: 0x7a5230,
          shininess: 20
        });
        
        const rock = new THREE.Mesh(rockGeometry, rockMaterial);
        rock.position.set(
          Math.random() * 400 - 200,
          1 + Math.random() * 2,
          Math.random() * 400 - 200
        );
        rock.castShadow = true;
        rock.receiveShadow = true;
        scene.add(rock);
      }
    }
    
    // Create Alamo-style bases for both teams
    function createBases() {
      // Blue base (Alamo style)
      const blueBaseGeometry = new THREE.BoxGeometry(30, 15, 40);
      const blueBaseMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x3355aa,
        emissive: 0x112244,
        shininess: 50
      });
      
      const blueBase = new THREE.Mesh(blueBaseGeometry, blueBaseMaterial);
      blueBase.position.set(-150, 7.5, 0);
      blueBase.castShadow = true;
      blueBase.receiveShadow = true;
      blueBase.team = Team.BLUE;
      // Make base non-collidable by not adding it to collision detection
      scene.add(blueBase);
      bases.push(blueBase);
      
      // Add Alamo-style facade to blue base
      const blueFacadeGeometry = new THREE.BoxGeometry(32, 10, 2);
      const blueFacade = new THREE.Mesh(blueFacadeGeometry, blueBaseMaterial);
      blueFacade.position.set(-150, 12, 21);
      scene.add(blueFacade);
      
      // Add entrance at the back
      const blueEntranceGeometry = new THREE.BoxGeometry(10, 8, 6);
      const blueEntranceMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x000000,
        emissive: 0x111111
      });
      
      const blueEntrance = new THREE.Mesh(blueEntranceGeometry, blueEntranceMaterial);
      blueEntrance.position.set(-150, 4, -21);
      scene.add(blueEntrance);
      
      // Add some structures to blue base (Alamo-style walls)
      const blueWallGeometry = new THREE.BoxGeometry(5, 8, 30);
      const blueWall1 = new THREE.Mesh(blueWallGeometry, blueBaseMaterial);
      blueWall1.position.set(-165, 4, 0);
      scene.add(blueWall1);
      
      const blueWall2 = new THREE.Mesh(blueWallGeometry, blueBaseMaterial);
      blueWall2.position.set(-135, 4, 0);
      scene.add(blueWall2);
      
      // Red base (Alamo style) - BRIGHT RED
      const redBaseGeometry = new THREE.BoxGeometry(30, 15, 40);
      const redBaseMaterial = new THREE.MeshPhongMaterial({ 
        color: 0xff0000,  // Bright red
        emissive: 0x990000,
        shininess: 50
      });
      
      const redBase = new THREE.Mesh(redBaseGeometry, redBaseMaterial);
      redBase.position.set(150, 7.5, 0);
      redBase.castShadow = true;
      redBase.receiveShadow = true;
      redBase.team = Team.RED;
      // Make base non-collidable by not adding it to collision detection
      scene.add(redBase);
      bases.push(redBase);
      
      // Add Alamo-style facade to red base
      const redFacadeGeometry = new THREE.BoxGeometry(32, 10, 2);
      const redFacade = new THREE.Mesh(redFacadeGeometry, redBaseMaterial);
      redFacade.position.set(150, 12, 21);
      scene.add(redFacade);
      
      // Add entrance at the back
      const redEntranceGeometry = new THREE.BoxGeometry(10, 8, 6);
      const redEntranceMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x000000,
        emissive: 0x111111
      });
      
      const redEntrance = new THREE.Mesh(redEntranceGeometry, redEntranceMaterial);
      redEntrance.position.set(150, 4, -21);
      scene.add(redEntrance);
      
      // Add some structures to red base (Alamo-style walls)
      const redWallGeometry = new THREE.BoxGeometry(5, 8, 30);
      const redWall1 = new THREE.Mesh(redWallGeometry, redBaseMaterial);
      redWall1.position.set(165, 4, 0);
      scene.add(redWall1);
      
      const redWall2 = new THREE.Mesh(redWallGeometry, redBaseMaterial);
      redWall2.position.set(135, 4, 0);
      scene.add(redWall2);
    }
    
    // Create flags for capture the flag mode
    function createFlags() {
      // Blue flag (at red base)
      const blueFlagGeometry = new THREE.BoxGeometry(2, 0.2, 4);
      const blueFlagMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x3355aa,
        emissive: 0x112244
      });
      
      const blueFlag = new THREE.Mesh(blueFlagGeometry, blueFlagMaterial);
      blueFlag.position.set(150, 2, 0);
      blueFlag.team = Team.BLUE;
      blueFlag.atBase = true;
      scene.add(blueFlag);
      flags.push(blueFlag);
      
      // Add flag pole
      const bluePoleGeometry = new THREE.CylinderGeometry(0.1, 0.1, 5, 8);
      const bluePoleMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
      const bluePole = new THREE.Mesh(bluePoleGeometry, bluePoleMaterial);
      bluePole.position.set(150, 2.5, 0);
      scene.add(bluePole);
      
      // Red flag (at blue base) - BRIGHT RED
      const redFlagGeometry = new THREE.BoxGeometry(2, 0.2, 4);
      const redFlagMaterial = new THREE.MeshPhongMaterial({ 
        color: 0xff0000,  // Bright red
        emissive: 0x990000
      });
      
      const redFlag = new THREE.Mesh(redFlagGeometry, redFlagMaterial);
      redFlag.position.set(-150, 2, 0);
      redFlag.team = Team.RED;
      redFlag.atBase = true;
      scene.add(redFlag);
      flags.push(redFlag);
      
      // Add flag pole
      const redPoleGeometry = new THREE.CylinderGeometry(0.1, 0.1, 5, 8);
      const redPoleMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
      const redPole = new THREE.Mesh(redPoleGeometry, redPoleMaterial);
      redPole.position.set(-150, 2.5, 0);
      scene.add(redPole);
    }
    
    // Create player
    function createPlayer() {
      // In first-person view, we don't need a visible player model
      // The camera represents the player's view
      player = new THREE.Object3D();
      player.position.set(-150, 5, 0);
      player.velocity = new THREE.Vector3();
      scene.add(player);
      
      // Add camera to player
      player.add(camera);
      camera.position.y = 1.7; // Eye height
    }
    
    // Spawn enemies
    function spawnEnemies() {
      // Create 9 blue drones (allies)
      for (let i = 0; i < 9; i++) {
        createFriendlyDrone(i);
      }
      
      // Create 10 red drones (enemies)
      for (let i = 0; i < 10; i++) {
        createEnemy(i);
      }
    }
    
    // Create a single enemy
    function createEnemy(id) {
      const enemyGeometry = new THREE.ConeGeometry(1.5, 3, 8);
      const enemyMaterial = new THREE.MeshPhongMaterial({ 
        color: 0xff0000,  // Bright red
        emissive: 0x990000
      });
      
      const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
      enemy.position.set(
        150 + Math.random() * 20 - 10,
        3,
        Math.random() * 40 - 20
      );
      enemy.rotation.order = 'YXZ';
      enemy.castShadow = true;
      enemy.receiveShadow = true;
      
      // Enemy properties - MAKE THEM ONE-SHOT KILLS
      enemy.health = 1;  // One-shot kills
      enemy.armor = 0;   // No armor
      enemy.team = Team.RED;
      enemy.id = id;
      enemy.speed = 8.0;  // Increased speed for more aggression
      enemy.fireCooldown = 0;
      enemy.target = null;
      enemy.state = 'assault';  // Start in assault mode
      enemy.lastStateChange = 0;
      enemy.isDrone = true;
      enemy.targetX = -150;  // Target blue base initially
      enemy.targetZ = 0;
      enemy.assaultMode = true;
      enemy.lastAttackTime = 0;
      
      scene.add(enemy);
      enemies.push(enemy);
    }
    
    // Create a friendly drone
    function createFriendlyDrone(id) {
      const droneGeometry = new THREE.ConeGeometry(1.5, 3, 8);
      const droneMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x3355aa,
        emissive: 0x112244
      });
      
      const drone = new THREE.Mesh(droneGeometry, droneMaterial);
      drone.position.set(
        -150 + Math.random() * 20 - 10,
        3,
        Math.random() * 40 - 20
      );
      drone.rotation.order = 'YXZ';
      drone.castShadow = true;
      drone.receiveShadow = true;
      
      // Drone properties - MAKE THEM ONE-SHOT KILLS
      drone.health = 1;  // One-shot kills
      drone.armor = 0;   // No armor
      drone.team = Team.BLUE;
      drone.id = id;
      drone.speed = 8.0;  // Increased speed for more aggression
      drone.fireCooldown = 0;
      drone.target = null;
      drone.state = 'assault';  // Start in assault mode
      drone.lastStateChange = 0;
      drone.isDrone = true;
      drone.targetX = 150;  // Target red base initially
      drone.targetZ = 0;
      drone.assaultMode = true;
      drone.lastAttackTime = 0;
      
      scene.add(drone);
      enemies.push(drone);
    }
    
    // Create a paintball projectile
    function createProjectile(position, velocity, team, isGrenade = false, isRocket = false) {
      // Paintball projectile
      const size = isRocket ? 1.0 : (isGrenade ? 1.0 : 0.4);
      const projectileGeometry = new THREE.SphereGeometry(size, 16, 16);
      const projectileMaterial = new THREE.MeshPhongMaterial({ 
        color: team === Team.BLUE ? 0x3355ff : 0xff0000,  // Bright red for red team
        emissive: team === Team.BLUE ? 0x002266 : 0x990000
      });
      
      const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
      projectile.position.copy(position);
      projectile.velocity = velocity.clone();
      projectile.team = team;
      projectile.damage = isRocket ? 500 : (isGrenade ? 200 : 1000); // Increased damage for one-shot kills
      projectile.isGrenade = isGrenade;
      projectile.isRocket = isRocket;
      projectile.lifetime = 0;
      projectile.maxLifetime = isRocket ? 5.0 : (isGrenade ? 3.0 : 2.0);
      
      // Make rockets larger
      if (isRocket) {
        projectile.scale.set(2, 2, 2);
      }
      
      scene.add(projectile);
      projectiles.push(projectile);
      
      return projectile;
    }
    
    // Create particle effect with performance optimization
    function createParticleEffect(position, color, count = 10, size = 0.5, lifetime = 1.0) {
      // Limit particle count for performance
      const actualCount = Math.min(count, 15);
      
      for (let i = 0; i < actualCount; i++) {
        const particleGeometry = new THREE.SphereGeometry(size, 8, 8);
        const particleMaterial = new THREE.MeshBasicMaterial({ 
          color: color,
          transparent: true,
          opacity: 0.8
        });
        
        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
        particle.position.copy(position);
        
        // Random velocity
        const angle1 = Math.random() * Math.PI * 2;
        const angle2 = Math.random() * Math.PI * 2;
        const speed = 5 + Math.random() * 10;
        
        particle.velocity = new THREE.Vector3(
          Math.sin(angle1) * Math.cos(angle2) * speed,
          Math.sin(angle1) * Math.sin(angle2) * speed,
          Math.cos(angle1) * speed
        );
        
        particle.lifetime = 0;
        particle.maxLifetime = lifetime;
        
        scene.add(particle);
        particles.push(particle);
      }
    }
    
    // Create muzzle flash
    function createMuzzleFlash(position, team) {
      const flashGeometry = new THREE.SphereGeometry(0.8, 16, 16);
      const flashMaterial = new THREE.MeshBasicMaterial({ 
        color: team === Team.BLUE ? 0x00ffff : 0xff5500,
        transparent: true,
        opacity: 0.9
      });
      
      const flash = new THREE.Mesh(flashGeometry, flashMaterial);
      flash.position.copy(position);
      flash.lifetime = 0;
      flash.maxLifetime = 0.1;
      
      scene.add(flash);
      particles.push(flash);
    }
    
    // Show a console message
    function showConsoleMessage(message, duration = 3000) {
      const consoleElement = document.getElementById('consoleMessage');
      consoleElement.textContent = message;
      consoleElement.classList.add('active');
      
      setTimeout(() => {
        consoleElement.classList.remove('active');
      }, duration);
    }
    
    // Update HUD elements
    function updateHUD() {
      // Update health, armor, and energy bars
      document.getElementById('healthFill').style.width = `${Math.max(0, playerStats.health)}%`;
      document.getElementById('armorFill').style.width = `${Math.max(0, playerStats.armor)}%`;
      document.getElementById('energyFill').style.width = `${Math.max(0, playerStats.energy)}%`;
      
      // Update ammo count
      document.getElementById('ammoCount').textContent = playerStats.ammo;
      
      // Update weapon name
      document.getElementById('weaponName').textContent = playerStats.weapon;
      
      // Update team scores
      document.getElementById('blueScore').textContent = gameStats.blueScore;
      document.getElementById('redScore').textContent = gameStats.redScore;
      
      // Update flag status
      let redFlagStatus = gameStats.redFlagAtBase ? "AT BASE" : "CAPTURED!";
      let blueFlagStatus = gameStats.blueFlagAtBase ? "AT BASE" : "CAPTURED!";
      document.getElementById('flagStatus').textContent = `RED FLAG: ${redFlagStatus} | BLUE FLAG: ${blueFlagStatus}`;
      
      // Update performance display
      if (clock.getElapsedTime() - lastFpsUpdate > 0.5) {
        document.getElementById('performanceDisplay').textContent = `FPS: ${Math.round(fps)} | ENEMIES: ${enemies.length}`;
        lastFpsUpdate = clock.getElapsedTime();
      }
      
      // Handle respawn timer
      if (currentState === GameState.DEAD) {
        const respawnElement = document.getElementById('respawnTimer');
        const respawnCountElement = document.getElementById('respawnCount');
        
        respawnElement.style.display = 'block';
        respawnCountElement.textContent = Math.ceil(playerStats.respawnTime);
      } else {
        document.getElementById('respawnTimer').style.display = 'none';
      }
    }
    
    // Add a kill event to the kill feed
    function addKillEvent(killer, victim, weapon) {
      const killFeed = document.getElementById('killFeed');
      const killEvent = document.createElement('div');
      killEvent.className = 'kill-event';
      
      const killerElement = document.createElement('span');
      killerElement.className = 'killer';
      killerElement.textContent = killer;
      
      const victimElement = document.createElement('span');
      victimElement.className = 'victim';
      victimElement.textContent = victim;
      
      const weaponElement = document.createElement('span');
      weaponElement.className = 'weapon';
      weaponElement.textContent = `[${weapon}]`;
      
      killEvent.appendChild(killerElement);
      killEvent.appendChild(document.createTextNode(' killed '));
      killEvent.appendChild(victimElement);
      killEvent.appendChild(document.createTextNode(' with '));
      killEvent.appendChild(weaponElement);
      
      killFeed.appendChild(killEvent);
      
      // Limit kill feed to 6 entries
      while (killFeed.children.length > 6) {
        killFeed.removeChild(killFeed.firstChild);
      }
      
      // Auto-scroll to bottom
      killFeed.scrollTop = killFeed.scrollHeight;
    }
    
    // Set up event listeners
    function setupEventListeners() {
      // Keyboard controls
      document.addEventListener('keydown', (e) => {
        switch (e.code) {
          case 'KeyW':
          case 'ArrowUp':
            controls.moveForward = true;
            break;
          case 'KeyS':
          case 'ArrowDown':
            controls.moveBackward = true;
            break;
          case 'KeyA':
          case 'ArrowLeft':
            controls.moveLeft = true;
            break;
          case 'KeyD':
          case 'ArrowRight':
            controls.moveRight = true;
            break;
          case 'Space':
            if (controls.isGrounded) {
              controls.jump = true;
            } else {
              controls.jetpack = true;
            }
            break;
          case 'ShiftLeft':
          case 'ShiftRight':
            controls.jetpack = true;
            break;
          case 'KeyQ':
            controls.tiltLeft = true;
            break;
          case 'KeyE':
            controls.tiltRight = true;
            break;
          case 'KeyZ':
            controls.rollLeft = true;
            break;
          case 'KeyC':
            controls.rollRight = true;
            break;
          case 'KeyF':
            controls.capture = true;
            break;
          case 'KeyR':
            // Reload weapon
            if (playerStats.ammo < playerStats.maxAmmo) {
              playerStats.ammo = playerStats.maxAmmo;
              showConsoleMessage("WEAPON RELOADED");
            }
            break;
          case 'Digit1':
            // Switch to gatling gun
            playerStats.weapon = 'PLASMA GATLING';
            playerStats.weaponType = WeaponType.GATLING;
            document.querySelectorAll('.weapon-icon').forEach(icon => icon.classList.remove('active'));
            document.querySelector('[data-weapon="gatling"]').classList.add('active');
            showConsoleMessage("SWITCHED TO PLASMA GATLING");
            break;
          case 'Digit2':
            // Switch to shotgun
            playerStats.weapon = 'SHOTGUN BIRDSHOT';
            playerStats.weaponType = WeaponType.SHOTGUN;
            document.querySelectorAll('.weapon-icon').forEach(icon => icon.classList.remove('active'));
            document.querySelector('[data-weapon="shotgun"]').classList.add('active');
            showConsoleMessage("SWITCHED TO SHOTGUN BIRDSHOT");
            break;
          case 'Digit3':
            // Switch to grenade launcher
            playerStats.weapon = 'PLASMA GRENADE';
            playerStats.weaponType = WeaponType.GRENADE;
            document.querySelectorAll('.weapon-icon').forEach(icon => icon.classList.remove('active'));
            document.querySelector('[data-weapon="grenade"]').classList.add('active');
            showConsoleMessage("SWITCHED TO PLASMA GRENADE");
            break;
        }
      });
      
      document.addEventListener('keyup', (e) => {
        switch (e.code) {
          case 'KeyW':
          case 'ArrowUp':
            controls.moveForward = false;
            break;
          case 'KeyS':
          case 'ArrowDown':
            controls.moveBackward = false;
            break;
          case 'KeyA':
          case 'ArrowLeft':
            controls.moveLeft = false;
            break;
          case 'KeyD':
          case 'ArrowRight':
            controls.moveRight = false;
            break;
          case 'Space':
            controls.jump = false;
            controls.jetpack = false;
            break;
          case 'ShiftLeft':
          case 'ShiftRight':
            controls.jetpack = false;
            break;
          case 'KeyQ':
            controls.tiltLeft = false;
            break;
          case 'KeyE':
            controls.tiltRight = false;
            break;
          case 'KeyZ':
            controls.rollLeft = false;
            break;
          case 'KeyC':
            controls.rollRight = false;
            break;
          case 'KeyF':
            controls.capture = false;
            break;
        }
      });
      
      // Mouse controls
      let isMouseLocked = false;
      
      document.addEventListener('click', () => {
        if (currentState === GameState.PLAYING || currentState === GameState.COMBAT) {
          if (!isMouseLocked) {
            document.body.requestPointerLock();
            isMouseLocked = true;
          }
        }
      });
      
      document.addEventListener('mousemove', (e) => {
        if (document.pointerLockElement === document.body && 
            (currentState === GameState.PLAYING || currentState === GameState.COMBAT)) {
          // Rotate player (left/right)
          player.rotation.y -= e.movementX * mouseSensitivity;
          
          // Rotate camera (up/down)
          const verticalSensitivity = invertYAxis ? -mouseSensitivity : mouseSensitivity;
          camera.rotation.x -= e.movementY * verticalSensitivity;
          
          // Limit camera vertical rotation
          camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
        }
      });
      
      // Mouse buttons
      document.addEventListener('mousedown', (e) => {
        if (currentState === GameState.PLAYING || currentState === GameState.COMBAT) {
          if (e.button === 0) { // Left click
            controls.fire = true;
          } else if (e.button === 2) { // Right click
            controls.altFire = true;
          }
        }
      });
      
      document.addEventListener('mouseup', (e) => {
        if (e.button === 0) {
          controls.fire = false;
        } else if (e.button === 2) {
          controls.altFire = false;
        }
      });
      
      // Prevent context menu
      document.addEventListener('contextmenu', (e) => e.preventDefault());
      
      // Window resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
      
      // Weapon selector buttons
      document.querySelectorAll('.weapon-icon').forEach(icon => {
        icon.addEventListener('click', () => {
          const weapon = icon.getAttribute('data-weapon');
          document.querySelectorAll('.weapon-icon').forEach(i => i.classList.remove('active'));
          icon.classList.add('active');
          
          switch (weapon) {
            case 'gatling':
              playerStats.weapon = 'PLASMA GATLING';
              playerStats.weaponType = WeaponType.GATLING;
              showConsoleMessage("SWITCHED TO PLASMA GATLING");
              break;
            case 'shotgun':
              playerStats.weapon = 'SHOTGUN BIRDSHOT';
              playerStats.weaponType = WeaponType.SHOTGUN;
              showConsoleMessage("SWITCHED TO SHOTGUN BIRDSHOT");
              break;
            case 'grenade':
              playerStats.weapon = 'PLASMA GRENADE';
              playerStats.weaponType = WeaponType.GRENADE;
              showConsoleMessage("SWITCHED TO PLASMA GRENADE");
              break;
          }
        });
      });
      
      // Menu buttons
      document.getElementById('startBtn').addEventListener('click', () => {
        document.getElementById('mainMenu').style.display = 'none';
        currentState = GameState.PLAYING;
        document.body.requestPointerLock();
      });
      
      document.getElementById('settingsBtn').addEventListener('click', () => {
        showConsoleMessage("SETTINGS NOT IMPLEMENTED IN DEMO");
      });
      
      document.getElementById('quitBtn').addEventListener('click', () => {
        showConsoleMessage("CANNOT QUIT - YOU ARE IN THE MATRIX");
      });
    }
    
    // Update player movement and physics
    function updatePlayer(deltaTime) {
      if (currentState === GameState.DEAD) {
        playerStats.respawnTime -= deltaTime;
        
        if (playerStats.respawnTime <= 0) {
          respawnPlayer();
        }
        
        return;
      }
      
      // Apply gravity
      playerStats.velocity.y -= playerStats.gravity * deltaTime;
      
      // Handle jetpack
      if (controls.jetpack && playerStats.energy > 0) {
        playerStats.velocity.y += playerStats.jetpackForce * deltaTime;
        playerStats.energy -= 20 * deltaTime;
        
        // Create jetpack particles
        if (Math.random() < 0.3) {
          const jetpackPos = new THREE.Vector3(
            player.position.x,
            player.position.y - 1,
            player.position.z
          );
          createParticleEffect(jetpackPos, 0x00ffff, 3, 0.3, 0.5);
        }
      }
      
      // Handle jump
      if (controls.jump && controls.isGrounded) {
        playerStats.velocity.y = playerStats.jumpForce;
        controls.isGrounded = false;
      }
      
      // Handle movement
      const moveSpeed = playerStats.speed * (controls.jetpack ? 1.5 : 1.0);
      const moveVector = new THREE.Vector3();
      
      if (controls.moveForward) {
        moveVector.z -= 1;
      }
      if (controls.moveBackward) {
        moveVector.z += 1;
      }
      if (controls.moveLeft) {
        moveVector.x -= 1;
      }
      if (controls.moveRight) {
        moveVector.x += 1;
      }
      
      // Normalize movement vector
      if (moveVector.length() > 0) {
        moveVector.normalize();
      }
      
      // Apply movement direction relative to player rotation
      moveVector.applyEuler(new THREE.Euler(0, player.rotation.y, 0));
      moveVector.multiplyScalar(moveSpeed);
      
      playerStats.velocity.x = moveVector.x;
      playerStats.velocity.z = moveVector.z;
      
      // Handle aircraft-style tilting
      const tiltSpeed = 2.0;
      if (controls.tiltLeft) {
        playerStats.tiltAngle += tiltSpeed * deltaTime;
      }
      if (controls.tiltRight) {
        playerStats.tiltAngle -= tiltSpeed * deltaTime;
      }
      
      // Handle rolling
      const rollSpeed = 2.0;
      if (controls.rollLeft) {
        playerStats.rollAngle += rollSpeed * deltaTime;
      }
      if (controls.rollRight) {
        playerStats.rollAngle -= rollSpeed * deltaTime;
      }
      
      // Apply tilt and roll to player rotation
      player.rotation.z = THREE.MathUtils.lerp(player.rotation.z, playerStats.tiltAngle, 5 * deltaTime);
      player.rotation.x = THREE.MathUtils.lerp(player.rotation.x, playerStats.rollAngle, 5 * deltaTime);
      
      // Apply damping to tilt and roll
      playerStats.tiltAngle = THREE.MathUtils.lerp(playerStats.tiltAngle, 0, 2 * deltaTime);
      playerStats.rollAngle = THREE.MathUtils.lerp(playerStats.rollAngle, 0, 2 * deltaTime);
      
      // Update player position
      player.position.x += playerStats.velocity.x * deltaTime;
      player.position.y += playerStats.velocity.y * deltaTime;
      player.position.z += playerStats.velocity.z * deltaTime;
      
      // Keep player within bounds
      player.position.x = THREE.MathUtils.clamp(player.position.x, -240, 240);
      player.position.z = THREE.MathUtils.clamp(player.position.z, -240, 240);
      
      // Ground collision
      if (player.position.y < 1.7) {
        player.position.y = 1.7;
        playerStats.velocity.y = 0;
        controls.isGrounded = true;
        
        // Reset energy when on ground
        playerStats.energy = Math.min(100, playerStats.energy + 10 * deltaTime);
      }
      
      // Ceiling collision
      if (player.position.y > 50) {
        player.position.y = 50;
        playerStats.velocity.y = 0;
      }
      
      // Handle weapon firing
      if (playerStats.weaponCooldown > 0) {
        playerStats.weaponCooldown -= deltaTime;
      }
      
      if (controls.fire && playerStats.weaponCooldown <= 0 && playerStats.ammo > 0) {
        fireWeapon();
      }
      
      // Handle flag capture
      if (controls.capture) {
        tryCaptureFlag();
      }
      
      // Regenerate energy
      if (!controls.jetpack) {
        playerStats.energy = Math.min(100, playerStats.energy + 5 * deltaTime);
      }
    }
    
    // Fire the current weapon
    function fireWeapon() {
      // Calculate initial position and direction
      const position = new THREE.Vector3();
      position.setFromMatrixPosition(camera.matrixWorld);
      
      const direction = new THREE.Vector3(0, 0, -1);
      direction.applyQuaternion(camera.quaternion);
      
      // Add some randomness to spread
      const spread = playerStats.weaponType === WeaponType.SHOTGUN ? 0.2 : 0.05;
      direction.x += (Math.random() - 0.5) * spread;
      direction.y += (Math.random() - 0.5) * spread;
      direction.z += (Math.random() - 0.5) * spread;
      direction.normalize();
      
      // Create muzzle flash
      createMuzzleFlash(position, playerStats.team);
      
      // Create projectile based on weapon type
      switch (playerStats.weaponType) {
        case WeaponType.GATLING:
          // Gatling gun - single projectile
          const velocity = direction.clone().multiplyScalar(100);
          createProjectile(position, velocity, playerStats.team);
          playerStats.weaponCooldown = 0.1;
          playerStats.ammo--;
          break;
          
        case WeaponType.SHOTGUN:
          // Shotgun - multiple projectiles
          for (let i = 0; i < 8; i++) {
            const shotDirection = direction.clone();
            shotDirection.x += (Math.random() - 0.5) * 0.3;
            shotDirection.y += (Math.random() - 0.5) * 0.3;
            shotDirection.z += (Math.random() - 0.5) * 0.3;
            shotDirection.normalize();
            
            const shotVelocity = shotDirection.clone().multiplyScalar(80);
            createProjectile(position, shotVelocity, playerStats.team);
          }
          playerStats.weaponCooldown = 0.8;
          playerStats.ammo -= 5;
          break;
          
        case WeaponType.GRENADE:
          // Grenade launcher - slower projectile with arc
          const grenadeVelocity = direction.clone().multiplyScalar(40);
          createProjectile(position, grenadeVelocity, playerStats.team, true);
          playerStats.weaponCooldown = 1.5;
          playerStats.ammo -= 10;
          break;
      }
      
      // Apply recoil
      camera.rotation.x += (Math.random() * 0.05) - 0.025;
    }
    
    // Try to capture the enemy flag
    function tryCaptureFlag() {
      // Check if player is at enemy base and flag is there
      if (playerStats.team === Team.BLUE) {
        // Blue player at red base
        const distToRedBase = player.position.distanceTo(new THREE.Vector3(150, 0, 0));
        if (distToRedBase < 30 && gameStats.redFlagAtBase) {
          // Capture red flag
          gameStats.redFlagAtBase = false;
          playerStats.hasFlag = true;
          
          // Find and hide the red flag
          const redFlag = flags.find(flag => flag.team === Team.RED);
          if (redFlag) {
            redFlag.visible = false;
            playerStats.flag = redFlag;
          }
          
          showConsoleMessage("BLUE CAPTURED RED FLAG!");
        }
        
        // Blue player at blue base with red flag
        const distToBlueBase = player.position.distanceTo(new THREE.Vector3(-150, 0, 0));
        if (distToBlueBase < 30 && playerStats.hasFlag && !gameStats.redFlagAtBase) {
          // Score point
          gameStats.blueScore++;
          playerStats.score += 10;
          playerStats.hasFlag = false;
          gameStats.redFlagAtBase = true;
          
          // Show the red flag again
          if (playerStats.flag) {
            playerStats.flag.visible = true;
            playerStats.flag = null;
          }
          
          showConsoleMessage("BLUE SCORED!");
        }
      }
    }
    
    // Respawn player
    function respawnPlayer() {
      playerStats.health = 10000;  // Very high health
      playerStats.armor = 10000;   // Very high armor
      playerStats.energy = 100;
      playerStats.ammo = playerStats.maxAmmo;
      
      // Reset position based on team
      if (playerStats.team === Team.BLUE) {
        player.position.set(-150, 5, 0);
      } else {
        player.position.set(150, 5, 0);
      }
      
      playerStats.velocity.set(0, 0, 0);
      currentState = GameState.PLAYING;
      
      showConsoleMessage("RESPAWNED");
    }
    
    // Update enemies
    function updateEnemies(deltaTime) {
      for (let i = 0; i < enemies.length; i++) {
        const enemy = enemies[i];
        
        // Skip if dead
        if (enemy.health <= 0) continue;
        
        // Update fire cooldown
        if (enemy.fireCooldown > 0) {
          enemy.fireCooldown -= deltaTime;
        }
        
        // Handle enemy AI states
        if (enemy.state === 'assault') {
          // Move toward enemy base
          let targetX, targetZ;
          
          if (enemy.team === Team.BLUE) {
            // Blue drones assault red base
            targetX = 150;
            targetZ = 0;
          } else {
            // Red drones assault blue base
            targetX = -150;
            targetZ = 0;
          }
          
          // Move toward target
          const dx = targetX - enemy.position.x;
          const dz = targetZ - enemy.position.z;
          const distance = Math.sqrt(dx * dx + dz * dz);
          
          if (distance > 5) {
            // Normalize direction and apply speed
            const speed = enemy.speed * deltaTime;
            enemy.position.x += (dx / distance) * speed;
            enemy.position.z += (dz / distance) * speed;
            
            // Face movement direction
            enemy.rotation.y = Math.atan2(dx, dz);
          } else {
            // At target, switch to combat mode
            enemy.state = 'combat';
            enemy.lastStateChange = clock.getElapsedTime();
          }
        } else if (enemy.state === 'combat') {
          // Look for targets
          let closestTarget = null;
          let closestDistance = Infinity;
          
          for (let j = 0; j < enemies.length; j++) {
            const target = enemies[j];
            
            // Skip self, dead targets, and same team
            if (i === j || target.health <= 0 || target.team === enemy.team) continue;
            
            const distance = enemy.position.distanceTo(target.position);
            if (distance < closestDistance) {
              closestDistance = distance;
              closestTarget = target;
            }
          }
          
          // Also consider player as target if not on the same team
          if (playerStats.team !== enemy.team && currentState !== GameState.DEAD) {
            const distanceToPlayer = enemy.position.distanceTo(player.position);
            if (distanceToPlayer < closestDistance) {
              closestDistance = distanceToPlayer;
              closestTarget = player;
            }
          }
          
          if (closestTarget && closestDistance < 50) {
            // Face target
            const dx = closestTarget.position.x - enemy.position.x;
            const dz = closestTarget.position.z - enemy.position.z;
            enemy.rotation.y = Math.atan2(dx, dz);
            
            // Move toward target
            if (closestDistance > 10) {
              const speed = enemy.speed * deltaTime;
              enemy.position.x += (dx / closestDistance) * speed;
              enemy.position.z += (dz / closestDistance) * speed;
            }
            
            // Fire at target
            if (enemy.fireCooldown <= 0 && closestDistance < 30) {
              const direction = new THREE.Vector3(
                closestTarget.position.x - enemy.position.x,
                closestTarget.position.y - enemy.position.y,
                closestTarget.position.z - enemy.position.z
              ).normalize();
              
              const velocity = direction.multiplyScalar(80);
              createProjectile(enemy.position.clone(), velocity, enemy.team);
              enemy.fireCooldown = 1.0;
            }
          } else {
            // No targets found, switch back to assault mode
            enemy.state = 'assault';
          }
        }
        
        // Keep enemy above ground
        if (enemy.position.y < 3) {
          enemy.position.y = 3;
        }
      }
    }
    
    // Update projectiles
    function updateProjectiles(deltaTime) {
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const projectile = projectiles[i];
        
        // Update position
        projectile.position.x += projectile.velocity.x * deltaTime;
        projectile.position.y += projectile.velocity.y * deltaTime;
        projectile.position.z += projectile.velocity.z * deltaTime;
        
        // Apply gravity to grenades
        if (projectile.isGrenade) {
          projectile.velocity.y -= playerStats.gravity * deltaTime;
        }
        
        // Update lifetime
        projectile.lifetime += deltaTime;
        if (projectile.lifetime >= projectile.maxLifetime) {
          // Remove old projectiles
          scene.remove(projectile);
          projectiles.splice(i, 1);
          continue;
        }
        
        // Check for collisions with enemies
        for (let j = enemies.length - 1; j >= 0; j--) {
          const enemy = enemies[j];
          
          // Skip dead enemies and same team
          if (enemy.health <= 0 || enemy.team === projectile.team) continue;
          
          // Check collision
          const distance = projectile.position.distanceTo(enemy.position);
          if (distance < 3) {
            // Hit enemy
            enemy.health -= projectile.damage;
            
            // Create hit effect
            createParticleEffect(
              projectile.position.clone(),
              projectile.team === Team.BLUE ? 0x3355ff : 0xff0000,
              10,
              0.5,
              1.0
            );
            
            // Remove projectile
            scene.remove(projectile);
            projectiles.splice(i, 1);
            
            // Check if enemy died
            if (enemy.health <= 0) {
              // Create death effect
              createParticleEffect(
                enemy.position.clone(),
                enemy.team === Team.BLUE ? 0x3355ff : 0xff0000,
                20,
                0.7,
                2.0
              );
              
              // Remove enemy
              scene.remove(enemy);
              enemies.splice(j, 1);
              
              // Add kill event if player killed the enemy
              if (projectile.team === playerStats.team) {
                playerStats.kills++;
                
                const killerName = projectile.team === Team.BLUE ? "BLUE DRONE" : "RED DRONE";
                const victimName = enemy.team === Team.BLUE ? "BLUE DRONE" : "RED DRONE";
                addKillEvent(killerName, victimName, playerStats.weapon);
                
                // Respawn enemy after delay
                setTimeout(() => {
                  if (enemy.team === Team.BLUE) {
                    createFriendlyDrone(enemy.id);
                  } else {
                    createEnemy(enemy.id);
                  }
                }, gameStats.respawnDelay * 1000);
              }
            }
            
            break;
          }
        }
        
        // Check for collision with player
        if (projectile.team !== playerStats.team && currentState !== GameState.DEAD) {
          const distance = projectile.position.distanceTo(player.position);
          if (distance < 2) {
            // Hit player - but player is invincible so just show effect
            createParticleEffect(
              projectile.position.clone(),
              projectile.team === Team.BLUE ? 0x3355ff : 0xff0000,
              10,
              0.5,
              1.0
            );
            
            // Remove projectile
            scene.remove(projectile);
            projectiles.splice(i, 1);
          }
        }
        
        // Check for collision with terrain or structures
        if (projectile.position.y < 1) {
          // Hit ground
          createParticleEffect(
            projectile.position.clone(),
            projectile.team === Team.BLUE ? 0x3355ff : 0xff0000,
            projectile.isGrenade ? 20 : 10,
            projectile.isGrenade ? 1.0 : 0.5,
            projectile.isGrenade ? 2.0 : 1.0
          );
          
          // Remove projectile
          scene.remove(projectile);
          projectiles.splice(i, 1);
        }
      }
    }
    
    // Update particles
    function updateParticles(deltaTime) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        
        // Update position
        particle.position.x += particle.velocity.x * deltaTime;
        particle.position.y += particle.velocity.y * deltaTime;
        particle.position.z += particle.velocity.z * deltaTime;
        
        // Apply gravity
        particle.velocity.y -= playerStats.gravity * deltaTime;
        
        // Update lifetime
        particle.lifetime += deltaTime;
        
        // Fade out
        if (particle.material.opacity) {
          particle.material.opacity = 0.8 * (1 - particle.lifetime / particle.maxLifetime);
        }
        
        // Remove old particles
        if (particle.lifetime >= particle.maxLifetime) {
          scene.remove(particle);
          particles.splice(i, 1);
        }
      }
    }
    
    // Check win condition
    function checkWinCondition() {
      if (gameStats.blueScore >= gameStats.winCondition) {
        showConsoleMessage("BLUE TEAM WINS!", 5000);
        // Reset scores
        gameStats.blueScore = 0;
        gameStats.redScore = 0;
      } else if (gameStats.redScore >= gameStats.winCondition) {
        showConsoleMessage("RED TEAM WINS!", 5000);
        // Reset scores
        gameStats.blueScore = 0;
        gameStats.redScore = 0;
      }
    }
    
    // Main game loop
    function animate() {
      requestAnimationFrame(animate);
      
      // Calculate delta time
      const deltaTime = Math.min(0.05, clock.getDelta());
      frameCount++;
      
      // Update FPS counter every second
      if (clock.getElapsedTime() - lastFpsUpdate > 1.0) {
        fps = frameCount / (clock.getElapsedTime() - lastFpsUpdate);
        frameCount = 0;
        lastFpsUpdate = clock.getElapsedTime();
      }
      
      // Update game state
      if (currentState === GameState.PLAYING || currentState === GameState.COMBAT || currentState === GameState.DEAD) {
        updatePlayer(deltaTime);
        updateEnemies(deltaTime);
        updateProjectiles(deltaTime);
        updateParticles(deltaTime);
        updateHUD();
        checkWinCondition();
      }
      
      // Render scene
      renderer.render(scene, camera);
    }
    
    // Start the game
    window.onload = init;
  </script>
</body>
</html>