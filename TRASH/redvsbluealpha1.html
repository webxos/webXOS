<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>GALAXYQUEST: RED VS BLUE | Paintball Combat</title>
  <meta name="description" content="Experience GALAXYQUEST: RED VS BLUE - a fast-paced paintball battle on Mars with Alamo-style bases.">
  <meta name="keywords" content="GalaxyQuest, Red vs Blue, paintball, Mars, team combat, jetpack">
  <meta name="author" content="WebXOS">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Orbitron', 'Courier New', monospace;
    }
    body {
      background: #000;
      color: #f55;
      height: 100vh;
      overflow: hidden;
      touch-action: none;
    }
    #gameCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }
    
    /* FPS HUD Elements */
    .hud-container {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 20;
    }
    
    .health-armor-display {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
    }
    
    .health-bar, .armor-bar, .energy-bar {
      width: 200px;
      height: 20px;
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid #f55;
      border-radius: 5px;
      overflow: hidden;
    }
    
    .health-fill {
      height: 100%;
      background: linear-gradient(90deg, #f00, #ff3300);
      transition: width 0.3s ease;
    }
    
    .armor-fill {
      height: 100%;
      background: linear-gradient(90deg, #f55, #f33);
      transition: width 0.3s ease;
    }
    
    .energy-fill {
      height: 100%;
      background: linear-gradient(90deg, #0f0, #0a0);
      transition: width 0.3s ease;
    }
    
    .ammo-display {
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border: 2px solid #f55;
      border-radius: 5px;
      font-size: 18px;
      color: #f55;
    }
    
    .weapon-display {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border: 2px solid #f55;
      border-radius: 5px;
      font-size: 18px;
      color: #f55;
      text-align: right;
      z-index: 20;
    }
    
    .team-score {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 50px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 20px;
      border: 2px solid #f55;
      border-radius: 5px;
      font-size: 18px;
      color: #f55;
      z-index: 20;
    }
    
    .team-blue, .team-red {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .team-blue { color: #55f; }
    .team-red { color: #f55; }
    
    .kill-feed {
      position: fixed;
      top: 80px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border: 2px solid #f55;
      border-radius: 5px;
      font-size: 14px;
      color: #fff;
      z-index: 20;
      display: flex;
      flex-direction: column;
      gap: 5px;
      max-height: 200px;
      overflow-y: auto;
    }
    
    .kill-event {
      display: flex;
      gap: 10px;
    }
    
    .kill-event .killer {
      color: #55f;
    }
    
    .kill-event .victim {
      color: #f55;
    }
    
    .respawn-timer {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      padding: 30px;
      border: 4px solid #f00;
      border-radius: 10px;
      font-size: 36px;
      color: #f00;
      z-index: 100;
      text-align: center;
      display: none;
    }
    
    .performance-display {
      position: fixed;
      top: 20px;
      right: 20px;
      color: #f00;
      font-size: 14px;
      z-index: 20;
      background: rgba(0, 0, 0, 0.7);
      padding: 5px 10px;
      border-radius: 5px;
    }
    
    /* Crosshair */
    .crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      z-index: 10;
      pointer-events: none;
    }
    
    .crosshair::before, .crosshair::after {
      content: '';
      position: absolute;
      background: #0f0;
    }
    
    .crosshair::before {
      top: 50%;
      left: 0;
      width: 100%;
      height: 2px;
      transform: translateY(-50%);
    }
    
    .crosshair::after {
      left: 50%;
      top: 0;
      height: 100%;
      width: 2px;
      transform: translateX(-50%);
    }
    
    /* Main Menu */
    .main-menu {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(20, 10, 0, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      color: #f55;
    }
    
    .game-title {
      font-size: 60px;
      margin-bottom: 40px;
      text-shadow: 0 0 20px rgba(255, 85, 85, 0.8);
      letter-spacing: 4px;
      color: #f55;
    }
    
    .menu-options {
      display: flex;
      flex-direction: column;
      gap: 20px;
      width: 300px;
    }
    
    .menu-btn {
      padding: 15px 30px;
      background: linear-gradient(145deg, #332211, #221100);
      border: 2px solid #f55;
      color: #f55;
      font-size: 20px;
      text-align: center;
      cursor: pointer;
      border-radius: 10px;
      transition: all 0.3s ease;
    }
    
    .menu-btn:hover {
      background: linear-gradient(145deg, #443322, #332211);
      box-shadow: 0 0 20px rgba(255, 85, 85, 0.8);
      transform: translateY(-3px);
    }
    
    /* Console Messages */
    .console-message {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 10px 20px;
      border: 2px solid #f55;
      border-radius: 10px;
      color: #f55;
      font-size: 18px;
      opacity: 0;
      transition: opacity 0.5s ease;
      z-index: 25;
    }
    
    .console-message.active {
      opacity: 1;
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      .game-title {
        font-size: 40px;
      }
      
      .menu-btn {
        padding: 12px 24px;
        font-size: 18px;
      }
      
      .health-bar, .armor-bar, .energy-bar {
        width: 150px;
      }
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    
    <!-- FPS HUD -->
    <div class="hud-container">
      <div class="health-armor-display">
        <div class="health-bar">
          <div class="health-fill" id="healthFill" style="width: 100%"></div>
        </div>
        <div class="armor-bar">
          <div class="armor-fill" id="armorFill" style="width: 100%"></div>
        </div>
        <div class="energy-bar">
          <div class="energy-fill" id="energyFill" style="width: 100%"></div>
        </div>
      </div>
      <div class="ammo-display">
        AMMO: <span id="ammoCount">200</span>/400
      </div>
    </div>
    
    <div class="weapon-display">
      WEAPON: <span id="weaponName">NERF GATLING</span>
    </div>
    
    <div class="team-score">
      <div class="team-blue">
        <div>BLUE TEAM</div>
        <div id="blueScore">0</div>
      </div>
      <div class="team-red">
        <div>RED TEAM</div>
        <div id="redScore">0</div>
      </div>
    </div>
    
    <div class="kill-feed" id="killFeed"></div>
    
    <div class="respawn-timer" id="respawnTimer">
      RESPAWNING IN: <span id="respawnCount">3</span>
    </div>
    
    <div class="performance-display" id="performanceDisplay">
      FPS: 0 | ENEMIES: 0
    </div>
    
    <div class="crosshair"></div>
    
    <!-- Console Messages -->
    <div class="console-message" id="consoleMessage"></div>
    
    <!-- Main Menu -->
    <div class="main-menu" id="mainMenu">
      <h1 class="game-title">GALAXYQUEST: RED VS BLUE</h1>
      <div class="menu-options">
        <div class="menu-btn" id="startBtn">JOIN BATTLE</div>
        <div class="menu-btn" id="settingsBtn">SETTINGS</div>
        <div class="menu-btn" id="quitBtn">QUIT</div>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
    // Game state and configuration
    const GameState = {
      MENU: 0,
      PLAYING: 1,
      COMBAT: 2,
      DEAD: 3
    };
    
    const Team = {
      BLUE: 0,
      RED: 1
    };
    
    let currentState = GameState.MENU;
    let mouseSensitivity = 0.0025;
    let invertYAxis = false;
    let scaleFactor = 0.7; // Scale factor for smaller level
    
    // Initialize Three.js
    let scene, camera, renderer;
    let player, enemies = [], projectiles = [], bases = [];
    let clock = new THREE.Clock();
    let fps = 0;
    let frameCount = 0;
    let lastFpsUpdate = 0;
    
    // Player controls state
    const controls = {
      moveForward: false,
      moveBackward: false,
      moveLeft: false,
      moveRight: false,
      jump: false,
      jetpack: false,
      fire: false,
      isGrounded: false
    };
    
    // Player stats
    const playerStats = {
      health: 100,
      armor: 100,
      energy: 100,
      ammo: 200,
      maxAmmo: 400,
      kills: 0,
      deaths: 0,
      team: Team.BLUE,
      score: 0,
      respawnTime: 0,
      speed: 8.0,
      jetpackForce: 25.0,
      jumpForce: 10.0,
      gravity: 15.0,
      velocity: new THREE.Vector3(),
      weapon: 'NERF GATLING',
      weaponCooldown: 0
    };
    
    // Game stats
    const gameStats = {
      blueScore: 0,
      redScore: 0,
      enemyCount: 10,
      respawnDelay: 3.0
    };
    
    // Initialize the game
    function init() {
      // Set up scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x220c0c);
      scene.fog = new THREE.Fog(0x331111, 50, 500);
      
      // Set up camera (first-person view)
      camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2, 0);
      
      // Set up renderer
      renderer = new THREE.WebGLRenderer({ 
        canvas: document.getElementById('gameCanvas'),
        antialias: true,
        powerPreference: "high-performance"
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      
      // Add lighting
      const ambientLight = new THREE.AmbientLight(0x774444);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffddcc, 1);
      directionalLight.position.set(50, 50, 50);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 1024;
      directionalLight.shadow.mapSize.height = 1024;
      scene.add(directionalLight);
      
      // Create terrain
      createTerrain();
      
      // Create bases
      createBases();
      
      // Create player
      createPlayer();
      
      // Create initial enemies
      spawnEnemies();
      
      // Set up event listeners
      setupEventListeners();
      
      // Start animation loop
      animate();
      
      // Show console message
      showConsoleMessage("GALAXYQUEST: RED VS BLUE initialized. Join the paintball battle!");
    }
    
    // Create Mars terrain
    function createTerrain() {
      // Create a smaller ground plane
      const groundSize = 300 * scaleFactor;
      const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize, 20, 20);
      const groundMaterial = new THREE.MeshPhongMaterial({ 
        color: 0xaa5533,
        shininess: 10,
        wireframe: false
      });
      
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      ground.receiveShadow = true;
      scene.add(ground);
      
      // Add Mars mountains on the edges (scaled down)
      for (let i = 0; i < 20; i++) {
        const hillGeometry = new THREE.ConeGeometry(
          10 + Math.random() * 15 * scaleFactor, 
          8 + Math.random() * 15 * scaleFactor, 
          8
        );
        const hillMaterial = new THREE.MeshPhongMaterial({ 
          color: 0x8c3e2a,
          shininess: 15
        });
        
        const hill = new THREE.Mesh(hillGeometry, hillMaterial);
        
        // Position mountains around the edges
        const edgePos = groundSize / 2 - 15;
        if (i < 5) {
          // North edge
          hill.position.set(Math.random() * groundSize - groundSize/2, 0, -edgePos + Math.random() * 20);
        } else if (i < 10) {
          // South edge
          hill.position.set(Math.random() * groundSize - groundSize/2, 0, edgePos - Math.random() * 20);
        } else if (i < 15) {
          // East edge
          hill.position.set(edgePos - Math.random() * 20, 0, Math.random() * groundSize - groundSize/2);
        } else {
          // West edge
          hill.position.set(-edgePos + Math.random() * 20, 0, Math.random() * groundSize - groundSize/2);
        }
        
        hill.rotation.x = -Math.PI / 2;
        hill.position.y = hill.geometry.parameters.height / 2;
        hill.castShadow = true;
        hill.receiveShadow = true;
        scene.add(hill);
      }
      
      // Add some Mars rocks scattered around (scaled down)
      for (let i = 0; i < 30; i++) {
        const rockGeometry = new THREE.DodecahedronGeometry(1 + Math.random() * 2 * scaleFactor, 0);
        const rockMaterial = new THREE.MeshPhongMaterial({ 
          color: 0x7a5230,
          shininess: 20
        });
        
        const rock = new THREE.Mesh(rockGeometry, rockMaterial);
        rock.position.set(
          Math.random() * groundSize - groundSize/2,
          1 + Math.random() * 2,
          Math.random() * groundSize - groundSize/2
        );
        rock.castShadow = true;
        rock.receiveShadow = true;
        scene.add(rock);
      }
    }
    
    // Create Alamo-style bases for both teams
    function createBases() {
      const baseSize = 0.8 * scaleFactor; // Scale down bases
      
      // Blue base (Alamo style)
      const blueBaseGeometry = new THREE.BoxGeometry(30 * baseSize, 15 * baseSize, 40 * baseSize);
      const blueBaseMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x3355aa,
        emissive: 0x112244,
        shininess: 50
      });
      
      const blueBase = new THREE.Mesh(blueBaseGeometry, blueBaseMaterial);
      blueBase.position.set(-100 * scaleFactor, 7.5 * baseSize, 0);
      blueBase.castShadow = true;
      blueBase.receiveShadow = true;
      blueBase.team = Team.BLUE;
      scene.add(blueBase);
      bases.push(blueBase);
      
      // Add Alamo-style facade to blue base
      const blueFacadeGeometry = new THREE.BoxGeometry(32 * baseSize, 10 * baseSize, 2 * baseSize);
      const blueFacade = new THREE.Mesh(blueFacadeGeometry, blueBaseMaterial);
      blueFacade.position.set(-100 * scaleFactor, 12 * baseSize, 21 * baseSize);
      scene.add(blueFacade);
      
      // Add entrance at the back
      const blueEntranceGeometry = new THREE.BoxGeometry(10 * baseSize, 8 * baseSize, 6 * baseSize);
      const blueEntranceMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x000000,
        emissive: 0x111111
      });
      
      const blueEntrance = new THREE.Mesh(blueEntranceGeometry, blueEntranceMaterial);
      blueEntrance.position.set(-100 * scaleFactor, 4 * baseSize, -21 * baseSize);
      scene.add(blueEntrance);
      
      // Add some structures to blue base (Alamo-style walls)
      const blueWallGeometry = new THREE.BoxGeometry(5 * baseSize, 8 * baseSize, 30 * baseSize);
      const blueWall1 = new THREE.Mesh(blueWallGeometry, blueBaseMaterial);
      blueWall1.position.set(-115 * scaleFactor, 4 * baseSize, 0);
      scene.add(blueWall1);
      
      const blueWall2 = new THREE.Mesh(blueWallGeometry, blueBaseMaterial);
      blueWall2.position.set(-85 * scaleFactor, 4 * baseSize, 0);
      scene.add(blueWall2);
      
      // Red base (Alamo style)
      const redBaseGeometry = new THREE.BoxGeometry(30 * baseSize, 15 * baseSize, 40 * baseSize);
      const redBaseMaterial = new THREE.MeshPhongMaterial({ 
        color: 0xaa5533,
        emissive: 0x442211,
        shininess: 50
      });
      
      const redBase = new THREE.Mesh(redBaseGeometry, redBaseMaterial);
      redBase.position.set(100 * scaleFactor, 7.5 * baseSize, 0);
      redBase.castShadow = true;
      redBase.receiveShadow = true;
      redBase.team = Team.RED;
      scene.add(redBase);
      bases.push(redBase);
      
      // Add Alamo-style facade to red base
      const redFacadeGeometry = new THREE.BoxGeometry(32 * baseSize, 10 * baseSize, 2 * baseSize);
      const redFacade = new THREE.Mesh(redFacadeGeometry, redBaseMaterial);
      redFacade.position.set(100 * scaleFactor, 12 * baseSize, 21 * baseSize);
      scene.add(redFacade);
      
      // Add entrance at the back
      const redEntranceGeometry = new THREE.BoxGeometry(10 * baseSize, 8 * baseSize, 6 * baseSize);
      const redEntranceMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x000000,
        emissive: 0x111111
      });
      
      const redEntrance = new THREE.Mesh(redEntranceGeometry, redEntranceMaterial);
      redEntrance.position.set(100 * scaleFactor, 4 * baseSize, -21 * baseSize);
      scene.add(redEntrance);
      
      // Add some structures to red base (Alamo-style walls)
      const redWallGeometry = new THREE.BoxGeometry(5 * baseSize, 8 * baseSize, 30 * baseSize);
      const redWall1 = new THREE.Mesh(redWallGeometry, redBaseMaterial);
      redWall1.position.set(115 * scaleFactor, 4 * baseSize, 0);
      scene.add(redWall1);
      
      const redWall2 = new THREE.Mesh(redWallGeometry, redBaseMaterial);
      redWall2.position.set(85 * scaleFactor, 4 * baseSize, 0);
      scene.add(redWall2);
      
      // Add flags
      createFlag(-100 * scaleFactor, 22 * baseSize, 21 * baseSize, Team.BLUE);
      createFlag(100 * scaleFactor, 22 * baseSize, 21 * baseSize, Team.RED);
    }
    
    // Create a flag for a base
    function createFlag(x, y, z, team) {
      const flagPoleGeometry = new THREE.CylinderGeometry(0.3 * scaleFactor, 0.3 * scaleFactor, 8 * scaleFactor, 8);
      const flagPoleMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
      const flagPole = new THREE.Mesh(flagPoleGeometry, flagPoleMaterial);
      flagPole.position.set(x, y - 4 * scaleFactor, z);
      scene.add(flagPole);
      
      const flagGeometry = new THREE.PlaneGeometry(5 * scaleFactor, 3 * scaleFactor);
      const flagMaterial = new THREE.MeshPhongMaterial({ 
        color: team === Team.BLUE ? 0x3355aa : 0xaa5533,
        side: THREE.DoubleSide
      });
      
      const flag = new THREE.Mesh(flagGeometry, flagMaterial);
      flag.position.set(x + (team === Team.BLUE ? 2.5 * scaleFactor : -2.5 * scaleFactor), y, z);
      flag.rotation.y = Math.PI / 2;
      scene.add(flag);
    }
    
    // Create player
    function createPlayer() {
      player = new THREE.Object3D();
      player.position.set(-100 * scaleFactor, 5, 0);
      player.velocity = new THREE.Vector3();
      scene.add(player);
      
      // Add camera to player
      player.add(camera);
      camera.position.y = 1.7;
    }
    
    // Spawn enemies
    function spawnEnemies() {
      for (let i = 0; i < gameStats.enemyCount; i++) {
        createEnemy(i);
      }
    }
    
    // Create a single enemy (triangle drone)
    function createEnemy(id) {
      // Create a pyramid (triangle) shape for the drone
      const enemyGeometry = new THREE.ConeGeometry(2 * scaleFactor, 4 * scaleFactor, 3);
      const enemyMaterial = new THREE.MeshPhongMaterial({ 
        color: 0xaa5533, // Red team color
        emissive: 0x442211,
        shininess: 50,
        wireframe: false
      });
      
      const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
      
      // Position enemy near red base
      enemy.position.set(
        100 * scaleFactor + Math.random() * 20 - 10,
        5 + Math.random() * 5, // Random height
        Math.random() * 40 - 20
      );
      
      enemy.rotation.order = 'YXZ';
      enemy.castShadow = true;
      enemy.receiveShadow = true;
      
      // Enemy properties
      enemy.health = 100;
      enemy.armor = 100;
      enemy.team = Team.RED;
      enemy.id = id;
      enemy.speed = 6.0;
      enemy.fireCooldown = 0;
      enemy.target = null;
      enemy.state = 'patrol';
      enemy.lastStateChange = 0;
      enemy.velocity = new THREE.Vector3();
      
      scene.add(enemy);
      enemies.push(enemy);
    }
    
    // Create a paintball projectile
    function createProjectile(position, velocity, team) {
      const projectileGeometry = new THREE.SphereGeometry(0.4 * scaleFactor, 16, 16);
      const projectileMaterial = new THREE.MeshPhongMaterial({ 
        color: team === Team.BLUE ? 0x3355ff : 0xff5533,
        emissive: team === Team.BLUE ? 0x002266 : 0x662200
      });
      
      const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
      projectile.position.copy(position);
      projectile.velocity = velocity.clone();
      projectile.team = team;
      projectile.damage = 100;
      projectile.isDisc = false;
      projectile.lifetime = 0;
      projectile.maxLifetime = 2.0;
      
      scene.add(projectile);
      projectiles.push(projectile);
      
      return projectile;
    }
    
    // Show a console message
    function showConsoleMessage(message, duration = 3000) {
      const consoleElement = document.getElementById('consoleMessage');
      consoleElement.textContent = message;
      consoleElement.classList.add('active');
      
      setTimeout(() => {
        consoleElement.classList.remove('active');
      }, duration);
    }
    
    // Add a kill event to the kill feed
    function addKillEvent(killer, victim, weapon) {
      const killFeed = document.getElementById('killFeed');
      const killEvent = document.createElement('div');
      killEvent.className = 'kill-event';
      killEvent.innerHTML = `
        <span class="killer">${killer}</span> 
        <span>paintballed</span> 
        <span class="victim">${victim}</span>
      `;
      
      killFeed.appendChild(killEvent);
      
      // Limit kill feed to 6 entries
      if (killFeed.children.length > 6) {
        killFeed.removeChild(killFeed.firstChild);
      }
      
      // Auto-remove after 10 seconds
      setTimeout(() => {
        if (killFeed.contains(killEvent)) {
          killFeed.removeChild(killEvent);
        }
      }, 10000);
    }
    
    // Update player stats display
    function updatePlayerDisplay() {
      document.getElementById('healthFill').style.width = `${playerStats.health}%`;
      document.getElementById('armorFill').style.width = `${playerStats.armor}%`;
      document.getElementById('energyFill').style.width = `${playerStats.energy}%`;
      document.getElementById('ammoCount').textContent = playerStats.ammo;
      document.getElementById('weaponName').textContent = playerStats.weapon;
      document.getElementById('blueScore').textContent = gameStats.blueScore;
      document.getElementById('redScore').textContent = gameStats.redScore;
    }
    
    // Update performance display
    function updatePerformanceDisplay() {
      document.getElementById('performanceDisplay').textContent = 
        `FPS: ${Math.round(fps)} | ENEMIES: ${enemies.length}`;
    }
    
    // Set up event listeners
    function setupEventListeners() {
      // Keyboard controls
      document.addEventListener('keydown', (e) => {
        if (currentState === GameState.MENU || currentState === GameState.DEAD) return;
        
        switch(e.key.toLowerCase()) {
          case 'w':
            controls.moveForward = true;
            break;
          case 's':
            controls.moveBackward = true;
            break;
          case 'a':
            controls.moveLeft = true;
            break;
          case 'd':
            controls.moveRight = true;
            break;
          case ' ':
            controls.jump = true;
            break;
          case 'shift':
            controls.jetpack = true;
            break;
          case 'r':
            // Reload
            if (playerStats.ammo < 200 && playerStats.maxAmmo > 0) {
              const needed = 200 - playerStats.ammo;
              const reloadAmount = Math.min(needed, playerStats.maxAmmo);
              playerStats.ammo += reloadAmount;
              playerStats.maxAmmo -= reloadAmount;
              showConsoleMessage(`Reloading... ${playerStats.ammo}/200`);
              updatePlayerDisplay();
            }
            break;
        }
      });
      
      document.addEventListener('keyup', (e) => {
        switch(e.key.toLowerCase()) {
          case 'w':
            controls.moveForward = false;
            break;
          case 's':
            controls.moveBackward = false;
            break;
          case 'a':
            controls.moveLeft = false;
            break;
          case 'd':
            controls.moveRight = false;
            break;
          case ' ':
            controls.jump = false;
            break;
          case 'shift':
            controls.jetpack = false;
            break;
        }
      });
      
      // Mouse movement for camera control
      document.addEventListener('mousemove', (e) => {
        if (currentState === GameState.PLAYING || currentState === GameState.COMBAT) {
          // Rotate player based on mouse movement
          player.rotation.y -= e.movementX * mouseSensitivity;
          camera.rotation.x -= e.movementY * mouseSensitivity * (invertYAxis ? -1 : 1);
          
          // Limit vertical look angle
          camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
        }
      });
      
      // Mouse click for firing
      document.addEventListener('mousedown', (e) => {
        if (currentState === GameState.PLAYING || currentState === GameState.COMBAT) {
          controls.fire = true;
        }
      });
      
      document.addEventListener('mouseup', (e) => {
        controls.fire = false;
      });
      
      // Menu event listeners
      document.getElementById('startBtn').addEventListener('click', startGame);
      document.getElementById('quitBtn').addEventListener('click', () => {
        showConsoleMessage("Thanks for playing GALAXYQUEST: RED VS BLUE!");
        setTimeout(() => { window.close(); }, 1000);
      });
      
      // Lock pointer on click
      document.getElementById('gameCanvas').addEventListener('click', () => {
        if (currentState === GameState.PLAYING || currentState === GameState.COMBAT) {
          document.getElementById('gameCanvas').requestPointerLock();
        }
      });
      
      // Exit pointer lock
      document.addEventListener('pointerlockchange', () => {
        if (document.pointerLockElement !== document.getElementById('gameCanvas')) {
          // Pointer was unlocked
        }
      });
      
      // Window resize handler
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }
    
    // Start the game
    function startGame() {
      currentState = GameState.PLAYING;
      document.getElementById('mainMenu').style.display = 'none';
      document.getElementById('gameCanvas').requestPointerLock();
      showConsoleMessage("Joining Blue Team. Paintball battle begins!");
    }
    
    // Respawn player
    function respawnPlayer() {
      playerStats.health = 100;
      playerStats.armor = 100;
      playerStats.energy = 100;
      playerStats.ammo = 200;
      playerStats.maxAmmo = 200;
      
      // Reset position based on team
      if (playerStats.team === Team.BLUE) {
        player.position.set(-100 * scaleFactor, 5, 0);
      } else {
        player.position.set(100 * scaleFactor, 5, 0);
      }
      
      player.velocity.set(0, 0, 0);
      currentState = GameState.PLAYING;
      document.getElementById('respawnTimer').style.display = 'none';
      
      updatePlayerDisplay();
      showConsoleMessage("Respawned! Get back in the paintball fight!");
    }
    
    // Update game state
    function update(deltaTime) {
      if (currentState === GameState.MENU) return;
      
      // Handle respawn timer
      if (currentState === GameState.DEAD) {
        playerStats.respawnTime -= deltaTime;
        document.getElementById('respawnCount').textContent = Math.ceil(playerStats.respawnTime);
        
        if (playerStats.respawnTime <= 0) {
          respawnPlayer();
        }
        return;
      }
      
      // Calculate movement direction based on controls
      const moveSpeed = playerStats.speed;
      const moveVector = new THREE.Vector3(0, 0, 0);
      
      if (controls.moveForward) moveVector.z -= 1;
      if (controls.moveBackward) moveVector.z += 1;
      if (controls.moveLeft) moveVector.x -= 1;
      if (controls.moveRight) moveVector.x += 1;
      
      // Normalize and apply movement speed
      if (moveVector.length() > 0) {
        moveVector.normalize().multiplyScalar(moveSpeed);
        
        // Apply movement relative to player's rotation
        moveVector.applyEuler(new THREE.Euler(0, player.rotation.y, 0));
        player.position.add(moveVector.multiplyScalar(deltaTime));
      }
      
      // Handle jumping
      if (controls.jump && controls.isGrounded) {
        player.velocity.y = playerStats.jumpForce;
        controls.isGrounded = false;
      }
      
      // Handle jetpack
      if (controls.jetpack && playerStats.energy > 0) {
        player.velocity.y += playerStats.jetpackForce * deltaTime;
        playerStats.energy -= 25 * deltaTime;
        if (playerStats.energy < 0) playerStats.energy = 0;
      }
      
      // Apply gravity
      player.velocity.y -= playerStats.gravity * deltaTime;
      
      // Update player position
      player.position.add(player.velocity.clone().multiplyScalar(deltaTime));
      
      // Check if player is on ground
      if (player.position.y <= 1.7) {
        player.position.y = 1.7;
        player.velocity.y = 0;
        controls.isGrounded = true;
      }
      
      // Regenerate energy when not using jetpack
      if (!controls.jetpack && playerStats.energy < 100) {
        playerStats.energy += 15 * deltaTime;
        if (playerStats.energy > 100) playerStats.energy = 100;
      }
      
      // Handle weapon firing
      if (controls.fire && playerStats.weaponCooldown <= 0 && playerStats.ammo > 0) {
        // Create a paintball projectile
        const direction = new THREE.Vector3(0, 0, -1);
        direction.applyQuaternion(camera.quaternion);
        
        const velocity = direction.clone().multiplyScalar(100);
        
        createProjectile(
          camera.position.clone().add(direction.clone().multiplyScalar(2)),
          velocity,
          playerStats.team
        );
        
        playerStats.ammo--;
        playerStats.weaponCooldown = 0.05;
        
        updatePlayerDisplay();
      }
      
      if (playerStats.weaponCooldown > 0) {
        playerStats.weaponCooldown -= deltaTime;
      }
      
      // Update projectiles
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const projectile = projectiles[i];
        
        // Update position
        projectile.position.add(projectile.velocity.clone().multiplyScalar(deltaTime));
        
        // Check for collisions with enemies
        for (let j = enemies.length - 1; j >= 0; j--) {
          const enemy = enemies[j];
          
          // Skip if projectile and enemy are on the same team
          if (projectile.team === enemy.team) continue;
          
          // Simple distance-based collision
          const distance = projectile.position.distanceTo(enemy.position);
          if (distance < 3 * scaleFactor) {
            // Hit enemy
            enemy.health -= projectile.damage;
            
            // Remove projectile
            scene.remove(projectile);
            projectiles.splice(i, 1);
            
            // Check if enemy is eliminated
            if (enemy.health <= 0) {
              // Score points for elimination
              if (playerStats.team === Team.BLUE) {
                gameStats.blueScore += 100;
              } else {
                gameStats.redScore += 100;
              }
              
              playerStats.kills++;
              
              // Add to kill feed
              addKillEvent("Blue Player", "Red Drone", "Paintball");
              
              // Remove enemy
              scene.remove(enemy);
              enemies.splice(j, 1);
              
              // Spawn a new enemy after a delay
              setTimeout(() => {
                createEnemy(enemies.length);
              }, 5000);
            }
            
            break;
          }
        }
        
        // Check for collisions with player
        if (projectile.team !== playerStats.team) {
          const distance = projectile.position.distanceTo(player.position);
          if (distance < 2 * scaleFactor) {
            // Hit player
            if (playerStats.armor > 0) {
              playerStats.armor -= projectile.damage;
              if (playerStats.armor < 0) {
                playerStats.health += playerStats.armor;
                playerStats.armor = 0;
              }
            } else {
              playerStats.health -= projectile.damage;
            }
            
            // Remove projectile
            scene.remove(projectile);
            projectiles.splice(i, 1);
            
            updatePlayerDisplay();
            
            // Check if player is eliminated
            if (playerStats.health <= 0) {
              playerStats.deaths++;
              currentState = GameState.DEAD;
              playerStats.respawnTime = gameStats.respawnDelay;
              document.getElementById('respawnTimer').style.display = 'block';
              
              // Score points for enemy team
              if (playerStats.team === Team.BLUE) {
                gameStats.redScore += 100;
              } else {
                gameStats.blueScore += 100;
              }
              
              // Add to kill feed
              addKillEvent("Red Drone", "Blue Player", "Paintball");
            }
          }
        }
        
        // Remove projectiles that have been alive too long
        projectile.lifetime += deltaTime;
        if (projectile.lifetime > projectile.maxLifetime) {
          scene.remove(projectile);
          projectiles.splice(i, 1);
        }
      }
      
      // Update enemies
      for (let i = 0; i < enemies.length; i++) {
        const enemy = enemies[i];
        
        // Simple AI behavior
        const distanceToPlayer = enemy.position.distanceTo(player.position);
        
        // State transitions
        if (distanceToPlayer < 20 * scaleFactor && enemy.state !== 'attack') {
          enemy.state = 'attack';
          enemy.lastStateChange = performance.now();
        } else if (distanceToPlayer > 30 * scaleFactor && enemy.state !== 'patrol') {
          enemy.state = 'patrol';
          enemy.lastStateChange = performance.now();
        }
        
        // State behaviors
        if (enemy.state === 'patrol') {
          // Random patrol movement
          if (performance.now() - enemy.lastStateChange > 3000) {
            enemy.target = new THREE.Vector3(
              100 * scaleFactor + Math.random() * 40 - 20,
              5 + Math.random() * 5,
              Math.random() * 40 - 20
            );
            enemy.lastStateChange = performance.now();
          }
          
          // Move toward target
          const direction = new THREE.Vector3().subVectors(enemy.target, enemy.position);
          if (direction.length() > 2 * scaleFactor) {
            direction.normalize().multiplyScalar(enemy.speed * deltaTime);
            enemy.position.add(direction);
            
            // Rotate to face movement direction
            enemy.rotation.y = Math.atan2(direction.x, direction.z);
          }
        } else if (enemy.state === 'attack') {
          // Move toward player
          const direction = new THREE.Vector3().subVectors(player.position, enemy.position);
          direction.y = 0; // Ignore height difference
          
          if (direction.length() > 10 * scaleFactor) {
            // Keep some distance
            direction.normalize().multiplyScalar(enemy.speed * deltaTime);
            enemy.position.add(direction);
          }
          
          // Rotate to face player
          enemy.rotation.y = Math.atan2(direction.x, direction.z);
          
          // Fire at player
          if (enemy.fireCooldown <= 0) {
            const fireDirection = new THREE.Vector3().subVectors(player.position, enemy.position).normalize();
            const fireVelocity = fireDirection.multiplyScalar(80);
            
            createProjectile(
              enemy.position.clone().add(fireDirection.clone().multiplyScalar(2)),
              fireVelocity,
              enemy.team
            );
            
            enemy.fireCooldown = 0.5;
          }
        }
        
        if (enemy.fireCooldown > 0) {
          enemy.fireCooldown -= deltaTime;
        }
      }
      
      // Update performance stats
      frameCount++;
      lastFpsUpdate += deltaTime;
      if (lastFpsUpdate >= 1.0) {
        fps = frameCount / lastFpsUpdate;
        frameCount = 0;
        lastFpsUpdate = 0;
        updatePerformanceDisplay();
      }
    }
    
    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      
      const deltaTime = Math.min(clock.getDelta(), 0.1);
      
      update(deltaTime);
      renderer.render(scene, camera);
    }
    
    // Initialize the game when the page loads
    window.addEventListener('load', init);
  </script>
</body>
</html>