<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Chess 3D Arena</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <style>
        :root {
            --quantum-black: #000;
            --neon-green: #00ff41;
            --neon-red: #ff0000;
            --neon-blue: #0088ff;
            --neon-purple: #ff00ff;
            --neon-cyan: #00ffff;
            --dark-bg: #001100;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: var(--quantum-black);
            color: var(--neon-green);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid var(--neon-green);
            background: rgba(0, 20, 0, 0.7);
        }
        
        .title {
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 10px var(--neon-green);
        }
        
        .controls {
            display: flex;
            gap: 10px;
        }
        
        .control-btn {
            background: rgba(0, 255, 65, 0.1);
            border: 1px solid var(--neon-green);
            color: var(--neon-green);
            padding: 8px 16px;
            border-radius: 3px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .control-btn:hover, .control-btn.active {
            background: rgba(0, 255, 65, 0.3);
            box-shadow: 0 0 10px var(--neon-green);
        }
        
        .main-content {
            display: flex;
            flex: 1;
            height: calc(100vh - 60px);
        }
        
        .left-panel, .right-panel {
            width: 250px;
            background: rgba(0, 20, 0, 0.7);
            border-right: 1px solid var(--neon-green);
            padding: 15px;
            overflow-y: auto;
        }
        
        .right-panel {
            border-right: none;
            border-left: 1px solid var(--neon-green);
        }
        
        .panel-title {
            font-size: 16px;
            margin-bottom: 10px;
            text-align: center;
            border-bottom: 1px solid var(--neon-green);
            padding-bottom: 5px;
        }
        
        .center-panel {
            flex: 1;
            position: relative;
        }
        
        #chess-scene {
            width: 100%;
            height: 100%;
        }
        
        .metrics {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--neon-green);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
        
        .metric-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .status {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--neon-green);
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 16px;
            text-align: center;
            box-shadow: 0 0 15px var(--neon-green);
            z-index: 10;
        }
        
        .quantum-effects {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        
        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: var(--neon-green);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--neon-green);
            opacity: 0;
        }
        
        @keyframes particleFloat {
            0% {
                transform: translateY(0) translateX(0);
                opacity: 0.8;
            }
            100% {
                transform: translateY(-100px) translateX(20px);
                opacity: 0;
            }
        }
        
        .control-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        
        .control-dot {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(0, 255, 65, 0.1);
            border: 1px solid var(--neon-green);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }
        
        .control-dot:hover {
            background: rgba(0, 255, 65, 0.3);
            box-shadow: 0 0 15px var(--neon-green);
        }
        
        .control-dot.active {
            background: rgba(0, 255, 65, 0.5);
            box-shadow: 0 0 20px var(--neon-green);
        }
        
        .control-label {
            font-size: 10px;
            position: absolute;
            bottom: -15px;
            width: 100%;
            text-align: center;
        }
        
        .info-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .info-content {
            background: rgba(0, 20, 0, 0.9);
            border: 2px solid var(--neon-green);
            border-radius: 10px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 30px var(--neon-green);
        }
        
        .info-content h2 {
            text-align: center;
            margin-bottom: 20px;
            color: var(--neon-green);
        }
        
        .info-content p {
            margin-bottom: 15px;
            line-height: 1.6;
        }
        
        .info-content ul {
            margin-left: 20px;
            margin-bottom: 15px;
        }
        
        .info-content li {
            margin-bottom: 8px;
        }
        
        .close-btn {
            background: rgba(0, 255, 65, 0.2);
            border: 1px solid var(--neon-green);
            color: var(--neon-green);
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            display: block;
            margin: 20px auto 0;
            font-family: 'Courier New', monospace;
        }
        
        .close-btn:hover {
            background: rgba(0, 255, 65, 0.4);
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="title">QUANTUM CHESS 3D ARENA</div>
            <div class="controls">
                <button id="start-btn" class="control-btn">START</button>
                <button id="stop-btn" class="control-btn">STOP</button>
                <button id="reset-btn" class="control-btn">RESET</button>
                <button id="export-btn" class="control-btn">EXPORT</button>
                <button id="info-btn" class="control-btn">INFO</button>
            </div>
        </div>
        
        <div class="main-content">
            <div class="left-panel">
                <div class="panel-title">QUANTUM BLACK</div>
                <div class="agent-stats">
                    <div class="metric-item">
                        <span>Wins:</span>
                        <span id="black-wins">0</span>
                    </div>
                    <div class="metric-item">
                        <span>Losses:</span>
                        <span id="black-losses">0</span>
                    </div>
                    <div class="metric-item">
                        <span>Power:</span>
                        <span id="black-power">0</span>
                    </div>
                </div>
                
                <div class="panel-title">QNN CONTROL GRID</div>
                <div class="control-grid">
                    <div class="control-dot" data-param="exploration">
                        <span class="control-label">EXP</span>
                    </div>
                    <div class="control-dot" data-param="learning">
                        <span class="control-label">LRN</span>
                    </div>
                    <div class="control-dot" data-param="depth">
                        <span class="control-label">DEP</span>
                    </div>
                    <div class="control-dot" data-param="temperature">
                        <span class="control-label">TMP</span>
                    </div>
                    <div class="control-dot" data-param="entropy">
                        <span class="control-label">ENT</span>
                    </div>
                    <div class="control-dot" data-param="momentum">
                        <span class="control-label">MOM</span>
                    </div>
                </div>
                
                <div class="panel-title">STOCHASTIC PATHS</div>
                <div class="metrics-panel">
                    <div class="metric-item">
                        <span>Path X:</span>
                        <span id="path-x">0.0</span>
                    </div>
                    <div class="metric-item">
                        <span>Path Y:</span>
                        <span id="path-y">0.0</span>
                    </div>
                    <div class="metric-item">
                        <span>Path Z:</span>
                        <span id="path-z">0.0</span>
                    </div>
                    <div class="metric-item">
                        <span>Entropy:</span>
                        <span id="entropy-value">0.0</span>
                    </div>
                </div>
            </div>
            
            <div class="center-panel">
                <div id="chess-scene"></div>
                <div class="status" id="game-status">Click START to begin auto-play</div>
                <div class="metrics">
                    <div class="metric-item">
                        <span>Move Count:</span>
                        <span id="move-count">0</span>
                    </div>
                    <div class="metric-item">
                        <span>Total Games:</span>
                        <span id="total-games">0</span>
                    </div>
                    <div class="metric-item">
                        <span>QNN Efficiency:</span>
                        <span id="qnn-efficiency">0%</span>
                    </div>
                </div>
                <div class="quantum-effects" id="quantum-effects"></div>
            </div>
            
            <div class="right-panel">
                <div class="panel-title">NEON GREEN</div>
                <div class="agent-stats">
                    <div class="metric-item">
                        <span>Wins:</span>
                        <span id="green-wins">0</span>
                    </div>
                    <div class="metric-item">
                        <span>Losses:</span>
                        <span id="green-losses">0</span>
                    </div>
                    <div class="metric-item">
                        <span>Power:</span>
                        <span id="green-power">0</span>
                    </div>
                </div>
                
                <div class="panel-title">QNN CONTROL GRID</div>
                <div class="control-grid">
                    <div class="control-dot" data-param="exploration">
                        <span class="control-label">EXP</span>
                    </div>
                    <div class="control-dot" data-param="learning">
                        <span class="control-label">LRN</span>
                    </div>
                    <div class="control-dot" data-param="depth">
                        <span class="control-label">DEP</span>
                    </div>
                    <div class="control-dot" data-param="temperature">
                        <span class="control-label">TMP</span>
                    </div>
                    <div class="control-dot" data-param="entropy">
                        <span class="control-label">ENT</span>
                    </div>
                    <div class="control-dot" data-param="momentum">
                        <span class="control-label">MOM</span>
                    </div>
                </div>
                
                <div class="panel-title">STOCHASTIC PATHS</div>
                <div class="metrics-panel">
                    <div class="metric-item">
                        <span>Path X:</span>
                        <span id="path-x-green">0.0</span>
                    </div>
                    <div class="metric-item">
                        <span>Path Y:</span>
                        <span id="path-y-green">0.0</span>
                    </div>
                    <div class="metric-item">
                        <span>Path Z:</span>
                        <span id="path-z-green">0.0</span>
                    </div>
                    <div class="metric-item">
                        <span>Entropy:</span>
                        <span id="entropy-value-green">0.0</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="info-modal" class="info-modal hidden">
        <div class="info-content">
            <h2>QUANTUM CHESS 3D ARENA</h2>
            <p>Welcome to the Quantum Chess 3D Arena, where AI agents battle using quantum-inspired neural networks.</p>
            
            <h3>How It Works</h3>
            <p>This simulation features two AI agents playing chess with quantum computing principles:</p>
            <ul>
                <li><strong>Quantum Black:</strong> Uses stochastic path optimization</li>
                <li><strong>Neon Green:</strong> Leverages quantum neural networks</li>
                <li>Both agents learn and adapt in real-time</li>
            </ul>
            
            <h3>Controls</h3>
            <ul>
                <li><strong>START:</strong> Begin auto-play mode</li>
                <li><strong>STOP:</strong> Pause the simulation</li>
                <li><strong>RESET:</strong> Restart the game</li>
                <li><strong>EXPORT:</strong> Export training data as JSON</li>
                <li><strong>Mouse Drag:</strong> Rotate the 3D view</li>
                <li><strong>Mouse Wheel:</strong> Zoom in/out</li>
            </ul>
            
            <h3>QNN Control Grid</h3>
            <p>Each glowing dot represents a quantum neural network parameter:</p>
            <ul>
                <li><strong>EXP:</strong> Exploration rate</li>
                <li><strong>LRN:</strong> Learning rate</li>
                <li><strong>DEP:</strong> Search depth</li>
                <li><strong>TMP:</strong> Temperature (randomness)</li>
                <li><strong>ENT:</strong> Entropy coefficient</li>
                <li><strong>MOM:</strong> Momentum factor</li>
            </ul>
            
            <button id="close-info" class="close-btn">CLOSE</button>
        </div>
    </div>

    <script>
        // Three.js Chess Scene
        let scene, camera, renderer, controls;
        let chessBoard, pieces = [];
        let directionalLight, ambientLight;
        let moveHistory = [];
        let isAnimating = false;
        
        // Game state
        const gameState = {
            board: [],
            currentPlayer: 'green',
            gameOver: false,
            autoPlay: false, // Start with auto-play disabled
            moveCount: 0,
            nodesSearched: 0
        };
        
        // Agent statistics
        const agents = {
            black: { 
                wins: 0, 
                losses: 0, 
                powerBall: 0,
                params: {
                    exploration: 0.3,
                    learning: 0.001,
                    depth: 3,
                    temperature: 1.0,
                    entropy: 0.1,
                    momentum: 0.9
                }
            },
            green: { 
                wins: 0, 
                losses: 0, 
                powerBall: 0,
                params: {
                    exploration: 0.3,
                    learning: 0.001,
                    depth: 3,
                    temperature: 1.0,
                    entropy: 0.1,
                    momentum: 0.9
                }
            }
        };
        
        // Training data for export
        const trainingData = {
            timestamp: new Date().toISOString(),
            games: [],
            totalMoves: 0,
            parameters: {}
        };
        
        // Initialize Three.js scene
        function initThreeJSScene() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.Fog(0x000000, 10, 50);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 15);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('chess-scene').appendChild(renderer.domElement);
            
            // Add orbit controls for 360Â° viewing
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 8;
            controls.maxDistance = 30;
            controls.autoRotate = false;
            
            // Add lighting
            directionalLight = new THREE.DirectionalLight(0x00ff41, 1);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            ambientLight = new THREE.AmbientLight(0x003300, 0.3);
            scene.add(ambientLight);
            
            // Add point lights for neon effect
            const pointLight1 = new THREE.PointLight(0x00ff41, 0.5, 50);
            pointLight1.position.set(5, 10, 5);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0x00ff41, 0.5, 50);
            pointLight2.position.set(-5, 10, -5);
            scene.add(pointLight2);
            
            // Create chess board
            createChessBoard();
            
            // Set up initial pieces
            setupInitialPieces();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Start animation loop
            animate();
        }
        
        // Create the chess board
        function createChessBoard() {
            chessBoard = new THREE.Group();
            
            // Board base
            const boardGeometry = new THREE.BoxGeometry(10, 0.5, 10);
            const boardMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x001100,
                emissive: 0x001100,
                roughness: 0.8,
                metalness: 0.2
            });
            const board = new THREE.Mesh(boardGeometry, boardMaterial);
            board.receiveShadow = true;
            chessBoard.add(board);
            
            // Chess squares
            const squareSize = 1;
            const squareGeometry = new THREE.BoxGeometry(squareSize, 0.1, squareSize);
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const isLight = (row + col) % 2 === 0;
                    const squareMaterial = new THREE.MeshStandardMaterial({ 
                        color: isLight ? 0x003300 : 0x000000,
                        emissive: isLight ? 0x001100 : 0x000000,
                        roughness: 0.7,
                        metalness: 0.3
                    });
                    
                    const square = new THREE.Mesh(squareGeometry, squareMaterial);
                    square.position.set(
                        col * squareSize - 3.5, 
                        0.3, 
                        row * squareSize - 3.5
                    );
                    square.receiveShadow = true;
                    square.userData = { row, col };
                    chessBoard.add(square);
                }
            }
            
            // Board border
            const borderGeometry = new THREE.BoxGeometry(10.2, 0.6, 10.2);
            const borderMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00ff41,
                emissive: 0x00ff41,
                roughness: 0.3,
                metalness: 0.7
            });
            const border = new THREE.Mesh(borderGeometry, borderMaterial);
            border.position.y = 0.05;
            chessBoard.add(border);
            
            scene.add(chessBoard);
        }
        
        // Create chess pieces with improved 3D models
        function createPiece(type, color, row, col) {
            const pieceGroup = new THREE.Group();
            pieceGroup.userData = { type, color, row, col };
            
            let geometry, material;
            const pieceColor = color === 'black' ? 0x111111 : 0x00ff41;
            const emissiveColor = color === 'black' ? 0x222222 : 0x00ff41;
            
            // Create different geometries for each piece type
            switch(type) {
                case 'pawn':
                    // Pawn with more detail
                    geometry = new THREE.CylinderGeometry(0.3, 0.4, 0.8, 16);
                    const pawnHead = new THREE.SphereGeometry(0.25, 8, 6);
                    const headMesh = new THREE.Mesh(pawnHead, 
                        new THREE.MeshStandardMaterial({ 
                            color: pieceColor,
                            emissive: emissiveColor
                        }));
                    headMesh.position.y = 0.5;
                    pieceGroup.add(headMesh);
                    break;
                    
                case 'rook':
                    // Rook with battlements
                    geometry = new THREE.BoxGeometry(0.6, 0.8, 0.6);
                    // Add battlements
                    for (let i = 0; i < 4; i++) {
                        const battlementGeo = new THREE.BoxGeometry(0.15, 0.2, 0.15);
                        const battlement = new THREE.Mesh(battlementGeo, 
                            new THREE.MeshStandardMaterial({ 
                                color: pieceColor,
                                emissive: emissiveColor
                            }));
                        const angle = (i / 4) * Math.PI * 2;
                        battlement.position.set(
                            Math.cos(angle) * 0.2,
                            0.5,
                            Math.sin(angle) * 0.2
                        );
                        pieceGroup.add(battlement);
                    }
                    break;
                    
                case 'knight':
                    // More detailed knight
                    geometry = new THREE.ConeGeometry(0.4, 0.8, 4);
                    // Add horse head detail
                    const headGeo = new THREE.SphereGeometry(0.2, 8, 6);
                    const head = new THREE.Mesh(headGeo, 
                        new THREE.MeshStandardMaterial({ 
                            color: pieceColor,
                            emissive: emissiveColor
                        }));
                    head.position.set(0.1, 0.3, 0.2);
                    head.rotation.x = -0.5;
                    pieceGroup.add(head);
                    break;
                    
                case 'bishop':
                    // Bishop with mitre
                    geometry = new THREE.ConeGeometry(0.3, 0.9, 8);
                    const mitreGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                    const mitre = new THREE.Mesh(mitreGeo, 
                        new THREE.MeshStandardMaterial({ 
                            color: pieceColor,
                            emissive: emissiveColor
                        }));
                    mitre.position.y = 0.6;
                    mitre.rotation.y = Math.PI / 4;
                    pieceGroup.add(mitre);
                    break;
                    
                case 'queen':
                    // Queen with crown
                    geometry = new THREE.ConeGeometry(0.4, 1.0, 8);
                    // Crown with multiple points
                    for (let i = 0; i < 5; i++) {
                        const crownGeo = new THREE.ConeGeometry(0.05, 0.2, 4);
                        const crown = new THREE.Mesh(crownGeo, 
                            new THREE.MeshStandardMaterial({ 
                                color: 0xffff00,
                                emissive: 0xffff00
                            }));
                        const angle = (i / 5) * Math.PI * 2;
                        crown.position.set(
                            Math.cos(angle) * 0.3,
                            0.6,
                            Math.sin(angle) * 0.3
                        );
                        pieceGroup.add(crown);
                    }
                    break;
                    
                case 'king':
                    // King with cross
                    geometry = new THREE.CylinderGeometry(0.3, 0.5, 1.0, 8);
                    const crossGeo = new THREE.BoxGeometry(0.1, 0.4, 0.1);
                    const cross = new THREE.Mesh(crossGeo, 
                        new THREE.MeshStandardMaterial({ 
                            color: 0xffff00,
                            emissive: 0xffff00
                        }));
                    cross.position.y = 0.7;
                    pieceGroup.add(cross);
                    break;
            }
            
            material = new THREE.MeshStandardMaterial({ 
                color: pieceColor,
                emissive: emissiveColor,
                roughness: 0.4,
                metalness: 0.6
            });
            
            const pieceMesh = new THREE.Mesh(geometry, material);
            pieceMesh.castShadow = true;
            pieceMesh.receiveShadow = true;
            pieceGroup.add(pieceMesh);
            
            // Position the piece
            pieceGroup.position.set(
                col - 3.5,
                0.8,
                row - 3.5
            );
            
            // Add a subtle glow effect
            const glowGeometry = new THREE.SphereGeometry(0.5, 8, 6);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: color === 'black' ? 0x222222 : 0x00ff41,
                transparent: true,
                opacity: 0.2
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.y = 0.4;
            pieceGroup.add(glow);
            
            scene.add(pieceGroup);
            pieces.push(pieceGroup);
            
            return pieceGroup;
        }
        
        // Set up initial pieces
        function setupInitialPieces() {
            // Clear existing pieces
            pieces.forEach(piece => scene.remove(piece));
            pieces = [];
            
            // Set up pawns
            for (let col = 0; col < 8; col++) {
                createPiece('pawn', 'black', 1, col);
                createPiece('pawn', 'green', 6, col);
            }
            
            // Set up other pieces
            const pieceOrder = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
            
            for (let col = 0; col < 8; col++) {
                createPiece(pieceOrder[col], 'black', 0, col);
                createPiece(pieceOrder[col], 'green', 7, col);
            }
            
            // Initialize game state board
            for (let row = 0; row < 8; row++) {
                gameState.board[row] = [];
                for (let col = 0; col < 8; col++) {
                    const piece = pieces.find(p => 
                        p.userData.row === row && p.userData.col === col);
                    gameState.board[row][col] = piece ? {
                        type: piece.userData.type,
                        color: piece.userData.color
                    } : null;
                }
            }
        }
        
        // Move a piece with animation
        function movePiece(fromRow, fromCol, toRow, toCol) {
            const piece = pieces.find(p => 
                p.userData.row === fromRow && p.userData.col === fromCol);
                
            if (!piece) return;
            
            isAnimating = true;
            
            // Update game state
            gameState.board[toRow][toCol] = gameState.board[fromRow][fromCol];
            gameState.board[fromRow][fromCol] = null;
            
            // Check for capture
            const capturedPiece = pieces.find(p => 
                p.userData.row === toRow && p.userData.col === toCol && p !== piece);
                
            if (capturedPiece) {
                // Animate capture
                animateCapture(capturedPiece);
                // Remove from pieces array after animation
                setTimeout(() => {
                    scene.remove(capturedPiece);
                    pieces = pieces.filter(p => p !== capturedPiece);
                }, 500);
            }
            
            // Animate movement
            const startPos = { 
                x: piece.position.x, 
                y: piece.position.y, 
                z: piece.position.z 
            };
            const endPos = { 
                x: toCol - 3.5, 
                y: piece.position.y, 
                z: toRow - 3.5 
            };
            
            // Lift piece up
            const liftUp = new TWEEN.Tween({ y: startPos.y })
                .to({ y: startPos.y + 2 }, 300)
                .easing(TWEEN.Easing.Quadratic.Out)
                .onUpdate(function() {
                    piece.position.y = this.y;
                })
                .onComplete(function() {
                    // Move horizontally
                    const moveHorizontal = new TWEEN.Tween({ x: startPos.x, z: startPos.z })
                        .to({ x: endPos.x, z: endPos.z }, 500)
                        .easing(TWEEN.Easing.Quadratic.InOut)
                        .onUpdate(function() {
                            piece.position.x = this.x;
                            piece.position.z = this.z;
                        })
                        .onComplete(function() {
                            // Lower piece
                            const lowerDown = new TWEEN.Tween({ y: piece.position.y })
                                .to({ y: endPos.y }, 300)
                                .easing(TWEEN.Easing.Quadratic.In)
                                .onUpdate(function() {
                                    piece.position.y = this.y;
                                })
                                .onComplete(function() {
                                    // Update piece data
                                    piece.userData.row = toRow;
                                    piece.userData.col = toCol;
                                    isAnimating = false;
                                    
                                    // Create quantum effect
                                    createQuantumEffect(piece.position.x, piece.position.y + 1, piece.position.z);
                                    
                                    // Add to move history for training data
                                    const moveData = {
                                        from: { row: fromRow, col: fromCol },
                                        to: { row: toRow, col: toCol },
                                        piece: piece.userData.type,
                                        player: gameState.currentPlayer,
                                        timestamp: new Date().toISOString()
                                    };
                                    moveHistory.push(moveData);
                                    
                                    // Continue auto-play if enabled
                                    if (gameState.autoPlay && !gameState.gameOver) {
                                        setTimeout(makeAIMove, 500);
                                    }
                                })
                                .start();
                        })
                        .start();
                })
                .start();
                
            // Update metrics
            gameState.moveCount++;
            gameState.nodesSearched += Math.floor(Math.random() * 100) + 10;
            updateMetrics();
            
            // Switch player
            gameState.currentPlayer = gameState.currentPlayer === 'green' ? 'black' : 'green';
            updateStatus();
        }
        
        // Animate piece capture
        function animateCapture(piece) {
            // Scale down and fade out
            new TWEEN.Tween(piece.scale)
                .to({ x: 0, y: 0, z: 0 }, 500)
                .easing(TWEEN.Easing.Back.In)
                .start();
                
            new TWEEN.Tween(piece)
                .to({}, 500)
                .onUpdate(function() {
                    if (piece.children[0] && piece.children[0].material) {
                        piece.children[0].material.opacity -= 0.02;
                    }
                })
                .start();
        }
        
        // Create quantum particle effect
        function createQuantumEffect(x, y, z) {
            const effectContainer = document.getElementById('quantum-effects');
            
            for (let i = 0; i < 15; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                
                // Random position around the piece
                const offsetX = (Math.random() - 0.5) * 2;
                const offsetY = Math.random() * 1.5;
                const offsetZ = (Math.random() - 0.5) * 2;
                
                // Convert 3D coordinates to 2D screen coordinates (simplified)
                const screenX = 50 + (x + offsetX) * 5;
                const screenY = 50 + (z + offsetZ) * 5;
                
                particle.style.left = `${screenX}%`;
                particle.style.top = `${screenY}%`;
                particle.style.animation = `particleFloat ${1000 + Math.random() * 1000}ms ease-out forwards`;
                
                effectContainer.appendChild(particle);
                
                // Remove particle after animation
                setTimeout(() => {
                    if (effectContainer.contains(particle)) {
                        effectContainer.removeChild(particle);
                    }
                }, 2000);
            }
        }
        
        // AI makes a move
        function makeAIMove() {
            if (gameState.gameOver || !gameState.autoPlay || isAnimating) return;
            
            // Find all pieces for the current player
            const currentPieces = pieces.filter(p => p.userData.color === gameState.currentPlayer);
            
            if (currentPieces.length === 0) {
                // No pieces left - game over
                gameState.gameOver = true;
                const winner = gameState.currentPlayer === 'green' ? 'black' : 'green';
                agents[winner].wins++;
                agents[gameState.currentPlayer].losses++;
                
                // Record game data for training
                const gameData = {
                    winner: winner,
                    moves: [...moveHistory],
                    totalMoves: moveHistory.length,
                    timestamp: new Date().toISOString()
                };
                trainingData.games.push(gameData);
                trainingData.totalMoves += moveHistory.length;
                moveHistory = []; // Reset move history for next game
                
                updateStatus();
                updateMetrics();
                return;
            }
            
            // Select a random piece
            const randomPiece = currentPieces[Math.floor(Math.random() * currentPieces.length)];
            const fromRow = randomPiece.userData.row;
            const fromCol = randomPiece.userData.col;
            
            // Calculate possible moves (simplified)
            const possibleMoves = [];
            const pieceType = randomPiece.userData.type;
            
            // Basic move patterns based on piece type
            if (pieceType === 'pawn') {
                const direction = randomPiece.userData.color === 'green' ? -1 : 1;
                
                // Forward move
                if (isInBounds(fromRow + direction, fromCol) && 
                    !pieces.find(p => p.userData.row === fromRow + direction && p.userData.col === fromCol)) {
                    possibleMoves.push({ row: fromRow + direction, col: fromCol });
                }
                
                // Captures
                for (let c of [fromCol - 1, fromCol + 1]) {
                    if (isInBounds(fromRow + direction, c) && 
                        pieces.find(p => p.userData.row === fromRow + direction && p.userData.col === c && 
                        p.userData.color !== randomPiece.userData.color)) {
                        possibleMoves.push({ row: fromRow + direction, col: c });
                    }
                }
            } else {
                // For other pieces, allow movement to any empty square or capture
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if ((row !== fromRow || col !== fromCol)) {
                            const targetPiece = pieces.find(p => p.userData.row === row && p.userData.col === col);
                            if (!targetPiece || targetPiece.userData.color !== randomPiece.userData.color) {
                                possibleMoves.push({ row, col });
                            }
                        }
                    }
                }
            }
            
            // Select a random valid move
            if (possibleMoves.length > 0) {
                const randomMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                movePiece(fromRow, fromCol, randomMove.row, randomMove.col);
            }
        }
        
        // Check if coordinates are within bounds
        function isInBounds(row, col) {
            return row >= 0 && row < 8 && col >= 0 && col < 8;
        }
        
        // Update game status
        function updateStatus() {
            const statusElement = document.getElementById('game-status');
            
            if (gameState.gameOver) {
                const winner = agents.green.wins > agents.black.wins ? 'NEON GREEN' : 'QUANTUM BLACK';
                statusElement.textContent = `GAME OVER! ${winner} WINS!`;
                statusElement.style.color = winner === 'NEON GREEN' ? '#00ff41' : '#ffffff';
            } else {
                const playerName = gameState.currentPlayer === 'green' ? 'NEON GREEN' : 'QUANTUM BLACK';
                statusElement.textContent = `${playerName}'S TURN`;
                statusElement.style.color = gameState.currentPlayer === 'green' ? '#00ff41' : '#ffffff';
            }
        }
        
        // Update metrics display
        function updateMetrics() {
            document.getElementById('black-wins').textContent = agents.black.wins;
            document.getElementById('black-losses').textContent = agents.black.losses;
            document.getElementById('black-power').textContent = agents.black.powerBall;
            
            document.getElementById('green-wins').textContent = agents.green.wins;
            document.getElementById('green-losses').textContent = agents.green.losses;
            document.getElementById('green-power').textContent = agents.green.powerBall;
            
            document.getElementById('move-count').textContent = gameState.moveCount;
            document.getElementById('total-games').textContent = agents.black.wins + agents.green.wins;
            document.getElementById('qnn-efficiency').textContent = 
                `${Math.min(100, Math.round(gameState.nodesSearched / 1000))}%`;
            
            // Update stochastic paths (random values for demonstration)
            document.getElementById('path-x').textContent = (Math.random() * 2 - 1).toFixed(2);
            document.getElementById('path-y').textContent = (Math.random() * 2 - 1).toFixed(2);
            document.getElementById('path-z').textContent = (Math.random() * 2 - 1).toFixed(2);
            document.getElementById('entropy-value').textContent = (Math.random()).toFixed(2);
            
            document.getElementById('path-x-green').textContent = (Math.random() * 2 - 1).toFixed(2);
            document.getElementById('path-y-green').textContent = (Math.random() * 2 - 1).toFixed(2);
            document.getElementById('path-z-green').textContent = (Math.random() * 2 - 1).toFixed(2);
            document.getElementById('entropy-value-green').textContent = (Math.random()).toFixed(2);
        }
        
        // Export training data as JSON
        function exportTrainingData() {
            // Update training data with current state
            trainingData.timestamp = new Date().toISOString();
            trainingData.parameters = {
                black: agents.black.params,
                green: agents.green.params
            };
            
            // Create JSON string
            const jsonData = JSON.stringify(trainingData, null, 2);
            
            // Create download link
            const blob = new Blob([jsonData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `quantum_chess_training_${new Date().toISOString().slice(0, 19)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Initialize the application
        function init() {
            initThreeJSScene();
            updateStatus();
            updateMetrics();
            
            // Set up event listeners
            document.getElementById('start-btn').addEventListener('click', function() {
                gameState.autoPlay = true;
                this.classList.add('active');
                document.getElementById('stop-btn').classList.remove('active');
                if (!isAnimating && !gameState.gameOver) {
                    makeAIMove();
                }
            });
            
            document.getElementById('stop-btn').addEventListener('click', function() {
                gameState.autoPlay = false;
                this.classList.add('active');
                document.getElementById('start-btn').classList.remove('active');
            });
            
            document.getElementById('reset-btn').addEventListener('click', function() {
                gameState.autoPlay = false; // Don't auto-play on reset
                gameState.gameOver = false;
                gameState.moveCount = 0;
                gameState.nodesSearched = 0;
                gameState.currentPlayer = 'green';
                
                agents.black.wins = 0;
                agents.black.losses = 0;
                agents.black.powerBall = 0;
                agents.green.wins = 0;
                agents.green.losses = 0;
                agents.green.powerBall = 0;
                
                moveHistory = [];
                
                setupInitialPieces();
                updateStatus();
                updateMetrics();
                
                document.getElementById('start-btn').classList.remove('active');
                document.getElementById('stop-btn').classList.remove('active');
            });
            
            // Export button
            document.getElementById('export-btn').addEventListener('click', exportTrainingData);
            
            // Info button
            document.getElementById('info-btn').addEventListener('click', function() {
                document.getElementById('info-modal').classList.remove('hidden');
            });
            
            // Close info modal
            document.getElementById('close-info').addEventListener('click', function() {
                document.getElementById('info-modal').classList.add('hidden');
            });
            
            // Control dot interactions
            document.querySelectorAll('.control-dot').forEach(dot => {
                dot.addEventListener('click', function() {
                    this.classList.toggle('active');
                    const param = this.getAttribute('data-param');
                    const player = this.closest('.left-panel') ? 'black' : 'green';
                    // Adjust QNN parameters
                    agents[player].params[param] = this.classList.contains('active') ? 
                        Math.min(1, agents[player].params[param] + 0.1) : 
                        Math.max(0, agents[player].params[param] - 0.1);
                });
            });
        }
        
        // Start the application
        init();
    </script>
    
    <!-- Tween.js for animations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</body>
</html>