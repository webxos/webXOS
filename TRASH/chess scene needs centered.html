<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Chess 3D Arena</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <style>
        :root {
            --quantum-black: #000;
            --neon-green: #00ff41;
            --neon-red: #ff0000;
            --neon-blue: #0088ff;
            --neon-purple: #ff00ff;
            --neon-cyan: #00ffff;
            --dark-bg: #001100;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: var(--quantum-black);
            color: var(--neon-green);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid var(--neon-green);
            background: rgba(0, 20, 0, 0.7);
            height: 60px;
            flex-shrink: 0;
        }
        
        .title {
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 10px var(--neon-green);
        }
        
        .controls {
            display: flex;
            gap: 10px;
        }
        
        .control-btn {
            background: rgba(0, 255, 65, 0.1);
            border: 1px solid var(--neon-green);
            color: var(--neon-green);
            padding: 8px 16px;
            border-radius: 3px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .control-btn:hover, .control-btn.active {
            background: rgba(0, 255, 65, 0.3);
            box-shadow: 0 0 10px var(--neon-green);
        }
        
        .main-content {
            display: flex;
            flex: 1;
            height: calc(100vh - 60px);
            width: 100vw;
            overflow: hidden;
        }
        
        .left-panel, .right-panel {
            width: 280px;
            min-width: 280px;
            background: rgba(0, 20, 0, 0.7);
            border-right: 1px solid var(--neon-green);
            padding: 15px;
            overflow-y: auto;
            flex-shrink: 0;
            z-index: 10;
        }
        
        .right-panel {
            border-right: none;
            border-left: 1px solid var(--neon-green);
        }
        
        .panel-title {
            font-size: 16px;
            margin-bottom: 10px;
            text-align: center;
            border-bottom: 1px solid var(--neon-green);
            padding-bottom: 5px;
        }
        
        .center-panel {
            flex: 1;
            position: relative;
            min-width: 0;
        }
        
        #chess-scene {
            width: 100%;
            height: 100%;
        }
        
        .metrics {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--neon-green);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 5;
        }
        
        .metric-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .status {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--neon-green);
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 16px;
            text-align: center;
            box-shadow: 0 0 15px var(--neon-green);
            z-index: 5;
        }
        
        .quantum-effects {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }
        
        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: var(--neon-green);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--neon-green);
            opacity: 0;
        }
        
        @keyframes particleFloat {
            0% {
                transform: translateY(0) translateX(0);
                opacity: 0.8;
            }
            100% {
                transform: translateY(-100px) translateX(20px);
                opacity: 0;
            }
        }
        
        .control-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        
        .control-dot {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(0, 255, 65, 0.1);
            border: 1px solid var(--neon-green);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }
        
        .control-dot:hover {
            background: rgba(0, 255, 65, 0.3);
            box-shadow: 0 0 15px var(--neon-green);
        }
        
        .control-dot.active {
            background: rgba(0, 255, 65, 0.5);
            box-shadow: 0 0 20px var(--neon-green);
        }
        
        .control-label {
            font-size: 10px;
            position: absolute;
            bottom: -15px;
            width: 100%;
            text-align: center;
        }
        
        .unified-control {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid var(--neon-green);
            border-radius: 8px;
            background: rgba(0, 30, 0, 0.5);
        }
        
        .control-slider {
            width: 100%;
            margin: 10px 0;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .info-modal, .export-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .info-content, .export-content {
            background: rgba(0, 20, 0, 0.9);
            border: 2px solid var(--neon-green);
            border-radius: 10px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 30px var(--neon-green);
        }
        
        .info-content h2, .export-content h2 {
            text-align: center;
            margin-bottom: 20px;
            color: var(--neon-green);
        }
        
        .info-content p, .export-content p {
            margin-bottom: 15px;
            line-height: 1.6;
        }
        
        .info-content ul, .export-content ul {
            margin-left: 20px;
            margin-bottom: 15px;
        }
        
        .info-content li, .export-content li {
            margin-bottom: 8px;
        }
        
        .close-btn, .export-btn {
            background: rgba(0, 255, 65, 0.2);
            border: 1px solid var(--neon-green);
            color: var(--neon-green);
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            display: block;
            margin: 20px auto 0;
            font-family: 'Courier New', monospace;
        }
        
        .close-btn:hover, .export-btn:hover {
            background: rgba(0, 255, 65, 0.4);
        }
        
        .export-data {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--neon-green);
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
        }
        
        .hidden {
            display: none;
        }
        
        .crystallized-model {
            background: rgba(0, 40, 0, 0.6);
            border: 1px solid var(--neon-green);
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
        }
        
        .model-progress {
            height: 8px;
            background: rgba(0, 20, 0, 0.8);
            border-radius: 4px;
            margin: 5px 0;
            overflow: hidden;
        }
        
        .model-progress-bar {
            height: 100%;
            background: var(--neon-green);
            border-radius: 4px;
            transition: width 0.3s;
        }
        
        @media (max-width: 1024px) {
            .left-panel, .right-panel {
                width: 220px;
                min-width: 220px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="title">QUANTUM CHESS 3D ARENA</div>
            <div class="controls">
                <button id="start-btn" class="control-btn active">START</button>
                <button id="stop-btn" class="control-btn">STOP</button>
                <button id="reset-btn" class="control-btn">RESET</button>
                <button id="export-btn" class="control-btn">EXPORT</button>
                <button id="info-btn" class="control-btn">INFO</button>
            </div>
        </div>
        
        <div class="main-content">
            <div class="left-panel">
                <div class="panel-title">QUANTUM BLACK</div>
                <div class="agent-stats">
                    <div class="metric-item">
                        <span>Wins:</span>
                        <span id="black-wins">0</span>
                    </div>
                    <div class="metric-item">
                        <span>Losses:</span>
                        <span id="black-losses">0</span>
                    </div>
                    <div class="metric-item">
                        <span>Power:</span>
                        <span id="black-power">0</span>
                    </div>
                </div>
                
                <div class="panel-title">FOUNDATIONAL MODEL</div>
                <div class="crystallized-model">
                    <div class="metric-item">
                        <span>Knowledge Base:</span>
                        <span id="black-knowledge">0%</span>
                    </div>
                    <div class="model-progress">
                        <div class="model-progress-bar" id="black-progress" style="width: 0%"></div>
                    </div>
                    <div class="metric-item">
                        <span>Patterns:</span>
                        <span id="black-patterns">0</span>
                    </div>
                    <div class="metric-item">
                        <span>Experience:</span>
                        <span id="black-experience">0</span>
                    </div>
                </div>
                
                <div class="panel-title">STOCHASTIC CONTROL</div>
                <div class="unified-control">
                    <div class="slider-label">
                        <span>Exploration</span>
                        <span id="black-exploration-value">0.3</span>
                    </div>
                    <input type="range" min="0" max="1" step="0.01" value="0.3" class="control-slider" id="black-exploration">
                    
                    <div class="slider-label">
                        <span>Learning Rate</span>
                        <span id="black-learning-value">0.001</span>
                    </div>
                    <input type="range" min="0" max="0.01" step="0.0001" value="0.001" class="control-slider" id="black-learning">
                    
                    <div class="slider-label">
                        <span>Temperature</span>
                        <span id="black-temperature-value">1.0</span>
                    </div>
                    <input type="range" min="0.1" max="2" step="0.1" value="1.0" class="control-slider" id="black-temperature">
                </div>
            </div>
            
            <div class="center-panel">
                <div id="chess-scene"></div>
                <div class="status" id="game-status">Quantum Chess Arena - Auto Play Active</div>
                <div class="metrics">
                    <div class="metric-item">
                        <span>Move Count:</span>
                        <span id="move-count">0</span>
                    </div>
                    <div class="metric-item">
                        <span>Total Games:</span>
                        <span id="total-games">0</span>
                    </div>
                    <div class="metric-item">
                        <span>Model Maturity:</span>
                        <span id="model-maturity">0%</span>
                    </div>
                </div>
                <div class="quantum-effects" id="quantum-effects"></div>
            </div>
            
            <div class="right-panel">
                <div class="panel-title">NEON GREEN</div>
                <div class="agent-stats">
                    <div class="metric-item">
                        <span>Wins:</span>
                        <span id="green-wins">0</span>
                    </div>
                    <div class="metric-item">
                        <span>Losses:</span>
                        <span id="green-losses">0</span>
                    </div>
                    <div class="metric-item">
                        <span>Power:</span>
                        <span id="green-power">0</span>
                    </div>
                </div>
                
                <div class="panel-title">FOUNDATIONAL MODEL</div>
                <div class="crystallized-model">
                    <div class="metric-item">
                        <span>Knowledge Base:</span>
                        <span id="green-knowledge">0%</span>
                    </div>
                    <div class="model-progress">
                        <div class="model-progress-bar" id="green-progress" style="width: 0%"></div>
                    </div>
                    <div class="metric-item">
                        <span>Patterns:</span>
                        <span id="green-patterns">0</span>
                    </div>
                    <div class="metric-item">
                        <span>Experience:</span>
                        <span id="green-experience">0</span>
                    </div>
                </div>
                
                <div class="panel-title">STOCHASTIC CONTROL</div>
                <div class="unified-control">
                    <div class="slider-label">
                        <span>Exploration</span>
                        <span id="green-exploration-value">0.3</span>
                    </div>
                    <input type="range" min="0" max="1" step="0.01" value="0.3" class="control-slider" id="green-exploration">
                    
                    <div class="slider-label">
                        <span>Learning Rate</span>
                        <span id="green-learning-value">0.001</span>
                    </div>
                    <input type="range" min="0" max="0.01" step="0.0001" value="0.001" class="control-slider" id="green-learning">
                    
                    <div class="slider-label">
                        <span>Temperature</span>
                        <span id="green-temperature-value">1.0</span>
                    </div>
                    <input type="range" min="0.1" max="2" step="0.1" value="1.0" class="control-slider" id="green-temperature">
                </div>
            </div>
        </div>
    </div>

    <div id="info-modal" class="info-modal hidden">
        <div class="info-content">
            <h2>QUANTUM CHESS 3D ARENA</h2>
            <p>Welcome to the Quantum Chess 3D Arena, where AI agents battle using crystallized intelligence theory.</p>
            
            <h3>How It Works</h3>
            <p>This simulation features two AI agents playing chess with foundational models based on crystallized intelligence:</p>
            <ul>
                <li><strong>Quantum Black:</strong> Uses crystallized knowledge from repeated games</li>
                <li><strong>Neon Green:</strong> Leverages pattern recognition and experience</li>
                <li>Both agents build foundational models through continuous play</li>
            </ul>
            
            <h3>Crystallized Intelligence Theory</h3>
            <p>Agents develop knowledge through repeated exposure to chess patterns, forming a crystallized intelligence base that improves decision-making over time.</p>
            
            <h3>Stochastic Control System</h3>
            <p>Use the sliders to control agent behavior:</p>
            <ul>
                <li><strong>Exploration:</strong> Controls how much agents explore new strategies vs exploiting known patterns</li>
                <li><strong>Learning Rate:</strong> How quickly agents adapt to new information</li>
                <li><strong>Temperature:</strong> Controls randomness in decision-making</li>
            </ul>
            
            <h3>Controls</h3>
            <ul>
                <li><strong>START:</strong> Begin endless auto-play mode</li>
                <li><strong>STOP:</strong> Pause the simulation</li>
                <li><strong>RESET:</strong> Restart the game and clear models</li>
                <li><strong>EXPORT:</strong> Download training data as JSON</li>
                <li><strong>Mouse Drag:</strong> Rotate the 3D view 360°</li>
                <li><strong>Mouse Wheel:</strong> Zoom in/out</li>
            </ul>
            
            <button id="close-info" class="close-btn">CLOSE</button>
        </div>
    </div>

    <div id="export-modal" class="export-modal hidden">
        <div class="export-content">
            <h2>EXPORT TRAINING DATA</h2>
            <p>All training data from the current session is ready for export.</p>
            
            <div class="export-data" id="export-data-preview">
                <!-- JSON data will be displayed here -->
            </div>
            
            <p>The data includes agent statistics, foundational models, move history, and crystallized intelligence patterns.</p>
            
            <button id="download-json" class="export-btn">DOWNLOAD JSON FILE</button>
            <button id="close-export" class="close-btn">CLOSE</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script>
        // Three.js Chess Scene
        let scene, camera, renderer, controls;
        let chessBoard, pieces = [];
        let directionalLight, ambientLight;
        let isAnimating = false;
        
        // Game state with crystallized intelligence
        const gameState = {
            board: [],
            currentPlayer: 'green',
            gameOver: false,
            autoPlay: true,
            moveCount: 0,
            nodesSearched: 0,
            totalGames: 0,
            sessionStartTime: new Date().toISOString(),
            moveHistory: [],
            crystallizedModels: {
                black: {
                    knowledgeBase: 0,
                    patterns: [],
                    experience: 0,
                    winPatterns: [],
                    lossPatterns: []
                },
                green: {
                    knowledgeBase: 0,
                    patterns: [],
                    experience: 0,
                    winPatterns: [],
                    lossPatterns: []
                }
            }
        };
        
        // Agent statistics with foundational models
        const agents = {
            black: { 
                wins: 0, 
                losses: 0, 
                powerBall: 0,
                params: {
                    exploration: 0.3,
                    learning: 0.001,
                    temperature: 1.0
                },
                foundationalModel: {
                    maturity: 0,
                    strategicDepth: 1,
                    tacticalAwareness: 1
                }
            },
            green: { 
                wins: 0, 
                losses: 0, 
                powerBall: 0,
                params: {
                    exploration: 0.3,
                    learning: 0.001,
                    temperature: 1.0
                },
                foundationalModel: {
                    maturity: 0,
                    strategicDepth: 1,
                    tacticalAwareness: 1
                }
            }
        };
        
        // Initialize Three.js scene
        function initThreeJSScene() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.Fog(0x000000, 10, 50);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 15);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('chess-scene').appendChild(renderer.domElement);
            
            // Add orbit controls for 360° viewing
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 8;
            controls.maxDistance = 30;
            
            // Add lighting
            directionalLight = new THREE.DirectionalLight(0x00ff41, 1);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            ambientLight = new THREE.AmbientLight(0x003300, 0.3);
            scene.add(ambientLight);
            
            // Add point lights for neon effect
            const pointLight1 = new THREE.PointLight(0x00ff41, 0.5, 50);
            pointLight1.position.set(5, 10, 5);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0x00ff41, 0.5, 50);
            pointLight2.position.set(-5, 10, -5);
            scene.add(pointLight2);
            
            // Create chess board and pieces
            createChessBoard();
            setupInitialPieces();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Start animation loop
            animate();
        }
        
        function createChessBoard() {
            chessBoard = new THREE.Group();
            
            // Board base
            const boardGeometry = new THREE.BoxGeometry(10, 0.5, 10);
            const boardMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x001100,
                emissive: 0x001100,
                roughness: 0.8,
                metalness: 0.2
            });
            const board = new THREE.Mesh(boardGeometry, boardMaterial);
            board.receiveShadow = true;
            chessBoard.add(board);
            
            // Chess squares
            const squareSize = 1;
            const squareGeometry = new THREE.BoxGeometry(squareSize, 0.1, squareSize);
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const isLight = (row + col) % 2 === 0;
                    const squareMaterial = new THREE.MeshStandardMaterial({ 
                        color: isLight ? 0x003300 : 0x000000,
                        emissive: isLight ? 0x001100 : 0x000000
                    });
                    
                    const square = new THREE.Mesh(squareGeometry, squareMaterial);
                    square.position.set(col * squareSize - 3.5, 0.3, row * squareSize - 3.5);
                    square.receiveShadow = true;
                    chessBoard.add(square);
                }
            }
            
            scene.add(chessBoard);
        }
        
        function createPiece(type, color, row, col) {
            const pieceGroup = new THREE.Group();
            pieceGroup.userData = { type, color, row, col };
            
            let geometry;
            const pieceColor = color === 'black' ? 0x111111 : 0x00ff41;
            
            // Create piece geometries
            switch(type) {
                case 'pawn':
                    geometry = new THREE.CylinderGeometry(0.3, 0.4, 0.8, 16);
                    break;
                case 'rook':
                    geometry = new THREE.BoxGeometry(0.6, 0.8, 0.6);
                    break;
                case 'knight':
                    geometry = new THREE.ConeGeometry(0.4, 0.8, 4);
                    break;
                case 'bishop':
                    geometry = new THREE.ConeGeometry(0.3, 0.9, 8);
                    break;
                case 'queen':
                    geometry = new THREE.ConeGeometry(0.4, 1.0, 8);
                    break;
                case 'king':
                    geometry = new THREE.CylinderGeometry(0.3, 0.5, 1.0, 8);
                    break;
            }
            
            const material = new THREE.MeshStandardMaterial({ 
                color: pieceColor,
                emissive: pieceColor,
                roughness: 0.4,
                metalness: 0.6
            });
            
            const pieceMesh = new THREE.Mesh(geometry, material);
            pieceMesh.castShadow = true;
            pieceGroup.add(pieceMesh);
            pieceGroup.position.set(col - 3.5, 0.8, row - 3.5);
            
            scene.add(pieceGroup);
            pieces.push(pieceGroup);
            return pieceGroup;
        }
        
        function setupInitialPieces() {
            pieces.forEach(piece => scene.remove(piece));
            pieces = [];
            
            // Set up pawns
            for (let col = 0; col < 8; col++) {
                createPiece('pawn', 'black', 1, col);
                createPiece('pawn', 'green', 6, col);
            }
            
            // Set up other pieces
            const pieceOrder = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
            for (let col = 0; col < 8; col++) {
                createPiece(pieceOrder[col], 'black', 0, col);
                createPiece(pieceOrder[col], 'green', 7, col);
            }
            
            // Initialize game state
            for (let row = 0; row < 8; row++) {
                gameState.board[row] = [];
                for (let col = 0; col < 8; col++) {
                    const piece = pieces.find(p => p.userData.row === row && p.userData.col === col);
                    gameState.board[row][col] = piece ? {
                        type: piece.userData.type,
                        color: piece.userData.color
                    } : null;
                }
            }
        }
        
        function movePiece(fromRow, fromCol, toRow, toCol) {
            const piece = pieces.find(p => p.userData.row === fromRow && p.userData.col === fromCol);
            if (!piece) return;
            
            isAnimating = true;
            
            // Record move for crystallized intelligence
            const moveRecord = {
                player: gameState.currentPlayer,
                from: { row: fromRow, col: fromCol },
                to: { row: toRow, col: toCol },
                piece: piece.userData.type,
                timestamp: Date.now(),
                moveNumber: gameState.moveCount + 1
            };
            
            gameState.moveHistory.push(moveRecord);
            
            // Update game state
            gameState.board[toRow][toCol] = gameState.board[fromRow][fromCol];
            gameState.board[fromRow][fromCol] = null;
            
            // Handle captures
            const capturedPiece = pieces.find(p => 
                p.userData.row === toRow && p.userData.col === toCol && p !== piece);
                
            if (capturedPiece) {
                moveRecord.captured = capturedPiece.userData.type;
                scene.remove(capturedPiece);
                pieces = pieces.filter(p => p !== capturedPiece);
            }
            
            // Animate movement
            const startPos = piece.position.clone();
            const endPos = new THREE.Vector3(toCol - 3.5, piece.position.y, toRow - 3.5);
            
            // Lift, move, and lower piece
            new TWEEN.Tween(piece.position)
                .to({ y: startPos.y + 2 }, 300)
                .easing(TWEEN.Easing.Quadratic.Out)
                .onComplete(() => {
                    new TWEEN.Tween(piece.position)
                        .to({ x: endPos.x, z: endPos.z }, 500)
                        .easing(TWEEN.Easing.Quadratic.InOut)
                        .onComplete(() => {
                            new TWEEN.Tween(piece.position)
                                .to({ y: endPos.y }, 300)
                                .easing(TWEEN.Easing.Quadratic.In)
                                .onComplete(() => {
                                    piece.userData.row = toRow;
                                    piece.userData.col = toCol;
                                    isAnimating = false;
                                    createQuantumEffect(piece.position.x, piece.position.y + 1, piece.position.z);
                                    
                                    // Update crystallized intelligence
                                    updateCrystallizedIntelligence(gameState.currentPlayer, moveRecord);
                                    
                                    // Continue auto-play
                                    if (gameState.autoPlay && !gameState.gameOver) {
                                        setTimeout(makeAIMove, 500);
                                    }
                                })
                                .start();
                        })
                        .start();
                })
                .start();
                
            // Update metrics
            gameState.moveCount++;
            gameState.nodesSearched += Math.floor(Math.random() * 100) + 10;
            updateMetrics();
            
            // Switch player
            gameState.currentPlayer = gameState.currentPlayer === 'green' ? 'black' : 'green';
            updateStatus();
        }
        
        function updateCrystallizedIntelligence(player, moveRecord) {
            const model = gameState.crystallizedModels[player];
            
            // Add pattern to knowledge base
            const patternKey = `${moveRecord.from.row},${moveRecord.from.col}-${moveRecord.to.row},${moveRecord.to.col}`;
            if (!model.patterns.includes(patternKey)) {
                model.patterns.push(patternKey);
            }
            
            // Increase experience
            model.experience++;
            
            // Update knowledge base (0-100%)
            model.knowledgeBase = Math.min(100, Math.floor((model.patterns.length / 100) * 100));
            
            // Update foundational model maturity
            agents[player].foundationalModel.maturity = Math.min(100, 
                Math.floor((model.experience / 50) * 100));
                
            // Update UI
            updateModelDisplay();
        }
        
        function makeAIMove() {
            if (gameState.gameOver || !gameState.autoPlay || isAnimating) return;
            
            const currentPieces = pieces.filter(p => p.userData.color === gameState.currentPlayer);
            if (currentPieces.length === 0) {
                endGame();
                return;
            }
            
            const randomPiece = currentPieces[Math.floor(Math.random() * currentPieces.length)];
            const fromRow = randomPiece.userData.row;
            const fromCol = randomPiece.userData.col;
            
            // Get possible moves using crystallized intelligence
            const possibleMoves = getPossibleMoves(fromRow, fromCol, randomPiece.userData.type);
            
            if (possibleMoves.length > 0) {
                const randomMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                movePiece(fromRow, fromCol, randomMove.row, randomMove.col);
            }
        }
        
        function getPossibleMoves(fromRow, fromCol, pieceType) {
            const possibleMoves = [];
            const player = gameState.currentPlayer;
            
            // Use crystallized intelligence to influence move selection
            const model = gameState.crystallizedModels[player];
            const explorationRate = agents[player].params.exploration;
            
            // Basic move patterns
            if (pieceType === 'pawn') {
                const direction = player === 'green' ? -1 : 1;
                
                // Forward move
                if (isInBounds(fromRow + direction, fromCol) && 
                    !pieces.find(p => p.userData.row === fromRow + direction && p.userData.col === fromCol)) {
                    possibleMoves.push({ row: fromRow + direction, col: fromCol });
                }
                
                // Captures
                for (let c of [fromCol - 1, fromCol + 1]) {
                    if (isInBounds(fromRow + direction, c) && 
                        pieces.find(p => p.userData.row === fromRow + direction && p.userData.col === c && 
                        p.userData.color !== player)) {
                        possibleMoves.push({ row: fromRow + direction, col: c });
                    }
                }
            } else {
                // For other pieces, use knowledge from crystallized intelligence
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if ((row !== fromRow || col !== fromCol)) {
                            const targetPiece = pieces.find(p => p.userData.row === row && p.userData.col === col);
                            if (!targetPiece || targetPiece.userData.color !== player) {
                                // Apply crystallized intelligence: prefer known patterns
                                const patternKey = `${fromRow},${fromCol}-${row},${col}`;
                                const isKnownPattern = model.patterns.includes(patternKey);
                                
                                // Higher knowledge base increases likelihood of choosing known patterns
                                if (isKnownPattern || Math.random() > explorationRate) {
                                    possibleMoves.push({ row, col });
                                }
                            }
                        }
                    }
                }
            }
            
            return possibleMoves;
        }
        
        function endGame() {
            gameState.gameOver = true;
            const winner = gameState.currentPlayer === 'green' ? 'black' : 'green';
            agents[winner].wins++;
            agents[gameState.currentPlayer].losses++;
            gameState.totalGames++;
            
            // Update crystallized intelligence with game result
            gameState.crystallizedModels[winner].winPatterns.push(...gameState.moveHistory
                .filter(m => m.player === winner)
                .slice(-5));
                
            updateStatus();
            updateMetrics();
            
            // Auto-reset after a delay
            setTimeout(() => {
                if (gameState.autoPlay) {
                    resetGame();
                }
            }, 2000);
        }
        
        function resetGame() {
            gameState.gameOver = false;
            gameState.moveCount = 0;
            gameState.moveHistory = [];
            gameState.currentPlayer = 'green';
            setupInitialPieces();
            updateStatus();
        }
        
        function isInBounds(row, col) {
            return row >= 0 && row < 8 && col >= 0 && col < 8;
        }
        
        function createQuantumEffect(x, y, z) {
            const effectContainer = document.getElementById('quantum-effects');
            
            for (let i = 0; i < 15; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                
                const screenX = 50 + (x + (Math.random() - 0.5) * 2) * 5;
                const screenY = 50 + (z + (Math.random() - 0.5) * 2) * 5;
                
                particle.style.left = `${screenX}%`;
                particle.style.top = `${screenY}%`;
                particle.style.animation = `particleFloat ${1000 + Math.random() * 1000}ms ease-out forwards`;
                
                effectContainer.appendChild(particle);
                
                setTimeout(() => {
                    if (effectContainer.contains(particle)) {
                        effectContainer.removeChild(particle);
                    }
                }, 2000);
            }
        }
        
        function updateStatus() {
            const statusElement = document.getElementById('game-status');
            
            if (gameState.gameOver) {
                const winner = agents.green.wins > agents.black.wins ? 'NEON GREEN' : 'QUANTUM BLACK';
                statusElement.textContent = `GAME OVER! ${winner} WINS!`;
                statusElement.style.color = winner === 'NEON GREEN' ? '#00ff41' : '#ffffff';
            } else {
                const playerName = gameState.currentPlayer === 'green' ? 'NEON GREEN' : 'QUANTUM BLACK';
                statusElement.textContent = `${playerName}'S TURN - Auto Play Active`;
                statusElement.style.color = gameState.currentPlayer === 'green' ? '#00ff41' : '#ffffff';
            }
        }
        
        function updateMetrics() {
            // Update agent stats
            document.getElementById('black-wins').textContent = agents.black.wins;
            document.getElementById('black-losses').textContent = agents.black.losses;
            document.getElementById('green-wins').textContent = agents.green.wins;
            document.getElementById('green-losses').textContent = agents.green.losses;
            
            // Update game stats
            document.getElementById('move-count').textContent = gameState.moveCount;
            document.getElementById('total-games').textContent = gameState.totalGames;
            
            // Calculate overall model maturity
            const totalMaturity = (agents.black.foundationalModel.maturity + agents.green.foundationalModel.maturity) / 2;
            document.getElementById('model-maturity').textContent = `${Math.round(totalMaturity)}%`;
        }
        
        function updateModelDisplay() {
            // Update black model
            document.getElementById('black-knowledge').textContent = `${gameState.crystallizedModels.black.knowledgeBase}%`;
            document.getElementById('black-progress').style.width = `${gameState.crystallizedModels.black.knowledgeBase}%`;
            document.getElementById('black-patterns').textContent = gameState.crystallizedModels.black.patterns.length;
            document.getElementById('black-experience').textContent = gameState.crystallizedModels.black.experience;
            
            // Update green model
            document.getElementById('green-knowledge').textContent = `${gameState.crystallizedModels.green.knowledgeBase}%`;
            document.getElementById('green-progress').style.width = `${gameState.crystallizedModels.green.knowledgeBase}%`;
            document.getElementById('green-patterns').textContent = gameState.crystallizedModels.green.patterns.length;
            document.getElementById('green-experience').textContent = gameState.crystallizedModels.green.experience;
        }
        
        function exportTrainingData() {
            const exportData = {
                metadata: {
                    sessionId: generateSessionId(),
                    sessionStart: gameState.sessionStartTime,
                    sessionEnd: new Date().toISOString(),
                    totalGames: gameState.totalGames,
                    totalMoves: gameState.moveCount
                },
                agents: {
                    black: {
                        ...agents.black,
                        crystallizedModel: gameState.crystallizedModels.black
                    },
                    green: {
                        ...agents.green,
                        crystallizedModel: gameState.crystallizedModels.green
                    }
                },
                gameHistory: gameState.moveHistory,
                foundationalModels: {
                    black: agents.black.foundationalModel,
                    green: agents.green.foundationalModel
                },
                trainingParameters: {
                    black: agents.black.params,
                    green: agents.green.params
                }
            };
            
            return JSON.stringify(exportData, null, 2);
        }
        
        function generateSessionId() {
            return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }
        
        function downloadJSON(data, filename) {
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename || 'quantum_chess_training_data.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Initialize the application
        function init() {
            initThreeJSScene();
            updateStatus();
            updateMetrics();
            updateModelDisplay();
            
            // Set up control sliders
            document.querySelectorAll('.control-slider').forEach(slider => {
                const agent = slider.id.split('-')[0];
                const param = slider.id.split('-')[1];
                const valueElement = document.getElementById(`${agent}-${param}-value`);
                
                slider.addEventListener('input', function() {
                    const value = this.value;
                    valueElement.textContent = value;
                    agents[agent].params[param] = parseFloat(value);
                });
            });
            
            // Set up control buttons
            document.getElementById('start-btn').addEventListener('click', function() {
                gameState.autoPlay = true;
                this.classList.add('active');
                document.getElementById('stop-btn').classList.remove('active');
                if (!isAnimating && !gameState.gameOver) {
                    makeAIMove();
                }
            });
            
            document.getElementById('stop-btn').addEventListener('click', function() {
                gameState.autoPlay = false;
                this.classList.add('active');
                document.getElementById('start-btn').classList.remove('active');
            });
            
            document.getElementById('reset-btn').addEventListener('click', function() {
                resetGame();
                // Reset crystallized intelligence
                gameState.crystallizedModels.black = { knowledgeBase: 0, patterns: [], experience: 0, winPatterns: [], lossPatterns: [] };
                gameState.crystallizedModels.green = { knowledgeBase: 0, patterns: [], experience: 0, winPatterns: [], lossPatterns: [] };
                agents.black.wins = 0;
                agents.black.losses = 0;
                agents.green.wins = 0;
                agents.green.losses = 0;
                gameState.totalGames = 0;
                updateMetrics();
                updateModelDisplay();
            });
            
            document.getElementById('export-btn').addEventListener('click', function() {
                const exportData = exportTrainingData();
                document.getElementById('export-data-preview').textContent = exportData;
                document.getElementById('export-modal').classList.remove('hidden');
            });
            
            document.getElementById('download-json').addEventListener('click', function() {
                const exportData = exportTrainingData();
                const filename = `quantum_chess_${new Date().toISOString().split('T')[0]}.json`;
                downloadJSON(exportData, filename);
            });
            
            document.getElementById('info-btn').addEventListener('click', function() {
                document.getElementById('info-modal').classList.remove('hidden');
            });
            
            document.getElementById('close-info').addEventListener('click', function() {
                document.getElementById('info-modal').classList.add('hidden');
            });
            
            document.getElementById('close-export').addEventListener('click', function() {
                document.getElementById('export-modal').classList.add('hidden');
            });
            
            // Start auto-play immediately
            makeAIMove();
        }
        
        // Start the application
        init();
    </script>
</body>
</html>