<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QUANTUM CHESS DASHBOARD</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
        }
        
        body { 
            font-family: 'Orbitron', monospace; 
            background: #000; 
            color: #00ff41; 
            overflow: hidden; 
            height: 100vh;
            width: 100vw;
            text-transform: uppercase;
        }
        
        /* Enhanced 80s Arcade Styling */
        .arcade-font {
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
        }
        
        .glitch-text {
            text-shadow: 
                1px 0 #ff00ff, 
                -1px 0 #00ffff,
                0 0 5px #ff00ff,
                0 0 10px #00ffff;
            animation: glitch 0.3s infinite;
        }
        
        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-1px, 1px); }
            40% { transform: translate(-1px, -1px); }
            60% { transform: translate(1px, 1px); }
            80% { transform: translate(1px, -1px); }
            100% { transform: translate(0); }
        }
        
        .neon-text {
            text-shadow: 
                0 0 5px currentColor,
                0 0 10px currentColor;
        }
        
        /* VHS Static Overlay */
        #vhs-static {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            z-index: 2000;
            pointer-events: none;
            opacity: 0;
            mix-blend-mode: screen;
            transition: opacity 0.5s;
        }
        
        .static-active {
            opacity: 1 !important;
        }
        
        /* Top Bar - Smaller buttons without glow */
        #top-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 40px;
            background: #000;
            border-bottom: 1px solid #00ff41;
            display: flex;
            align-items: center;
            padding: 0 5px;
            z-index: 1000;
        }
        
        .top-btn {
            padding: 5px 10px;
            margin: 0 3px;
            background: rgba(0, 255, 65, 0.1);
            border: 1px solid #00ff41;
            color: #00ff41;
            cursor: pointer;
            border-radius: 2px;
            font-family: 'Orbitron', monospace;
            font-size: 10px;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: none !important;
        }
        
        .top-btn:hover {
            background: rgba(0, 255, 65, 0.3);
        }
        
        .play-btn {
            background: rgba(0, 255, 65, 0.3);
        }
        
        .play-btn.active {
            background: rgba(0, 255, 65, 0.8);
        }
        
        .stop-btn {
            background: rgba(255, 0, 0, 0.3);
            border-color: #ff0000;
            color: #ff0000;
        }
        
        .stop-btn.active {
            background: rgba(255, 0, 0, 0.8);
        }
        
        .reset-btn {
            background: rgba(255, 255, 0, 0.3);
            border-color: #ffff00;
            color: #ffff00;
        }
        
        .auto-play-btn {
            background: rgba(0, 136, 255, 0.3);
            border-color: #0088ff;
            color: #0088ff;
        }
        
        .auto-play-btn.active {
            background: rgba(0, 136, 255, 0.8);
        }
        
        /* Main Container */
        .container {
            display: flex;
            height: calc(100vh - 120px);
            margin-top: 40px;
            flex-direction: row;
        }
        
        .panel { 
            width: 25%; 
            height: 100%; 
            position: relative; 
            overflow: hidden;
        }
        
        .center-panel { 
            width: 50%; 
            height: 100%; 
            position: relative; 
        }
        
        .black-panel { 
            background: linear-gradient(135deg, #000, #001100); 
            border-right: 1px solid #00ff41; 
        }
        
        .green-panel { 
            background: linear-gradient(135deg, #000, #110000); 
            border-left: 1px solid #00ff41; 
        }
        
        .center-panel { 
            background: #000; 
        }
        
        .panel-title { 
            position: absolute; 
            top: 5px; 
            left: 5px; 
            font-size: 12px; 
            z-index: 10; 
        }
        
        .black-panel .panel-title { 
            color: #ffffff; 
        }
        
        .green-panel .panel-title { 
            color: #00ff41; 
        }
        
        .center-panel .panel-title { 
            color: #00ff41; 
            text-align: center; 
            left: 0; 
            right: 0; 
        }
        
        /* XY Grids */
        .xy-grid-container {
            position: absolute;
            bottom: 5px;
            left: 5px;
            right: 5px;
            height: 150px;
            border: 1px solid #00ff41;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            padding: 3px;
        }
        
        .xy-grid-title {
            text-align: center;
            font-size: 10px;
            margin-bottom: 3px;
        }
        
        .xy-grid {
            flex: 1;
            position: relative;
            border: 1px solid #00ff41;
            background: rgba(0, 20, 0, 0.3);
        }
        
        .grid-dot {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s;
        }
        
        .green-dot {
            background: #00ff41;
            z-index: 3;
            box-shadow: 0 0 5px #00ff41;
        }
        
        .red-dot {
            background: #ff0000;
            z-index: 2;
            box-shadow: 0 0 5px #ff0000;
        }
        
        .blue-dot {
            background: #0088ff;
            z-index: 1;
            box-shadow: 0 0 5px #0088ff;
        }
        
        .grid-line {
            position: absolute;
            background: rgba(0, 255, 65, 0.3);
        }
        
        .grid-line.horizontal {
            width: 100%;
            height: 1px;
            left: 0;
        }
        
        .grid-line.vertical {
            width: 1px;
            height: 100%;
            top: 0;
        }
        
        .grid-center {
            position: absolute;
            width: 1px;
            height: 1px;
            background: #00ff41;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        /* Training Mode Buttons */
        .training-controls {
            position: absolute;
            bottom: 160px;
            left: 5px;
            right: 5px;
            display: flex;
            justify-content: space-between;
        }
        
        .mode-btn {
            padding: 4px 8px;
            background: rgba(0, 255, 65, 0.2);
            border: 1px solid #00ff41;
            color: #00ff41;
            cursor: pointer;
            border-radius: 2px;
            font-family: 'Orbitron', monospace;
            font-size: 9px;
            flex: 1;
            margin: 0 3px;
            text-align: center;
            font-weight: bold;
        }
        
        .mode-btn.active {
            background: rgba(0, 255, 65, 0.5);
        }
        
        /* Error Logs */
        .error-log {
            position: absolute;
            top: 160px;
            left: 5px;
            right: 5px;
            bottom: 160px;
            border: 1px solid #ff0000;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px;
            overflow-y: auto;
            font-size: 9px;
        }
        
        .error-entry {
            margin-bottom: 3px;
            color: #ff0000;
            border-bottom: 1px solid rgba(255, 0, 0, 0.3);
            padding-bottom: 3px;
        }
        
        /* Engine Optimization */
        .engine-optimization {
            position: absolute;
            top: 30px;
            left: 5px;
            right: 5px;
            height: 120px;
            border: 1px solid #00ff41;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px;
            overflow-y: auto;
            font-size: 9px;
        }
        
        .optimization-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 3px;
        }
        
        .optimization-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff0000;
        }
        
        .optimization-status.active {
            background: #00ff41;
        }
        
        /* QNN Metrics Console */
        #qnn-metrics {
            position: fixed;
            bottom: 0;
            left: 25%;
            width: 50%;
            height: 80px;
            background: rgba(0, 0, 0, 0.9);
            border-top: 1px solid #00ff41;
            border-left: 1px solid #00ff41;
            border-right: 1px solid #00ff41;
            padding: 5px;
            font-size: 9px;
            overflow-y: auto;
            z-index: 999;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
        }
        
        .metric-item {
            flex: 0 0 48%;
            margin-bottom: 3px;
            display: flex;
            justify-content: space-between;
        }
        
        /* Chess Board */
        #chess-board {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 400px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: 2px solid #00ff41;
            box-shadow: 0 0 10px #00ff41;
        }
        
        .chess-square {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        .chess-square.light {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .chess-square.dark {
            background: rgba(0, 0, 0, 0.5);
        }
        
        .chess-piece {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            z-index: 10;
        }
        
        .chess-piece.black {
            background: #222;
            color: #fff;
            border: 1px solid #fff;
        }
        
        .chess-piece.green {
            background: #003300;
            color: #00ff41;
            border: 1px solid #00ff41;
            box-shadow: 0 0 5px #00ff41;
        }
        
        .chess-piece.selected {
            box-shadow: 0 0 10px #ffff00;
        }
        
        .valid-move {
            position: absolute;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: rgba(0, 255, 65, 0.5);
            z-index: 5;
        }
        
        /* Score Board */
        #score-board {
            position: fixed;
            top: 50px;
            right: 10px;
            width: 250px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #00ff41;
            padding: 10px;
            z-index: 1001;
            display: none;
        }
        
        .score-title {
            text-align: center;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .score-section {
            margin-bottom: 10px;
        }
        
        .score-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 11px;
        }
        
        /* Info Panel */
        #info-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 4000;
            display: none;
            overflow-y: auto;
            padding: 20px;
            color: #00ff41;
        }
        
        .info-content {
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
        }
        
        .info-section {
            margin-bottom: 20px;
            border-bottom: 1px solid #00ff41;
            padding-bottom: 15px;
        }
        
        .info-title {
            font-size: 18px;
            margin-bottom: 10px;
            color: #00ff41;
        }
        
        .info-text {
            font-size: 14px;
            margin-bottom: 10px;
        }
        
        .close-btn {
            background: none;
            border: none;
            color: #00ff41;
            font-size: 20px;
            cursor: pointer;
            position: absolute;
            top: 10px;
            right: 10px;
        }
        
        /* Copyright */
        .copyright {
            position: fixed;
            bottom: 5px;
            right: 5px;
            font-size: 8px;
            color: #00ff41;
            opacity: 0.7;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <!-- VHS Static Overlay -->
    <div id="vhs-static"></div>
    
    <!-- Top Bar -->
    <div id="top-bar">
        <button id="score-board-btn" class="top-btn">SCORE BOARD</button>
        <button id="play-btn" class="top-btn play-btn">START</button>
        <button id="stop-btn" class="top-btn stop-btn">STOP</button>
        <button id="reset-btn" class="top-btn reset-btn">RESET</button>
        <button id="auto-play-btn" class="top-btn auto-play-btn">AUTO PLAY</button>
        <button id="info-btn" class="top-btn">INFO</button>
    </div>
    
    <!-- Main Container -->
    <div class="container">
        <!-- Left Panel (Black Agent) -->
        <div class="panel black-panel">
            <div class="panel-title arcade-font">AGENT 1: QUANTUM BLACK</div>
            <div class="status arcade-font" id="black-status">TRAINING QNN...</div>
            
            <!-- Engine Optimization -->
            <div class="engine-optimization arcade-font">
                <div class="optimization-item">
                    <span>ALPHA-BETA</span>
                    <div class="optimization-status active"></div>
                </div>
                <div class="optimization-item">
                    <span>MOVE ORDERING</span>
                    <div class="optimization-status active"></div>
                </div>
                <div class="optimization-item">
                    <span>TRANSPOSITION</span>
                    <div class="optimization-status active"></div>
                </div>
                <div class="optimization-item">
                    <span>QUIESCENCE</span>
                    <div class="optimization-status active"></div>
                </div>
                <div class="optimization-item">
                    <span>ITERATIVE DEEP</span>
                    <div class="optimization-status active"></div>
                </div>
            </div>
            
            <!-- Error Log -->
            <div class="error-log arcade-font" id="black-error-log">
                <div class="error-entry">SYSTEM INITIALIZED</div>
            </div>
            
            <!-- Training Controls -->
            <div class="training-controls">
                <button id="black-fast-btn" class="mode-btn arcade-font">FAST</button>
                <button id="black-slow-btn" class="mode-btn arcade-font active">DEEP</button>
            </div>
            
            <!-- XY Grid -->
            <div class="xy-grid-container">
                <div class="xy-grid-title arcade-font">QNN TRAINING CONTROLLER</div>
                <div class="xy-grid" id="black-xy-grid">
                    <!-- Grid lines -->
                    <div class="grid-line horizontal" style="top: 25%"></div>
                    <div class="grid-line horizontal" style="top: 50%"></div>
                    <div class="grid-line horizontal" style="top: 75%"></div>
                    <div class="grid-line vertical" style="left: 25%"></div>
                    <div class="grid-line vertical" style="left: 50%"></div>
                    <div class="grid-line vertical" style="left: 75%"></div>
                    <div class="grid-center"></div>
                    
                    <!-- Dots -->
                    <div class="grid-dot green-dot" id="black-green-dot" style="left: 50%; top: 50%;"></div>
                    <div class="grid-dot red-dot" id="black-red-dot" style="left: 50%; top: 50%;"></div>
                    <div class="grid-dot blue-dot" id="black-blue-dot" style="left: 50%; top: 50%;"></div>
                </div>
            </div>
        </div>
        
        <!-- Center Panel with Chess Board -->
        <div class="center-panel">
            <div class="panel-title arcade-font glitch-text">QUANTUM CHESS ARENA</div>
            <div id="chess-board">
                <!-- Chess board will be generated by JavaScript -->
            </div>
        </div>
        
        <!-- Right Panel (Green Agent) -->
        <div class="panel green-panel">
            <div class="panel-title arcade-font">AGENT 2: NEON QUANTUM</div>
            <div class="status arcade-font" id="green-status">TRAINING QNN...</div>
            
            <!-- Engine Optimization -->
            <div class="engine-optimization arcade-font">
                <div class="optimization-item">
                    <span>ALPHA-BETA</span>
                    <div class="optimization-status active"></div>
                </div>
                <div class="optimization-item">
                    <span>MOVE ORDERING</span>
                    <div class="optimization-status active"></div>
                </div>
                <div class="optimization-item">
                    <span>TRANSPOSITION</span>
                    <div class="optimization-status active"></div>
                </div>
                <div class="optimization-item">
                    <span>QUIESCENCE</span>
                    <div class="optimization-status active"></div>
                </div>
                <div class="optimization-item">
                    <span>ITERATIVE DEEP</span>
                    <div class="optimization-status active"></div>
                </div>
            </div>
            
            <!-- Error Log -->
            <div class="error-log arcade-font" id="green-error-log">
                <div class="error-entry">SYSTEM INITIALIZED</div>
            </div>
            
            <!-- Training Controls -->
            <div class="training-controls">
                <button id="green-fast-btn" class="mode-btn arcade-font">FAST</button>
                <button id="green-slow-btn" class="mode-btn arcade-font active">DEEP</button>
            </div>
            
            <!-- XY Grid -->
            <div class="xy-grid-container">
                <div class="xy-grid-title arcade-font">QNN TRAINING CONTROLLER</div>
                <div class="xy-grid" id="green-xy-grid">
                    <!-- Grid lines -->
                    <div class="grid-line horizontal" style="top: 25%"></div>
                    <div class="grid-line horizontal" style="top: 50%"></div>
                    <div class="grid-line horizontal" style="top: 75%"></div>
                    <div class="grid-line vertical" style="left: 25%"></div>
                    <div class="grid-line vertical" style="left: 50%"></div>
                    <div class="grid-line vertical" style="left: 75%"></div>
                    <div class="grid-center"></div>
                    
                    <!-- Dots -->
                    <div class="grid-dot green-dot" id="green-green-dot" style="left: 50%; top: 50%;"></div>
                    <div class="grid-dot red-dot" id="green-red-dot" style="left: 50%; top: 50%;"></div>
                    <div class="grid-dot blue-dot" id="green-blue-dot" style="left: 50%; top: 50%;"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- QNN Metrics Console -->
    <div id="qnn-metrics" class="arcade-font">
        <div class="metric-item">
            <span>NODES SEARCHED:</span>
            <span id="nodes-searched">0</span>
        </div>
        <div class="metric-item">
            <span>CACHE HIT RATE:</span>
            <span id="cache-hit-rate">0%</span>
        </div>
        <div class="metric-item">
            <span>AVG DEPTH:</span>
            <span id="average-depth">0</span>
        </div>
        <div class="metric-item">
            <span>QNP EFFICIENCY:</span>
            <span id="qnp-efficiency">0%</span>
        </div>
        <div class="metric-item">
            <span>GAN EFFICIENCY:</span>
            <span id="gan-efficiency">0%</span>
        </div>
        <div class="metric-item">
            <span>MEMORY USAGE:</span>
            <span id="memory-usage">0 MB</span>
        </div>
        <div class="metric-item">
            <span>TRAINING SPEED:</span>
            <span id="training-speed">1.0x</span>
        </div>
        <div class="metric-item">
            <span>MOVE COUNT:</span>
            <span id="move-count">0</span>
        </div>
    </div>
    
    <!-- Score Board -->
    <div id="score-board">
        <div class="score-title arcade-font">QUANTUM CHESS SCOREBOARD</div>
        <div class="score-section">
            <div class="score-row">
                <span>BLACK AGENT:</span>
                <span id="black-score">0</span>
            </div>
            <div class="score-row">
                <span>WINS:</span>
                <span id="black-wins">0</span>
            </div>
            <div class="score-row">
                <span>LOSSES:</span>
                <span id="black-losses">0</span>
            </div>
            <div class="score-row">
                <span>POWER BALL:</span>
                <span id="black-power">0</span>
            </div>
        </div>
        <div class="score-section">
            <div class="score-row">
                <span>GREEN AGENT:</span>
                <span id="green-score">0</span>
            </div>
            <div class="score-row">
                <span>WINS:</span>
                <span id="green-wins">0</span>
            </div>
            <div class="score-row">
                <span>LOSSES:</span>
                <span id="green-losses">0</span>
            </div>
            <div class="score-row">
                <span>POWER BALL:</span>
                <span id="green-power">0</span>
            </div>
        </div>
        <div class="score-section">
            <div class="score-row">
                <span>TOTAL GAMES:</span>
                <span id="total-games">0</span>
            </div>
            <div class="score-row">
                <span>AVG MOVES/GAME:</span>
                <span id="avg-moves">0</span>
            </div>
        </div>
    </div>
    
    <!-- Info Panel -->
    <div id="info-panel">
        <button class="close-btn" id="close-info">✕</button>
        <div class="info-content">
            <div class="info-section">
                <h2 class="info-title arcade-font">QUANTUM CHESS DASHBOARD MANUAL</h2>
                <p class="info-text">
                    Welcome to the Quantum Chess Dashboard - a revolutionary interface for training quantum neural networks through chess gameplay.
                </p>
            </div>

            <div class="info-section">
                <h2 class="info-title arcade-font">CONTROLS & INTERFACE</h2>
                <p class="info-text">
                    <strong>TOP BUTTONS:</strong><br>
                    - SCORE BOARD: View game statistics and agent performance<br>
                    - START/STOP: Control training sessions<br>
                    - RESET: Clear training data and restart<br>
                    - AUTO PLAY: Continuous training mode<br>
                    - INFO: Display this manual
                </p>
                <p class="info-text">
                    <strong>AGENT PANELS:</strong><br>
                    Left (Black) and Right (Green) panels display agent-specific data including:<br>
                    - Engine optimization status<br>
                    - Error logs<br>
                    - Training mode controls (FAST/DEEP)<br>
                    - QNN training controllers with XY grids
                </p>
            </div>

            <div class="info-section">
                <h2 class="info-title arcade-font">QNN TRAINING CONTROLLER</h2>
                <p class="info-text">
                    Each agent has an XY grid controller with three dots:<br>
                    - <span style="color: #00ff41">GREEN DOT</span>: User-controlled training parameters<br>
                    - <span style="color: #ff0000">RED DOT</span>: Vector space of agent's moves on chess board<br>
                    - <span style="color: #0088ff">BLUE DOT</span>: Powerball RNG balancing logic
                </p>
                <p class="info-text">
                    Drag the green dot to adjust training parameters in real-time:<br>
                    - X-Axis: Controls move speed (left = slower, right = faster)<br>
                    - Y-Axis: Controls logic curve (bottom = shorter, top = longer)
                </p>
            </div>

            <div class="info-section">
                <h2 class="info-title arcade-font">CHESS ENGINE OPTIMIZATIONS</h2>
                <p class="info-text">
                    Both agents utilize advanced chess engine optimizations:<br>
                    - Alpha-Beta Pruning with quantum enhancements<br>
                    - Move Ordering (TT-Move, MVV-LVA, Killer Moves)<br>
                    - Transposition Tables for position caching<br>
                    - Quiescence Search for stable positions<br>
                    - Iterative Deepening for optimal search depth
                </p>
            </div>

            <div class="info-section">
                <h2 class="info-title arcade-font">QNN METRICS CONSOLE</h2>
                <p class="info-text">
                    The bottom center console displays real-time QNN training metrics:<br>
                    - Nodes Searched: Total positions evaluated<br>
                    - Cache Hit Rate: Efficiency of position caching<br>
                    - Average Depth: Mean search depth per move<br>
                    - QNP Efficiency: Quantum Network Protocol performance<br>
                    - GAN Efficiency: Generative Adversarial Network convergence<br>
                    - Memory Usage: System resource utilization<br>
                    - Training Speed: Relative training pace<br>
                    - Move Count: Total moves in current session
                </p>
            </div>

            <div class="info-section">
                <h2 class="info-title arcade-font">QUANTUM NEURAL NETWORK TRAINING</h2>
                <p class="info-text">
                    Quantum Neural Networks (QNNs) leverage quantum computing principles:<br>
                    - Superposition allows simultaneous evaluation of multiple positions<br>
                    - Entanglement creates correlations between strategic patterns<br>
                    - Quantum interference amplifies promising move sequences<br>
                    - Quantum tunneling escapes local optima in strategy space
                </p>
                <p class="info-text">
                    The training process combines:<br>
                    - Reinforcement learning from game outcomes<br>
                    - Supervised learning from master games<br>
                    - Quantum-enhanced search algorithms<br>
                    - Adversarial training between agents
                </p>
            </div>

            <div class="info-section">
                <h2 class="info-title arcade-font">ERROR LOGGING & DIAGNOSTICS</h2>
                <p class="info-text">
                    Separate error logs for each agent track:<br>
                    - Illegal move attempts<br>
                    - Strategy convergence issues<br>
                    - Quantum state decoherence<br>
                    - Training instability<br>
                    - Performance degradation<br>
                    - Resource allocation problems
                </p>
            </div>
        </div>
    </div>
    
    <!-- Copyright -->
    <div class="copyright arcade-font">© 2025 WEBXOS QUANTUM CHESS</div>

    <script>
        // Quantum Chess Dashboard
        // Global variables
        let gameRunning = false;
        let autoPlayRunning = false;
        let gameInterval;
        let autoPlayInterval;
        let currentGameMode = 'ai-vs-ai';
        let blackTrainingMode = 'slow';
        let greenTrainingMode = 'slow';
        let moveCount = 0;
        let gameHistory = [];
        
        // Agent statistics
        const agents = {
            black: { 
                wins: 0,
                losses: 0,
                powerBall: 0,
                errors: []
            },
            green: { 
                wins: 0,
                losses: 0,
                powerBall: 0,
                errors: []
            }
        };

        // Chess board state
        let boardState = Array(8).fill().map(() => Array(8).fill(null));
        let selectedPiece = null;
        let currentPlayer = 'green'; // Green starts

        // Performance metrics
        const metrics = {
            nodesSearched: 0,
            cacheHitRate: 0,
            averageDepth: 0,
            qnpEfficiency: 0,
            ganEfficiency: 0,
            memoryUsage: 0,
            trainingSpeed: 1.0
        };

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initUI();
            initChessBoard();
            initXYGrids();
            initVHSEffect();
            updateMetrics();
            updateScoreBoard();
        });

        // Initialize UI elements and event listeners
        function initUI() {
            // Top bar buttons
            document.getElementById('score-board-btn').addEventListener('click', function() {
                const scoreBoard = document.getElementById('score-board');
                scoreBoard.style.display = scoreBoard.style.display === 'block' ? 'none' : 'block';
            });
            
            document.getElementById('play-btn').addEventListener('click', startGame);
            document.getElementById('stop-btn').addEventListener('click', stopGame);
            document.getElementById('reset-btn').addEventListener('click', resetGame);
            document.getElementById('auto-play-btn').addEventListener('click', toggleAutoPlay);
            document.getElementById('info-btn').addEventListener('click', function() {
                document.getElementById('info-panel').style.display = 'block';
            });
            
            // Training mode buttons
            document.getElementById('black-fast-btn').addEventListener('click', function() {
                setTrainingMode('black', 'fast');
            });
            
            document.getElementById('black-slow-btn').addEventListener('click', function() {
                setTrainingMode('black', 'slow');
            });
            
            document.getElementById('green-fast-btn').addEventListener('click', function() {
                setTrainingMode('green', 'fast');
            });
            
            document.getElementById('green-slow-btn').addEventListener('click', function() {
                setTrainingMode('green', 'slow');
            });
            
            // Close buttons
            document.getElementById('close-info').addEventListener('click', function() {
                document.getElementById('info-panel').style.display = 'none';
            });
        }

        // Initialize XY Grids with drag functionality
        function initXYGrids() {
            initXYGrid('black-xy-grid', 'black');
            initXYGrid('green-xy-grid', 'green');
        }
        
        function initXYGrid(gridId, agent) {
            const grid = document.getElementById(gridId);
            const greenDot = document.getElementById(`${agent}-green-dot`);
            const redDot = document.getElementById(`${agent}-red-dot`);
            const blueDot = document.getElementById(`${agent}-blue-dot`);
            
            let isDragging = false;
            
            // Mouse events
            grid.addEventListener('mousedown', startDrag);
            grid.addEventListener('mousemove', drag);
            grid.addEventListener('mouseup', endDrag);
            grid.addEventListener('mouseleave', endDrag);
            
            function startDrag(e) {
                isDragging = true;
                updateDotPosition(e);
                e.preventDefault();
            }
            
            function drag(e) {
                if (isDragging) {
                    updateDotPosition(e);
                    e.preventDefault();
                }
            }
            
            function endDrag() {
                isDragging = false;
            }
            
            function updateDotPosition(e) {
                const rect = grid.getBoundingClientRect();
                let clientX, clientY;
                
                if (e.type.includes('touch')) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                const x = Math.max(0, Math.min(clientX - rect.left, rect.width));
                const y = Math.max(0, Math.min(clientY - rect.top, rect.height));
                
                const xPercent = (x / rect.width) * 100;
                const yPercent = (y / rect.height) * 100;
                
                // Update green dot (user control)
                greenDot.style.left = `${xPercent}%`;
                greenDot.style.top = `${yPercent}%`;
                
                // Update red dot (vector space of moves)
                const redX = 50 + (Math.random() - 0.5) * 40;
                const redY = 50 + (Math.random() - 0.5) * 40;
                redDot.style.left = `${redX}%`;
                redDot.style.top = `${redY}%`;
                
                // Update blue dot (powerball RNG)
                const blueX = 25 + Math.random() * 50;
                const blueY = 25 + Math.random() * 50;
                blueDot.style.left = `${blueX}%`;
                blueDot.style.top = `${blueY}%`;
                
                // Update agent status
                document.getElementById(`${agent}-status`).textContent = 
                    `QNN TRAINING - X:${Math.round(xPercent)}% Y:${Math.round(yPercent)}%`;
                
                // Update metrics based on position
                updateTrainingParams(agent, xPercent, yPercent);
            }
        }

        // Update training parameters based on XY position
        function updateTrainingParams(agent, x, y) {
            // Update training speed based on X position
            metrics.trainingSpeed = (0.5 + (x / 100) * 1.5).toFixed(1);
            
            // Update GAN efficiency based on Y position
            metrics.ganEfficiency = Math.round(y);
            
            // Update memory usage based on both coordinates
            metrics.memoryUsage = Math.round(50 + (x / 100) * 200 + (y / 100) * 150);
            
            // Update metrics display
            updateMetrics();
        }

        // Initialize chess board
        function initChessBoard() {
            const chessBoard = document.getElementById('chess-board');
            chessBoard.innerHTML = '';
            
            // Create chess squares
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `chess-square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    
                    // Add click event for piece selection/movement
                    square.addEventListener('click', handleSquareClick);
                    
                    chessBoard.appendChild(square);
                }
            }
            
            // Set up initial pieces
            setupInitialPieces();
        }

        // Set up initial chess pieces
        function setupInitialPieces() {
            // Clear board
            boardState = Array(8).fill().map(() => Array(8).fill(null));
            
            // Set up black pieces (top)
            placePiece(0, 0, 'rook', 'black');
            placePiece(0, 1, 'knight', 'black');
            placePiece(0, 2, 'bishop', 'black');
            placePiece(0, 3, 'queen', 'black');
            placePiece(0, 4, 'king', 'black');
            placePiece(0, 5, 'bishop', 'black');
            placePiece(0, 6, 'knight', 'black');
            placePiece(0, 7, 'rook', 'black');
            
            for (let col = 0; col < 8; col++) {
                placePiece(1, col, 'pawn', 'black');
            }
            
            // Set up green pieces (bottom)
            placePiece(7, 0, 'rook', 'green');
            placePiece(7, 1, 'knight', 'green');
            placePiece(7, 2, 'bishop', 'green');
            placePiece(7, 3, 'queen', 'green');
            placePiece(7, 4, 'king', 'green');
            placePiece(7, 5, 'bishop', 'green');
            placePiece(7, 6, 'knight', 'green');
            placePiece(7, 7, 'rook', 'green');
            
            for (let col = 0; col < 8; col++) {
                placePiece(6, col, 'pawn', 'green');
            }
        }

        // Place a piece on the board
        function placePiece(row, col, type, color) {
            const square = document.querySelector(`.chess-square[data-row="${row}"][data-col="${col}"]`);
            const piece = document.createElement('div');
            piece.className = `chess-piece ${color}`;
            piece.dataset.type = type;
            piece.dataset.color = color;
            
            // Use Unicode chess symbols
            const symbols = {
                king: '♔',
                queen: '♕',
                rook: '♖',
                bishop: '♗',
                knight: '♘',
                pawn: '♙'
            };
            
            piece.textContent = symbols[type];
            square.appendChild(piece);
            
            // Update board state
            boardState[row][col] = { type, color, element: piece };
        }

        // Handle square clicks for piece selection and movement
        function handleSquareClick(event) {
            const square = event.currentTarget;
            const row = parseInt(square.dataset.row);
            const col = parseInt(square.dataset.col);
            
            // If a piece is already selected
            if (selectedPiece) {
                // Try to move the selected piece to this square
                if (isValidMove(selectedPiece.row, selectedPiece.col, row, col)) {
                    movePiece(selectedPiece.row, selectedPiece.col, row, col);
                    clearSelection();
                    
                    // Switch player
                    currentPlayer = currentPlayer === 'green' ? 'black' : 'green';
                    
                    // Update game state
                    moveCount++;
                    updateMetrics();
                    
                    // If auto play is on, make AI move
                    if (autoPlayRunning && !gameRunning) {
                        setTimeout(makeAIMove, 500);
                    }
                } else {
                    // Invalid move, clear selection
                    clearSelection();
                }
            } else {
                // Select a piece if it belongs to current player
                const piece = boardState[row][col];
                if (piece && piece.color === currentPlayer) {
                    selectedPiece = { row, col, element: piece.element };
                    piece.element.classList.add('selected');
                    
                    // Show valid moves
                    showValidMoves(row, col);
                }
            }
        }

        // Show valid moves for a piece
        function showValidMoves(row, col) {
            const piece = boardState[row][col];
            if (!piece) return;
            
            // For simplicity, we'll show a basic set of moves
            // In a real implementation, this would use proper chess rules
            
            const moves = [];
            
            if (piece.type === 'pawn') {
                // Pawn moves
                const direction = piece.color === 'black' ? 1 : -1;
                
                // Forward move
                if (isInBounds(row + direction, col) && !boardState[row + direction][col]) {
                    moves.push({ row: row + direction, col: col });
                    
                    // Double move from starting position
                    if ((piece.color === 'black' && row === 1) || (piece.color === 'green' && row === 6)) {
                        if (!boardState[row + 2 * direction][col]) {
                            moves.push({ row: row + 2 * direction, col: col });
                        }
                    }
                }
                
                // Captures
                const captureOffsets = [{r: direction, c: -1}, {r: direction, c: 1}];
                for (let offset of captureOffsets) {
                    const newRow = row + offset.r;
                    const newCol = col + offset.c;
                    if (isInBounds(newRow, newCol) && boardState[newRow][newCol] && 
                        boardState[newRow][newCol].color !== piece.color) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            } else if (piece.type === 'knight') {
                // Knight moves
                const knightMoves = [
                    {r: -2, c: -1}, {r: -2, c: 1},
                    {r: -1, c: -2}, {r: -1, c: 2},
                    {r: 1, c: -2}, {r: 1, c: 2},
                    {r: 2, c: -1}, {r: 2, c: 1}
                ];
                
                for (let move of knightMoves) {
                    const newRow = row + move.r;
                    const newCol = col + move.c;
                    if (isInBounds(newRow, newCol) && 
                        (!boardState[newRow][newCol] || boardState[newRow][newCol].color !== piece.color)) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            }
            
            // Display valid moves
            for (let move of moves) {
                const square = document.querySelector(`.chess-square[data-row="${move.row}"][data-col="${move.col}"]`);
                const indicator = document.createElement('div');
                indicator.className = 'valid-move';
                square.appendChild(indicator);
            }
        }

        // Check if a move is valid
        function isValidMove(fromRow, fromCol, toRow, toCol) {
            // For simplicity, we'll accept any move to an empty square or capture
            // In a real implementation, this would use proper chess rules
            
            const piece = boardState[fromRow][fromCol];
            if (!piece) return false;
            
            // Check if destination has a piece of the same color
            if (boardState[toRow][toCol] && boardState[toRow][toCol].color === piece.color) {
                return false;
            }
            
            // Basic move validation based on piece type
            if (piece.type === 'pawn') {
                const direction = piece.color === 'black' ? 1 : -1;
                
                // Forward move
                if (fromCol === toCol && !boardState[toRow][toCol]) {
                    if (toRow === fromRow + direction) return true;
                    if ((piece.color === 'black' && fromRow === 1 && toRow === 3 && !boardState[2][toCol]) ||
                        (piece.color === 'green' && fromRow === 6 && toRow === 4 && !boardState[5][toCol])) {
                        return true;
                    }
                }
                
                // Capture
                if (Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction && 
                    boardState[toRow][toCol] && boardState[toRow][toCol].color !== piece.color) {
                    return true;
                }
            } else if (piece.type === 'knight') {
                const rowDiff = Math.abs(fromRow - toRow);
                const colDiff = Math.abs(fromCol - toCol);
                return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
            }
            
            // For other pieces, accept any move for now
            return true;
        }

        // Move a piece on the board
        function movePiece(fromRow, fromCol, toRow, toCol) {
            const piece = boardState[fromRow][fromCol];
            if (!piece) return;
            
            // Capture piece if destination is occupied
            if (boardState[toRow][toCol]) {
                const capturedPiece = boardState[toRow][toCol];
                capturedPiece.element.remove();
                
                // Update power ball score
                agents[piece.color].powerBall += 5;
                updateScoreBoard();
                
                // Log capture
                logError(piece.color === 'black' ? 'green' : 'black', 
                         `PIECE CAPTURED: ${capturedPiece.type} at ${toRow},${toCol}`);
            }
            
            // Move piece
            const toSquare = document.querySelector(`.chess-square[data-row="${toRow}"][data-col="${toCol}"]`);
            toSquare.appendChild(piece.element);
            
            // Update board state
            boardState[toRow][toCol] = piece;
            boardState[fromRow][fromCol] = null;
            
            // Update metrics
            metrics.nodesSearched += Math.floor(Math.random() * 100) + 10;
            metrics.cacheHitRate = Math.min(100, metrics.cacheHitRate + Math.random() * 5);
            metrics.averageDepth = Math.floor(Math.random() * 8) + 3;
            metrics.qnpEfficiency = Math.min(100, metrics.qnpEfficiency + Math.random() * 3);
            
            updateMetrics();
            
            // Check for game end conditions
            checkGameEnd();
        }

        // Check if coordinates are within board bounds
        function isInBounds(row, col) {
            return row >= 0 && row < 8 && col >= 0 && col < 8;
        }

        // Clear piece selection and valid move indicators
        function clearSelection() {
            if (selectedPiece) {
                selectedPiece.element.classList.remove('selected');
                selectedPiece = null;
            }
            
            // Clear valid move indicators
            const indicators = document.querySelectorAll('.valid-move');
            indicators.forEach(indicator => indicator.remove());
        }

        // Make an AI move
        function makeAIMove() {
            if (!gameRunning && autoPlayRunning) {
                // Find all pieces for current player
                const pieces = [];
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (boardState[row][col] && boardState[row][col].color === currentPlayer) {
                            pieces.push({ row, col });
                        }
                    }
                }
                
                if (pieces.length > 0) {
                    // Select a random piece
                    const randomPiece = pieces[Math.floor(Math.random() * pieces.length)];
                    
                    // Find valid moves for this piece
                    const validMoves = [];
                    for (let row = 0; row < 8; row++) {
                        for (let col = 0; col < 8; col++) {
                            if (isValidMove(randomPiece.row, randomPiece.col, row, col)) {
                                validMoves.push({ row, col });
                            }
                        }
                    }
                    
                    if (validMoves.length > 0) {
                        // Select a random valid move
                        const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
                        
                        // Make the move
                        movePiece(randomPiece.row, randomPiece.col, randomMove.row, randomMove.col);
                        
                        // Switch player
                        currentPlayer = currentPlayer === 'green' ? 'black' : 'green';
                        
                        // Continue auto play
                        if (autoPlayRunning) {
                            setTimeout(makeAIMove, 500 / metrics.trainingSpeed);
                        }
                    }
                }
            }
        }

        // Check for game end conditions
        function checkGameEnd() {
            // Check for king capture (simplified checkmate)
            let blackKing = false;
            let greenKing = false;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = boardState[row][col];
                    if (piece && piece.type === 'king') {
                        if (piece.color === 'black') blackKing = true;
                        if (piece.color === 'green') greenKing = true;
                    }
                }
            }
            
            if (!blackKing) {
                // Green wins
                agents.green.wins++;
                agents.black.losses++;
                logError('black', 'CHECKMATE - KING CAPTURED');
                endGame('green');
            } else if (!greenKing) {
                // Black wins
                agents.black.wins++;
                agents.green.losses++;
                logError('green', 'CHECKMATE - KING CAPTURED');
                endGame('black');
            }
            
            updateScoreBoard();
        }

        // End the game
        function endGame(winner) {
            stopGame();
            showVHSEffect(1500);
            
            // Log game result
            logError('black', `GAME ENDED - ${winner.toUpperCase()} WINS`);
            logError('green', `GAME ENDED - ${winner.toUpperCase()} WINS`);
            
            // Add to game history
            gameHistory.push({
                winner: winner,
                moves: moveCount,
                timestamp: new Date().toISOString()
            });
            
            // Reset for next game
            moveCount = 0;
            setupInitialPieces();
            currentPlayer = 'green';
            
            // If auto play is running, start a new game after a delay
            if (autoPlayRunning) {
                setTimeout(() => {
                    if (autoPlayRunning) {
                        startGame();
                    }
                }, 3000);
            }
        }

        // Game control functions
        function startGame() {
            if (gameRunning) return;
            
            gameRunning = true;
            document.getElementById('play-btn').classList.add('active');
            document.getElementById('stop-btn').classList.remove('active');
            
            logError('black', 'TRAINING SESSION STARTED');
            logError('green', 'TRAINING SESSION STARTED');
            
            // If auto play is on, start AI moves
            if (autoPlayRunning) {
                makeAIMove();
            }
        }
        
        function stopGame() {
            if (!gameRunning) return;
            
            gameRunning = false;
            document.getElementById('play-btn').classList.remove('active');
            document.getElementById('stop-btn').classList.add('active');
            
            logError('black', 'TRAINING SESSION PAUSED');
            logError('green', 'TRAINING SESSION PAUSED');
        }
        
        function resetGame() {
            stopGame();
            
            // Show VHS static effect
            showVHSEffect(1000);
            
            // Reset game state
            moveCount = 0;
            setupInitialPieces();
            currentPlayer = 'green';
            
            // Reset agent statistics
            agents.black.wins = 0;
            agents.black.losses = 0;
            agents.black.powerBall = 0;
            agents.black.errors = [];
            
            agents.green.wins = 0;
            agents.green.losses = 0;
            agents.green.powerBall = 0;
            agents.green.errors = [];
            
            // Reset metrics
            metrics.nodesSearched = 0;
            metrics.cacheHitRate = 0;
            metrics.averageDepth = 0;
            metrics.qnpEfficiency = 0;
            metrics.ganEfficiency = 0;
            metrics.memoryUsage = 0;
            metrics.trainingSpeed = 1.0;
            
            // Clear error logs
            document.getElementById('black-error-log').innerHTML = '<div class="error-entry">SYSTEM RESET</div>';
            document.getElementById('green-error-log').innerHTML = '<div class="error-entry">SYSTEM RESET</div>';
            
            // Update displays
            updateMetrics();
            updateScoreBoard();
            
            logError('black', 'SYSTEM RESET - READY FOR TRAINING');
            logError('green', 'SYSTEM RESET - READY FOR TRAINING');
        }
        
        function toggleAutoPlay() {
            if (autoPlayRunning) {
                autoPlayRunning = false;
                document.getElementById('auto-play-btn').classList.remove('active');
                logError('black', 'AUTO TRAINING DISABLED');
                logError('green', 'AUTO TRAINING DISABLED');
            } else {
                autoPlayRunning = true;
                document.getElementById('auto-play-btn').classList.add('active');
                logError('black', 'AUTO TRAINING ENABLED');
                logError('green', 'AUTO TRAINING ENABLED');
                
                // If game is running, start AI moves
                if (gameRunning) {
                    makeAIMove();
                }
            }
        }

        function setTrainingMode(agent, mode) {
            if (agent === 'black') {
                blackTrainingMode = mode;
                document.getElementById('black-fast-btn').classList.toggle('active', mode === 'fast');
                document.getElementById('black-slow-btn').classList.toggle('active', mode === 'slow');
            } else {
                greenTrainingMode = mode;
                document.getElementById('green-fast-btn').classList.toggle('active', mode === 'fast');
                document.getElementById('green-slow-btn').classList.toggle('active', mode === 'slow');
            }
            
            logError(agent, `TRAINING MODE SET TO ${mode.toUpperCase()}`);
        }

        // Log error to agent's error log
        function logError(agent, message) {
            const errorLog = document.getElementById(`${agent}-error-log`);
            const errorEntry = document.createElement('div');
            errorEntry.className = 'error-entry';
            errorEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            errorLog.appendChild(errorEntry);
            errorLog.scrollTop = errorLog.scrollHeight;
            
            // Store error in agent data
            agents[agent].errors.push({
                timestamp: new Date().toISOString(),
                message: message
            });
            
            // Limit error log size
            if (errorLog.children.length > 20) {
                errorLog.removeChild(errorLog.firstChild);
            }
        }

        // Update metrics display
        function updateMetrics() {
            document.getElementById('nodes-searched').textContent = metrics.nodesSearched.toLocaleString();
            document.getElementById('cache-hit-rate').textContent = Math.round(metrics.cacheHitRate) + '%';
            document.getElementById('average-depth').textContent = metrics.averageDepth;
            document.getElementById('qnp-efficiency').textContent = Math.round(metrics.qnpEfficiency) + '%';
            document.getElementById('gan-efficiency').textContent = Math.round(metrics.ganEfficiency) + '%';
            document.getElementById('memory-usage').textContent = metrics.memoryUsage + ' MB';
            document.getElementById('training-speed').textContent = metrics.trainingSpeed + 'x';
            document.getElementById('move-count').textContent = moveCount;
        }

        // Update score board
        function updateScoreBoard() {
            document.getElementById('black-score').textContent = agents.black.wins;
            document.getElementById('black-wins').textContent = agents.black.wins;
            document.getElementById('black-losses').textContent = agents.black.losses;
            document.getElementById('black-power').textContent = agents.black.powerBall;
            
            document.getElementById('green-score').textContent = agents.green.wins;
            document.getElementById('green-wins').textContent = agents.green.wins;
            document.getElementById('green-losses').textContent = agents.green.losses;
            document.getElementById('green-power').textContent = agents.green.powerBall;
            
            const totalGames = agents.black.wins + agents.black.losses;
            document.getElementById('total-games').textContent = totalGames;
            document.getElementById('avg-moves').textContent = totalGames > 0 ? 
                Math.round(moveCount / totalGames) : 0;
        }

        // VHS Static Effect
        function initVHSEffect() {
            const staticOverlay = document.getElementById('vhs-static');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            staticOverlay.appendChild(canvas);
            
            function drawStatic() {
                const imageData = ctx.createImageData(canvas.width, canvas.height);
                const data = imageData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    const value = Math.random() > 0.5 ? 255 : 0;
                    data[i] = value;     // R
                    data[i + 1] = value; // G
                    data[i + 2] = value; // B
                    data[i + 3] = Math.random() > 0.7 ? 150 : 0; // A
                }
                
                ctx.putImageData(imageData, 0, 0);
            }
            
            function animateStatic() {
                drawStatic();
                requestAnimationFrame(animateStatic);
            }
            
            animateStatic();
        }
        
        // Show VHS static effect
        function showVHSEffect(duration = 1000) {
            const staticOverlay = document.getElementById('vhs-static');
            staticOverlay.classList.add('static-active');
            
            setTimeout(() => {
                staticOverlay.classList.remove('static-active');
            }, duration);
        }
    </script>
</body>
</html>