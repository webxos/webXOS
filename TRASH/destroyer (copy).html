<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WEBXOS 2025 DESTROYER FPV DRONE TEST ENVIRONMENT v1.0 beta test</title>
    <style>
        body { 
            margin: 0; 
            background-color: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            touch-action: manipulation;
        }
        canvas { 
            display: block; 
        }
        #hud {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #0ff;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            text-shadow: 0 0 5px #0ff, 0 0 10px #0ff;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 1px solid #0ff;
            border-radius: 5px;
            box-shadow: 0 0 10px #0ff;
        }
        .hud-stat {
            margin: 5px 0;
        }
        #console {
            position: absolute;
            bottom: 60px;
            left: 10px;
            width: 300px;
            height: 100px;
            color: #0ff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px;
            border: 1px solid #0ff;
            overflow-y: auto;
            box-shadow: 0 0 10px #0ff;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background: transparent;
            border: 2px solid #0ff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 0 10px #0ff;
        }
        #controls {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            background: rgba(0, 0, 0, 0.7);
            color: #0ff;
            border: 1px solid #0ff;
            border-radius: 5px;
            cursor: pointer;
            touch-action: manipulation;
            text-shadow: 0 0 5px #0ff;
            box-shadow: 0 0 10px #0ff;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .glow {
            animation: glow 2s infinite alternate;
        }
        @keyframes glow {
            from {
                box-shadow: 0 0 5px #0ff, 0 0 10px #0ff;
                text-shadow: 0 0 5px #0ff, 0 0 10px #0ff;
            }
            to {
                box-shadow: 0 0 10px #0ff, 0 0 20px #0ff, 0 0 30px #0ff;
                text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
            }
        }
        #controller-status {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #0ff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 1px solid #0ff;
            border-radius: 5px;
            box-shadow: 0 0 10px #0ff;
        }
        #title {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #0ff;
            font-family: 'Courier New', monospace;
            font-size: 24px;
            text-align: center;
            text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border: 2px solid #0ff;
            border-radius: 10px;
            box-shadow: 0 0 20px #0ff;
            z-index: 100;
        }
        #instructions {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            color: #0ff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            text-align: center;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 1px solid #0ff;
            border-radius: 5px;
            box-shadow: 0 0 10px #0ff;
            max-width: 80%;
        }
        #mobile-controls {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 10;
        }
        .mobile-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.3);
            border: 2px solid #0ff;
            color: #0ff;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            touch-action: manipulation;
            box-shadow: 0 0 10px #0ff;
        }
    </style>
</head>
<body>
    <div id="title">
        WEBXOS 2025 DESTROYER<br>FPV DRONE TEST ENVIRONMENT<br>v1.0 beta test
        <div style="margin-top: 20px; font-size: 16px;">CLICK TO START</div>
    </div>
    <div id="controller-status">CONTROLLER: NOT DETECTED</div>
    <div id="hud">
        <div class="hud-stat">WAVE: <span id="wave">1</span></div>
        <div class="hud-stat">ENEMIES: <span id="enemies">0</span></div>
        <div class="hud-stat">SCORE: <span id="score">0</span></div>
        <div class="hud-stat">HEALTH: <span id="health">100</span></div>
        <div class="hud-stat">SHIELD: <span id="shield">100</span></div>
        <div class="hud-stat">DRONES: <span id="drones">0/3</span></div>
    </div>
    <div id="console"></div>
    <div id="crosshair"></div>
    <div id="instructions">
        CONTROLS: WASD/ARROWS = MOVE | MOUSE LEFT = FIRE | MOUSE RIGHT = LIGHTSPEED<br>
        CONTROLLER: LEFT STICK = MOVE | RIGHT TRIGGER = FIRE | LEFT TRIGGER = LIGHTSPEED<br>
        MOBILE: TILT TO MOVE | TAP BUTTONS FOR ACTIONS
    </div>
    <div id="mobile-controls">
        <div class="mobile-btn" id="mobileFire">FIRE</div>
        <div class="mobile-btn" id="mobileLightspeed">LIGHTSPEED</div>
    </div>
    <div id="controls">
        <button id="fireBtn">FIRE</button>
        <button id="lightspeedBtn">LIGHTSPEED</button>
        <button id="destroyBtn">DESTROY ALL</button>
        <button id="endGameBtn">END GAME</button>
    </div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { GlitchPass } from 'three/addons/postprocessing/GlitchPass.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Postprocessing
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        composer.addPass(bloomPass);
        const glitchPass = new GlitchPass();
        glitchPass.enabled = false;
        composer.addPass(glitchPass);

        // Camera position
        camera.position.z = 3;

        // Clock for 30 fps game loop
        const clock = new THREE.Clock();
        const fps = 30;
        const interval = 1 / fps;
        let delta = 0;

        // Game state
        let gameStarted = false;
        let spaceship = null;
        let playerPosition = new THREE.Vector3(0, 0, 0);
        let playerVelocity = new THREE.Vector3(0, 0, -0.2);
        let playerTilt = 0;
        let playerPitch = 0;
        let barrelRoll = 0;
        let turn360 = 0;
        let score = 0;
        let health = 100;
        let shield = 100;
        let dronesKilled = 0;
        let startTime = Date.now();
        let scoreTimeRatios = [];
        let lastRatioUpdate = Date.now();
        let autoPlay = false;
        let lastInputTime = Date.now();
        let wave = 1;

        // Track generation parameters
        const segmentLength = 20;
        const segmentCount = 15;
        const trackRadius = 5;
        const segments = [];
        let currentZ = 0;

        // UI Elements
        const waveElement = document.getElementById('wave');
        const enemiesElement = document.getElementById('enemies');
        const scoreElement = document.getElementById('score');
        const healthElement = document.getElementById('health');
        const shieldElement = document.getElementById('shield');
        const dronesElement = document.getElementById('drones');
        const consoleElement = document.getElementById('console');
        const titleElement = document.getElementById('title');
        const controllerStatusElement = document.getElementById('controller-status');
        const mobileControls = document.getElementById('mobile-controls');

        // Controller state
        let gamepadConnected = false;
        let gamepadIndex = null;

        // Check if mobile device
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        if (isMobile) {
            mobileControls.style.display = 'flex';
        }

        function logConsole(message) {
            consoleElement.innerHTML += `${message}<br>`;
            consoleElement.scrollTop = consoleElement.scrollHeight;
        }

        // Keyboard controls
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            up: false,
            left: false,
            down: false,
            right: false,
            e: false,
            q: false,
            z: false,
            x: false,
            c: false,
            shift: false,
            space: false,
            r: false,
            backtick: false,
            esc: false
        };
        window.addEventListener('keydown', (event) => {
            if (!gameStarted) {
                startGame();
                return;
            }
            if (event.key === 'w' || event.key === 'W') keys.w = true;
            if (event.key === 'a' || event.key === 'A') keys.a = true;
            if (event.key === 's' || event.key === 'S') keys.s = true;
            if (event.key === 'd' || event.key === 'D') keys.d = true;
            if (event.key === 'ArrowUp') keys.up = true;
            if (event.key === 'ArrowLeft') keys.left = true;
            if (event.key === 'ArrowDown') keys.down = true;
            if (event.key === 'ArrowRight') keys.right = true;
            if (event.key === 'e' || event.key === 'E') keys.e = true;
            if (event.key === 'q' || event.key === 'Q') keys.q = true;
            if (event.key === 'z' || event.key === 'Z') keys.z = true;
            if (event.key === 'x' || event.key === 'X') keys.x = true;
            if (event.key === 'c' || event.key === 'C') keys.c = true;
            if (event.key === 'Shift') keys.shift = true;
            if (event.key === ' ') keys.space = true;
            if (event.key === 'r' || event.key === 'R') keys.r = true;
            if (event.key === '`') keys.backtick = true;
            if (event.key === 'Escape') keys.esc = true;
            lastInputTime = Date.now();
        });
        window.addEventListener('keyup', (event) => {
            if (event.key === 'w' || event.key === 'W') keys.w = false;
            if (event.key === 'a' || event.key === 'A') keys.a = false;
            if (event.key === 's' || event.key === 'S') keys.s = false;
            if (event.key === 'd' || event.key === 'D') keys.d = false;
            if (event.key === 'ArrowUp') keys.up = false;
            if (event.key === 'ArrowLeft') keys.left = false;
            if (event.key === 'ArrowDown') keys.down = false;
            if (event.key === 'ArrowRight') keys.right = false;
            if (event.key === 'e' || event.key === 'E') keys.e = false;
            if (event.key === 'q' || event.key === 'Q') keys.q = false;
            if (event.key === 'z' || event.key === 'Z') keys.z = false;
            if (event.key === 'x' || event.key === 'X') keys.x = false;
            if (event.key === 'c' || event.key === 'C') keys.c = false;
            if (event.key === 'Shift') keys.shift = false;
            if (event.key === ' ') keys.space = false;
            if (event.key === 'r' || event.key === 'R') keys.r = false;
            if (event.key === '`') keys.backtick = false;
            if (event.key === 'Escape') keys.esc = false;
        });

        // Mouse controls
        let mouseLeftDown = false;
        let mouseRightDown = false;
        renderer.domElement.addEventListener('mousedown', (event) => {
            if (!gameStarted) {
                startGame();
                return;
            }
            if (event.button === 0) { // Left click
                mouseLeftDown = true;
                fireProjectiles(true);
            } else if (event.button === 2) { // Right click
                mouseRightDown = true;
                activateLightspeed();
            }
            lastInputTime = Date.now();
            event.preventDefault();
        });
        renderer.domElement.addEventListener('mouseup', (event) => {
            if (event.button === 0) {
                mouseLeftDown = false;
            } else if (event.button === 2) {
                mouseRightDown = false;
            }
            event.preventDefault();
        });
        // Prevent context menu on right click
        renderer.domElement.addEventListener('contextmenu', (event) => {
            event.preventDefault();
        });

        // Mobile touch controls
        const mobileFireBtn = document.getElementById('mobileFire');
        const mobileLightspeedBtn = document.getElementById('mobileLightspeed');
        
        mobileFireBtn.addEventListener('touchstart', (event) => {
            fireProjectiles(true);
            lastInputTime = Date.now();
            event.preventDefault();
        });
        
        mobileLightspeedBtn.addEventListener('touchstart', (event) => {
            activateLightspeed();
            lastInputTime = Date.now();
            event.preventDefault();
        });

        // Button controls
        const fireBtn = document.getElementById('fireBtn');
        const destroyBtn = document.getElementById('destroyBtn');
        const lightspeedBtn = document.getElementById('lightspeedBtn');
        const endGameBtn = document.getElementById('endGameBtn');
        fireBtn.addEventListener('click', () => { fireProjectiles(true); lastInputTime = Date.now(); });
        destroyBtn.addEventListener('click', () => { destroyAllDrones(); lastInputTime = Date.now(); });
        lightspeedBtn.addEventListener('click', () => { activateLightspeed(); lastInputTime = Date.now(); });
        endGameBtn.addEventListener('click', () => { endGame(); lastInputTime = Date.now(); });

        // Lightspeed state
        let isLightspeed = false;
        let lightspeedEndTime = 0;
        let lightspeedCooldownEnd = 0;

        // Destroy all state
        let canDestroyAll = true;

        // Tilt controls for mobile
        let tiltLR = 0;
        let tiltFB = 0;
        window.addEventListener('deviceorientation', (event) => {
            tiltLR = event.gamma ? event.gamma / 90 : 0;
            tiltFB = event.beta ? (event.beta - 45) / 90 : 0;
            lastInputTime = Date.now();
        }, true);

        // Gamepad support
        window.addEventListener("gamepadconnected", (e) => {
            gamepadConnected = true;
            gamepadIndex = e.gamepad.index;
            controllerStatusElement.textContent = `CONTROLLER: ${e.gamepad.id}`;
            logConsole(`Gamepad connected: ${e.gamepad.id}`);
        });

        window.addEventListener("gamepaddisconnected", (e) => {
            gamepadConnected = false;
            gamepadIndex = null;
            controllerStatusElement.textContent = "CONTROLLER: NOT DETECTED";
            logConsole("Gamepad disconnected");
        });

        function updateGamepad() {
            if (!gamepadConnected || gamepadIndex === null) return;
            
            const gamepad = navigator.getGamepads()[gamepadIndex];
            if (!gamepad) return;

            // Left stick for movement
            const deadZone = 0.1;
            let xAxis = Math.abs(gamepad.axes[0]) > deadZone ? gamepad.axes[0] : 0;
            let yAxis = Math.abs(gamepad.axes[1]) > deadZone ? -gamepad.axes[1] : 0; // Invert Y axis

            playerVelocity.x += xAxis * 0.02;
            playerVelocity.y += yAxis * 0.02;

            // Right trigger for fire
            if (gamepad.buttons[7] && gamepad.buttons[7].pressed) {
                fireProjectiles(true);
            }

            // Left trigger for lightspeed
            if (gamepad.buttons[6] && gamepad.buttons[6].pressed) {
                activateLightspeed();
            }

            // Buttons for special moves
            if (gamepad.buttons[0] && gamepad.buttons[0].pressed) { // A button
                barrelRoll += 0.1;
            }
            if (gamepad.buttons[1] && gamepad.buttons[1].pressed) { // B button
                barrelRoll -= 0.1;
            }
            if (gamepad.buttons[2] && gamepad.buttons[2].pressed) { // X button
                turn360 += 0.05;
            }
            if (gamepad.buttons[3] && gamepad.buttons[3].pressed) { // Y button
                turn360 -= 0.05;
            }
        }

        // Particle system for player trail
        const particlesGeometry = new THREE.BufferGeometry();
        const particleCount = 200;
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        for (let i = 0; i < particleCount; i++) {
            positions[i * 3] = 0;
            positions[i * 3 + 1] = 0;
            positions[i * 3 + 2] = 0;
            colors[i * 3] = 1;
            colors[i * 3 + 1] = 0;
            colors[i * 3 + 2] = 0;
        }
        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        const particleMaterial = new THREE.PointsMaterial({
            size: 0.1,
            vertexColors: true,
            transparent: true,
            opacity: 0.8
        });
        const particles = new THREE.Points(particlesGeometry, particleMaterial);
        scene.add(particles);

        // Stars
        const starGeometry = new THREE.BufferGeometry();
        const starCount = 2000;
        const starPositions = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount; i++) {
            starPositions[i * 3] = (Math.random() - 0.5) * 2000;
            starPositions[i * 3 + 1] = (Math.random() - 0.5) * 2000;
            starPositions[i * 3 + 2] = (Math.random() - 0.5) * 2000;
        }
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5 });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // Glowing stars
        const glowStarGeometry = new THREE.BufferGeometry();
        const glowStarCount = 100;
        const glowStarPositions = new Float32Array(glowStarCount * 3);
        for (let i = 0; i < glowStarCount; i++) {
            glowStarPositions[i * 3] = (Math.random() - 0.5) * 1500;
            glowStarPositions[i * 3 + 1] = (Math.random() - 0.5) * 1500;
            glowStarPositions[i * 3 + 2] = (Math.random() - 0.5) * 1500;
        }
        glowStarGeometry.setAttribute('position', new THREE.BufferAttribute(glowStarPositions, 3));
        const glowStarMaterial = new THREE.PointsMaterial({
            color: 0x00ffff,
            size: 2.0,
            transparent: true,
            opacity: 0.7
        });
        const glowStars = new THREE.Points(glowStarGeometry, glowStarMaterial);
        scene.add(glowStars);

        // Nebula effects
        const nebulaGeometry = new THREE.BufferGeometry();
        const nebulaCount = 20;
        const nebulaPositions = new Float32Array(nebulaCount * 3);
        const nebulaSizes = new Float32Array(nebulaCount);
        const nebulaColors = new Float32Array(nebulaCount * 3);
        for (let i = 0; i < nebulaCount; i++) {
            nebulaPositions[i * 3] = (Math.random() - 0.5) * 1000;
            nebulaPositions[i * 3 + 1] = (Math.random() - 0.5) * 1000;
            nebulaPositions[i * 3 + 2] = (Math.random() - 0.5) * 1000;
            nebulaSizes[i] = Math.random() * 50 + 20;
            
            const hue = Math.random();
            const color = new THREE.Color().setHSL(hue, 1, 0.5);
            nebulaColors[i * 3] = color.r;
            nebulaColors[i * 3 + 1] = color.g;
            nebulaColors[i * 3 + 2] = color.b;
        }
        nebulaGeometry.setAttribute('position', new THREE.BufferAttribute(nebulaPositions, 3));
        nebulaGeometry.setAttribute('size', new THREE.BufferAttribute(nebulaSizes, 1));
        nebulaGeometry.setAttribute('color', new THREE.BufferAttribute(nebulaColors, 3));
        const nebulaMaterial = new THREE.PointsMaterial({
            size: 1,
            vertexColors: true,
            transparent: true,
            opacity: 0.3,
            blending: THREE.AdditiveBlending
        });
        const nebulas = new THREE.Points(nebulaGeometry, nebulaMaterial);
        scene.add(nebulas);

        // Planets with rings
        const planets = [];
        for (let i = 0; i < 8; i++) {
            const planetGroup = new THREE.Group();
            const geometry = new THREE.IcosahedronGeometry(Math.random() * 8 + 3, 3);
            const material = new THREE.MeshBasicMaterial({ 
                color: new THREE.Color().setHSL(Math.random(), 1, 0.5),
                wireframe: true
            });
            const planet = new THREE.Mesh(geometry, material);
            planetGroup.add(planet);
            if (Math.random() > 0.3) {
                const ringGeometry = new THREE.TorusGeometry(Math.random() * 3 + 8, 0.5, 4, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.7
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2;
                planetGroup.add(ring);
            }
            planetGroup.position.set(
                (Math.random() - 0.5) * 500,
                (Math.random() - 0.5) * 500,
                (Math.random() - 0.5) * 1000 - 500
            );
            scene.add(planetGroup);
            planets.push(planetGroup);
        }

        // Drone swarms
        const drones = [];
        function createDrone() {
            const droneGroup = new THREE.Group();
            const coreGeometry = new THREE.IcosahedronGeometry(0.5, 1);
            const coreMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff0000,
                wireframe: true
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            droneGroup.add(core);
            for (let i = 0; i < 4; i++) {
                const spikeGeometry = new THREE.ConeGeometry(0.2, 0.6, 4);
                const spike = new THREE.Mesh(spikeGeometry, coreMaterial);
                spike.position.set(
                    Math.random() * 0.6 - 0.3,
                    Math.random() * 0.6 - 0.3,
                    Math.random() * 0.6 - 0.3
                );
                spike.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);
                droneGroup.add(spike);
            }
            return droneGroup;
        }
        function spawnDrone() {
            const drone = createDrone();
            drone.position.set(
                (Math.random() - 0.5) * trackRadius * 2,
                (Math.random() - 0.5) * trackRadius * 2,
                playerPosition.z - 30 - Math.random() * 20
            );
            scene.add(drone);
            drones.push(drone);
            enemiesElement.textContent = drones.length;
        }

        // Projectiles and missiles
        const projectiles = [];
        const missileGeometry = new THREE.SphereGeometry(0.2, 8, 8);
        const missileMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        let lastAutoFire = 0;
        function fireProjectiles(manual = false) {
            for (let i = -1; i <= 1; i++) {
                const projectile = new THREE.Mesh(missileGeometry, missileMaterial);
                projectile.position.copy(playerPosition);
                projectile.velocity = new THREE.Vector3(i * 0.05, 0, -0.5);
                scene.add(projectile);
                projectiles.push(projectile);
            }
            if (drones.length > 0) {
                const missile = new THREE.Mesh(missileGeometry, missileMaterial);
                missile.position.copy(playerPosition);
                missile.target = drones.reduce((closest, drone) => {
                    const dist = drone.position.distanceTo(playerPosition);
                    return !closest || dist < closest.dist ? { drone, dist } : closest;
                }, null).drone;
                missile.velocity = new THREE.Vector3(0, 0, -0.7);
                scene.add(missile);
                projectiles.push(missile);
            }
            if (manual) logConsole('Fired multishot and missile!');
        }

        // Destroy all drones
        function destroyAllDrones() {
            if (!canDestroyAll) return;
            drones.forEach(drone => {
                score += 10;
                dronesKilled++;
                scoreElement.textContent = score;
                scene.remove(drone);
                logConsole('Drone destroyed!');
            });
            drones.length = 0;
            enemiesElement.textContent = drones.length;
            canDestroyAll = false;
            destroyBtn.disabled = true;
        }

        // Lightspeed
        function activateLightspeed() {
            const now = Date.now();
            if (now < lightspeedCooldownEnd) return;
            isLightspeed = true;
            lightspeedEndTime = now + 10000;
            lightspeedCooldownEnd = now + 20000;
            lightspeedBtn.disabled = true;
            particleMaterial.size = 0.3;
            glitchPass.enabled = true;
            logConsole('Lightspeed activated!');
        }

        // End game
        function endGame() {
            const timePlayed = (Date.now() - startTime) / 1000;
            const finalRatio = (score / timePlayed) || 0;
            scoreTimeRatios.push(finalRatio);
            const medianRatio = scoreTimeRatios.length ? scoreTimeRatios.sort((a, b) => a - b)[Math.floor(scoreTimeRatios.length / 2)] : 0;
            const highScores = JSON.parse(localStorage.getItem('webxosDestroyerScores') || '[]');
            highScores.push({ score, time: timePlayed, ratio: medianRatio });
            highScores.sort((a, b) => b.score - a.score);
            highScores.splice(5); // Keep top 5
            localStorage.setItem('webxosDestroyerScores', JSON.stringify(highScores));
            let scoreText = `Game Over!\nDrones Killed: ${dronesKilled}\nTime Played: ${timePlayed.toFixed(2)}s\nFinal Score: ${score}\nMedian Score/Time Ratio: ${medianRatio.toFixed(2)}\n\nHigh Scores:\n`;
            highScores.forEach((s, i) => {
                scoreText += `${i + 1}. Score: ${s.score}, Time: ${s.time.toFixed(2)}s, Ratio: ${s.ratio.toFixed(2)}\n`;
            });
            alert(scoreText);
            score = 0;
            dronesKilled = 0;
            health = 100;
            shield = 100;
            scoreTimeRatios = [];
            startTime = Date.now();
            wave = 1;
            scoreElement.textContent = score;
            healthElement.textContent = health;
            shieldElement.textContent = shield;
            waveElement.textContent = wave;
            canDestroyAll = true;
            destroyBtn.disabled = false;
            logConsole('Game reset!');
        }

        // Enhanced track segment types with more variation
        const segmentTypes = [
            () => createStraightSegment(),
            () => createCurveSegment(1),
            () => createCurveSegment(-1),
            () => createSpiralSegment(1),
            () => createSpiralSegment(-1),
            () => createNarrowSegment(),
            () => createVerticalTubeSegment(),
            () => createObstacleSegment(),
            () => createWavySegment(),
            () => createHelixSegment(),
            () => createCorkscrewSegment(),
            () => createElevatorSegment()
        ];

        function createStraightSegment() {
            const shape = new THREE.Shape();
            const sides = 8;
            const radius = trackRadius;
            for (let i = 0; i < sides; i++) {
                const angle = (i / sides) * Math.PI * 2;
                shape.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
            }
            shape.closePath();
            const extrudeSettings = { depth: segmentLength, bevelEnabled: false };
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff, 
                side: THREE.DoubleSide,
                wireframe: true,
                transparent: true,
                opacity: 0.7
            });
            const segment = new THREE.Mesh(geometry, material);
            segment.rotation.x = Math.PI / 2;
            return segment;
        }

        function createCurveSegment(direction) {
            const path = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(direction * trackRadius * 2, 0, segmentLength / 2),
                new THREE.Vector3(0, 0, segmentLength)
            ]);
            const geometry = new THREE.TubeGeometry(path, 50, trackRadius, 24, false);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xff00ff, 
                side: THREE.DoubleSide,
                wireframe: true,
                transparent: true,
                opacity: 0.7
            });
            const segment = new THREE.Mesh(geometry, material);
            return segment;
        }

        function createSpiralSegment(direction) {
            const points = [];
            const spiralTurns = 0.5;
            for (let i = 0; i <= 50; i++) {
                const t = i / 50;
                const angle = t * Math.PI * 2 * spiralTurns;
                const x = Math.cos(angle) * trackRadius * direction;
                const y = Math.sin(angle) * trackRadius;
                const z = t * segmentLength;
                points.push(new THREE.Vector3(x, y, z));
            }
            const path = new THREE.CatmullRomCurve3(points);
            const geometry = new THREE.TubeGeometry(path, 50, trackRadius * 0.8, 24, false);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xffff00, 
                side: THREE.DoubleSide,
                wireframe: true,
                transparent: true,
                opacity: 0.7
            });
            const segment = new THREE.Mesh(geometry, material);
            return segment;
        }

        function createNarrowSegment() {
            const shape = new THREE.Shape();
            const sides = 8;
            const radius = trackRadius * 0.6; // Narrower
            for (let i = 0; i < sides; i++) {
                const angle = (i / sides) * Math.PI * 2;
                shape.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
            }
            shape.closePath();
            const extrudeSettings = { depth: segmentLength, bevelEnabled: false };
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xff0000, 
                side: THREE.DoubleSide,
                wireframe: true,
                transparent: true,
                opacity: 0.7
            });
            const segment = new THREE.Mesh(geometry, material);
            segment.rotation.x = Math.PI / 2;
            return segment;
        }

        function createVerticalTubeSegment() {
            const path = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, trackRadius * 2, segmentLength / 2),
                new THREE.Vector3(0, 0, segmentLength)
            ]);
            const geometry = new THREE.TubeGeometry(path, 50, trackRadius, 24, false);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00, 
                side: THREE.DoubleSide,
                wireframe: true,
                transparent: true,
                opacity: 0.7
            });
            const segment = new THREE.Mesh(geometry, material);
            return segment;
        }

        function createObstacleSegment() {
            const segment = createStraightSegment();
            // Add obstacles inside the segment
            const obstacleCount = 5;
            for (let i = 0; i < obstacleCount; i++) {
                const obstacleGeometry = new THREE.IcosahedronGeometry(0.5, 0);
                const obstacleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff0000,
                    wireframe: true
                });
                const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
                obstacle.position.set(
                    (Math.random() - 0.5) * trackRadius * 1.5,
                    (Math.random() - 0.5) * trackRadius * 1.5,
                    (Math.random() - 0.5) * segmentLength
                );
                segment.add(obstacle);
            }
            return segment;
        }

        function createWavySegment() {
            const path = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(trackRadius, trackRadius, segmentLength / 3),
                new THREE.Vector3(-trackRadius, -trackRadius, segmentLength * 2 / 3),
                new THREE.Vector3(0, 0, segmentLength)
            ]);
            const geometry = new THREE.TubeGeometry(path, 50, trackRadius * 0.9, 24, false);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xff8800, 
                side: THREE.DoubleSide,
                wireframe: true,
                transparent: true,
                opacity: 0.7
            });
            const segment = new THREE.Mesh(geometry, material);
            return segment;
        }

        function createHelixSegment() {
            const points = [];
            const helixTurns = 1;
            for (let i = 0; i <= 50; i++) {
                const t = i / 50;
                const angle = t * Math.PI * 2 * helixTurns;
                const x = Math.cos(angle) * trackRadius;
                const y = t * segmentLength / 2;
                const z = Math.sin(angle) * trackRadius;
                points.push(new THREE.Vector3(x, y, z));
            }
            const path = new THREE.CatmullRomCurve3(points);
            const geometry = new THREE.TubeGeometry(path, 50, trackRadius * 0.7, 24, false);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x8800ff, 
                side: THREE.DoubleSide,
                wireframe: true,
                transparent: true,
                opacity: 0.7
            });
            const segment = new THREE.Mesh(geometry, material);
            return segment;
        }

        function createCorkscrewSegment() {
            const points = [];
            const corkscrewTurns = 2;
            for (let i = 0; i <= 50; i++) {
                const t = i / 50;
                const angle = t * Math.PI * 2 * corkscrewTurns;
                const x = Math.cos(angle) * trackRadius * 0.8;
                const y = Math.sin(angle) * trackRadius * 0.8;
                const z = t * segmentLength;
                points.push(new THREE.Vector3(x, y, z));
            }
            const path = new THREE.CatmullRomCurve3(points);
            const geometry = new THREE.TubeGeometry(path, 50, trackRadius * 0.6, 24, false);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x00ff88, 
                side: THREE.DoubleSide,
                wireframe: true,
                transparent: true,
                opacity: 0.7
            });
            const segment = new THREE.Mesh(geometry, material);
            return segment;
        }

        function createElevatorSegment() {
            const points = [];
            for (let i = 0; i <= 50; i++) {
                const t = i / 50;
                const x = 0;
                const y = (t - 0.5) * segmentLength * 2;
                const z = t * segmentLength;
                points.push(new THREE.Vector3(x, y, z));
            }
            const path = new THREE.CatmullRomCurve3(points);
            const geometry = new THREE.TubeGeometry(path, 50, trackRadius, 24, false);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x88ff00, 
                side: THREE.DoubleSide,
                wireframe: true,
                transparent: true,
                opacity: 0.7
            });
            const segment = new THREE.Mesh(geometry, material);
            return segment;
        }

        // Initialize track
        function initTrack() {
            for (let i = 0; i < segmentCount; i++) {
                spawnSegment();
            }
            logConsole('Wave 1 started!');
        }

        function spawnSegment() {
            const segmentType = segmentTypes[Math.floor(Math.random() * segmentTypes.length)];
            const segment = segmentType();
            segment.position.z = currentZ - segmentLength * segments.length;
            scene.add(segment);
            segments.push(segment);
            currentZ -= segmentLength;

            if (segments.length > segmentCount) {
                const oldSegment = segments.shift();
                scene.remove(oldSegment);
                oldSegment.geometry.dispose();
                oldSegment.material.dispose();
            }
            wave++;
            waveElement.textContent = wave;
            canDestroyAll = true;
            destroyBtn.disabled = false;
            logConsole(`Wave ${wave} started!`);
        }

        // Load spaceship
        function loadSpaceship() {
            spaceship = new THREE.Group();
            const bodyGeometry = new THREE.ConeGeometry(0.5, 1.5, 8);
            const bodyMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff,
                wireframe: true
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.x = Math.PI / 2;
            spaceship.add(body);

            const wingGeometry = new THREE.CylinderGeometry(0.1, 0.3, 1.2, 4);
            const wing1 = new THREE.Mesh(wingGeometry, bodyMaterial);
            wing1.position.set(0.6, 0, 0);
            wing1.rotation.z = Math.PI / 2;
            spaceship.add(wing1);
            const wing2 = wing1.clone();
            wing2.position.set(-0.6, 0, 0);
            spaceship.add(wing2);

            const cockpitGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const cockpit = new THREE.Mesh(cockpitGeometry, bodyMaterial);
            cockpit.position.set(0, 0.2, 0.6);
            spaceship.add(cockpit);

            // Add engine glow
            const engineGlowGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const engineGlowMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.7
            });
            const engineGlow = new THREE.Mesh(engineGlowGeometry, engineGlowMaterial);
            engineGlow.position.set(0, 0, -0.8);
            spaceship.add(engineGlow);

            scene.add(spaceship);
        }

        // Rainbow effect with neon colors
        let hue = 0;
        function updateRainbowEffect() {
            hue = (hue + 0.01) % 1;
            const color = new THREE.Color().setHSL(hue, 1, 0.5);
            
            // Update HUD colors
            document.getElementById('hud').style.color = `hsl(${hue * 360}, 100%, 50%)`;
            document.getElementById('hud').style.borderColor = `hsl(${hue * 360}, 100%, 50%)`;
            document.getElementById('hud').style.boxShadow = `0 0 10px hsl(${hue * 360}, 100%, 50%)`;
            
            document.getElementById('console').style.color = `hsl(${hue * 360}, 100%, 50%)`;
            document.getElementById('console').style.borderColor = `hsl(${hue * 360}, 100%, 50%)`;
            document.getElementById('console').style.boxShadow = `0 0 10px hsl(${hue * 360}, 100%, 50%)`;
            
            document.getElementById('crosshair').style.borderColor = `hsl(${hue * 360}, 100%, 50%)`;
            document.getElementById('crosshair').style.boxShadow = `0 0 10px hsl(${hue * 360}, 100%, 50%)`;
            
            const buttons = document.querySelectorAll('button');
            buttons.forEach(btn => {
                btn.style.color = `hsl(${hue * 360}, 100%, 50%)`;
                btn.style.borderColor = `hsl(${hue * 360}, 100%, 50%)`;
                btn.style.boxShadow = `0 0 10px hsl(${hue * 360}, 100%, 50%)`;
            });

            // Update track and ship colors
            segments.forEach(segment => {
                segment.material.color.set(color);
            });
            if (spaceship) {
                spaceship.children.forEach(child => {
                    if (child.material) {
                        child.material.color.set(color);
                    }
                });
            }
            const colors = particlesGeometry.attributes.color.array;
            for (let i = 0; i < particleCount; i++) {
                const particleHue = (hue + i / particleCount) % 1;
                const particleColor = new THREE.Color().setHSL(particleHue, 1, 0.5);
                colors[i * 3] = particleColor.r;
                colors[i * 3 + 1] = particleColor.g;
                colors[i * 3 + 2] = particleColor.b;
            }
            particlesGeometry.attributes.color.needsUpdate = true;
            projectiles.forEach(projectile => {
                projectile.material.color.set(color);
            });
        }

        // Update particles
        function updateParticles() {
            const positions = particlesGeometry.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] += (Math.random() - 0.5) * 0.1;
                positions[i * 3 + 1] += (Math.random() - 0.5) * 0.1;
                positions[i * 3 + 2] -= isLightspeed ? 0.4 : 0.2;
                if (positions[i * 3 + 2] < playerPosition.z - 5) {
                    positions[i * 3] = playerPosition.x;
                    positions[i * 3 + 1] = playerPosition.y;
                    positions[i * 3 + 2] = playerPosition.z;
                }
            }
            particlesGeometry.attributes.position.needsUpdate = true;
        }

        // Update drones
        function updateDrones() {
            const spawnChance = 0.03 + (wave - 1) * 0.005;
            if (Math.random() < spawnChance) {
                spawnDrone();
            }
            const toRemove = [];
            drones.forEach((drone, index) => {
                // Make drones follow the track path
                const segmentIndex = Math.floor((playerPosition.z - drone.position.z) / segmentLength);
                if (segmentIndex >= 0 && segmentIndex < segments.length) {
                    const segment = segments[segmentIndex];
                    const targetPos = new THREE.Vector3(
                        segment.position.x,
                        segment.position.y,
                        drone.position.z
                    );
                    drone.position.lerp(targetPos, 0.01);
                }
                
                drone.position.x += (Math.random() - 0.5) * 0.05;
                drone.position.y += (Math.random() - 0.5) * 0.05;
                drone.rotation.y += 0.1;

                const screenPos = drone.position.clone().project(camera);
                const screenX = (screenPos.x + 1) * window.innerWidth / 2;
                const screenY = (-screenPos.y + 1) * window.innerHeight / 2;
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                const distance = Math.sqrt((screenX - centerX) ** 2 + (screenY - centerY) ** 2);

                if (distance < 25) {
                    toRemove.push(index);
                    score += 10;
                    dronesKilled++;
                    scoreElement.textContent = score;
                    logConsole('Drone destroyed!');
                    camera.position.x += (Math.random() - 0.5) * 0.2; // Screen shake
                    camera.position.y += (Math.random() - 0.5) * 0.2;
                }

                if (drone.position.z > playerPosition.z + 10) {
                    toRemove.push(index);
                }

                if (drone.position.distanceTo(playerPosition) < 1) {
                    health = Math.max(0, health - (shield > 0 ? 0 : 5));
                    shield = Math.max(0, shield - 5);
                    healthElement.textContent = health;
                    shieldElement.textContent = shield;
                    if (health <= 0) {
                        endGame();
                    }
                }
            });

            toRemove.reverse().forEach(index => {
                scene.remove(drones[index]);
                drones.splice(index, 1);
            });
            enemiesElement.textContent = drones.length;
        }

        // Update projectiles
        function updateProjectiles() {
            const toRemove = [];
            projectiles.forEach((projectile, index) => {
                if (projectile.target) {
                    const direction = new THREE.Vector3().subVectors(projectile.target.position, projectile.position).normalize().multiplyScalar(0.1);
                    projectile.velocity.add(direction);
                    projectile.velocity.clampLength(0, 0.7);
                }
                projectile.position.add(projectile.velocity);
                projectile.rotation.x += 0.1;
                projectile.rotation.y += 0.1;

                if (projectile.position.z < playerPosition.z - 50) {
                    toRemove.push(index);
                }

                drones.forEach((drone, droneIndex) => {
                    if (projectile.position.distanceTo(drone.position) < 1) {
                        toRemove.push(index);
                        scene.remove(drones[droneIndex]);
                        drones.splice(droneIndex, 1);
                        score += 10;
                        dronesKilled++;
                        scoreElement.textContent = score;
                        logConsole('Drone destroyed by missile!');
                    }
                });
            });

            toRemove.reverse().forEach(index => {
                scene.remove(projectiles[index]);
                projectiles.splice(index, 1);
            });
        }

        // Update track
        function updateTrack() {
            if (playerPosition.z < segments[segments.length - 1].position.z + segmentLength * 0.5) {
                spawnSegment();
            }
        }

        // Update lightspeed
        function updateLightspeed() {
            const now = Date.now();
            if (isLightspeed && now > lightspeedEndTime) {
                isLightspeed = false;
                particleMaterial.size = 0.1;
                glitchPass.enabled = false;
                logConsole('Lightspeed ended!');
            }
            if (now > lightspeedCooldownEnd) {
                lightspeedBtn.disabled = false;
            }
        }

        // Update auto play
        function updateAutoPlay() {
            if (Date.now() - lastInputTime > 10000) {
                if (!autoPlay) {
                    autoPlay = true;
                    logConsole('Auto play activated!');
                }
                if (Math.random() < 0.1) {
                    playerVelocity.x += (Math.random() - 0.5) * 0.01;
                    playerVelocity.y += (Math.random() - 0.5) * 0.01;
                }
                if (Math.random() < 0.05) {
                    fireProjectiles();
                }
                if (Math.random() < 0.01) {
                    activateLightspeed();
                }
            } else {
                if (autoPlay) {
                    autoPlay = false;
                    logConsole('Auto play deactivated!');
                }
            }
        }

        // Update score/time ratio
        function updateScoreTimeRatio() {
            const now = Date.now();
            if (now - lastRatioUpdate > 5000) {
                const timePlayed = (now - startTime) / 1000;
                const ratio = (score / timePlayed) || 0;
                scoreTimeRatios.push(ratio);
                lastRatioUpdate = now;
            }
        }

        // Start game
        function startGame() {
            if (gameStarted) return;
            gameStarted = true;
            titleElement.style.display = 'none';
            loadSpaceship();
            initTrack();
            logConsole('WEBXOS 2025 DESTROYER FPV DRONE TEST ENVIRONMENT v1.0 beta test');
            logConsole('All systems operational');
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            delta += clock.getDelta();
            if (delta > interval) {
                updateGame();
                delta = delta % interval;
            }
            composer.render();
        }

        function updateGame() {
            if (!gameStarted) return;

            // Update gamepad inputs
            updateGamepad();

            // Update player position
            const speed = isLightspeed ? 0.4 : 0.2;
            const turnSpeed = isLightspeed ? 0.02 : 0.04;
            playerVelocity.z = -speed;
            playerVelocity.x += (keys.a || keys.left) ? -turnSpeed : 0;
            playerVelocity.x += (keys.d || keys.right) ? turnSpeed : 0;
            playerVelocity.y += (keys.s || keys.down) ? -turnSpeed : 0;
            playerVelocity.y += (keys.w || keys.up) ? turnSpeed : 0;
            
            // Mobile tilt controls
            if (isMobile) {
                playerVelocity.x += tiltLR * turnSpeed * 2;
                playerVelocity.y += tiltFB * turnSpeed * 2;
            }
            
            playerVelocity.multiplyScalar(0.98);
            playerPosition.add(playerVelocity);

            // Update player tilt and pitch
            playerTilt = THREE.MathUtils.lerp(playerTilt, playerVelocity.x * 2, 0.1);
            playerPitch = THREE.MathUtils.lerp(playerPitch, playerVelocity.y * 2, 0.1);
            if (keys.q) barrelRoll += 0.1;
            if (keys.e) barrelRoll -= 0.1;
            if (keys.z) turn360 += 0.05;
            if (keys.x) turn360 -= 0.05;
            if (keys.c) {
                barrelRoll = 0;
                turn360 = 0;
            }

            // Update spaceship rotation
            if (spaceship) {
                spaceship.position.copy(playerPosition);
                spaceship.rotation.set(playerPitch, playerTilt, barrelRoll + turn360);
            }

            // Update camera position
            camera.position.x = THREE.MathUtils.lerp(camera.position.x, playerPosition.x, 0.1);
            camera.position.y = THREE.MathUtils.lerp(camera.position.y, playerPosition.y + 1, 0.1);
            camera.position.z = playerPosition.z + 3;
            camera.lookAt(playerPosition.x, playerPosition.y, playerPosition.z - 5);

            // Update game elements
            updateParticles();
            updateDrones();
            updateProjectiles();
            updateTrack();
            updateLightspeed();
            updateAutoPlay();
            updateScoreTimeRatio();
            updateRainbowEffect();

            // Auto fire
            const now = Date.now();
            if (now - lastAutoFire > 1000 && autoPlay) {
                fireProjectiles();
                lastAutoFire = now;
            }

            // Update HUD
            dronesElement.textContent = `${dronesKilled}/3`;
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start animation
        animate();
    </script>
</body>
</html>