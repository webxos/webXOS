<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>GALAXYCRAFT: RED VS BLUE | Paintball Combat</title>
  <meta name="description" content="Experience GALAXYCRAFT: RED VS BLUE - a fast-paced paintball battle with jetpacks and drones.">
  <meta name="keywords" content="GalaxyCraft, Red vs Blue, paintball, jetpack, team combat, neurots">
  <meta name="author" content="WebXOS">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Orbitron', 'Courier New', monospace;
    }
    body {
      background: #000;
      color: #f55;
      height: 100vh;
      overflow: hidden;
      touch-action: none;
    }
    #gameCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }
    
    /* Crosshair */
    .crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 30px;
      height: 30px;
      z-index: 10;
      pointer-events: none;
    }
    .crosshair::before, .crosshair::after {
      content: '';
      position: absolute;
      background: #0f0;
    }
    .crosshair::before {
      width: 20px;
      height: 2px;
      left: 5px;
      top: 14px;
    }
    .crosshair::after {
      width: 2px;
      height: 20px;
      left: 14px;
      top: 5px;
    }
    
    /* HUD Elements */
    .hud-container {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 20;
    }
    
    .health-armor-display {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
    }
    
    .health-bar, .armor-bar, .energy-bar {
      width: 200px;
      height: 20px;
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid #f55;
      border-radius: 5px;
      overflow: hidden;
    }
    
    .health-fill {
      height: 100%;
      background: linear-gradient(90deg, #f00, #ff3300);
      transition: width 0.3s ease;
    }
    
    .armor-fill {
      height: 100%;
      background: linear-gradient(90deg, #f55, #f33);
      transition: width 0.3s ease;
    }
    
    .energy-fill {
      height: 100%;
      background: linear-gradient(90deg, #0f0, #0a0);
      transition: width 0.3s ease;
    }
    
    .ammo-display {
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border: 2px solid #f55;
      border-radius: 5px;
      font-size: 18px;
      color: #f55;
    }
    
    .weapon-display {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border: 2px solid #f55;
      border-radius: 5px;
      font-size: 18px;
      color: #f55;
      text-align: right;
      z-index: 20;
    }
    
    .team-score {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 50px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 20px;
      border: 2px solid #f55;
      border-radius: 5px;
      font-size: 18px;
      color: #f55;
      z-index: 20;
    }
    
    .team-blue, .team-red {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .team-blue { color: #55f; }
    .team-red { color: #f55; }
    
    .kill-feed {
      position: fixed;
      top: 80px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border: 2px solid #f55;
      border-radius: 5px;
      font-size: 14px;
      color: #fff;
      z-index: 20;
      display: flex;
      flex-direction: column;
      gap: 5px;
      max-height: 200px;
      overflow-y: auto;
    }
    
    .kill-event {
      display: flex;
      gap: 10px;
    }
    
    .kill-event .killer {
      color: #55f;
    }
    
    .kill-event .victim {
      color: #f55;
    }
    
    .respawn-timer {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      padding: 30px;
      border: 4px solid #f00;
      border-radius: 10px;
      font-size: 36px;
      color: #f00;
      z-index: 100;
      text-align: center;
      display: none;
    }
    
    .performance-display {
      position: fixed;
      top: 20px;
      right: 20px;
      color: #f00;
      font-size: 14px;
      z-index: 20;
      background: rgba(0, 0, 0, 0.7);
      padding: 5px 10px;
      border-radius: 5px;
    }
    
    /* Hit Effect */
    .hit-effect {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100px;
      height: 100px;
      pointer-events: none;
      opacity: 0;
      z-index: 15;
      transition: opacity 0.2s;
    }
    
    .hit-effect.blue {
      box-shadow: 0 0 30px 10px rgba(0, 100, 255, 0.7);
      border-radius: 50%;
    }
    
    .hit-effect.red {
      box-shadow: 0 0 30px 10px rgba(255, 50, 50, 0.7);
      border-radius: 50%;
    }
    
    /* Main Menu */
    .main-menu {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(20, 10, 0, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      color: #f55;
    }
    
    .game-title {
      font-size: 60px;
      margin-bottom: 40px;
      text-shadow: 0 0 20px rgba(255, 85, 85, 0.8);
      letter-spacing: 4px;
      color: #f55;
    }
    
    .menu-options {
      display: flex;
      flex-direction: column;
      gap: 20px;
      width: 300px;
    }
    
    .menu-btn {
      padding: 15px 30px;
      background: linear-gradient(145deg, #332211, #221100);
      border: 2px solid #f55;
      color: #f55;
      font-size: 20px;
      text-align: center;
      cursor: pointer;
      border-radius: 10px;
      transition: all 0.3s ease;
    }
    
    .menu-btn:hover {
      background: linear-gradient(145deg, #443322, #332211);
      box-shadow: 0 0 20px rgba(255, 85, 85, 0.8);
      transform: translateY(-3px);
    }
    
    /* Console Messages */
    .console-message {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 10px 20px;
      border: 2px solid #f55;
      border-radius: 10px;
      color: #f55;
      font-size: 18px;
      opacity: 0;
      transition: opacity 0.5s ease;
      z-index: 25;
    }
    
    .console-message.active {
      opacity: 1;
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      .game-title {
        font-size: 40px;
      }
      
      .menu-btn {
        padding: 12px 24px;
        font-size: 18px;
      }
      
      .health-bar, .armor-bar, .energy-bar {
        width: 150px;
      }
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    
    <!-- FPS HUD -->
    <div class="hud-container">
      <div class="health-armor-display">
        <div class="health-bar">
          <div class="health-fill" id="healthFill" style="width: 100%"></div>
        </div>
        <div class="armor-bar">
          <div class="armor-fill" id="armorFill" style="width: 100%"></div>
        </div>
        <div class="energy-bar">
          <div class="energy-fill" id="energyFill" style="width: 100%"></div>
        </div>
      </div>
      <div class="ammo-display">
        AMMO: <span id="ammoCount">200</span>/400
      </div>
    </div>
    
    <div class="weapon-display">
      WEAPON: <span id="weaponName">NEUROT BLASTER</span>
    </div>
    
    <div class="team-score">
      <div class="team-blue">
        <div>BLUE TEAM</div>
        <div id="blueScore">0</div>
      </div>
      <div class="team-red">
        <div>RED TEAM</div>
        <div id="redScore">0</div>
      </div>
    </div>
    
    <div class="kill-feed" id="killFeed"></div>
    
    <div class="respawn-timer" id="respawnTimer">
      RESPAWNING IN: <span id="respawnCount">3</span>
    </div>
    
    <div class="performance-display" id="performanceDisplay">
      FPS: 0 | ENEMIES: 0
    </div>
    
    <div class="crosshair"></div>
    
    <!-- Hit Effects -->
    <div class="hit-effect blue" id="hitEffectBlue"></div>
    <div class="hit-effect red" id="hitEffectRed"></div>
    
    <!-- Console Messages -->
    <div class="console-message" id="consoleMessage"></div>
    
    <!-- Main Menu -->
    <div class="main-menu" id="mainMenu">
      <h1 class="game-title">GALAXYCRAFT: RED VS BLUE</h1>
      <div class="menu-options">
        <div class="menu-btn" id="startBtn">JOIN BATTLE</div>
        <div class="menu-btn" id="settingsBtn">SETTINGS</div>
        <div class="menu-btn" id="quitBtn">QUIT</div>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
    // Game state and configuration
    const GameState = {
      MENU: 0,
      PLAYING: 1,
      COMBAT: 2,
      DEAD: 3
    };
    
    const Team = {
      BLUE: 0,
      RED: 1
    };
    
    let currentState = GameState.MENU;
    let mouseSensitivity = 0.0025;
    let invertYAxis = false;
    
    // Initialize Three.js
    let scene, camera, renderer;
    let player, enemies = [], projectiles = [], bases = [], particleSystems = [];
    let clock = new THREE.Clock();
    let fps = 0;
    let frameCount = 0;
    let lastFpsUpdate = 0;
    let lastFrameTime = 0;
    
    // Player controls state
    const controls = {
      moveForward: false,
      moveBackward: false,
      moveLeft: false,
      moveRight: false,
      jump: false,
      jetpack: false,
      fire: false,
      fireSecondary: false,
      isGrounded: false
    };
    
    // Player stats
    const playerStats = {
      health: 100,
      armor: 100,
      energy: 100,
      ammo: 200,
      maxAmmo: 400,
      kills: 0,
      deaths: 0,
      team: Team.BLUE,
      score: 0,
      respawnTime: 0,
      speed: 8.0,
      jetpackForce: 25.0,
      jumpForce: 10.0,
      gravity: 15.0,
      velocity: new THREE.Vector3(),
      weapon: 'NEUROT BLASTER',
      weaponCooldown: 0,
      secondaryCooldown: 0
    };
    
    // Game stats
    const gameStats = {
      blueScore: 0,
      redScore: 0,
      enemyCount: 19, // 10 red + 9 blue
      respawnDelay: 3.0
    };
    
    // Initialize the game
    function init() {
      // Set up scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x220c0c);
      scene.fog = new THREE.Fog(0x331111, 50, 300);
      
      // Set up camera (first-person view)
      camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 500);
      camera.position.set(0, 2, 0);
      
      // Set up renderer with performance optimizations
      renderer = new THREE.WebGLRenderer({ 
        canvas: document.getElementById('gameCanvas'),
        antialias: false,
        powerPreference: "high-performance"
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(1);
      renderer.shadowMap.enabled = false;
      
      // Add lighting
      const ambientLight = new THREE.AmbientLight(0x774444);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffddcc, 0.7);
      directionalLight.position.set(50, 50, 50);
      scene.add(directionalLight);
      
      // Create terrain
      createTerrain();
      
      // Create bases
      createBases();
      
      // Create player
      createPlayer();
      
      // Create initial enemies
      spawnEnemies();
      
      // Set up event listeners
      setupEventListeners();
      
      // Start animation loop
      lastFrameTime = performance.now();
      animate();
      
      // Show console message
      showConsoleMessage("GALAXYCRAFT: RED VS BLUE initialized. Join the neurot battle!");
    }
    
    // Create terrain - optimized and smaller
    function createTerrain() {
      // Create a smaller ground plane for better performance
      const groundGeometry = new THREE.PlaneGeometry(300, 300, 10, 10);
      const groundMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x336633,
        shininess: 10,
        wireframe: false
      });
      
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      scene.add(ground);
      
      // Add paintball course obstacles (American Gladiators style)
      createObstacleCourse();
      
      // Add minimal rocks for performance
      for (let i = 0; i < 15; i++) {
        const rockGeometry = new THREE.SphereGeometry(1 + Math.random() * 2, 8, 6);
        const rockMaterial = new THREE.MeshPhongMaterial({ 
          color: 0x7a5230,
          shininess: 20
        });
        
        const rock = new THREE.Mesh(rockGeometry, rockMaterial);
        rock.position.set(
          Math.random() * 250 - 125,
          1 + Math.random() * 2,
          Math.random() * 250 - 125
        );
        scene.add(rock);
      }
    }
    
    // Create paintball course obstacles
    function createObstacleCourse() {
      // Center obstacles
      for (let i = 0; i < 10; i++) {
        const obstacleGeometry = new THREE.BoxGeometry(
          5 + Math.random() * 10,
          3 + Math.random() * 7,
          5 + Math.random() * 10
        );
        const obstacleMaterial = new THREE.MeshPhongMaterial({ 
          color: 0x888888,
          shininess: 30
        });
        
        const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
        obstacle.position.set(
          Math.random() * 100 - 50,
          1.5,
          Math.random() * 100 - 50
        );
        scene.add(obstacle);
      }
      
      // Add some ramps and platforms
      for (let i = 0; i < 5; i++) {
        const rampGeometry = new THREE.BoxGeometry(15, 1, 5);
        const rampMaterial = new THREE.MeshPhongMaterial({ 
          color: 0xaaaaaa,
          shininess: 30
        });
        
        const ramp = new THREE.Mesh(rampGeometry, rampMaterial);
        ramp.position.set(
          Math.random() * 100 - 50,
          2,
          Math.random() * 100 - 50
        );
        ramp.rotation.z = Math.PI / 6 * (Math.random() > 0.5 ? 1 : -1);
        scene.add(ramp);
      }
    }
    
    // Create Alamo-style bases for both teams
    function createBases() {
      // Blue base
      const blueBaseGeometry = new THREE.BoxGeometry(30, 15, 40);
      const blueBaseMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x3355aa,
        emissive: 0x112244,
        shininess: 50
      });
      
      const blueBase = new THREE.Mesh(blueBaseGeometry, blueBaseMaterial);
      blueBase.position.set(-100, 7.5, 0);
      blueBase.team = Team.BLUE;
      scene.add(blueBase);
      bases.push(blueBase);
      
      // Add Alamo-style facade to blue base
      const blueFacadeGeometry = new THREE.BoxGeometry(32, 10, 2);
      const blueFacade = new THREE.Mesh(blueFacadeGeometry, blueBaseMaterial);
      blueFacade.position.set(-100, 12, 21);
      scene.add(blueFacade);
      
      // Add entrance at the back
      const blueEntranceGeometry = new THREE.BoxGeometry(10, 8, 6);
      const blueEntranceMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x000000,
        emissive: 0x111111
      });
      
      const blueEntrance = new THREE.Mesh(blueEntranceGeometry, blueEntranceMaterial);
      blueEntrance.position.set(-100, 4, -21);
      scene.add(blueEntrance);
      
      // Add some structures to blue base (Alamo-style walls)
      const blueWallGeometry = new THREE.BoxGeometry(5, 8, 30);
      const blueWall1 = new THREE.Mesh(blueWallGeometry, blueBaseMaterial);
      blueWall1.position.set(-115, 4, 0);
      scene.add(blueWall1);
      
      const blueWall2 = new THREE.Mesh(blueWallGeometry, blueBaseMaterial);
      blueWall2.position.set(-85, 4, 0);
      scene.add(blueWall2);
      
      // Red base
      const redBaseGeometry = new THREE.BoxGeometry(30, 15, 40);
      const redBaseMaterial = new THREE.MeshPhongMaterial({ 
        color: 0xaa5533,
        emissive: 0x442211,
        shininess: 50
      });
      
      const redBase = new THREE.Mesh(redBaseGeometry, redBaseMaterial);
      redBase.position.set(100, 7.5, 0);
      redBase.team = Team.RED;
      scene.add(redBase);
      bases.push(redBase);
      
      // Add Alamo-style facade to red base
      const redFacadeGeometry = new THREE.BoxGeometry(32, 10, 2);
      const redFacade = new THREE.Mesh(redFacadeGeometry, redBaseMaterial);
      redFacade.position.set(100, 12, 21);
      scene.add(redFacade);
      
      // Add entrance at the back
      const redEntranceGeometry = new THREE.BoxGeometry(10, 8, 6);
      const redEntranceMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x000000,
        emissive: 0x111111
      });
      
      const redEntrance = new THREE.Mesh(redEntranceGeometry, redEntranceMaterial);
      redEntrance.position.set(100, 4, -21);
      scene.add(redEntrance);
      
      // Add some structures to red base (Alamo-style walls)
      const redWallGeometry = new THREE.BoxGeometry(5, 8, 30);
      const redWall1 = new THREE.Mesh(redWallGeometry, redBaseMaterial);
      redWall1.position.set(115, 4, 0);
      scene.add(redWall1);
      
      const redWall2 = new THREE.Mesh(redWallGeometry, redBaseMaterial);
      redWall2.position.set(85, 4, 0);
      scene.add(redWall2);
      
      // Add flags
      createFlag(-100, 22, 21, Team.BLUE);
      createFlag(100, 22, 21, Team.RED);
    }
    
    // Create a flag for a base
    function createFlag(x, y, z, team) {
      const flagPoleGeometry = new THREE.CylinderGeometry(0.3, 0.3, 8, 8);
      const flagPoleMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
      const flagPole = new THREE.Mesh(flagPoleGeometry, flagPoleMaterial);
      flagPole.position.set(x, y - 4, z);
      scene.add(flagPole);
      
      const flagGeometry = new THREE.PlaneGeometry(5, 3);
      const flagMaterial = new THREE.MeshPhongMaterial({ 
        color: team === Team.BLUE ? 0x3355aa : 0xaa5533,
        side: THREE.DoubleSide
      });
      
      const flag = new THREE.Mesh(flagGeometry, flagMaterial);
      flag.position.set(x + (team === Team.BLUE ? 2.5 : -2.5), y, z);
      flag.rotation.y = Math.PI / 2;
      scene.add(flag);
    }
    
    // Create player
    function createPlayer() {
      player = new THREE.Object3D();
      player.position.set(-100, 5, 0);
      player.velocity = new THREE.Vector3();
      scene.add(player);
      
      // Add camera to player
      player.add(camera);
      camera.position.y = 1.7;
      
      // Create a simple weapon model
      const weaponGeometry = new THREE.BoxGeometry(0.3, 0.3, 1.5);
      const weaponMaterial = new THREE.MeshPhongMaterial({
        color: 0x3355aa,
        emissive: 0x112244,
        specular: 0xffffff,
        shininess: 30
      });
      
      const weapon = new THREE.Mesh(weaponGeometry, weaponMaterial);
      weapon.position.set(0.5, -0.5, -1);
      camera.add(weapon);
    }
    
    // Spawn enemies
    function spawnEnemies() {
      // Create 10 red enemies
      for (let i = 0; i < 10; i++) {
        createEnemy(i, Team.RED);
      }
      
      // Create 9 blue enemies
      for (let i = 10; i < 19; i++) {
        createEnemy(i, Team.BLUE);
      }
    }
    
    // Create a single enemy (triangle shape standing vertically)
    function createEnemy(id, team) {
      // Create a triangle geometry for the enemy
      const enemyGeometry = new THREE.ConeGeometry(1.5, 3, 3);
      const enemyMaterial = new THREE.MeshPhongMaterial({ 
        color: team === Team.BLUE ? 0x3355aa : 0xaa5533,
        emissive: team === Team.BLUE ? 0x112244 : 0x442211
      });
      
      const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
      
      // Position based on team
      if (team === Team.BLUE) {
        enemy.position.set(
          -90 + Math.random() * 20 - 10,
          1.5,
          Math.random() * 40 - 20
        );
      } else {
        enemy.position.set(
          90 + Math.random() * 20 - 10,
          1.5,
          Math.random() * 40 - 20
        );
      }
      
      enemy.rotation.x = Math.PI / 2;
      
      // Enemy properties
      enemy.health = 100;
      enemy.armor = 100;
      enemy.team = team;
      enemy.id = id;
      enemy.speed = 6.0;
      enemy.fireCooldown = 0;
      enemy.target = null;
      enemy.state = 'patrol';
      enemy.lastStateChange = 0;
      enemy.velocity = new THREE.Vector3();
      enemy.isGrounded = true;
      
      scene.add(enemy);
      enemies.push(enemy);
      
      return enemy;
    }
    
    // Create a neurot projectile
    function createProjectile(position, velocity, team, isSecondary = false) {
      const projectileGeometry = new THREE.SphereGeometry(0.4, 8, 6);
      const projectileMaterial = new THREE.MeshPhongMaterial({ 
        color: team === Team.BLUE ? 0x3355ff : 0xff5533,
        emissive: team === Team.BLUE ? 0x002266 : 0x662200
      });
      
      const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
      projectile.position.copy(position);
      projectile.velocity = velocity.clone();
      projectile.team = team;
      projectile.damage = isSecondary ? 50 : 25; // More damage for secondary fire
      projectile.lifetime = 0;
      projectile.maxLifetime = isSecondary ? 1.5 : 2.0;
      projectile.isSecondary = isSecondary;
      
      // Add glow effect
      const glowGeometry = new THREE.SphereGeometry(0.6, 10, 8);
      const glowMaterial = new THREE.MeshBasicMaterial({
        color: team === Team.BLUE ? 0x0088ff : 0xff3300,
        transparent: true,
        opacity: 0.7
      });
      
      const glow = new THREE.Mesh(glowGeometry, glowMaterial);
      projectile.add(glow);
      
      scene.add(projectile);
      projectiles.push(projectile);
      
      return projectile;
    }
    
    // Create hit effect particles
    function createHitEffect(position, team) {
      const particleCount = 15;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      
      for (let i = 0; i < particleCount; i++) {
        const i3 = i * 3;
        // Random positions around the hit point
        positions[i3] = (Math.random() - 0.5) * 2;
        positions[i3 + 1] = (Math.random() - 0.5) * 2;
        positions[i3 + 2] = (Math.random() - 0.5) * 2;
        
        // Team-based colors
        if (team === Team.BLUE) {
          colors[i3] = 0.2; // R
          colors[i3 + 1] = 0.4; // G
          colors[i3 + 2] = 1.0; // B
        } else {
          colors[i3] = 1.0; // R
          colors[i3 + 1] = 0.2; // G
          colors[i3 + 2] = 0.2; // B
        }
      }
      
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      
      const material = new THREE.PointsMaterial({
        size: 0.3,
        vertexColors: true,
        transparent: true,
        opacity: 0.8
      });
      
      const particles = new THREE.Points(geometry, material);
      particles.position.copy(position);
      particles.velocity = [];
      
      // Set random velocities for each particle
      for (let i = 0; i < particleCount; i++) {
        particles.velocity.push({
          x: (Math.random() - 0.5) * 10,
          y: (Math.random() - 0.5) * 10,
          z: (Math.random() - 0.5) * 10
        });
      }
      
      particles.lifetime = 0;
      particles.maxLifetime = 1.0;
      
      scene.add(particles);
      particleSystems.push(particles);
      
      // Show screen hit effect
      const hitEffect = document.getElementById(team === Team.BLUE ? 'hitEffectBlue' : 'hitEffectRed');
      hitEffect.style.opacity = '0.8';
      setTimeout(() => {
        hitEffect.style.opacity = '0';
      }, 200);
    }
    
    // Show a console message
    function showConsoleMessage(message, duration = 3000) {
      const consoleElement = document.getElementById('consoleMessage');
      consoleElement.textContent = message;
      consoleElement.classList.add('active');
      
      setTimeout(() => {
        consoleElement.classList.remove('active');
      }, duration);
    }
    
    // Add a kill event to the kill feed
    function addKillEvent(killer, victim, weapon) {
      const killFeed = document.getElementById('killFeed');
      const killEvent = document.createElement('div');
      killEvent.className = 'kill-event';
      killEvent.innerHTML = `
        <span class="killer">${killer}</span> 
        <span>neurotted</span> 
        <span class="victim">${victim}</span>
      `;
      
      killFeed.appendChild(killEvent);
      
      // Limit kill feed to 6 entries
      if (killFeed.children.length > 6) {
        killFeed.removeChild(killFeed.firstChild);
      }
      
      // Auto-remove after 10 seconds
      setTimeout(() => {
        if (killFeed.contains(killEvent)) {
          killFeed.removeChild(killEvent);
        }
      }, 10000);
    }
    
    // Update player stats display
    function updatePlayerDisplay() {
      document.getElementById('healthFill').style.width = `${playerStats.health}%`;
      document.getElementById('armorFill').style.width = `${playerStats.armor}%`;
      document.getElementById('energyFill').style.width = `${playerStats.energy}%`;
      document.getElementById('ammoCount').textContent = playerStats.ammo;
      document.getElementById('weaponName').textContent = playerStats.weapon;
      document.getElementById('blueScore').textContent = gameStats.blueScore;
      document.getElementById('redScore').textContent = gameStats.redScore;
    }
    
    // Update performance display
    function updatePerformanceDisplay() {
      document.getElementById('performanceDisplay').textContent = 
        `FPS: ${Math.round(fps)} | ENEMIES: ${enemies.length}`;
    }
    
    // Set up event listeners
    function setupEventListeners() {
      // Keyboard controls
      document.addEventListener('keydown', (e) => {
        if (currentState === GameState.MENU || currentState === GameState.DEAD) return;
        
        switch(e.key.toLowerCase()) {
          case 'w':
            controls.moveForward = true;
            break;
          case 's':
            controls.moveBackward = true;
            break;
          case 'a':
            controls.moveLeft = true;
            break;
          case 'd':
            controls.moveRight = true;
            break;
          case ' ':
            if (controls.isGrounded) {
              controls.jump = true;
            } else {
              controls.jetpack = true;
            }
            break;
          case 'shift':
            controls.jetpack = true;
            break;
          case 'r':
            // Reload
            if (playerStats.ammo < 200 && playerStats.maxAmmo > 0) {
              const needed = 200 - playerStats.ammo;
              const reloadAmount = Math.min(needed, playerStats.maxAmmo);
              playerStats.ammo += reloadAmount;
              playerStats.maxAmmo -= reloadAmount;
              showConsoleMessage(`Reloading... ${playerStats.ammo}/200`);
              updatePlayerDisplay();
            }
            break;
        }
      });
      
      document.addEventListener('keyup', (e) => {
        switch(e.key.toLowerCase()) {
          case 'w':
            controls.moveForward = false;
            break;
          case 's':
            controls.moveBackward = false;
            break;
          case 'a':
            controls.moveLeft = false;
            break;
          case 'd':
            controls.moveRight = false;
            break;
          case ' ':
            controls.jump = false;
            controls.jetpack = false;
            break;
          case 'shift':
            controls.jetpack = false;
            break;
        }
      });
      
      // Mouse movement for camera control
      document.addEventListener('mousemove', (e) => {
        if (currentState === GameState.PLAYING || currentState === GameState.COMBAT) {
          // Rotate player based on mouse movement
          player.rotation.y -= e.movementX * mouseSensitivity;
          camera.rotation.x -= e.movementY * mouseSensitivity * (invertYAxis ? -1 : 1);
          
          // Limit vertical look angle
          camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
        }
      });
      
      // Mouse click for firing
      document.addEventListener('mousedown', (e) => {
        if (currentState === GameState.PLAYING || currentState === GameState.COMBAT) {
          if (e.button === 0) { // Left click
            controls.fire = true;
          } else if (e.button === 2) { // Right click
            controls.fireSecondary = true;
          }
        }
      });
      
      document.addEventListener('mouseup', (e) => {
        if (e.button === 0) {
          controls.fire = false;
        } else if (e.button === 2) {
          controls.fireSecondary = false;
        }
      });
      
      // Prevent context menu on right click
      document.addEventListener('contextmenu', (e) => {
        e.preventDefault();
      });
      
      // Menu event listeners
      document.getElementById('startBtn').addEventListener('click', startGame);
      document.getElementById('quitBtn').addEventListener('click', () => {
        showConsoleMessage("Thanks for playing GALAXYCRAFT: RED VS BLUE!");
        setTimeout(() => { window.close(); }, 1000);
      });
      
      // Lock pointer on click
      document.getElementById('gameCanvas').addEventListener('click', () => {
        if (currentState === GameState.PLAYING || currentState === GameState.COMBAT) {
          document.getElementById('gameCanvas').requestPointerLock();
        }
      });
      
      // Exit pointer lock
      document.addEventListener('pointerlockchange', () => {
        if (document.pointerLockElement !== document.getElementById('gameCanvas')) {
          // Pointer was unlocked
        }
      });
      
      // Window resize handler
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }
    
    // Start the game
    function startGame() {
      currentState = GameState.PLAYING;
      document.getElementById('mainMenu').style.display = 'none';
      document.getElementById('gameCanvas').requestPointerLock();
      showConsoleMessage("Joining Blue Team. Neurot battle begins!");
    }
    
    // Respawn player
    function respawnPlayer() {
      playerStats.health = 100;
      playerStats.armor = 100;
      playerStats.energy = 100;
      playerStats.ammo = 200;
      playerStats.maxAmmo = 200;
      
      // Reset position based on team
      if (playerStats.team === Team.BLUE) {
        player.position.set(-100, 5, 0);
      } else {
        player.position.set(100, 5, 0);
      }
      
      player.velocity.set(0, 0, 0);
      currentState = GameState.PLAYING;
      document.getElementById('respawnTimer').style.display = 'none';
      
      updatePlayerDisplay();
      showConsoleMessage("Respawned! Get back in the neurot fight!");
    }
    
    // Respawn enemy
    function respawnEnemy(enemy) {
      enemy.health = 100;
      enemy.armor = 100;
      
      // Reset position based on team
      if (enemy.team === Team.BLUE) {
        enemy.position.set(
          -90 + Math.random() * 20 - 10,
          1.5,
          Math.random() * 40 - 20
        );
      } else {
        enemy.position.set(
          90 + Math.random() * 20 - 10,
          1.5,
          Math.random() * 40 - 20
        );
      }
      
      enemy.velocity.set(0, 0, 0);
      enemy.state = 'patrol';
    }
    
    // Update game state
    function update(deltaTime) {
      if (currentState === GameState.MENU) return;
      
      // Handle respawn timer
      if (currentState === GameState.DEAD) {
        playerStats.respawnTime -= deltaTime;
        document.getElementById('respawnCount').textContent = Math.ceil(playerStats.respawnTime);
        
        if (playerStats.respawnTime <= 0) {
          respawnPlayer();
        }
        return;
      }
      
      // Calculate movement direction based on controls
      const moveSpeed = playerStats.speed;
      const moveVector = new THREE.Vector3(0, 0, 0);
      
      if (controls.moveForward) moveVector.z -= 1;
      if (controls.moveBackward) moveVector.z += 1;
      if (controls.moveLeft) moveVector.x -= 1;
      if (controls.moveRight) moveVector.x += 1;
      
      // Normalize and apply movement speed
      if (moveVector.length() > 0) {
        moveVector.normalize().multiplyScalar(moveSpeed);
        
        // Apply movement relative to player's rotation
        moveVector.applyEuler(new THREE.Euler(0, player.rotation.y, 0));
        player.position.add(moveVector.multiplyScalar(deltaTime));
      }
      
      // Handle jumping and jetpack
      if (controls.jump && controls.isGrounded) {
        player.velocity.y = playerStats.jumpForce;
        controls.isGrounded = false;
      }
      
      if (controls.jetpack && playerStats.energy > 0) {
        player.velocity.y += playerStats.jetpackForce * deltaTime;
        playerStats.energy -= 25 * deltaTime;
        if (playerStats.energy < 0) playerStats.energy = 0;
      }
      
      // Apply gravity
      player.velocity.y -= playerStats.gravity * deltaTime;
      
      // Update player position
      player.position.add(player.velocity.clone().multiplyScalar(deltaTime));
      
      // Check if player is on ground
      if (player.position.y <= 1.7) {
        player.position.y = 1.7;
        player.velocity.y = 0;
        controls.isGrounded = true;
      }
      
      // Regenerate energy when not using jetpack
      if (!controls.jetpack && playerStats.energy < 100) {
        playerStats.energy += 15 * deltaTime;
        if (playerStats.energy > 100) playerStats.energy = 100;
      }
      
      // Handle weapon firing - FIXED: Now properly creates projectiles from gun position
      if (controls.fire && playerStats.weaponCooldown <= 0 && playerStats.ammo > 0) {
        // Create a neurot projectile from the gun position
        const direction = new THREE.Vector3(0, 0, -1);
        direction.applyQuaternion(camera.quaternion);
        
        const velocity = direction.clone().multiplyScalar(100);
        
        // Get gun position (offset from camera)
        const gunPosition = new THREE.Vector3(0.5, -0.5, -1);
        gunPosition.applyQuaternion(camera.quaternion);
        gunPosition.add(camera.position);
        
        createProjectile(
          gunPosition,
          velocity,
          playerStats.team,
          false
        );
        
        playerStats.ammo--;
        playerStats.weaponCooldown = 0.1; // Slightly slower firing for visibility
        
        updatePlayerDisplay();
      }
      
      // Handle secondary fire (paintball grenade)
      if (controls.fireSecondary && playerStats.secondaryCooldown <= 0 && playerStats.ammo >= 10) {
        // Create a paintball grenade from the gun position
        const direction = new THREE.Vector3(0, 0, -1);
        direction.applyQuaternion(camera.quaternion);
        
        // Add some upward angle to grenade
        direction.y += 0.3;
        direction.normalize();
        
        const velocity = direction.clone().multiplyScalar(60);
        
        // Get gun position (offset from camera)
        const gunPosition = new THREE.Vector3(0.5, -0.5, -1);
        gunPosition.applyQuaternion(camera.quaternion);
        gunPosition.add(camera.position);
        
        createProjectile(
          gunPosition,
          velocity,
          playerStats.team,
          true
        );
        
        playerStats.ammo -= 10;
        playerStats.secondaryCooldown = 1.0; // Longer cooldown for secondary
        
        updatePlayerDisplay();
      }
      
      if (playerStats.weaponCooldown > 0) {
        playerStats.weaponCooldown -= deltaTime;
      }
      
      if (playerStats.secondaryCooldown > 0) {
        playerStats.secondaryCooldown -= deltaTime;
      }
      
      // Update projectiles
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const projectile = projectiles[i];
        
        // Update position
        projectile.position.add(projectile.velocity.clone().multiplyScalar(deltaTime));
        
        // Apply gravity to secondary projectiles (grenades)
        if (projectile.isSecondary) {
          projectile.velocity.y -= playerStats.gravity * deltaTime * 0.5;
        }
        
        // Check for collisions with enemies
        for (let j = enemies.length - 1; j >= 0; j--) {
          const enemy = enemies[j];
          
          // Skip if projectile and enemy are on the same team
          if (projectile.team === enemy.team) continue;
          
          // Simple distance-based collision
          const distance = projectile.position.distanceTo(enemy.position);
          if (distance < 2.5) {
            // Hit enemy
            if (enemy.armor > 0) {
              enemy.armor -= projectile.damage;
              if (enemy.armor < 0) {
                enemy.health += enemy.armor;
                enemy.armor = 0;
              }
            } else {
              enemy.health -= projectile.damage;
            }
            
            // Create hit effect
            createHitEffect(enemy.position.clone(), projectile.team);
            
            // Remove projectile
            scene.remove(projectile);
            projectiles.splice(i, 1);
            
            // Check if enemy is dead
            if (enemy.health <= 0) {
              // Add score
              if (playerStats.team === Team.BLUE) {
                gameStats.blueScore += 10;
              } else {
                gameStats.redScore += 10;
              }
              
              playerStats.score += 10;
              playerStats.kills++;
              
              // Add kill event
              addKillEvent("Player", `Drone ${enemy.id}`, "NEUROT BLASTER");
              
              // Respawn enemy
              respawnEnemy(enemy);
            }
            
            break;
          }
        }
        
        // Check for collisions with player
        if (projectile.team !== playerStats.team) {
          const distance = projectile.position.distanceTo(player.position);
          if (distance < 2.5) {
            // Hit player
            if (playerStats.armor > 0) {
              playerStats.armor -= projectile.damage;
              if (playerStats.armor < 0) {
                playerStats.health += playerStats.armor;
                playerStats.armor = 0;
              }
            } else {
              playerStats.health -= projectile.damage;
            }
            
            // Create hit effect
            createHitEffect(player.position.clone(), projectile.team);
            
            // Remove projectile
            scene.remove(projectile);
            projectiles.splice(i, 1);
            
            // Check if player is dead
            if (playerStats.health <= 0) {
              playerStats.deaths++;
              playerStats.respawnTime = gameStats.respawnDelay;
              currentState = GameState.DEAD;
              document.getElementById('respawnTimer').style.display = 'block';
              
              // Add kill event
              addKillEvent(`Drone ${enemies.find(e => e.team === projectile.team)?.id || 'Unknown'}`, "Player", "NEUROT BLASTER");
            }
            
            updatePlayerDisplay();
          }
        }
        
        // Remove projectiles that are too old or too far away
        projectile.lifetime += deltaTime;
        if (projectile.lifetime > projectile.maxLifetime || 
            Math.abs(projectile.position.x) > 200 || 
            Math.abs(projectile.position.z) > 200) {
          scene.remove(projectile);
          projectiles.splice(i, 1);
        }
      }
      
      // Update particle systems
      for (let i = particleSystems.length - 1; i >= 0; i--) {
        const particles = particleSystems[i];
        particles.lifetime += deltaTime;
        
        if (particles.lifetime > particles.maxLifetime) {
          scene.remove(particles);
          particleSystems.splice(i, 1);
          continue;
        }
        
        // Animate particles
        const positions = particles.geometry.attributes.position.array;
        for (let j = 0; j < positions.length / 3; j++) {
          const velocity = particles.velocity[j];
          positions[j * 3] += velocity.x * deltaTime;
          positions[j * 3 + 1] += velocity.y * deltaTime;
          positions[j * 3 + 2] += velocity.z * deltaTime;
        }
        
        particles.geometry.attributes.position.needsUpdate = true;
        
        // Fade out particles
        const alpha = 1.0 - (particles.lifetime / particles.maxLifetime);
        particles.material.opacity = alpha * 0.8;
      }
      
      // Update enemies
      updateEnemies(deltaTime);
      
      // Update player display
      updatePlayerDisplay();
    }
    
    // Update enemy AI
    function updateEnemies(deltaTime) {
      for (const enemy of enemies) {
        // Skip if enemy is dead
        if (enemy.health <= 0) continue;
        
        // Update enemy state
        enemy.lastStateChange += deltaTime;
        
        // Simple AI states
        switch(enemy.state) {
          case 'patrol':
            // Move toward center of the map
            const center = new THREE.Vector3(0, 0, 0);
            const direction = center.clone().sub(enemy.position).normalize();
            
            enemy.velocity.x = direction.x * enemy.speed;
            enemy.velocity.z = direction.z * enemy.speed;
            
            // Look at center
            enemy.lookAt(center);
            
            // Check if close to center
            if (enemy.position.distanceTo(center) < 30) {
              enemy.state = 'combat';
              enemy.lastStateChange = 0;
            }
            
            // Check if player is nearby
            if (enemy.team !== playerStats.team && 
                enemy.position.distanceTo(player.position) < 50) {
              enemy.target = player;
              enemy.state = 'chase';
              enemy.lastStateChange = 0;
            }
            break;
            
          case 'chase':
            // Chase the player
            if (enemy.target) {
              const targetDirection = enemy.target.position.clone().sub(enemy.position).normalize();
              
              enemy.velocity.x = targetDirection.x * enemy.speed;
              enemy.velocity.z = targetDirection.z * enemy.speed;
              
              // Look at player
              enemy.lookAt(enemy.target.position);
              
              // Fire at player if in range
              if (enemy.position.distanceTo(enemy.target.position) < 40) {
                enemy.state = 'combat';
                enemy.lastStateChange = 0;
              }
            } else {
              enemy.state = 'patrol';
              enemy.lastStateChange = 0;
            }
            break;
            
          case 'combat':
            // Move randomly and fire at player
            if (Math.random() < 0.01 || enemy.lastStateChange > 3) {
              enemy.velocity.x = (Math.random() - 0.5) * enemy.speed;
              enemy.velocity.z = (Math.random() - 0.5) * enemy.speed;
              enemy.lastStateChange = 0;
            }
            
            // Look at player if nearby
            if (enemy.team !== playerStats.team && 
                enemy.position.distanceTo(player.position) < 50) {
              enemy.lookAt(player.position);
              
              // Fire at player
              if (enemy.fireCooldown <= 0) {
                const direction = player.position.clone().sub(enemy.position).normalize();
                const velocity = direction.clone().multiplyScalar(80);
                
                createProjectile(
                  enemy.position.clone().add(direction.clone().multiplyScalar(2)),
                  velocity,
                  enemy.team,
                  false
                );
                
                enemy.fireCooldown = 0.5 + Math.random() * 0.5;
              }
            } else {
              // Look toward center
              const center = new THREE.Vector3(0, 0, 0);
              enemy.lookAt(center);
            }
            
            // Check if player is too far
            if (enemy.team !== playerStats.team && 
                enemy.position.distanceTo(player.position) > 60) {
              enemy.state = 'chase';
              enemy.lastStateChange = 0;
            }
            
            // Occasionally switch back to patrol
            if (Math.random() < 0.005) {
              enemy.state = 'patrol';
              enemy.lastStateChange = 0;
            }
            break;
        }
        
        // Apply gravity
        enemy.velocity.y -= playerStats.gravity * deltaTime;
        
        // Update position
        enemy.position.add(enemy.velocity.clone().multiplyScalar(deltaTime));
        
        // Keep on ground
        if (enemy.position.y < 1.5) {
          enemy.position.y = 1.5;
          enemy.velocity.y = 0;
          enemy.isGrounded = true;
        }
        
        // Update fire cooldown
        if (enemy.fireCooldown > 0) {
          enemy.fireCooldown -= deltaTime;
        }
      }
    }
    
    // Animation loop with performance optimization
    function animate() {
      requestAnimationFrame(animate);
      
      // Calculate delta time with performance.now() for better accuracy
      const now = performance.now();
      const deltaTime = Math.min((now - lastFrameTime) / 1000, 0.1);
      lastFrameTime = now;
      
      // Update FPS counter
      frameCount++;
      if (now >= lastFpsUpdate + 1000) {
        fps = frameCount * 1000 / (now - lastFpsUpdate);
        frameCount = 0;
        lastFpsUpdate = now;
        
        updatePerformanceDisplay();
      }
      
      // Update game state
      update(deltaTime);
      
      // Render the scene
      renderer.render(scene, camera);
    }
    
    // Initialize the game when the page loads
    window.addEventListener('load', init);
  </script>
</body>
</html>