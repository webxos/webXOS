<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WEBXOS AI CHESS - Quantum Training</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
        }

        body {
            background: #000;
            color: #39ff14;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Scanlines effect */
        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 100;
        }

        .header {
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #39ff14;
            box-shadow: 0 0 15px #39ff14;
            z-index: 100;
            height: 80px;
            flex-shrink: 0;
        }

        .logo {
            display: flex;
            align-items: center;
        }

        .logo h1 {
            font-size: 22px;
            font-weight: 700;
            text-shadow: 0 0 15px #39ff14;
            margin-right: 15px;
        }

        .version {
            background: rgba(57, 255, 20, 0.3);
            padding: 4px 8px;
            border-radius: 10px;
            font-size: 11px;
            color: #39ff14;
            text-shadow: 0 0 8px #39ff14;
        }

        .nav-buttons {
            display: flex;
            gap: 12px;
        }

        .nav-btn {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #39ff14;
            color: #39ff14;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: 700;
            text-shadow: 0 0 8px #39ff14;
            box-shadow: 0 0 10px rgba(57, 255, 20, 0.7);
        }

        .nav-btn:hover {
            background: rgba(57, 255, 20, 0.3);
            box-shadow: 0 0 20px #39ff14;
            transform: translateY(-2px);
        }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
            height: calc(100vh - 350px);
        }

        .game-container {
            flex: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
            height: 100%;
        }

        #chessboard-3d {
            width: 95%;
            height: 95%;
            position: relative;
        }

        .training-controls {
            width: 350px;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            border-left: 1px solid #39ff14;
            box-shadow: -5px 0 25px rgba(57, 255, 20, 0.4);
            position: relative;
            height: 100%;
            flex-shrink: 0;
            overflow: hidden;
        }

        .status-panel {
            background: rgba(10, 15, 10, 0.9);
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #39ff14;
            box-shadow: 0 0 15px rgba(57, 255, 20, 0.4);
            flex-shrink: 0;
        }

        .status-panel h2 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #39ff14;
            text-shadow: 0 0 8px #39ff14;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .status-item {
            display: flex;
            flex-direction: column;
        }

        .status-label {
            font-size: 12px;
            color: #88ff88;
            margin-bottom: 4px;
            text-shadow: 0 0 5px #88ff88;
        }

        .status-value {
            font-size: 16px;
            font-weight: 700;
            color: #39ff14;
            text-shadow: 0 0 8px #39ff14;
        }

        .training-buttons {
            display: flex;
            gap: 15px;
        }

        .training-btn {
            flex: 1;
            background: linear-gradient(135deg, #000, #0a2a0a);
            border: 3px solid;
            color: white;
            padding: 18px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            text-shadow: 0 0 8px;
        }

        .training-btn.start {
            border-color: #39ff14;
            color: #39ff14;
            box-shadow: 0 0 20px rgba(57, 255, 20, 0.7);
        }

        .training-btn.start:hover, .training-btn.start.active {
            background: rgba(57, 255, 20, 0.3);
            box-shadow: 0 0 30px #39ff14;
            transform: translateY(-3px);
        }

        .training-btn.stop {
            border-color: #ff3333;
            color: #ff3333;
            box-shadow: 0 0 20px rgba(255, 51, 51, 0.7);
        }

        .training-btn.stop:hover, .training-btn.stop.active {
            background: rgba(255, 51, 51, 0.3);
            box-shadow: 0 0 30px #ff3333;
            transform: translateY(-3px);
        }

        .training-btn.reset {
            border-color: #ffff00;
            color: #ffff00;
            background: linear-gradient(135deg, #000, #2a2a00);
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.7);
        }

        .training-btn.reset:hover {
            background: rgba(255, 255, 0, 0.3);
            box-shadow: 0 0 30px #ffff00;
            transform: translateY(-3px);
        }

        .training-mode-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .mode-btn {
            flex: 1;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #39ff14;
            color: #39ff14;
            padding: 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: 700;
            text-shadow: 0 0 5px #39ff14;
            box-shadow: 0 0 8px rgba(57, 255, 20, 0.5);
        }

        .mode-btn:hover, .mode-btn.active {
            background: rgba(57, 255, 20, 0.2);
            box-shadow: 0 0 15px #39ff14;
        }

        .ai-thinking {
            display: none;
            align-items: center;
            gap: 10px;
            padding: 12px;
            background: rgba(20, 30, 20, 0.7);
            border-radius: 8px;
            margin-top: 10px;
            border: 2px solid #39ff14;
            box-shadow: 0 0 10px rgba(57, 255, 20, 0.4);
            height: 40px;
        }

        .ai-thinking.active {
            display: flex;
        }

        .thinking-dots {
            display: flex;
            gap: 4px;
        }

        .thinking-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #39ff14;
            animation: pulse 1.5s infinite ease-in-out;
            box-shadow: 0 0 8px #39ff14;
        }

        .thinking-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .thinking-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.3); opacity: 1; }
        }

        .footer {
            background: rgba(0, 0, 0, 0.95);
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-top: 1px solid #39ff14;
            box-shadow: 0 0 15px #39ff14;
            height: 270px;
            flex-shrink: 0;
            position: relative;
        }

        .copyright {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: #39ff14;
            text-shadow: 0 0 8px #39ff14;
            opacity: 0.7;
        }

        .qnn-grids {
            display: flex;
            gap: 30px;
            width: 100%;
            height: 100%;
            max-width: 900px;
        }

        .qnn-grid {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: rgba(10, 15, 10, 0.9);
            border: 2px solid;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 0 15px;
            height: 230px;
        }

        .qnn-grid.green {
            border-color: #39ff14;
            box-shadow: 0 0 15px rgba(57, 255, 20, 0.5);
        }

        .qnn-grid.black {
            border-color: #ffffff;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }

        .qnn-header {
            text-align: center;
            margin-bottom: 15px;
            font-size: 16px;
            text-shadow: 0 0 8px;
            height: 25px;
            font-weight: 700;
        }

        .qnn-header.green {
            color: #39ff14;
        }

        .qnn-header.black {
            color: #ffffff;
        }

        .qnn-canvas-container {
            flex: 1;
            position: relative;
            border: 2px solid;
            background: #000;
            height: 150px;
        }

        .qnn-canvas-container.green {
            border-color: #39ff14;
        }

        .qnn-canvas-container.black {
            border-color: #ffffff;
        }

        .qnn-canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .qnn-values {
            display: flex;
            justify-content: space-between;
            margin-top: 12px;
            font-size: 12px;
            height: 20px;
            font-weight: 700;
        }

        .qnn-values.green {
            color: #39ff14;
            text-shadow: 0 0 5px #39ff14;
        }

        .qnn-values.black {
            color: #ffffff;
            text-shadow: 0 0 5px #ffffff;
        }

        /* Popup windows */
        .popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            height: 500px;
            background: rgba(0, 0, 0, 0.98);
            border: 3px solid #39ff14;
            border-radius: 12px;
            box-shadow: 0 0 30px #39ff14;
            z-index: 1000;
            overflow: hidden;
        }

        .popup.active {
            display: flex;
            flex-direction: column;
        }

        .popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            background: rgba(10, 15, 10, 0.9);
            border-bottom: 2px solid #39ff14;
        }

        .popup-title {
            font-size: 20px;
            font-weight: bold;
            text-shadow: 0 0 8px #39ff14;
            color: #39ff14;
        }

        .popup-close {
            background: none;
            border: none;
            color: #ff3333;
            font-size: 24px;
            cursor: pointer;
            text-shadow: 0 0 8px #ff3333;
            transition: all 0.3s ease;
        }

        .popup-close:hover {
            transform: scale(1.2);
        }

        .popup-content {
            flex: 1;
            padding: 25px;
            overflow-y: auto;
        }

        .overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 999;
        }

        .overlay.active {
            display: block;
        }

        /* Loading screen */
        .loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.98);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }

        .loading-logo {
            font-size: 42px;
            font-weight: 700;
            background: linear-gradient(90deg, #39ff14, #88ff88);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: 20px;
            text-shadow: 0 0 15px #39ff14;
        }

        .loading-bar-container {
            width: 300px;
            height: 6px;
            background: rgba(57, 255, 20, 0.3);
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #39ff14, #88ff88);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 15px #39ff14;
        }

        .loading-text {
            font-size: 16px;
            color: #88ff88;
            text-shadow: 0 0 8px #88ff88;
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .main-container {
                flex-direction: column;
                height: calc(100vh - 350px);
            }
            
            .training-controls {
                width: 100%;
                height: 45%;
                border-left: none;
                border-top: 2px solid #39ff14;
                box-shadow: 0 -5px 25px rgba(57, 255, 20, 0.4);
            }
            
            .game-container {
                height: 55%;
            }
            
            .nav-buttons {
                gap: 8px;
            }
            
            .nav-btn {
                font-size: 12px;
                padding: 8px 12px;
            }
        }

        @media (max-width: 768px) {
            .header {
                padding: 12px 15px;
                height: 70px;
            }
            
            .logo h1 {
                font-size: 18px;
            }
            
            .version {
                font-size: 10px;
                padding: 3px 6px;
            }
            
            .nav-buttons {
                gap: 6px;
            }
            
            .nav-btn {
                font-size: 11px;
                padding: 6px 10px;
            }
            
            .footer {
                height: 250px;
                padding: 15px;
            }
            
            .qnn-grid {
                height: 200px;
                padding: 12px;
            }
            
            .qnn-header {
                font-size: 14px;
            }
            
            .popup {
                width: 95%;
                height: 85%;
            }
            
            .training-btn {
                font-size: 14px;
                padding: 15px;
            }
            
            .training-controls {
                padding: 15px;
            }
            
            .status-panel {
                padding: 15px;
            }
        }

        @media (max-width: 480px) {
            .header {
                flex-direction: column;
                height: 100px;
                padding: 10px;
            }
            
            .logo {
                margin-bottom: 8px;
            }
            
            .nav-buttons {
                width: 100%;
                justify-content: center;
            }
            
            .training-buttons {
                flex-direction: column;
            }
            
            .qnn-grids {
                flex-direction: column;
                gap: 15px;
            }
            
            .qnn-grid {
                height: 180px;
            }
            
            .footer {
                height: 400px;
            }
        }

        /* Glitch effect */
        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }

        .glitch {
            animation: glitch 0.3s ease;
        }

        /* Quantum cube visualization */
        .quantum-cube {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 2px solid;
            transform-style: preserve-3d;
            transition: all 0.5s ease;
        }

        .quantum-cube.green {
            border-color: #39ff14;
            box-shadow: 0 0 15px #39ff14;
        }

        .quantum-cube.red {
            border-color: #ff3333;
            box-shadow: 0 0 15px #ff3333;
        }

        .cube-face {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(57, 255, 20, 0.1);
            border: 1px solid;
        }

        .cube-face.green {
            border-color: #39ff14;
        }

        .cube-face.red {
            border-color: #ff3333;
        }
    </style>
</head>
<body>
    <div class="overlay" id="overlay"></div>
    
    <!-- QNN Dashboard Popup -->
    <div class="popup" id="qnnDashboard">
        <div class="popup-header">
            <div class="popup-title">QNN DASHBOARD</div>
            <button class="popup-close" id="closeDashboard">✕</button>
        </div>
        <div class="popup-content">
            <div style="display: flex; flex-direction: column; gap: 20px;">
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 15px; background: rgba(20, 30, 20, 0.7); border-radius: 8px; border: 2px solid #39ff14;">
                    <div style="font-size: 18px; font-weight: bold; color: #39ff14;">GREEN QNN</div>
                    <div style="display: flex; gap: 25px;">
                        <div style="text-align: center;">
                            <div style="font-size: 24px; font-weight: bold;" id="dashboardGreenWins">0</div>
                            <div style="font-size: 12px; color: #88ff88;">WINS</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 24px; font-weight: bold;" id="dashboardGreenLosses">0</div>
                            <div style="font-size: 12px; color: #88ff88;">LOSSES</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 24px; font-weight: bold;" id="dashboardGreenScore">0%</div>
                            <div style="font-size: 12px; color: #88ff88;">SCORE</div>
                        </div>
                    </div>
                </div>
                
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 15px; background: rgba(30, 30, 30, 0.7); border-radius: 8px; border: 2px solid #ffffff;">
                    <div style="font-size: 18px; font-weight: bold; color: #ffffff;">BLACK QNN</div>
                    <div style="display: flex; gap: 25px;">
                        <div style="text-align: center;">
                            <div style="font-size: 24px; font-weight: bold;" id="dashboardBlackWins">0</div>
                            <div style="font-size: 12px; color: #cccccc;">WINS</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 24px; font-weight: bold;" id="dashboardBlackLosses">0</div>
                            <div style="font-size: 12px; color: #cccccc;">LOSSES</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 24px; font-weight: bold;" id="dashboardBlackScore">0%</div>
                            <div style="font-size: 12px; color: #cccccc;">SCORE</div>
                        </div>
                    </div>
                </div>
                
                <div style="display: flex; gap: 15px; justify-content: center; margin-top: 10px;">
                    <button class="training-btn start" style="padding: 12px 20px; font-size: 14px;" id="exportGreenBtn">EXPORT GREEN</button>
                    <button class="training-btn reset" style="padding: 12px 20px; font-size: 14px;" id="exportBlackBtn">EXPORT BLACK</button>
                </div>
                
                <div style="text-align: center; padding: 15px; background: rgba(57, 255, 20, 0.2); border-radius: 8px; border: 2px solid #39ff14; margin-top: 15px;">
                    <strong style="color: #39ff14;">RECOMMENDATION:</strong> 
                    <span id="dashboardRecommendation">Train both agents to improve performance</span>
                </div>

                <div style="margin-top: 20px;">
                    <h3 style="color: #39ff14; margin-bottom: 10px; text-shadow: 0 0 5px #39ff14;">QUANTUM TRAINING LOG</h3>
                    <div style="height: 150px; overflow-y: auto; background: rgba(0, 0, 0, 0.7); padding: 10px; border-radius: 6px; border: 1px solid #39ff14;">
                        <div id="trainingLog">
                            <div>System initialized and ready</div>
                            <div>QNN parameters calibrated</div>
                            <div>Quantum training environment loaded</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="loading-screen" id="loadingScreen">
        <div class="loading-logo">WEBXOS AI CHESS</div>
        <div class="loading-bar-container">
            <div class="loading-bar" id="loadingBar"></div>
        </div>
        <div class="loading-text" id="loadingText">Initializing Quantum Neural Networks...</div>
    </div>

    <div class="header">
        <div class="logo">
            <h1>WEBXOS AI CHESS</h1>
            <span class="version">QNN v5.0</span>
        </div>
        <div class="nav-buttons">
            <button class="nav-btn" id="dashboardBtn">QNN DASHBOARD</button>
            <button class="nav-btn reset" id="resetBtn">RESET</button>
        </div>
    </div>

    <div class="main-container">
        <div class="game-container">
            <div id="chessboard-3d">
                <!-- 3D chessboard will be rendered here -->
            </div>
        </div>
        <div class="training-controls">
            <div class="status-panel">
                <h2>QUANTUM TRAINING STATUS</h2>
                <div class="status-grid">
                    <div class="status-item">
                        <span class="status-label">Training Mode</span>
                        <span class="status-value" id="gameMode">QNN vs QNN</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Training Iterations</span>
                        <span class="status-value" id="moveCount">0</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Training Status</span>
                        <span class="status-value" id="gameStatus">READY</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Active Agent</span>
                        <span class="status-value" id="currentPlayer">-</span>
                    </div>
                </div>
            </div>

            <div class="status-panel">
                <h2>QUANTUM TRAINING CONTROLS</h2>
                <div class="training-buttons">
                    <button class="training-btn start" id="startBtn">START TRAINING</button>
                    <button class="training-btn stop" id="stopBtn">STOP TRAINING</button>
                </div>
                <div class="training-mode-buttons">
                    <button class="mode-btn" id="fastModeBtn">FAST MODE</button>
                    <button class="mode-btn" id="slowModeBtn">SLOW MODE</button>
                </div>
                <div class="ai-thinking" id="aiThinking">
                    <span>QNN Processing:</span>
                    <div class="thinking-dots">
                        <div class="thinking-dot"></div>
                        <div class="thinking-dot"></div>
                        <div class="thinking-dot"></div>
                    </div>
                    <span id="thinkingAI">Quantum AI</span>
                </div>
            </div>

            <div class="status-panel">
                <h2>AGENT METRICS</h2>
                <div class="status-grid">
                    <div class="status-item">
                        <span class="status-label">Green Win Rate</span>
                        <span class="status-value" id="greenWinRate">0%</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Black Win Rate</span>
                        <span class="status-value" id="blackWinRate">0%</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Avg Moves/Game</span>
                        <span class="status-value" id="avgMoves">0</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Training Speed</span>
                        <span class="status-value" id="trainingSpeed">MEDIUM</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="footer">
        <div class="qnn-grids">
            <div class="qnn-grid green">
                <div class="qnn-header green">GREEN QNN - AGENT 2</div>
                <div class="qnn-canvas-container green">
                    <canvas class="qnn-canvas" id="greenQnnCanvas" width="300" height="150"></canvas>
                </div>
                <div class="qnn-values green">
                    <span>YES/NO: <span id="greenFeedback">YES</span></span>
                    <span>Speed: <span id="greenSpeed">MEDIUM</span></span>
                    <span>Power: <span id="greenPower">0</span></span>
                </div>
            </div>
            <div class="qnn-grid black">
                <div class="qnn-header black">BLACK QNN - AGENT 1</div>
                <div class="qnn-canvas-container black">
                    <canvas class="qnn-canvas" id="blackQnnCanvas" width="300" height="150"></canvas>
                </div>
                <div class="qnn-values black">
                    <span>YES/NO: <span id="blackFeedback">YES</span></span>
                    <span>Speed: <span id="blackSpeed">MEDIUM</span></span>
                    <span>Power: <span id="blackPower">0</span></span>
                </div>
            </div>
        </div>
        <div class="copyright">WEBXOS © 2025-2026 | Quantum Neural Network Training System</div>
    </div>

    <script>
        // Enhanced game state with user feedback system
        let gameMode = 'ai-vs-ai';
        let currentPlayer = 'green';
        let moveCount = 0;
        let gameActive = false;
        let boardState = [];
        let autoPlayInterval = null;
        let isTraining = false;
        let trainingInterval = null;
        let trainingLog = [
            "System initialized and ready",
            "QNN parameters calibrated",
            "Quantum training environment loaded"
        ];
        let gamesCompleted = 0;
        let totalMoves = 0;
        let trainingMode = 'fast'; // 'fast' or 'slow'
        
        // Agent performance tracking with enhanced metrics
        let agentPerformance = {
            green: { 
                wins: 0, 
                losses: 0, 
                score: 0, 
                strategy: 'balanced', 
                speed: 1.0,
                movesTried: 0,
                piecesUsed: {},
                thinkingTime: 0
            },
            black: { 
                wins: 0, 
                losses: 0, 
                score: 0, 
                strategy: 'balanced', 
                speed: 1.0,
                movesTried: 0,
                piecesUsed: {},
                thinkingTime: 0
            }
        };
        
        // User feedback system
        let userFeedback = {
            green: { 
                lastYesNo: 'yes', 
                lastX: 0.5, 
                lastY: 0.5, 
                powerBalls: [],
                quantumCube: { x: 0, y: 0, z: 0, perfect: false }
            },
            black: { 
                lastYesNo: 'yes', 
                lastX: 0.5, 
                lastY: 0.5, 
                powerBalls: [],
                quantumCube: { x: 0, y: 0, z: 0, perfect: false }
            }
        };
        
        // Three.js variables
        let scene, camera, renderer, controls;
        let chessboard, pieces = [];
        let selectedPiece = null;
        let possibleMoves = [];

        // QNN Visualization
        let greenCanvas, blackCanvas;
        let greenCtx, blackCtx;

        // Initialize the application
        function init() {
            updateLoading("Initializing Quantum Processors...", 20);
            
            // Initialize 3D chessboard
            init3DChessboard();
            
            updateLoading("Calibrating QNN Parameters...", 50);
            setupQnnCanvases();
            setupEventListeners();
            
            updateLoading("Preparing Quantum Training...", 80);
            initializeBoard();
            
            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loadingScreen').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.display = 'none';
                    updateGameInfo();
                    updateTrainingLog();
                }, 500);
            }, 1000);
        }

        function updateLoading(text, progress) {
            document.getElementById('loadingText').textContent = text;
            document.getElementById('loadingBar').style.width = `${progress}%`;
        }

        // Initialize 3D chessboard with enhanced visuals
        function init3DChessboard() {
            // Create scene with neural background
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // Add neural pattern background
            createNeuralBackground();
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, 20);
            camera.lookAt(0, 0, 0);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(document.getElementById('chessboard-3d').clientWidth, 
                            document.getElementById('chessboard-3d').clientHeight);
            document.getElementById('chessboard-3d').appendChild(renderer.domElement);
            
            // Add orbit controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Add enhanced lighting
            const ambientLight = new THREE.AmbientLight(0x222222, 1);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0x39ff14, 1);
            directionalLight.position.set(10, 20, 10);
            scene.add(directionalLight);
            
            const pointLight = new THREE.PointLight(0x39ff14, 0.7, 100);
            pointLight.position.set(0, 10, 0);
            scene.add(pointLight);
            
            // Create chessboard with enhanced materials
            createChessboard3D();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Start animation loop
            animate();
        }
        
        function createNeuralBackground() {
            // Create neural connections in the background
            const neuralGeometry = new THREE.BufferGeometry();
            const neuralMaterial = new THREE.LineBasicMaterial({ 
                color: 0x39ff14, 
                transparent: true,
                opacity: 0.1
            });
            
            const vertices = [];
            for (let i = 0; i < 100; i++) {
                vertices.push(
                    Math.random() * 100 - 50,
                    Math.random() * 100 - 50,
                    Math.random() * 100 - 50
                );
            }
            
            neuralGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const neuralLines = new THREE.Line(neuralGeometry, neuralMaterial);
            scene.add(neuralLines);
        }
        
        function createChessboard3D() {
            // Enhanced board with better textures
            const boardGeometry = new THREE.BoxGeometry(18, 0.5, 18);
            const boardMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x111111,
                roughness: 0.7,
                metalness: 0.3,
                emissive: 0x061006
            });
            chessboard = new THREE.Mesh(boardGeometry, boardMaterial);
            chessboard.position.y = -0.25;
            scene.add(chessboard);
            
            // Create squares with enhanced materials
            const squareGeometry = new THREE.BoxGeometry(2, 0.1, 2);
            const lightMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a3d1a,
                roughness: 0.5,
                metalness: 0.4,
                emissive: 0x0a2a0a
            });
            const darkMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x000000,
                roughness: 0.5,
                metalness: 0.4,
                emissive: 0x061006
            });
            
            for (let x = 0; x < 8; x++) {
                for (let z = 0; z < 8; z++) {
                    const isLight = (x + z) % 2 === 0;
                    const material = isLight ? lightMaterial : darkMaterial;
                    const square = new THREE.Mesh(squareGeometry, material);
                    square.position.set((x - 3.5) * 2, 0, (z - 3.5) * 2);
                    square.userData = { x: x, z: z, isSquare: true };
                    scene.add(square);
                }
            }
            
            // Enhanced border with stronger glow
            const borderGeometry = new THREE.BoxGeometry(18.2, 0.6, 18.2);
            const borderMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x39ff14,
                roughness: 0.2,
                metalness: 0.8,
                emissive: 0x0a3a0a
            });
            const border = new THREE.Mesh(borderGeometry, borderMaterial);
            border.position.y = -0.3;
            scene.add(border);
            
            // Create initial pieces
            createPieces3D();
        }
        
        function createPieces3D() {
            // Enhanced piece geometries with better details
            const pieceGeometries = {
                pawn: new THREE.CylinderGeometry(0.6, 0.8, 1.6, 16),
                rook: new THREE.CylinderGeometry(0.8, 0.8, 1.6, 16),
                knight: new THREE.ConeGeometry(0.8, 1.6, 16),
                bishop: new THREE.ConeGeometry(0.6, 1.6, 16),
                queen: new THREE.SphereGeometry(0.8, 16, 16),
                king: new THREE.CylinderGeometry(0.6, 0.8, 2, 16)
            };
            
            // Enhanced materials with stronger glow
            const greenMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x39ff14,
                roughness: 0.1,
                metalness: 0.9,
                emissive: 0x0a3a0a
            });
            
            const blackMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x111111,
                roughness: 0.1,
                metalness: 0.9,
                emissive: 0x050505
            });
            
            // Set up initial piece positions
            const initialPositions = [
                // Black pieces (back row)
                { type: 'rook', color: 'black', x: 0, z: 0 },
                { type: 'knight', color: 'black', x: 1, z: 0 },
                { type: 'bishop', color: 'black', x: 2, z: 0 },
                { type: 'queen', color: 'black', x: 3, z: 0 },
                { type: 'king', color: 'black', x: 4, z: 0 },
                { type: 'bishop', color: 'black', x: 5, z: 0 },
                { type: 'knight', color: 'black', x: 6, z: 0 },
                { type: 'rook', color: 'black', x: 7, z: 0 },
                
                // Black pawns
                { type: 'pawn', color: 'black', x: 0, z: 1 },
                { type: 'pawn', color: 'black', x: 1, z: 1 },
                { type: 'pawn', color: 'black', x: 2, z: 1 },
                { type: 'pawn', color: 'black', x: 3, z: 1 },
                { type: 'pawn', color: 'black', x: 4, z: 1 },
                { type: 'pawn', color: 'black', x: 5, z: 1 },
                { type: 'pawn', color: 'black', x: 6, z: 1 },
                { type: 'pawn', color: 'black', x: 7, z: 1 },
                
                // Green pieces (back row)
                { type: 'rook', color: 'green', x: 0, z: 7 },
                { type: 'knight', color: 'green', x: 1, z: 7 },
                { type: 'bishop', color: 'green', x: 2, z: 7 },
                { type: 'queen', color: 'green', x: 3, z: 7 },
                { type: 'king', color: 'green', x: 4, z: 7 },
                { type: 'bishop', color: 'green', x: 5, z: 7 },
                { type: 'knight', color: 'green', x: 6, z: 7 },
                { type: 'rook', color: 'green', x: 7, z: 7 },
                
                // Green pawns
                { type: 'pawn', color: 'green', x: 0, z: 6 },
                { type: 'pawn', color: 'green', x: 1, z: 6 },
                { type: 'pawn', color: 'green', x: 2, z: 6 },
                { type: 'pawn', color: 'green', x: 3, z: 6 },
                { type: 'pawn', color: 'green', x: 4, z: 6 },
                { type: 'pawn', color: 'green', x: 5, z: 6 },
                { type: 'pawn', color: 'green', x: 6, z: 6 },
                { type: 'pawn', color: 'green', x: 7, z: 6 }
            ];
            
            // Create pieces
            initialPositions.forEach(pos => {
                const geometry = pieceGeometries[pos.type];
                const material = pos.color === 'green' ? greenMaterial : blackMaterial;
                const piece = new THREE.Mesh(geometry, material);
                
                piece.position.set((pos.x - 3.5) * 2, 1, (pos.z - 3.5) * 2);
                piece.userData = { 
                    type: pos.type, 
                    color: pos.color, 
                    x: pos.x, 
                    z: pos.z,
                    isPiece: true
                };
                
                scene.add(piece);
                pieces.push(piece);
            });
        }
        
        function onWindowResize() {
            camera.aspect = document.getElementById('chessboard-3d').clientWidth / 
                           document.getElementById('chessboard-3d').clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(document.getElementById('chessboard-3d').clientWidth, 
                           document.getElementById('chessboard-3d').clientHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            
            // Update QNN visualizations
            updateQnnVisualizations();
        }

        // Enhanced QNN visualization with three dots and quantum cube
        function setupQnnCanvases() {
            greenCanvas = document.getElementById('greenQnnCanvas');
            blackCanvas = document.getElementById('blackQnnCanvas');
            greenCtx = greenCanvas.getContext('2d');
            blackCtx = blackCanvas.getContext('2d');
            
            // Set canvas size to match container
            greenCanvas.width = greenCanvas.parentElement.clientWidth;
            greenCanvas.height = greenCanvas.parentElement.clientHeight;
            blackCanvas.width = blackCanvas.parentElement.clientWidth;
            blackCanvas.height = blackCanvas.parentElement.clientHeight;
            
            // Add click handlers for user feedback
            greenCanvas.addEventListener('click', (e) => handleUserFeedback(e, 'green'));
            blackCanvas.addEventListener('click', (e) => handleUserFeedback(e, 'black'));
            
            // Draw initial QNN grids
            drawQnnGrid(greenCtx, greenCanvas, 'green');
            drawQnnGrid(blackCtx, blackCanvas, 'black');
        }
        
        function drawQnnGrid(ctx, canvas, color) {
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            
            // Draw grid
            ctx.strokeStyle = color === 'green' ? '#39ff14' : '#ffffff';
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.3;
            
            // Vertical lines
            for (let x = 0; x <= width; x += width / 10) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let y = 0; y <= height; y += height / 10) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            ctx.globalAlpha = 1.0;
            
            // Draw user feedback dot (top - green)
            const feedback = userFeedback[color];
            const userX = feedback.lastX * width;
            const userY = feedback.lastY * height * 0.3; // Top third for user feedback
            
            ctx.fillStyle = feedback.lastYesNo === 'yes' ? '#39ff14' : '#ff3333';
            ctx.beginPath();
            ctx.arc(userX, userY, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowColor = feedback.lastYesNo === 'yes' ? '#39ff14' : '#ff3333';
            ctx.shadowBlur = 15;
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Draw agent move dot (middle - red) - real-time position
            const moveX = (Math.random() * 0.8 + 0.1) * width;
            const moveY = height * 0.5;
            
            ctx.fillStyle = '#ff3333';
            ctx.beginPath();
            ctx.arc(moveX, moveY, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowColor = '#ff3333';
            ctx.shadowBlur = 10;
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Draw powerball dots (bottom - blue)
            feedback.powerBalls.forEach(ball => {
                ctx.fillStyle = '#00ffff';
                ctx.beginPath();
                ctx.arc(ball.x * width, ball.y * height, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 8;
                ctx.fill();
                ctx.shadowBlur = 0;
            });
            
            // Draw quantum cube visualization
            drawQuantumCube(ctx, canvas, color);
            
            // Add powerball count
            ctx.fillStyle = '#00ffff';
            ctx.font = '10px Courier New';
            ctx.fillText(`Power: ${feedback.powerBalls.length}`, 5, height - 5);
        }
        
        function drawQuantumCube(ctx, canvas, color) {
            const width = canvas.width;
            const height = canvas.height;
            const feedback = userFeedback[color];
            const cube = feedback.quantumCube;
            
            // Draw cube outline
            const cubeSize = 30;
            const cubeX = width - cubeSize - 10;
            const cubeY = height / 2 - cubeSize / 2;
            
            ctx.strokeStyle = color === 'green' ? '#39ff14' : '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(cubeX, cubeY, cubeSize, cubeSize);
            
            // Draw cube faces based on quantum state
            ctx.fillStyle = color === 'green' ? 'rgba(57, 255, 20, 0.2)' : 'rgba(255, 255, 255, 0.2)';
            ctx.fillRect(cubeX, cubeY, cubeSize, cubeSize);
            
            // Draw internal lines representing quantum state
            ctx.strokeStyle = color === 'green' ? '#39ff14' : '#ffffff';
            ctx.lineWidth = 1;
            
            // X dimension (entanglement)
            const xLine = cubeX + cube.x * cubeSize;
            ctx.beginPath();
            ctx.moveTo(xLine, cubeY);
            ctx.lineTo(xLine, cubeY + cubeSize);
            ctx.stroke();
            
            // Y dimension (superposition)
            const yLine = cubeY + cube.y * cubeSize;
            ctx.beginPath();
            ctx.moveTo(cubeX, yLine);
            ctx.lineTo(cubeX + cubeSize, yLine);
            ctx.stroke();
            
            // Z dimension (interference)
            const zOffset = cube.z * 10;
            ctx.beginPath();
            ctx.moveTo(cubeX + zOffset, cubeY + zOffset);
            ctx.lineTo(cubeX + cubeSize - zOffset, cubeY + cubeSize - zOffset);
            ctx.stroke();
            
            // Highlight if cube is perfect
            if (cube.perfect) {
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 3;
                ctx.strokeRect(cubeX - 2, cubeY - 2, cubeSize + 4, cubeSize + 4);
            }
        }
        
        function handleUserFeedback(event, color) {
            const canvas = color === 'green' ? greenCanvas : blackCanvas;
            const rect = canvas.getBoundingClientRect();
            const x = (event.clientX - rect.left) / canvas.width;
            const y = (event.clientY - rect.top) / canvas.height;
            
            const feedback = userFeedback[color];
            feedback.lastX = x;
            feedback.lastY = y;
            
            // Determine YES/NO based on position (left = NO, right = YES)
            feedback.lastYesNo = x > 0.5 ? 'yes' : 'no';
            
            // Determine speed based on Y position (top = fast, bottom = slow)
            const speed = y < 0.33 ? 'FAST' : y < 0.66 ? 'MEDIUM' : 'SLOW';
            
            // Update agent behavior based on feedback
            updateAgentBehavior(color, feedback.lastYesNo, speed, x, y);
            
            // Update UI
            document.getElementById(`${color}Feedback`).textContent = feedback.lastYesNo.toUpperCase();
            document.getElementById(`${color}Speed`).textContent = speed;
            document.getElementById(`${color}Power`).textContent = feedback.powerBalls.length;
            
            // Redraw grid
            const ctx = color === 'green' ? greenCtx : blackCtx;
            drawQnnGrid(ctx, canvas, color);
            
            // Add powerball for this interaction
            feedback.powerBalls.push({ x: Math.random(), y: Math.random() });
            
            // Update quantum cube based on user input
            updateQuantumCube(color, x, y);
            
            // Log user feedback
            trainingLog.push(`User ${feedback.lastYesNo.toUpperCase()} for ${color} agent at speed ${speed}`);
            updateTrainingLog();
        }
        
        function updateAgentBehavior(color, yesNo, speed, x, y) {
            const agent = agentPerformance[color];
            
            // Update strategy based on YES/NO
            if (yesNo === 'yes') {
                // Continue current strategy, refine parameters
                agent.strategy = 'refined';
                trainingLog.push(`${color} agent continuing current strategy`);
            } else {
                // Change strategy, explore new approaches
                agent.strategy = 'exploratory';
                trainingLog.push(`${color} agent changing strategy`);
            }
            
            // Update speed based on Y position
            switch(speed) {
                case 'FAST': agent.speed = 2.0; break;
                case 'MEDIUM': agent.speed = 1.0; break;
                case 'SLOW': agent.speed = 0.5; break;
            }
            
            // Update training speed display
            document.getElementById('trainingSpeed').textContent = speed;
            
            // Update quantum metrics based on XY position
            updateQuantumMetrics(color, x, y);
        }
        
        function updateQuantumMetrics(color, x, y) {
            // Update quantum metrics based on user input
            const feedback = userFeedback[color];
            
            // X controls entanglement (curve complexity)
            feedback.quantumCube.x = x;
            
            // Y controls superposition (curve length)
            feedback.quantumCube.y = y;
            
            // Z controls interference (random factor)
            feedback.quantumCube.z = Math.random();
            
            // Check if cube is perfect (all values close to 0.5)
            const isPerfect = Math.abs(x - 0.5) < 0.1 && Math.abs(y - 0.5) < 0.1 && Math.abs(feedback.quantumCube.z - 0.5) < 0.1;
            feedback.quantumCube.perfect = isPerfect;
            
            if (isPerfect) {
                trainingLog.push(`${color} agent achieved perfect quantum superposition`);
                updateTrainingLog();
            }
        }
        
        function updateQuantumCube(color, x, y) {
            // This function updates the quantum cube visualization
            const feedback = userFeedback[color];
            feedback.quantumCube.x = x;
            feedback.quantumCube.y = y;
            feedback.quantumCube.z = Math.random();
            
            // Check if cube is perfect
            const isPerfect = Math.abs(x - 0.5) < 0.1 && Math.abs(y - 0.5) < 0.1 && Math.abs(feedback.quantumCube.z - 0.5) < 0.1;
            feedback.quantumCube.perfect = isPerfect;
            
            // Redraw the grid to update the cube
            const canvas = color === 'green' ? greenCanvas : blackCanvas;
            const ctx = color === 'green' ? greenCtx : blackCtx;
            drawQnnGrid(ctx, canvas, color);
        }
        
        function updateQnnVisualizations() {
            // Randomly update powerballs and agent positions
            if (Math.random() < 0.1) {
                ['green', 'black'].forEach(color => {
                    const feedback = userFeedback[color];
                    
                    // Occasionally add new powerballs
                    if (Math.random() < 0.3 && feedback.powerBalls.length < 50) {
                        feedback.powerBalls.push({ 
                            x: Math.random(), 
                            y: Math.random() 
                        });
                    }
                    
                    // Update displays
                    document.getElementById(`${color}Power`).textContent = feedback.powerBalls.length;
                    
                    // Redraw grid
                    const canvas = color === 'green' ? greenCanvas : blackCanvas;
                    const ctx = color === 'green' ? greenCtx : blackCtx;
                    drawQnnGrid(ctx, canvas, color);
                });
            }
        }

        function initializeBoard() {
            // Initialize an 8x8 board
            boardState = Array(8).fill().map(() => Array(8).fill(null));
            
            // Set up pawns
            for (let i = 0; i < 8; i++) {
                boardState[i][1] = { type: 'pawn', color: 'black' };
                boardState[i][6] = { type: 'pawn', color: 'green' };
            }
            
            // Set up other pieces
            const backRow = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
            for (let i = 0; i < 8; i++) {
                boardState[i][0] = { type: backRow[i], color: 'black' };
                boardState[i][7] = { type: backRow[i], color: 'green' };
            }
        }

        function setupEventListeners() {
            // Training buttons
            document.getElementById('startBtn').addEventListener('click', startTraining);
            document.getElementById('stopBtn').addEventListener('click', pauseTraining);
            document.getElementById('resetBtn').addEventListener('click', resetSystem);
            
            // Training mode buttons
            document.getElementById('fastModeBtn').addEventListener('click', () => setTrainingMode('fast'));
            document.getElementById('slowModeBtn').addEventListener('click', () => setTrainingMode('slow'));
            
            // Dashboard button
            document.getElementById('dashboardBtn').addEventListener('click', showDashboard);
            document.getElementById('closeDashboard').addEventListener('click', hideDashboard);
            
            // Agent management
            document.getElementById('exportGreenBtn').addEventListener('click', () => saveAgent('green'));
            document.getElementById('exportBlackBtn').addEventListener('click', () => saveAgent('black'));
            
            // Overlay click to close popups
            document.getElementById('overlay').addEventListener('click', () => {
                hideDashboard();
            });
            
            // Add click handler for 3D board
            renderer.domElement.addEventListener('click', onCanvasClick, false);
        }
        
        function setTrainingMode(mode) {
            trainingMode = mode;
            
            // Update UI
            document.getElementById('fastModeBtn').classList.toggle('active', mode === 'fast');
            document.getElementById('slowModeBtn').classList.toggle('active', mode === 'slow');
            
            // Update training speed based on mode
            if (mode === 'fast') {
                agentPerformance.green.speed = 2.0;
                agentPerformance.black.speed = 2.0;
                document.getElementById('trainingSpeed').textContent = 'FAST';
            } else {
                agentPerformance.green.speed = 0.5;
                agentPerformance.black.speed = 0.5;
                document.getElementById('trainingSpeed').textContent = 'SLOW';
            }
            
            trainingLog.push(`Training mode set to ${mode.toUpperCase()}`);
            updateTrainingLog();
            
            // Restart auto-play if training is active
            if (isTraining) {
                startAutoPlay();
            }
        }
        
        function showDashboard() {
            // Update dashboard with current data
            document.getElementById('dashboardGreenWins').textContent = agentPerformance.green.wins;
            document.getElementById('dashboardGreenLosses').textContent = agentPerformance.green.losses;
            document.getElementById('dashboardGreenScore').textContent = agentPerformance.green.score + '%';
            
            document.getElementById('dashboardBlackWins').textContent = agentPerformance.black.wins;
            document.getElementById('dashboardBlackLosses').textContent = agentPerformance.black.losses;
            document.getElementById('dashboardBlackScore').textContent = agentPerformance.black.score + '%';
            
            // Update recommendation
            let recommendation = document.getElementById('dashboardRecommendation');
            if (agentPerformance.green.score > agentPerformance.black.score) {
                recommendation.textContent = 'Export the GREEN QNN agent for best performance';
            } else if (agentPerformance.black.score > agentPerformance.green.score) {
                recommendation.textContent = 'Export the BLACK QNN agent for best performance';
            } else {
                recommendation.textContent = 'Both agents performing similarly - continue training';
            }
            
            document.getElementById('qnnDashboard').classList.add('active');
            document.getElementById('overlay').classList.add('active');
        }
        
        function hideDashboard() {
            document.getElementById('qnnDashboard').classList.remove('active');
            document.getElementById('overlay').classList.remove('active');
        }
        
        function resetSystem() {
            pauseTraining();
            
            // Reset game state
            moveCount = 0;
            currentPlayer = 'green';
            gameActive = false;
            gamesCompleted = 0;
            isTraining = false;
            totalMoves = 0;
            
            // Reset user feedback
            userFeedback = {
                green: { 
                    lastYesNo: 'yes', 
                    lastX: 0.5, 
                    lastY: 0.5, 
                    powerBalls: [],
                    quantumCube: { x: 0, y: 0, z: 0, perfect: false }
                },
                black: { 
                    lastYesNo: 'yes', 
                    lastX: 0.5, 
                    lastY: 0.5, 
                    powerBalls: [],
                    quantumCube: { x: 0, y: 0, z: 0, perfect: false }
                }
            };
            
            // Reset agent performance
            agentPerformance = {
                green: { 
                    wins: 0, 
                    losses: 0, 
                    score: 0, 
                    strategy: 'balanced', 
                    speed: 1.0,
                    movesTried: 0,
                    piecesUsed: {},
                    thinkingTime: 0
                },
                black: { 
                    wins: 0, 
                    losses: 0, 
                    score: 0, 
                    strategy: 'balanced', 
                    speed: 1.0,
                    movesTried: 0,
                    piecesUsed: {},
                    thinkingTime: 0
                }
            };
            
            // Reset training log
            trainingLog = [
                "System initialized and ready",
                "QNN parameters calibrated",
                "Quantum training environment loaded"
            ];
            
            // Reset UI displays
            document.getElementById('greenFeedback').textContent = 'YES';
            document.getElementById('greenSpeed').textContent = 'MEDIUM';
            document.getElementById('greenPower').textContent = '0';
            document.getElementById('blackFeedback').textContent = 'YES';
            document.getElementById('blackSpeed').textContent = 'MEDIUM';
            document.getElementById('blackPower').textContent = '0';
            document.getElementById('greenWinRate').textContent = '0%';
            document.getElementById('blackWinRate').textContent = '0%';
            document.getElementById('avgMoves').textContent = '0';
            document.getElementById('trainingSpeed').textContent = 'MEDIUM';
            
            // Reset training mode
            setTrainingMode('fast');
            
            // Redraw QNN grids
            drawQnnGrid(greenCtx, greenCanvas, 'green');
            drawQnnGrid(blackCtx, blackCanvas, 'black');
            
            // Reset 3D board
            reset3DBoard();
            
            // Update game info
            updateGameInfo();
            updateTrainingLog();
            
            // Add glitch effect
            document.body.classList.add('glitch');
            setTimeout(() => document.body.classList.remove('glitch'), 300);
        }
        
        function saveAgent(color) {
            // Create comprehensive quantum training log
            const quantumMetrics = {
                superposition: calculateSuperposition(color),
                entanglement: calculateEntanglement(color),
                interference: calculateInterference(color),
                coherence: calculateCoherence(color),
                quantumCube: userFeedback[color].quantumCube
            };
            
            const agentData = {
                metadata: {
                    version: "QNN v5.0",
                    timestamp: new Date().toISOString(),
                    trainingSessions: gamesCompleted,
                    totalMoves: totalMoves,
                    trainingMode: trainingMode,
                    exportType: "Quantum Training Session"
                },
                agent: {
                    color: color,
                    performance: agentPerformance[color],
                    strategy: agentPerformance[color].strategy,
                    speed: agentPerformance[color].speed,
                    userFeedback: userFeedback[color]
                },
                quantumMetrics: quantumMetrics,
                trainingHistory: {
                    moveLog: trainingLog.filter(entry => entry.includes(color)),
                    gameHistory: getGameHistory(color),
                    userPreferences: {
                        lastYesNo: userFeedback[color].lastYesNo,
                        preferredX: userFeedback[color].lastX,
                        preferredY: userFeedback[color].lastY
                    }
                },
                quantumStudyData: {
                    superpositionExplanation: "Qubits exist in multiple states simultaneously, enabling parallel computation",
                    entanglementExplanation: "Qubits become interdependent, enhancing collective processing power",
                    interferenceExplanation: "Quantum algorithms manipulate probabilities to amplify correct solutions",
                    practicalApplications: {
                        drugDiscovery: "Simulates molecular interactions through quantum-inspired training",
                        aiAcceleration: "Demonstrates rapid AI evolution using quantum principles",
                        optimization: "Solves complex problems by exploring vast solution spaces"
                    }
                }
            };
            
            const blob = new Blob([JSON.stringify(agentData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `quantum_chess_${color}_agent_${new Date().toISOString().slice(0, 10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            trainingLog.push(`${color} agent exported with quantum training metrics`);
            updateTrainingLog();
        }
        
        // Quantum metric calculations (simulated)
        function calculateSuperposition(color) {
            // Simulate superposition based on agent behavior diversity
            const diversity = userFeedback[color].powerBalls.length / 50;
            return Math.min(1, diversity * 1.2);
        }
        
        function calculateEntanglement(color) {
            // Simulate entanglement based on strategy consistency
            const consistency = agentPerformance[color].wins / (agentPerformance[color].wins + agentPerformance[color].losses || 1);
            return Math.min(1, consistency * 0.8 + 0.2);
        }
        
        function calculateInterference(color) {
            // Simulate interference based on move effectiveness
            const effectiveness = agentPerformance[color].score / 100;
            return Math.min(1, effectiveness * 0.9 + 0.1);
        }
        
        function calculateCoherence(color) {
            // Simulate coherence based on training stability
            const stability = gamesCompleted > 0 ? Math.min(1, moveCount / (gamesCompleted * 20)) : 0.5;
            return Math.min(1, stability * 0.7 + 0.3);
        }
        
        function getGameHistory(color) {
            // Generate simulated game history
            const history = [];
            for (let i = 0; i < Math.min(10, gamesCompleted); i++) {
                history.push({
                    game: i + 1,
                    moves: Math.floor(Math.random() * 30) + 10,
                    result: Math.random() > 0.5 ? 'win' : 'loss',
                    strategy: Math.random() > 0.5 ? 'aggressive' : 'defensive'
                });
            }
            return history;
        }
        
        function updateTrainingLog() {
            const logContainer = document.getElementById('trainingLog');
            logContainer.innerHTML = '';
            
            // Add entries in reverse order (newest first)
            for (let i = trainingLog.length - 1; i >= 0; i--) {
                const entry = document.createElement('div');
                entry.textContent = trainingLog[i];
                entry.style.padding = '2px 0';
                entry.style.borderBottom = '1px solid rgba(57, 255, 20, 0.2)';
                logContainer.appendChild(entry);
            }
        }
        
        function onCanvasClick(event) {
            if (!gameActive || gameMode === 'ai-vs-ai') return;
            
            // Calculate mouse position in normalized device coordinates
            const mouse = new THREE.Vector2();
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Create raycaster
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            // Check for intersections
            const intersects = raycaster.intersectObjects(scene.children);
            
            if (intersects.length > 0) {
                const object = intersects[0].object;
                
                if (object.userData.isPiece) {
                    // If it's a piece of the current player's color
                    if (object.userData.color === currentPlayer) {
                        selectPiece(object);
                    }
                } else if (object.userData.isSquare && selectedPiece) {
                    // If it's a square and we have a selected piece
                    movePiece(object.userData.x, object.userData.z);
                }
            }
        }
        
        function selectPiece(piece) {
            // Deselect previous piece
            if (selectedPiece) {
                selectedPiece.material.emissive.setHex(0x000000);
            }
            
            // Select new piece
            selectedPiece = piece;
            selectedPiece.material.emissive.setHex(0x333333);
            
            // Calculate possible moves (simplified)
            calculatePossibleMoves(piece.userData.x, piece.userData.z);
            
            // Highlight possible moves
            highlightPossibleMoves();
        }
        
        function calculatePossibleMoves(x, z) {
            // Simplified move calculation for demonstration
            possibleMoves = [];
            
            // For pawns
            if (selectedPiece.userData.type === 'pawn') {
                const direction = selectedPiece.userData.color === 'green' ? -1 : 1;
                
                // Forward move
                if (z + direction >= 0 && z + direction < 8 && !boardState[x][z + direction]) {
                    possibleMoves.push({ x: x, z: z + direction });
                }
                
                // Capture moves
                if (x > 0 && z + direction >= 0 && z + direction < 8 && 
                    boardState[x-1][z + direction] && 
                    boardState[x-1][z + direction].color !== selectedPiece.userData.color) {
                    possibleMoves.push({ x: x-1, z: z + direction });
                }
                
                if (x < 7 && z + direction >= 0 && z + direction < 8 && 
                    boardState[x+1][z + direction] && 
                    boardState[x+1][z + direction].color !== selectedPiece.userData.color) {
                    possibleMoves.push({ x: x+1, z: z + direction });
                }
            }
            
            // For other pieces, we'd implement more complex logic
            // This is a simplified version for demonstration
        }
        
        function highlightPossibleMoves() {
            // Remove previous highlights
            clearHighlights();
            
            // Add highlights for possible moves
            possibleMoves.forEach(move => {
                const squareGeometry = new THREE.PlaneGeometry(1.8, 1.8);
                const highlightMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x39ff14, 
                    transparent: true, 
                    opacity: 0.5,
                    side: THREE.DoubleSide
                });
                const highlight = new THREE.Mesh(squareGeometry, highlightMaterial);
                highlight.rotation.x = -Math.PI / 2;
                highlight.position.set((move.x - 3.5) * 2, 0.1, (move.z - 3.5) * 2);
                highlight.userData.isHighlight = true;
                scene.add(highlight);
            });
        }
        
        function clearHighlights() {
            scene.children.forEach(child => {
                if (child.userData.isHighlight) {
                    scene.remove(child);
                }
            });
        }
        
        function movePiece(x, z) {
            // Check if the move is valid
            const isValidMove = possibleMoves.some(move => move.x === x && move.z === z);
            
            if (isValidMove) {
                // Update board state
                const fromX = selectedPiece.userData.x;
                const fromZ = selectedPiece.userData.z;
                
                boardState[x][z] = {
                    type: selectedPiece.userData.type,
                    color: selectedPiece.userData.color
                };
                boardState[fromX][fromZ] = null;
                
                // Update piece position
                selectedPiece.position.set((x - 3.5) * 2, 1, (z - 3.5) * 2);
                selectedPiece.userData.x = x;
                selectedPiece.userData.z = z;
                
                // Switch player
                currentPlayer = currentPlayer === 'green' ? 'black' : 'green';
                moveCount++;
                totalMoves++;
                
                // Update UI
                updateGameInfo();
                
                // Deselect piece and clear highlights
                selectedPiece.material.emissive.setHex(0x000000);
                selectedPiece = null;
                clearHighlights();
                
                // If in AI mode, trigger AI move
                if (gameMode === 'ai-vs-ai' && gameActive) {
                    setTimeout(makeAIMove, 500);
                }
                
                // Add glitch effect
                document.body.classList.add('glitch');
                setTimeout(() => document.body.classList.remove('glitch'), 300);
            }
        }
        
        function startTraining() {
            if (isTraining) return;
            
            isTraining = true;
            gameActive = true;
            
            // Show training indicator
            document.getElementById('startBtn').classList.add('active');
            document.getElementById('stopBtn').classList.remove('active');
            
            // Start auto-play
            startAutoPlay();
            
            trainingLog.push("Quantum training started");
            updateTrainingLog();
        }

        function startAutoPlay() {
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
            }
            
            // Adjust interval based on training mode
            const interval = trainingMode === 'fast' ? 1000 : 3000;
            
            autoPlayInterval = setInterval(() => {
                if (gameActive) {
                    makeAIMove();
                }
            }, interval / agentPerformance[currentPlayer].speed);
        }

        function makeAIMove() {
            if (!gameActive) return;
            
            // Show AI thinking indicator
            document.getElementById('aiThinking').classList.add('active');
            document.getElementById('thinkingAI').textContent = 
                currentPlayer === 'green' ? 'Quantum AI' : 'NeuralNet';
            
            // Record thinking start time for slow mode
            const thinkStart = Date.now();
            
            // Simulate AI thinking time based on mode
            const thinkTime = trainingMode === 'fast' ? 
                500 / agentPerformance[currentPlayer].speed : 
                2000 / agentPerformance[currentPlayer].speed;
            
            setTimeout(() => {
                // Record thinking time for slow mode
                if (trainingMode === 'slow') {
                    agentPerformance[currentPlayer].thinkingTime += Date.now() - thinkStart;
                }
                
                // In a real implementation, this would use the AI to select a move
                // For now, we'll simulate a move
                simulateAIMove();
                
                // Hide AI thinking indicator
                document.getElementById('aiThinking').classList.remove('active');
            }, thinkTime);
        }

        function simulateAIMove() {
            // This is a simplified move simulation
            // In a real implementation, this would use proper chess logic
            
            // Find all pieces of the current player
            const currentPieces = pieces.filter(piece => 
                piece.userData.color === currentPlayer && 
                boardState[piece.userData.x][piece.userData.z] !== null
            );
            
            if (currentPieces.length === 0) {
                endGame();
                return;
            }
            
            // In slow mode, try multiple moves before selecting one
            let moveAttempts = trainingMode === 'slow' ? Math.floor(Math.random() * 5) + 3 : 1;
            agentPerformance[currentPlayer].movesTried += moveAttempts;
            
            // Select a random piece
            const randomPiece = currentPieces[Math.floor(Math.random() * currentPieces.length)];
            
            // Track piece usage
            if (!agentPerformance[currentPlayer].piecesUsed[randomPiece.userData.type]) {
                agentPerformance[currentPlayer].piecesUsed[randomPiece.userData.type] = 0;
            }
            agentPerformance[currentPlayer].piecesUsed[randomPiece.userData.type]++;
            
            // Select a random valid move for that piece
            selectPiece(randomPiece);
            calculatePossibleMoves(randomPiece.userData.x, randomPiece.userData.z);
            
            if (possibleMoves.length > 0) {
                const randomMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                movePiece(randomMove.x, randomMove.z);
                trainingLog.push(`${currentPlayer.toUpperCase()} QNN makes a move`);
                updateTrainingLog();
            } else {
                // If no valid moves, try another piece
                simulateAIMove();
            }
            
            // Randomly end the game after some moves
            if (moveCount > 10 && Math.random() < 0.1) {
                endGame();
            }
        }

        function endGame() {
            gameActive = false;
            document.getElementById('gameStatus').textContent = 'GAME OVER';
            
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
                autoPlayInterval = null;
            }
            
            // Show result
            const results = ['Green QNN wins by checkmate', 'Black QNN wins by checkmate', 'Draw by stalemate'];
            const result = results[Math.floor(Math.random() * results.length)];
            
            // Update agent performance based on result
            if (result.includes('Green')) {
                agentPerformance.green.wins++;
                agentPerformance.black.losses++;
            } else if (result.includes('Black')) {
                agentPerformance.black.wins++;
                agentPerformance.green.losses++;
            }
            
            // Calculate scores
            const totalGames = agentPerformance.green.wins + agentPerformance.green.losses + 
                              agentPerformance.black.wins + agentPerformance.black.losses;
            
            if (totalGames > 0) {
                agentPerformance.green.score = Math.round((agentPerformance.green.wins / totalGames) * 100);
                agentPerformance.black.score = Math.round((agentPerformance.black.wins / totalGames) * 100);
            }
            
            // Update metrics
            updateMetrics();
            
            // Log result
            trainingLog.push(`Training session completed: ${result}`);
            updateTrainingLog();
            
            gamesCompleted++;
            
            // Reset for next game
            setTimeout(() => {
                resetGame();
                if (isTraining) {
                    startAutoPlay();
                }
            }, 2000);
        }

        function updateGameInfo() {
            document.getElementById('moveCount').textContent = moveCount;
            document.getElementById('gameStatus').textContent = gameActive ? 'RUNNING' : isTraining ? 'PAUSED' : 'READY';
            document.getElementById('currentPlayer').textContent = gameActive ? (currentPlayer === 'green' ? 'Green' : 'Black') : '-';
        }
        
        function updateMetrics() {
            // Update win rates
            document.getElementById('greenWinRate').textContent = agentPerformance.green.score + '%';
            document.getElementById('blackWinRate').textContent = agentPerformance.black.score + '%';
            
            // Update average moves
            const avgMoves = gamesCompleted > 0 ? Math.round(totalMoves / gamesCompleted) : 0;
            document.getElementById('avgMoves').textContent = avgMoves;
        }

        function pauseTraining() {
            if (!isTraining) return;
            
            isTraining = false;
            gameActive = false;
            
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
                autoPlayInterval = null;
            }
            
            document.getElementById('startBtn').classList.remove('active');
            document.getElementById('stopBtn').classList.add('active');
            
            trainingLog.push("Training paused");
            updateTrainingLog();
        }

        function resetGame() {
            // Reset game state
            moveCount = 0;
            currentPlayer = 'green';
            gameActive = isTraining;
            
            // Reset 3D board
            reset3DBoard();
            
            // Update game info
            updateGameInfo();
        }
        
        function reset3DBoard() {
            // Remove all pieces
            pieces.forEach(piece => scene.remove(piece));
            pieces = [];
            
            // Clear board state
            initializeBoard();
            
            // Recreate pieces
            createPieces3D();
        }

        // Start the application when the page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>