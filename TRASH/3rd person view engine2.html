<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>GalaxyCraft | StarFox-Inspired Space Combat</title>
  <meta name="description" content="Experience GalaxyCraft - a StarFox 64-inspired space combat simulator with precise third-person controls and targeting.">
  <meta name="keywords" content="GalaxyCraft, StarFox, space combat, WebGL, drone swarm, space simulator">
  <meta name="author" content="WebXOS">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Orbitron', 'Courier New', monospace;
    }
    body {
      background: #000;
      color: #0ff;
      height: 100vh;
      overflow: hidden;
      touch-action: none;
    }
    #gameCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }
    /* Main UI */
    .ui-container {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      z-index: 20;
      padding: 15px;
      background: rgba(0, 20, 30, 0.7);
      border-radius: 20px;
      border: 2px solid #0ff;
      backdrop-filter: blur(5px);
      transition: all 0.5s ease;
    }
    .ui-btn {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      background: linear-gradient(145deg, #003344, #001122);
      border: 2px solid #0ff;
      color: #0ff;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
      transition: all 0.2s ease;
    }
    .ui-btn:hover {
      background: linear-gradient(145deg, #004455, #002233);
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
    }
    .ui-btn.active {
      background: linear-gradient(145deg, #ff3300, #cc2200);
      border-color: #ff3300;
      box-shadow: 0 0 20px rgba(255, 51, 0, 0.8);
      color: #fff;
    }
    .ui-btn .key {
      font-size: 20px;
      font-weight: bold;
      margin-bottom: 4px;
    }
    
    /* StarFox-Style Reticle */
    .starfox-reticle {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 10;
      pointer-events: none;
      transition: all 0.5s ease;
    }
    .crosshair {
      width: 30px;
      height: 30px;
      border: 2px solid #0f0;
      border-radius: 50%;
      position: relative;
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.7);
      transition: all 0.5s ease;
    }
    .crosshair::before, .crosshair::after {
      content: '';
      position: absolute;
      background: #0f0;
    }
    .crosshair::before {
      width: 20px;
      height: 2px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    .crosshair::after {
      width: 2px;
      height: 20px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    .target-lock {
      position: absolute;
      width: 20px;
      height: 20px;
      border: 2px solid #f00;
      border-radius: 50%;
      box-shadow: 0 0 15px rgba(255, 0, 0, 0.8);
      animation: pulse 0.5s infinite alternate;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    @keyframes pulse {
      from { opacity: 0.7; transform: translate(-50%, -50%) scale(1); }
      to { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
    }
    
    /* Combat Stats */
    .combat-stats {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border: 2px solid #0f0;
      border-radius: 10px;
      font-size: 16px;
      color: #0f0;
      z-index: 15;
      transition: all 0.5s ease;
    }
    .health-bar, .shield-bar {
      width: 200px;
      height: 20px;
      background: #333;
      border-radius: 10px;
      margin: 10px 0;
      overflow: hidden;
    }
    .health-fill {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, #f00, #ff3300);
      border-radius: 10px;
      transition: width 0.3s ease;
    }
    .shield-fill {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, #0cf, #06f);
      border-radius: 10px;
      transition: width 0.3s ease;
    }
    .warning-alert {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 36px;
      color: #f00;
      text-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
      text-align: center;
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: 25;
      pointer-events: none;
    }
    .warning-alert.active {
      animation: alert-flash 0.5s infinite alternate;
    }
    @keyframes alert-flash {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    /* Main Menu */
    .main-menu {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 10, 20, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      color: #0ff;
    }
    .game-title {
      font-size: 60px;
      margin-bottom: 40px;
      text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
      letter-spacing: 4px;
    }
    .menu-options {
      display: flex;
      flex-direction: column;
      gap: 20px;
      width: 300px;
    }
    .menu-btn {
      padding: 15px 30px;
      background: linear-gradient(145deg, #003344, #001122);
      border: 2px solid #0ff;
      color: #0ff;
      font-size: 20px;
      text-align: center;
      cursor: pointer;
      border-radius: 10px;
      transition: all 0.3s ease;
    }
    .menu-btn:hover {
      background: linear-gradient(145deg, #004455, #002233);
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
      transform: translateY(-3px);
    }
    .settings-panel {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 20, 30, 0.9);
      padding: 30px;
      border: 2px solid #0ff;
      border-radius: 15px;
      width: 400px;
      display: none;
      z-index: 110;
    }
    .settings-panel h2 {
      margin-bottom: 20px;
      text-align: center;
    }
    .settings-row {
      display: flex;
      justify-content: space-between;
      margin: 15px 0;
    }
    .settings-row label {
      font-size: 18px;
    }
    .settings-row input {
      background: #002233;
      border: 1px solid #0ff;
      color: #0ff;
      padding: 5px 10px;
      border-radius: 5px;
      width: 80px;
    }
    .close-settings {
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      color: #0ff;
      font-size: 20px;
      cursor: pointer;
    }
    
    /* Console Messages */
    .console-message {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 10px 20px;
      border: 2px solid #0ff;
      border-radius: 10px;
      color: #0ff;
      font-size: 18px;
      opacity: 0;
      transition: opacity 0.5s ease;
      z-index: 25;
    }
    .console-message.active {
      opacity: 1;
    }
    
    /* SWARM MODE UI */
    .swarm-mode-ui {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.5s ease;
      z-index: 5;
    }
    .swarm-mode-ui.active {
      opacity: 1;
    }
    .swarm-reticle {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 80px;
      height: 80px;
      border: 3px solid #0f0;
      border-radius: 50%;
      box-shadow: 0 0 20px rgba(0, 255, 0, 0.8);
      pointer-events: none;
    }
    .swarm-reticle::before, .swarm-reticle::after {
      content: '';
      position: absolute;
      background: #0f0;
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.8);
    }
    .swarm-reticle::before {
      width: 60px;
      height: 3px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    .swarm-reticle::after {
      width: 3px;
      height: 60px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    .swarm-stats {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border: 2px solid #0f0;
      border-radius: 10px;
      font-size: 16px;
      color: #0f0;
      text-shadow: 0 0 5px rgba(0, 255, 0, 0.8);
    }
    .damage-taken {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 0, 0, 0.3);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    .damage-taken.active {
      opacity: 1;
    }
    .under-attack {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 0, 0.2);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    .under-attack.active {
      opacity: 1;
    }
    .swarm-wave-alert {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      color: #f00;
      text-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease;
    }
    .swarm-wave-alert.active {
      opacity: 1;
      animation: swarm-alert 1s infinite alternate;
    }
    @keyframes swarm-alert {
      from { transform: translate(-50%, -50%) scale(1); }
      to { transform: translate(-50%, -50%) scale(1.2); }
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      .ui-container {
        bottom: 10px;
        padding: 10px;
        gap: 10px;
      }
      .ui-btn {
        width: 60px;
        height: 60px;
        font-size: 10px;
      }
      .ui-btn .key {
        font-size: 16px;
      }
      .game-title {
        font-size: 40px;
      }
      .menu-btn {
        padding: 12px 24px;
        font-size: 18px;
      }
      .combat-stats {
        bottom: 100px;
        left: 10px;
        font-size: 14px;
        padding: 10px;
      }
      .health-bar, .shield-bar {
        width: 150px;
        height: 15px;
      }
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    
    <!-- StarFox-Style Reticle -->
    <div class="starfox-reticle">
      <div class="crosshair"></div>
      <div class="target-lock" id="targetLock" style="display: none;"></div>
    </div>
    
    <!-- SWARM MODE UI -->
    <div class="swarm-mode-ui" id="swarmModeUI">
      <div class="swarm-reticle"></div>
      <div class="swarm-stats">
        <div>SWARM WAVE: <span id="swarmWaveCount">1</span></div>
        <div>DRONES: <span id="droneCount">0</span></div>
        <div>SCORE: <span id="swarmScore">0</span></div>
        <div>DAMAGE TAKEN: <span id="damageTaken">0%</span></div>
      </div>
      <div class="damage-taken" id="damageTakenOverlay"></div>
      <div class="under-attack" id="underAttackOverlay"></div>
      <div class="swarm-wave-alert" id="swarmWaveAlert">INCOMING SWARM!</div>
    </div>
    
    <!-- Combat Stats -->
    <div class="combat-stats">
      <div>WAVE: <span id="waveCount">1</span></div>
      <div>ENEMIES: <span id="enemyCount">0</span></div>
      <div>SCORE: <span id="combatScore">0</span></div>
      <div>HEALTH:</div>
      <div class="health-bar"><div class="health-fill" id="healthFill" style="width: 100%"></div></div>
      <div>SHIELD:</div>
      <div class="shield-bar"><div class="shield-fill" id="shieldFill" style="width: 100%"></div></div>
    </div>
    
    <div class="warning-alert" id="warningAlert">INCOMING!</div>
    
    <!-- Main UI Controls -->
    <div class="ui-container">
      <div class="ui-btn" id="thrustBtn">
        <div class="key">W</div>
        <div>THRUST</div>
      </div>
      <div class="ui-btn" id="swarmBtn">
        <div class="key">ALT</div>
        <div>SWARM</div>
      </div>
      <div class="ui-btn" id="fireBtn">
        <div class="key">SPC</div>
        <div>FIRE</div>
      </div>
      <div class="ui-btn" id="boostBtn">
        <div class="key">SHIFT</div>
        <div>BOOST</div>
      </div>
      <div class="ui-btn" id="menuBtn">
        <div class="key">ESC</div>
        <div>MENU</div>
      </div>
    </div>
    
    <!-- Console Messages -->
    <div class="console-message" id="consoleMessage"></div>
    
    <!-- Main Menu -->
    <div class="main-menu" id="mainMenu">
      <h1 class="game-title">GALAXYCRAFT</h1>
      <div class="menu-options">
        <div class="menu-btn" id="startBtn">SINGLE PLAYER</div>
        <div class="menu-btn" id="multiplayerBtn">MULTIPLAYER</div>
        <div class="menu-btn" id="settingsBtn">SETTINGS</div>
        <div class="menu-btn" id="quitBtn">QUIT</div>
      </div>
      
      <div class="settings-panel" id="settingsPanel">
        <button class="close-settings" id="closeSettings">X</button>
        <h2>GAME SETTINGS</h2>
        <div class="settings-row">
          <label>Mouse Sensitivity:</label>
          <input type="number" id="mouseSensitivity" value="0.003" step="0.001" min="0.001" max="0.01">
        </div>
        <div class="settings-row">
          <label>Invert Y-Axis:</label>
          <input type="checkbox" id="invertYAxis">
        </div>
        <div class="settings-row">
          <label>Flight Assist:</label>
          <input type="checkbox" id="flightAssist" checked>
        </div>
        <div class="settings-row">
          <label>Sound Volume:</label>
          <input type="range" id="soundVolume" min="0" max="100" value="80">
        </div>
        <div class="settings-row">
          <label>Swarm Difficulty:</label>
          <input type="range" id="swarmDifficulty" min="1" max="10" value="5">
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
    // Game state and configuration
    const GameState = {
      MENU: 0,
      PLAYING: 1,
      SWARM: 2,
      PAUSED: 3
    };
    
    let currentState = GameState.MENU;
    let mouseSensitivity = 0.003;
    let invertYAxis = false;
    let flightAssist = true;
    let swarmDifficulty = 5;
    
    // Initialize Three.js
    let scene, camera, renderer;
    let player, playerModel, enemies = [], projectiles = [], particles = [];
    let homePlanet, asteroids = [];
    let mixers = [];
    let clock = new THREE.Clock();
    
    // Player controls state
    const controls = {
      forward: false,
      backward: false,
      left: false,
      right: false,
      up: false,
      down: false,
      boost: false,
      fire: false,
      swarm: false,
      rollLeft: false,
      rollRight: false,
      lightspeed: false,
      barrelRollLeft: false,
      barrelRollRight: false,
      reverse: false
    };
    
    // Player stats
    const playerStats = {
      health: 100,
      shield: 100,
      score: 0,
      wave: 1,
      speed: 30,
      boostMultiplier: 2,
      lightspeedMultiplier: 10,
      fireRate: 0.05,
      lastFire: 0,
      rotationSpeed: 2.0,
      damageTaken: 0,
      swarmWave: 1,
      swarmScore: 0
    };
    
    // Initialize the game
    function init() {
      // Set up scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000010);
      scene.fog = new THREE.Fog(0x000010, 50, 500);
      
      // Set up camera - Third person view like StarFox
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
      camera.position.set(0, 3, 10);
      
      // Set up renderer
      renderer = new THREE.WebGLRenderer({ 
        canvas: document.getElementById('gameCanvas'),
        antialias: true,
        powerPreference: "high-performance"
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      
      // Add lighting
      const ambientLight = new THREE.AmbientLight(0x444455);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(5, 5, 5);
      directionalLight.castShadow = true;
      scene.add(directionalLight);
      
      // Create starfield
      createStarfield();
      
      // Create home planet
      createHomePlanet();
      
      // Create asteroid field
      createAsteroidField(20);
      
      // Create player ship with blue triangle like StarFox
      createPlayerShip();
      
      // Create initial enemies
      spawnEnemyWave(5);
      
      // Set up event listeners
      setupEventListeners();
      
      // Start animation loop
      animate();
      
      // Show console message
      showConsoleMessage("GalaxyCraft initialized. Ready for launch!");
    }
    
    // Create starfield background
    function createStarfield() {
      const starGeometry = new THREE.BufferGeometry();
      const starMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.5,
        sizeAttenuation: true
      });
      
      const starVertices = [];
      for (let i = 0; i < 5000; i++) {
        const x = (Math.random() - 0.5) * 2000;
        const y = (Math.random() - 0.5) * 2000;
        const z = (Math.random() - 0.5) * 2000;
        starVertices.push(x, y, z);
      }
      
      starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
      const stars = new THREE.Points(starGeometry, starMaterial);
      scene.add(stars);
    }
    
    // Create home planet
    function createHomePlanet() {
      const planetGeometry = new THREE.SphereGeometry(15, 32, 32);
      const planetMaterial = new THREE.MeshPhongMaterial({
        color: 0x00ff00,
        emissive: 0x006600,
        specular: 0x88ff88,
        shininess: 30,
        flatShading: false
      });
      
      homePlanet = new THREE.Mesh(planetGeometry, planetMaterial);
      homePlanet.position.set(0, 0, -200);
      scene.add(homePlanet);
    }
    
    // Create asteroid field
    function createAsteroidField(count) {
      for (let i = 0; i < count; i++) {
        const size = 2 + Math.random() * 5;
        const asteroidGeometry = new THREE.SphereGeometry(size, 8, 8);
        const asteroidMaterial = new THREE.MeshPhongMaterial({
          color: 0x888888,
          emissive: 0x222222,
          specular: 0xaaaaaa,
          shininess: 10,
          flatShading: true
        });
        
        const asteroid = new THREE.Mesh(asteroidGeometry, asteroidMaterial);
        
        // Position asteroids randomly
        asteroid.position.set(
          (Math.random() - 0.5) * 300,
          (Math.random() - 0.5) * 300,
          (Math.random() - 0.5) * 300 - 100
        );
        
        // Add some rotation
        asteroid.userData.rotationSpeed = {
          x: Math.random() * 0.01,
          y: Math.random() * 0.01,
          z: Math.random() * 0.01
        };
        
        scene.add(asteroid);
        asteroids.push(asteroid);
      }
    }
    
    // Create player ship with blue triangle like StarFox
    function createPlayerShip() {
      // Create a group for the player to allow for easier camera following
      player = new THREE.Group();
      scene.add(player);
      
      // Create the ship model (blue triangle like StarFox)
      const shipGeometry = new THREE.ConeGeometry(1.5, 4, 3);
      const shipMaterial = new THREE.MeshPhongMaterial({
        color: 0x0066ff,
        emissive: 0x0033aa,
        specular: 0xffffff,
        shininess: 100,
        flatShading: true
      });
      
      playerModel = new THREE.Mesh(shipGeometry, shipMaterial);
      playerModel.rotation.x = Math.PI / 2;
      playerModel.position.z = -2; // Position the model slightly in front of the player group
      player.add(playerModel);
      
      // Add engine glow
      const engineGeometry = new THREE.SphereGeometry(0.5, 16, 16);
      const engineMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        emissive: 0x0088ff,
        transparent: true,
        opacity: 0.8
      });
      
      const leftEngine = new THREE.Mesh(engineGeometry, engineMaterial);
      leftEngine.position.set(-0.8, 0, -3);
      player.add(leftEngine);
      
      const rightEngine = new THREE.Mesh(engineGeometry, engineMaterial);
      rightEngine.position.set(0.8, 0, -3);
      player.add(rightEngine);
      
      // Center the player in the scene
      player.position.set(0, 0, 0);
      
      // Create a target indicator for the player (invisible but helps with targeting)
      const targetHelper = new THREE.Object3D();
      player.add(targetHelper);
    }
    
    // Spawn a wave of enemies
    function spawnEnemyWave(count) {
      for (let i = 0; i < count; i++) {
        const enemyGeometry = new THREE.ConeGeometry(1.2, 2.5, 3);
        const enemyMaterial = new THREE.MeshPhongMaterial({
          color: 0xff0000,
          emissive: 0xaa0000,
          specular: 0xff6666,
          shininess: 100,
          flatShading: true
        });
        
        const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
        
        // Position enemies in front of the player in a formation
        const angle = (i / count) * Math.PI * 2;
        const radius = 15 + Math.random() * 20;
        enemy.position.set(
          Math.cos(angle) * radius,
          Math.sin(angle) * radius * 0.5,
          -40 - Math.random() * 20
        );
        
        enemy.rotation.x = Math.PI / 2;
        enemy.speed = 4 + Math.random() * 4;
        enemy.health = 10;
        enemy.userData.isSwarm = false;
        
        scene.add(enemy);
        enemies.push(enemy);
      }
      
      updateEnemyCount();
    }
    
    // Spawn a swarm wave
    function spawnSwarmWave(count) {
      for (let i = 0; i < count; i++) {
        const enemyGeometry = new THREE.ConeGeometry(1.0, 2.0, 3);
        const enemyMaterial = new THREE.MeshPhongMaterial({
          color: 0xff0000,
          emissive: 0xaa0000,
          specular: 0xff6666,
          shininess: 100,
          flatShading: true
        });
        
        const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
        
        // Position swarm drones in more aggressive patterns
        const formation = i % 4;
        let x, y, z;
        
        switch(formation) {
          case 0: // Top formation
            x = (Math.random() - 0.5) * 30;
            y = 20 + Math.random() * 10;
            z = -50 - Math.random() * 20;
            break;
          case 1: // Bottom formation
            x = (Math.random() - 0.5) * 30;
            y = -20 - Math.random() * 10;
            z = -50 - Math.random() * 20;
            break;
          case 2: // Left formation
            x = -20 - Math.random() * 10;
            y = (Math.random() - 0.5) * 30;
            z = -50 - Math.random() * 20;
            break;
          case 3: // Right formation
            x = 20 + Math.random() * 10;
            y = (Math.random() - 0.5) * 30;
            z = -50 - Math.random() * 20;
            break;
        }
        
        enemy.position.set(x, y, z);
        enemy.rotation.x = Math.PI / 2;
        enemy.speed = 6 + Math.random() * 4 + swarmDifficulty;
        enemy.health = 5;
        enemy.userData.isSwarm = true;
        enemy.userData.kamikaze = Math.random() > 0.7; // Some drones will kamikaze
        
        scene.add(enemy);
        enemies.push(enemy);
      }
      
      updateEnemyCount();
      document.getElementById('droneCount').textContent = enemies.length;
    }
    
    // Create a projectile
    function createProjectile(isPlayerProjectile = true) {
      const geometry = new THREE.SphereGeometry(0.2, 8, 8);
      const material = new THREE.MeshBasicMaterial({
        color: isPlayerProjectile ? getRandomProjectileColor() : 0xff0000,
        emissive: isPlayerProjectile ? 0x00aa00 : 0xaa0000
      });
      
      const projectile = new THREE.Mesh(geometry, material);
      
      if (isPlayerProjectile) {
        // Player projectiles come from the player's position
        projectile.position.copy(player.position);
        projectile.position.z -= 2; // Start from the front of the ship
        
        // Calculate direction based on camera view (forward direction)
        const direction = new THREE.Vector3(0, 0, -1);
        direction.applyQuaternion(camera.quaternion);
        
        projectile.velocity = direction.multiplyScalar(120);
        projectile.isPlayerProjectile = true;
        
        // Add homing capability in swarm mode
        if (currentState === GameState.SWARM) {
          projectile.userData.homing = true;
          projectile.userData.homingStrength = 0.1;
        }
      } else {
        // Enemy projectiles would come from enemy positions
        // Not implemented in this demo
      }
      
      scene.add(projectile);
      projectiles.push(projectile);
      
      // Remove projectile after 2 seconds
      setTimeout(() => {
        if (scene.children.includes(projectile)) {
          scene.remove(projectile);
          const index = projectiles.indexOf(projectile);
          if (index > -1) {
            projectiles.splice(index, 1);
          }
        }
      }, 2000);
    }
    
    // Get random projectile color for tempest effect
    function getRandomProjectileColor() {
      const colors = [
        0x00ff00, // Green
        0xff00ff, // Magenta
        0xffff00, // Yellow
        0x00ffff, // Cyan
        0xff8800, // Orange
        0xff0088  // Pink
      ];
      return colors[Math.floor(Math.random() * colors.length)];
    }
    
    // Create explosion particles
    function createExplosion(position, color = 0xff0000, count = 20) {
      for (let i = 0; i < count; i++) {
        const geometry = new THREE.SphereGeometry(0.2, 8, 8);
        const material = new THREE.MeshBasicMaterial({
          color: color,
          emissive: color,
          transparent: true,
          opacity: 0.8
        });
        
        const particle = new THREE.Mesh(geometry, material);
        particle.position.copy(position);
        
        // Random velocity for explosion effect
        particle.velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 10,
          (Math.random() - 0.5) * 10,
          (Math.random() - 0.5) * 10
        );
        
        particle.userData.lifetime = 1.0;
        
        scene.add(particle);
        particles.push(particle);
      }
    }
    
    // Update enemy count display
    function updateEnemyCount() {
      document.getElementById('enemyCount').textContent = enemies.length;
    }
    
    // Show a console message
    function showConsoleMessage(message, duration = 3000) {
      const consoleElement = document.getElementById('consoleMessage');
      consoleElement.textContent = message;
      consoleElement.classList.add('active');
      
      setTimeout(() => {
        consoleElement.classList.remove('active');
      }, duration);
    }
    
    // Show warning alert
    function showWarningAlert(message, duration = 2000) {
      const warningElement = document.getElementById('warningAlert');
      warningElement.textContent = message;
      warningElement.classList.add('active');
      
      setTimeout(() => {
        warningElement.classList.remove('active');
      }, duration);
    }
    
    // Show swarm wave alert
    function showSwarmWaveAlert(message, duration = 2000) {
      const alertElement = document.getElementById('swarmWaveAlert');
      alertElement.textContent = message;
      alertElement.classList.add('active');
      
      setTimeout(() => {
        alertElement.classList.remove('active');
      }, duration);
    }
    
    // Toggle swarm mode
    function toggleSwarmMode() {
      if (currentState === GameState.PLAYING) {
        // Enter swarm mode
        currentState = GameState.SWARM;
        document.getElementById('swarmModeUI').classList.add('active');
        document.getElementById('swarmBtn').classList.add('active');
        showConsoleMessage("SWARM MODE ENGAGED!");
        
        // Clear existing enemies and spawn swarm
        enemies.forEach(enemy => scene.remove(enemy));
        enemies = [];
        
        // Spawn initial swarm wave
        playerStats.swarmWave = 1;
        spawnSwarmWave(10 + swarmDifficulty);
        document.getElementById('swarmWaveCount').textContent = playerStats.swarmWave;
        
      } else if (currentState === GameState.SWARM) {
        // Exit swarm mode
        currentState = GameState.PLAYING;
        document.getElementById('swarmModeUI').classList.remove('active');
        document.getElementById('swarmBtn').classList.remove('active');
        showConsoleMessage("Returning to normal flight mode");
        
        // Clear swarm enemies and spawn regular enemies
        enemies.forEach(enemy => scene.remove(enemy));
        enemies = [];
        spawnEnemyWave(5);
      }
    }
    
    // Handle player damage
    function applyDamage(amount) {
      if (playerStats.shield > 0) {
        playerStats.shield -= amount;
        if (playerStats.shield < 0) {
          playerStats.health += playerStats.shield; // Apply remaining damage to health
          playerStats.shield = 0;
        }
      } else {
        playerStats.health -= amount;
      }
      
      // Update UI
      document.getElementById('healthFill').style.width = `${playerStats.health}%`;
      document.getElementById('shieldFill').style.width = `${playerStats.shield}%`;
      
      // Show damage effect
      if (currentState === GameState.SWARM) {
        document.getElementById('damageTakenOverlay').classList.add('active');
        setTimeout(() => {
          document.getElementById('damageTakenOverlay').classList.remove('active');
        }, 200);
        
        // Update damage taken counter
        playerStats.damageTaken += amount;
        document.getElementById('damageTaken').textContent = `${Math.min(100, playerStats.damageTaken)}%`;
      }
      
      // Check for game over
      if (playerStats.health <= 0) {
        gameOver();
      }
    }
    
    // Game over handler
    function gameOver() {
      showConsoleMessage("MISSION FAILED! Returning to menu...", 5000);
      
      // Reset game state
      currentState = GameState.MENU;
      document.getElementById('mainMenu').style.display = 'flex';
      
      // Reset player stats
      playerStats.health = 100;
      playerStats.shield = 100;
      playerStats.score = 0;
      playerStats.wave = 1;
      playerStats.damageTaken = 0;
      playerStats.swarmWave = 1;
      playerStats.swarmScore = 0;
      
      // Update UI
      document.getElementById('healthFill').style.width = '100%';
      document.getElementById('shieldFill').style.width = '100%';
      document.getElementById('waveCount').textContent = '1';
      document.getElementById('combatScore').textContent = '0';
      document.getElementById('swarmWaveCount').textContent = '1';
      document.getElementById('swarmScore').textContent = '0';
      document.getElementById('damageTaken').textContent = '0%';
      
      // Clear enemies and projectiles
      enemies.forEach(enemy => scene.remove(enemy));
      enemies = [];
      
      projectiles.forEach(projectile => scene.remove(projectile));
      projectiles = [];
      
      particles.forEach(particle => scene.remove(particle));
      particles = [];
      
      // Reset player position
      player.position.set(0, 0, 0);
      player.rotation.set(0, 0, 0);
      
      // Exit swarm mode if active
      document.getElementById('swarmModeUI').classList.remove('active');
      document.getElementById('swarmBtn').classList.remove('active');
    }
    
    // Set up event listeners
    function setupEventListeners() {
      // Keyboard controls
      document.addEventListener('keydown', (event) => {
        if (currentState === GameState.MENU) return;
        
        switch(event.code) {
          case 'KeyW':
            controls.forward = true;
            break;
          case 'KeyS':
            controls.backward = true;
            break;
          case 'KeyA':
            controls.left = true;
            break;
          case 'KeyD':
            controls.right = true;
            break;
          case 'KeyQ':
            controls.rollLeft = true;
            break;
          case 'KeyE':
            controls.rollRight = true;
            break;
          case 'KeyR':
            controls.reverse = true;
            break;
          case 'Space':
            controls.fire = true;
            break;
          case 'ShiftLeft':
          case 'ShiftRight':
            controls.boost = true;
            break;
          case 'AltLeft':
          case 'AltRight':
            if (!event.repeat) toggleSwarmMode();
            break;
          case 'Backquote':
            controls.lightspeed = true;
            break;
          case 'KeyX':
            controls.barrelRollRight = true;
            break;
          case 'KeyZ':
            controls.barrelRollLeft = true;
            break;
          case 'KeyC':
            // 180 degree turn
            player.rotation.y += Math.PI;
            break;
          case 'Escape':
            togglePause();
            break;
        }
      });
      
      document.addEventListener('keyup', (event) => {
        switch(event.code) {
          case 'KeyW':
            controls.forward = false;
            break;
          case 'KeyS':
            controls.backward = false;
            break;
          case 'KeyA':
            controls.left = false;
            break;
          case 'KeyD':
            controls.right = false;
            break;
          case 'KeyQ':
            controls.rollLeft = false;
            break;
          case 'KeyE':
            controls.rollRight = false;
            break;
          case 'KeyR':
            controls.reverse = false;
            break;
          case 'Space':
            controls.fire = false;
            break;
          case 'ShiftLeft':
          case 'ShiftRight':
            controls.boost = false;
            break;
          case 'AltLeft':
          case 'AltRight':
            controls.swarm = false;
            break;
          case 'Backquote':
            controls.lightspeed = false;
            break;
          case 'KeyX':
            controls.barrelRollRight = false;
            break;
          case 'KeyZ':
            controls.barrelRollLeft = false;
            break;
        }
      });
      
      // Mouse movement for camera control
      let isMouseDown = false;
      document.addEventListener('mousedown', () => {
        isMouseDown = true;
      });
      
      document.addEventListener('mouseup', () => {
        isMouseDown = false;
      });
      
      document.addEventListener('mousemove', (event) => {
        if (isMouseDown && currentState !== GameState.MENU) {
          // Rotate camera based on mouse movement
          const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
          const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
          
          // Adjust camera rotation based on mouse movement
          camera.rotation.y -= movementX * mouseSensitivity;
          camera.rotation.x -= movementY * mouseSensitivity * (invertYAxis ? -1 : 1);
          
          // Limit vertical camera rotation
          camera.rotation.x = Math.max(-Math.PI/3, Math.min(Math.PI/3, camera.rotation.x));
        }
      });
      
      // Touch controls for mobile
      document.getElementById('thrustBtn').addEventListener('touchstart', () => {
        controls.forward = true;
      });
      
      document.getElementById('thrustBtn').addEventListener('touchend', () => {
        controls.forward = false;
      });
      
      document.getElementById('fireBtn').addEventListener('touchstart', () => {
        controls.fire = true;
      });
      
      document.getElementById('fireBtn').addEventListener('touchend', () => {
        controls.fire = false;
      });
      
      document.getElementById('boostBtn').addEventListener('touchstart', () => {
        controls.boost = true;
      });
      
      document.getElementById('boostBtn').addEventListener('touchend', () => {
        controls.boost = false;
      });
      
      document.getElementById('swarmBtn').addEventListener('click', toggleSwarmMode);
      document.getElementById('menuBtn').addEventListener('click', togglePause);
      
      // Menu button handlers
      document.getElementById('startBtn').addEventListener('click', startGame);
      document.getElementById('multiplayerBtn').addEventListener('click', () => {
        showConsoleMessage("Multiplayer mode coming soon!");
      });
      document.getElementById('settingsBtn').addEventListener('click', showSettings);
      document.getElementById('quitBtn').addEventListener('click', () => {
        window.close();
      });
      document.getElementById('closeSettings').addEventListener('click', hideSettings);
      
      // Settings change handlers
      document.getElementById('mouseSensitivity').addEventListener('change', (e) => {
        mouseSensitivity = parseFloat(e.target.value);
      });
      
      document.getElementById('invertYAxis').addEventListener('change', (e) => {
        invertYAxis = e.target.checked;
      });
      
      document.getElementById('flightAssist').addEventListener('change', (e) => {
        flightAssist = e.target.checked;
      });
      
      document.getElementById('swarmDifficulty').addEventListener('change', (e) => {
        swarmDifficulty = parseInt(e.target.value);
      });
      
      // Window resize handler
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }
    
    // Start the game
    function startGame() {
      document.getElementById('mainMenu').style.display = 'none';
      currentState = GameState.PLAYING;
      showConsoleMessage("Mission start! Defend the home planet!");
    }
    
    // Toggle pause
    function togglePause() {
      if (currentState === GameState.PAUSED) {
        currentState = GameState.PLAYING;
        document.getElementById('mainMenu').style.display = 'none';
      } else {
        currentState = GameState.PAUSED;
        document.getElementById('mainMenu').style.display = 'flex';
      }
    }
    
    // Show settings panel
    function showSettings() {
      document.getElementById('settingsPanel').style.display = 'block';
    }
    
    // Hide settings panel
    function hideSettings() {
      document.getElementById('settingsPanel').style.display = 'none';
    }
    
    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      
      const delta = clock.getDelta();
      
      if (currentState === GameState.PLAYING || currentState === GameState.SWARM) {
        // Update player movement
        updatePlayerMovement(delta);
        
        // Update camera to follow player with third-person offset
        updateCamera(delta);
        
        // Update enemies
        updateEnemies(delta);
        
        // Update projectiles
        updateProjectiles(delta);
        
        // Update particles
        updateParticles(delta);
        
        // Update asteroids
        updateAsteroids(delta);
        
        // Handle firing
        handleFiring(delta);
        
        // Check collisions
        checkCollisions();
      }
      
      // Update any animations
      if (mixers.length > 0) {
        mixers.forEach(mixer => mixer.update(delta));
      }
      
      // Render the scene
      renderer.render(scene, camera);
    }
    
    // Update player movement based on controls
    function updatePlayerMovement(delta) {
      // Calculate movement speed
      let speed = playerStats.speed;
      if (controls.boost) speed *= playerStats.boostMultiplier;
      if (controls.lightspeed) speed *= playerStats.lightspeedMultiplier;
      
      // Forward/backward movement
      if (controls.forward) {
        player.translateZ(-speed * delta);
      }
      if (controls.backward) {
        player.translateZ(speed * delta * 0.5);
      }
      
      // Strafe left/right
      if (controls.left) {
        player.translateX(-speed * delta * 0.7);
      }
      if (controls.right) {
        player.translateX(speed * delta * 0.7);
      }
      
      // Strafe up/down
      if (controls.up) {
        player.translateY(speed * delta * 0.7);
      }
      if (controls.down) {
        player.translateY(-speed * delta * 0.7);
      }
      
      // Roll left/right
      if (controls.rollLeft) {
        player.rotation.z += playerStats.rotationSpeed * delta;
      }
      if (controls.rollRight) {
        player.rotation.z -= playerStats.rotationSpeed * delta;
      }
      
      // Barrel rolls
      if (controls.barrelRollLeft) {
        player.rotation.x += playerStats.rotationSpeed * 3 * delta;
      }
      if (controls.barrelRollRight) {
        player.rotation.x -= playerStats.rotationSpeed * 3 * delta;
      }
      
      // Apply flight assist (gradually level out the ship)
      if (flightAssist) {
        player.rotation.z *= 0.95;
        player.rotation.x *= 0.95;
      }
      
      // Limit player rotation for better control
      player.rotation.z = Math.max(-Math.PI/4, Math.min(Math.PI/4, player.rotation.z));
      player.rotation.x = Math.max(-Math.PI/4, Math.min(Math.PI/4, player.rotation.x));
      
      // Keep player within bounds
      const maxDistance = 200;
      player.position.x = Math.max(-maxDistance, Math.min(maxDistance, player.position.x));
      player.position.y = Math.max(-maxDistance, Math.min(maxDistance, player.position.y));
      player.position.z = Math.max(-maxDistance, Math.min(maxDistance, player.position.z));
    }
    
    // Update camera to follow player
    function updateCamera(delta) {
      // Third-person camera that follows behind the player
      const targetPosition = new THREE.Vector3(
        player.position.x,
        player.position.y + 3,
        player.position.z + 10
      );
      
      // Smoothly move the camera towards the target position
      camera.position.lerp(targetPosition, 0.1);
      
      // Make the camera look slightly ahead of the player
      const lookAtPosition = new THREE.Vector3(
        player.position.x,
        player.position.y,
        player.position.z - 10
      );
      
      camera.lookAt(lookAtPosition);
    }
    
    // Update enemies
    function updateEnemies(delta) {
      for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        
        // Different behavior based on mode
        if (currentState === GameState.SWARM && enemy.userData.isSwarm) {
          // Swarm mode: more aggressive behavior
          const direction = new THREE.Vector3();
          direction.subVectors(player.position, enemy.position).normalize();
          
          // Some drones kamikaze
          if (enemy.userData.kamikaze) {
            enemy.position.add(direction.multiplyScalar(enemy.speed * 1.5 * delta));
          } else {
            // Move toward player but try to maintain distance
            const distance = enemy.position.distanceTo(player.position);
            if (distance > 15) {
              enemy.position.add(direction.multiplyScalar(enemy.speed * delta));
            } else if (distance < 10) {
              enemy.position.add(direction.multiplyScalar(-enemy.speed * delta));
            }
            
            // Swarming movement pattern
            enemy.position.x += Math.sin(Date.now() * 0.001 + i) * 0.1;
            enemy.position.y += Math.cos(Date.now() * 0.001 + i) * 0.1;
          }
          
          // Always face the player in swarm mode
          enemy.lookAt(player.position);
        } else {
          // Normal mode: move toward player but more predictably
          const direction = new THREE.Vector3();
          direction.subVectors(player.position, enemy.position).normalize();
          enemy.position.add(direction.multiplyScalar(enemy.speed * delta));
          
          // Face the direction of movement
          enemy.lookAt(enemy.position.clone().add(direction));
        }
        
        // Check if enemy is too close to player
        if (enemy.position.distanceTo(player.position) < 5) {
          // Enemy hit player
          createExplosion(enemy.position, 0xff0000, 10);
          scene.remove(enemy);
          enemies.splice(i, 1);
          applyDamage(5);
          showWarningAlert("COLLISION!");
        }
        
        // Check if enemy is too far away
        if (enemy.position.distanceTo(player.position) > 300) {
          scene.remove(enemy);
          enemies.splice(i, 1);
        }
      }
      
      // Spawn new enemies if needed
      if (enemies.length === 0) {
        if (currentState === GameState.SWARM) {
          playerStats.swarmWave++;
          document.getElementById('swarmWaveCount').textContent = playerStats.swarmWave;
          
          // Show wave alert every 5 waves
          if (playerStats.swarmWave % 5 === 0) {
            showSwarmWaveAlert(`WAVE ${playerStats.swarmWave} INCOMING!`);
          }
          
          spawnSwarmWave(10 + swarmDifficulty + playerStats.swarmWave);
        } else {
          playerStats.wave++;
          document.getElementById('waveCount').textContent = playerStats.wave;
          spawnEnemyWave(5 + playerStats.wave);
        }
      }
      
      updateEnemyCount();
    }
    
    // Update projectiles
    function updateProjectiles(delta) {
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const projectile = projectiles[i];
        
        // Move projectile
        projectile.position.add(projectile.velocity.clone().multiplyScalar(delta));
        
        // Homing projectiles in swarm mode
        if (projectile.userData.homing && enemies.length > 0) {
          // Find nearest enemy
          let nearestEnemy = null;
          let nearestDistance = Infinity;
          
          for (const enemy of enemies) {
            const distance = projectile.position.distanceTo(enemy.position);
            if (distance < nearestDistance) {
              nearestDistance = distance;
              nearestEnemy = enemy;
            }
          }
          
          // Adjust trajectory toward nearest enemy
          if (nearestEnemy && nearestDistance < 50) {
            const direction = new THREE.Vector3();
            direction.subVectors(nearestEnemy.position, projectile.position).normalize();
            projectile.velocity.lerp(direction.multiplyScalar(projectile.velocity.length()), projectile.userData.homingStrength);
          }
        }
        
        // Check if projectile is out of bounds
        if (projectile.position.length() > 500) {
          scene.remove(projectile);
          projectiles.splice(i, 1);
        }
      }
    }
    
    // Update particles
    function updateParticles(delta) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        
        // Move particle
        particle.position.add(particle.velocity.clone().multiplyScalar(delta));
        
        // Fade out particle
        particle.userData.lifetime -= delta;
        particle.material.opacity = particle.userData.lifetime;
        
        // Remove particle when lifetime expires
        if (particle.userData.lifetime <= 0) {
          scene.remove(particle);
          particles.splice(i, 1);
        }
      }
    }
    
    // Update asteroids
    function updateAsteroids(delta) {
      for (const asteroid of asteroids) {
        // Rotate asteroids
        asteroid.rotation.x += asteroid.userData.rotationSpeed.x;
        asteroid.rotation.y += asteroid.userData.rotationSpeed.y;
        asteroid.rotation.z += asteroid.userData.rotationSpeed.z;
        
        // Check for collision with player
        if (asteroid.position.distanceTo(player.position) < 10) {
          // Push player away from asteroid
          const direction = new THREE.Vector3();
          direction.subVectors(player.position, asteroid.position).normalize();
          player.position.add(direction.multiplyScalar(20 * delta));
          
          // Apply damage
          applyDamage(2);
          createExplosion(asteroid.position, 0x888888, 5);
        }
      }
    }
    
    // Handle firing
    function handleFiring(delta) {
      if (controls.fire && currentState !== GameState.MENU && currentState !== GameState.PAUSED) {
        const currentTime = Date.now();
        if (currentTime - playerStats.lastFire > playerStats.fireRate * 1000) {
          createProjectile(true);
          playerStats.lastFire = currentTime;
        }
      }
    }
    
    // Check for collisions
    function checkCollisions() {
      // Check projectile-enemy collisions
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const projectile = projectiles[i];
        
        for (let j = enemies.length - 1; j >= 0; j--) {
          const enemy = enemies[j];
          
          if (projectile.position.distanceTo(enemy.position) < 3) {
            // Hit detected
            enemy.health -= 5;
            
            // Create explosion
            createExplosion(enemy.position, 0xff0000, 5);
            
            // Remove projectile
            scene.remove(projectile);
            projectiles.splice(i, 1);
            
            // Check if enemy is destroyed
            if (enemy.health <= 0) {
              // Bigger explosion for destroyed enemy
              createExplosion(enemy.position, 0xff3300, 15);
              
              // Remove enemy
              scene.remove(enemy);
              enemies.splice(j, 1);
              
              // Update score
              if (currentState === GameState.SWARM) {
                playerStats.swarmScore += 100;
                document.getElementById('swarmScore').textContent = playerStats.swarmScore;
              } else {
                playerStats.score += 100;
                document.getElementById('combatScore').textContent = playerStats.score;
              }
            }
            
            break;
          }
        }
      }
    }
    
    // Initialize the game when the page loads
    window.addEventListener('load', init);
  </script>
</body>
</html>