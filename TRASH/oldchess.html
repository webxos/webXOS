<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WEBXOS 2025 AI CHESS (BETA v1.0)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: #000;
            color: #0f0;
            min-height: 100vh;
            overflow-x: hidden;
            background: radial-gradient(circle at center, #001100, #000);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            padding: 20px 0;
            border-bottom: 2px solid #0f0;
            margin-bottom: 30px;
            position: relative;
        }
        
        h1 {
            font-size: 2.8rem;
            letter-spacing: 3px;
            text-transform: uppercase;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #0f0, 0 0 20px #0f0;
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: #8f8;
            letter-spacing: 2px;
        }
        
        .game-container {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            justify-content: center;
        }
        
        .chess-board {
            width: 560px;
            height: 560px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: 3px solid #0f0;
            box-shadow: 0 0 15px #0f0, inset 0 0 10px rgba(0, 255, 0, 0.2);
            position: relative;
        }
        
        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 40px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .square.light {
            background-color: #111;
        }
        
        .square.dark {
            background-color: #033;
        }
        
        .square.selected {
            background-color: #0a5;
            box-shadow: inset 0 0 15px #0f0;
        }
        
        .square.valid-move::before {
            content: "";
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: rgba(0, 255, 0, 0.5);
            box-shadow: 0 0 10px #0f0;
        }
        
        .square.valid-capture::before {
            content: "";
            position: absolute;
            width: 100%;
            height: 100%;
            border: 3px solid #0f0;
            box-shadow: 0 0 10px #0f0;
            border-radius: 0;
        }
        
        .coordinates {
            position: absolute;
            color: #0f0;
            font-size: 14px;
            font-weight: bold;
        }
        
        .coordinate-file {
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .coordinate-rank {
            left: -25px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .game-info {
            flex: 1;
            min-width: 300px;
            background: rgba(0, 20, 0, 0.7);
            border: 2px solid #0f0;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 15px #0f0;
        }
        
        .status {
            text-align: center;
            padding: 15px;
            margin-bottom: 20px;
            background: rgba(0, 30, 0, 0.5);
            border-radius: 8px;
            border: 1px solid #0f0;
            font-size: 1.2rem;
            text-shadow: 0 0 5px #0f0;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 30px;
        }
        
        button {
            background: #000;
            color: #0f0;
            border: 2px solid #0f0;
            padding: 12px;
            font-size: 1rem;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        button:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 15px #0f0;
        }
        
        .move-history {
            max-height: 300px;
            overflow-y: auto;
            background: rgba(0, 10, 0, 0.8);
            border: 1px solid #0a0;
            border-radius: 5px;
            padding: 15px;
        }
        
        .move-history h3 {
            margin-bottom: 10px;
            text-align: center;
            border-bottom: 1px solid #0a0;
            padding-bottom: 5px;
        }
        
        .moves {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }
        
        .move {
            padding: 5px 10px;
            background: rgba(0, 20, 0, 0.5);
            border-radius: 3px;
            font-family: monospace;
        }
        
        .move:nth-child(odd) {
            background: rgba(0, 30, 0, 0.5);
        }
        
        .ai-thinking {
            text-align: center;
            margin-top: 20px;
            padding: 10px;
            background: rgba(0, 30, 0, 0.5);
            border-radius: 5px;
            border: 1px solid #0a0;
            display: none;
        }
        
        .thinking-dots::after {
            content: '';
            animation: dots 1.5s steps(4, end) infinite;
        }
        
        @keyframes dots {
            0%, 20% { content: ''; }
            40% { content: '.'; }
            60% { content: '..'; }
            80%, 100% { content: '...'; }
        }
        
        footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            border-top: 1px solid #0a0;
            color: #8f8;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
                align-items: center;
            }
            
            .chess-board {
                width: 95vw;
                height: 95vw;
                max-width: 450px;
                max-height: 450px;
            }
            
            .square {
                font-size: 30px;
            }
        }
        
        .glow {
            text-shadow: 0 0 5px #0f0, 0 0 10px #0f0, 0 0 15px #0f0;
        }
        
        .piece-info {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 30, 0, 0.5);
            border-radius: 8px;
            border: 1px solid #0a0;
            font-size: 0.9rem;
        }
        
        .piece-info h3 {
            margin-bottom: 10px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1 class="glow">WEBXOS 2025 AI CHESS</h1>
            <div class="subtitle">(BEGINNER MODE BETA TEST, EXPERT MODE COMING SOON)</div>
        </header>
        
        <div class="game-container">
            <div class="chess-board" id="chess-board">
                <!-- Chess board will be generated by JavaScript -->
            </div>
            
            <div class="game-info">
                <div class="status" id="status">
                    White's turn. Make your move.
                </div>
                
                <div class="controls">
                    <button id="new-game">New Game</button>
                    <button id="undo-move">Undo Move</button>
                    <button id="hint">Show Hint</button>
                    <button id="flip-board">Flip Board</button>
                </div>
                
                <div class="ai-thinking" id="ai-thinking">
                    AI Thinking<span class="thinking-dots"></span>
                </div>
                
                <div class="move-history">
                    <h3>Move History</h3>
                    <div class="moves" id="moves">
                        <!-- Move history will be populated by JavaScript -->
                    </div>
                </div>
                
                <div class="piece-info">
                    <h3>(BEGINNER MODE BETA TEST, EXPERT MODE COMING SOON)</h3>
 
                </div>
            </div>
        </div>
        
        <footer>
            WEBXOS 2025 CHESS SYSTEM | OFFLINE AI | SECURE ENVIRONMENT
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Game state
            const gameState = {
                board: [],
                currentPlayer: 'white',
                selectedPiece: null,
                validMoves: [],
                moveHistory: [],
                boardFlipped: false,
                gameOver: false
            };

            // Initialize the chess board
            function initBoard() {
                const boardElement = document.getElementById('chess-board');
                boardElement.innerHTML = '';
                
                // Create coordinates
                const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
                const ranks = ['8', '7', '6', '5', '4', '3', '2', '1'];
                
                // Create board squares
                for (let rank = 0; rank < 8; rank++) {
                    gameState.board[rank] = [];
                    for (let file = 0; file < 8; file++) {
                        const square = document.createElement('div');
                        square.className = `square ${(rank + file) % 2 === 0 ? 'light' : 'dark'}`;
                        square.dataset.rank = rank;
                        square.dataset.file = file;
                        
                        // Add coordinates
                        if (file === 0) {
                            const rankCoord = document.createElement('div');
                            rankCoord.className = 'coordinates coordinate-rank';
                            rankCoord.textContent = ranks[rank];
                            square.appendChild(rankCoord);
                        }
                        
                        if (rank === 7) {
                            const fileCoord = document.createElement('div');
                            fileCoord.className = 'coordinates coordinate-file';
                            fileCoord.textContent = files[file];
                            square.appendChild(fileCoord);
                        }
                        
                        square.addEventListener('click', handleSquareClick);
                        boardElement.appendChild(square);
                        gameState.board[rank][file] = null;
                    }
                }
                
                setupPieces();
                updateBoard();
            }

            // Set up initial piece positions
            function setupPieces() {
                // Clear the board
                for (let rank = 0; rank < 8; rank++) {
                    for (let file = 0; file < 8; file++) {
                        gameState.board[rank][file] = null;
                    }
                }
                
                // Set up pawns
                for (let file = 0; file < 8; file++) {
                    gameState.board[1][file] = { type: 'pawn', color: 'black' };
                    gameState.board[6][file] = { type: 'pawn', color: 'white' };
                }
                
                // Set up other pieces
                const pieceOrder = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
                
                for (let file = 0; file < 8; file++) {
                    gameState.board[0][file] = { type: pieceOrder[file], color: 'black' };
                    gameState.board[7][file] = { type: pieceOrder[file], color: 'white' };
                }
            }

            // Update the visual representation of the board
            function updateBoard() {
                const squares = document.querySelectorAll('.square');
                
                // Clear all squares
                squares.forEach(square => {
                    square.innerHTML = '';
                    square.classList.remove('selected', 'valid-move', 'valid-capture');
                    
                    // Re-add coordinates if needed
                    const rank = parseInt(square.dataset.rank);
                    const file = parseInt(square.dataset.file);
                    const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
                    const ranks = ['8', '7', '6', '5', '4', '3', '2', '1'];
                    
                    if (file === 0) {
                        const rankCoord = document.createElement('div');
                        rankCoord.className = 'coordinates coordinate-rank';
                        rankCoord.textContent = ranks[rank];
                        square.appendChild(rankCoord);
                    }
                    
                    if (rank === 7) {
                        const fileCoord = document.createElement('div');
                        fileCoord.className = 'coordinates coordinate-file';
                        fileCoord.textContent = files[file];
                        square.appendChild(fileCoord);
                    }
                });
                
                // Place pieces on the board
                for (let rank = 0; rank < 8; rank++) {
                    for (let file = 0; file < 8; file++) {
                        const piece = gameState.board[rank][file];
                        if (piece) {
                            const squareIndex = rank * 8 + file;
                            const square = squares[squareIndex];
                            const pieceElement = document.createElement('div');
                            pieceElement.className = 'piece';
                            pieceElement.textContent = getPieceSymbol(piece.type, piece.color);
                            square.appendChild(pieceElement);
                        }
                    }
                }
                
                // Highlight selected piece and valid moves
                if (gameState.selectedPiece) {
                    const { rank, file } = gameState.selectedPiece;
                    const squareIndex = rank * 8 + file;
                    squares[squareIndex].classList.add('selected');
                    
                    gameState.validMoves.forEach(move => {
                        const moveIndex = move.rank * 8 + move.file;
                        if (gameState.board[move.rank][move.file]) {
                            squares[moveIndex].classList.add('valid-capture');
                        } else {
                            squares[moveIndex].classList.add('valid-move');
                        }
                    });
                }
                
                // Update status
                updateStatus();
                
                // Update move history
                updateMoveHistory();
            }

            // Get Unicode symbol for a chess piece
            function getPieceSymbol(type, color) {
                const symbols = {
                    white: {
                        king: '♔',
                        queen: '♕',
                        rook: '♖',
                        bishop: '♗',
                        knight: '♘',
                        pawn: '♙'
                    },
                    black: {
                        king: '♚',
                        queen: '♛',
                        rook: '♜',
                        bishop: '♝',
                        knight: '♞',
                        pawn: '♟'
                    }
                };
                return symbols[color][type];
            }

            // Handle square clicks
            function handleSquareClick(event) {
                if (gameState.gameOver || gameState.currentPlayer === 'black') return;
                
                const square = event.currentTarget;
                const rank = parseInt(square.dataset.rank);
                const file = parseInt(square.dataset.file);
                
                // If a piece is already selected
                if (gameState.selectedPiece) {
                    // Check if the clicked square is a valid move
                    const isValidMove = gameState.validMoves.some(move => 
                        move.rank === rank && move.file === file
                    );
                    
                    if (isValidMove) {
                        // Move the piece
                        movePiece(gameState.selectedPiece.rank, gameState.selectedPiece.file, rank, file);
                        gameState.selectedPiece = null;
                        gameState.validMoves = [];
                        
                        // AI makes a move after a short delay
                        if (!gameState.gameOver) {
                            setTimeout(makeAIMove, 800);
                        }
                    } else {
                        // If clicking on another piece of the same color, select it
                        const piece = gameState.board[rank][file];
                        if (piece && piece.color === 'white') {
                            gameState.selectedPiece = { rank, file };
                            gameState.validMoves = calculateValidMoves(rank, file);
                        } else {
                            gameState.selectedPiece = null;
                            gameState.validMoves = [];
                        }
                    }
                } else {
                    // Select a piece if it's the current player's piece
                    const piece = gameState.board[rank][file];
                    if (piece && piece.color === 'white') {
                        gameState.selectedPiece = { rank, file };
                        gameState.validMoves = calculateValidMoves(rank, file);
                    }
                }
                
                updateBoard();
            }

            // Calculate valid moves for a piece (fixed with proper chess rules)
            function calculateValidMoves(rank, file) {
                const piece = gameState.board[rank][file];
                if (!piece) return [];
                
                const moves = [];
                const color = piece.color;
                
                switch (piece.type) {
                    case 'pawn':
                        const direction = color === 'white' ? -1 : 1;
                        const startRank = color === 'white' ? 6 : 1;
                        
                        // Move forward one
                        if (isInBoard(rank + direction, file) && !gameState.board[rank + direction][file]) {
                            moves.push({ rank: rank + direction, file });
                            
                            // Move forward two from starting position
                            if (rank === startRank && !gameState.board[rank + 2 * direction][file]) {
                                moves.push({ rank: rank + 2 * direction, file });
                            }
                        }
                        
                        // Captures
                        for (let f of [file - 1, file + 1]) {
                            if (isInBoard(rank + direction, f) && 
                                gameState.board[rank + direction][f] && 
                                gameState.board[rank + direction][f].color !== color) {
                                moves.push({ rank: rank + direction, file: f });
                            }
                        }
                        break;
                        
                    case 'knight':
                        const knightMoves = [
                            { r: -2, f: -1 }, { r: -2, f: 1 },
                            { r: -1, f: -2 }, { r: -1, f: 2 },
                            { r: 1, f: -2 }, { r: 1, f: 2 },
                            { r: 2, f: -1 }, { r: 2, f: 1 }
                        ];
                        
                        knightMoves.forEach(move => {
                            const newRank = rank + move.r;
                            const newFile = file + move.f;
                            
                            if (isInBoard(newRank, newFile) && 
                                (!gameState.board[newRank][newFile] || 
                                gameState.board[newRank][newFile].color !== color)) {
                                moves.push({ rank: newRank, file: newFile });
                            }
                        });
                        break;
                        
                    case 'bishop':
                        // Bishop moves diagonally in all four directions
                        const bishopDirections = [
                            { r: -1, f: -1 }, // up-left
                            { r: -1, f: 1 },  // up-right
                            { r: 1, f: -1 },  // down-left
                            { r: 1, f: 1 }    // down-right
                        ];
                        
                        bishopDirections.forEach(dir => {
                            let newRank = rank + dir.r;
                            let newFile = file + dir.f;
                            
                            while (isInBoard(newRank, newFile)) {
                                if (!gameState.board[newRank][newFile]) {
                                    // Empty square, add and continue
                                    moves.push({ rank: newRank, file: newFile });
                                } else {
                                    // Piece found
                                    if (gameState.board[newRank][newFile].color !== color) {
                                        // Opponent's piece, can capture
                                        moves.push({ rank: newRank, file: newFile });
                                    }
                                    // Stop in this direction after hitting any piece
                                    break;
                                }
                                newRank += dir.r;
                                newFile += dir.f;
                            }
                        });
                        break;
                        
                    case 'rook':
                        // Rook moves horizontally and vertically
                        const rookDirections = [
                            { r: -1, f: 0 },  // up
                            { r: 1, f: 0 },   // down
                            { r: 0, f: -1 },  // left
                            { r: 0, f: 1 }    // right
                        ];
                        
                        rookDirections.forEach(dir => {
                            let newRank = rank + dir.r;
                            let newFile = file + dir.f;
                            
                            while (isInBoard(newRank, newFile)) {
                                if (!gameState.board[newRank][newFile]) {
                                    // Empty square, add and continue
                                    moves.push({ rank: newRank, file: newFile });
                                } else {
                                    // Piece found
                                    if (gameState.board[newRank][newFile].color !== color) {
                                        // Opponent's piece, can capture
                                        moves.push({ rank: newRank, file: newFile });
                                    }
                                    // Stop in this direction after hitting any piece
                                    break;
                                }
                                newRank += dir.r;
                                newFile += dir.f;
                            }
                        });
                        break;
                        
                    case 'queen':
                        // Queen combines bishop and rook movements
                        const queenDirections = [
                            { r: -1, f: -1 }, // up-left
                            { r: -1, f: 1 },  // up-right
                            { r: 1, f: -1 },  // down-left
                            { r: 1, f: 1 },   // down-right
                            { r: -1, f: 0 },  // up
                            { r: 1, f: 0 },   // down
                            { r: 0, f: -1 },  // left
                            { r: 0, f: 1 }    // right
                        ];
                        
                        queenDirections.forEach(dir => {
                            let newRank = rank + dir.r;
                            let newFile = file + dir.f;
                            
                            while (isInBoard(newRank, newFile)) {
                                if (!gameState.board[newRank][newFile]) {
                                    // Empty square, add and continue
                                    moves.push({ rank: newRank, file: newFile });
                                } else {
                                    // Piece found
                                    if (gameState.board[newRank][newFile].color !== color) {
                                        // Opponent's piece, can capture
                                        moves.push({ rank: newRank, file: newFile });
                                    }
                                    // Stop in this direction after hitting any piece
                                    break;
                                }
                                newRank += dir.r;
                                newFile += dir.f;
                            }
                        });
                        break;
                        
                    case 'king':
                        // King moves one square in any direction
                        const kingMoves = [
                            { r: -1, f: -1 }, { r: -1, f: 0 }, { r: -1, f: 1 },
                            { r: 0, f: -1 },                   { r: 0, f: 1 },
                            { r: 1, f: -1 },  { r: 1, f: 0 },  { r: 1, f: 1 }
                        ];
                        
                        kingMoves.forEach(move => {
                            const newRank = rank + move.r;
                            const newFile = file + move.f;
                            
                            if (isInBoard(newRank, newFile) && 
                                (!gameState.board[newRank][newFile] || 
                                gameState.board[newRank][newFile].color !== color)) {
                                moves.push({ rank: newRank, file: newFile });
                            }
                        });
                        
                        // TODO: Add castling logic in the future
                        break;
                }
                
                return moves;
            }

            // Check if coordinates are within the board
            function isInBoard(rank, file) {
                return rank >= 0 && rank < 8 && file >= 0 && file < 8;
            }

            // Move a piece from one square to another
            function movePiece(fromRank, fromFile, toRank, toFile) {
                const piece = gameState.board[fromRank][fromFile];
                gameState.board[toRank][toFile] = piece;
                gameState.board[fromRank][fromFile] = null;
                
                // Record the move
                const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
                const ranks = ['8', '7', '6', '5', '4', '3', '2', '1'];
                const moveNotation = `${piece.type.charAt(0).toUpperCase()}${files[fromFile]}${ranks[fromRank]}-${files[toFile]}${ranks[toRank]}`;
                
                gameState.moveHistory.push({
                    player: gameState.currentPlayer,
                    notation: moveNotation
                });
                
                // Switch player
                gameState.currentPlayer = gameState.currentPlayer === 'white' ? 'black' : 'white';
                
                // Check for game over conditions (simplified)
                checkGameOver();
            }

            // AI makes a move
            function makeAIMove() {
                if (gameState.gameOver || gameState.currentPlayer !== 'black') return;
                
                document.getElementById('ai-thinking').style.display = 'block';
                
                // Simulate AI thinking
                setTimeout(() => {
                    // Find all black pieces and their possible moves
                    const possibleMoves = [];
                    
                    for (let rank = 0; rank < 8; rank++) {
                        for (let file = 0; file < 8; file++) {
                            const piece = gameState.board[rank][file];
                            if (piece && piece.color === 'black') {
                                const moves = calculateValidMoves(rank, file);
                                moves.forEach(move => {
                                    possibleMoves.push({
                                        from: { rank, file },
                                        to: move
                                    });
                                });
                            }
                        }
                    }
                    
                    // Pick a random move (in a real AI, this would use a proper algorithm)
                    if (possibleMoves.length > 0) {
                        const randomMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                        movePiece(
                            randomMove.from.rank, 
                            randomMove.from.file, 
                            randomMove.to.rank, 
                            randomMove.to.file
                        );
                    }
                    
                    document.getElementById('ai-thinking').style.display = 'none';
                    updateBoard();
                }, 1000);
            }

            // Check for game over conditions
            function checkGameOver() {
                // Simplified game over check - just look for kings
                let whiteKing = false;
                let blackKing = false;
                
                for (let rank = 0; rank < 8; rank++) {
                    for (let file = 0; file < 8; file++) {
                        const piece = gameState.board[rank][file];
                        if (piece && piece.type === 'king') {
                            if (piece.color === 'white') whiteKing = true;
                            if (piece.color === 'black') blackKing = true;
                        }
                    }
                }
                
                if (!whiteKing) {
                    gameState.gameOver = true;
                    document.getElementById('status').textContent = 'Game Over! Black wins by checkmate.';
                } else if (!blackKing) {
                    gameState.gameOver = true;
                    document.getElementById('status').textContent = 'Game Over! White wins by checkmate.';
                }
            }

            // Update the game status display
            function updateStatus() {
                const statusElement = document.getElementById('status');
                
                if (gameState.gameOver) {
                    // Status already set by checkGameOver
                    return;
                }
                
                if (gameState.currentPlayer === 'white') {
                    statusElement.textContent = 'Your turn. Make your move.';
                } else {
                    statusElement.textContent = 'AI thinking...';
                }
            }

            // Update the move history display
            function updateMoveHistory() {
                const movesElement = document.getElementById('moves');
                movesElement.innerHTML = '';
                
                gameState.moveHistory.forEach((move, index) => {
                    const moveElement = document.createElement('div');
                    moveElement.className = 'move';
                    moveElement.textContent = `${index + 1}. ${move.notation}`;
                    movesElement.appendChild(moveElement);
                });
                
                // Scroll to bottom
                movesElement.scrollTop = movesElement.scrollHeight;
            }

            // Set up event listeners for buttons
            document.getElementById('new-game').addEventListener('click', function() {
                gameState.currentPlayer = 'white';
                gameState.selectedPiece = null;
                gameState.validMoves = [];
                gameState.moveHistory = [];
                gameState.gameOver = false;
                setupPieces();
                updateBoard();
            });
            
            document.getElementById('undo-move').addEventListener('click', function() {
                // Simplified undo - just reset the game
                if (confirm('Start a new game?')) {
                    document.getElementById('new-game').click();
                }
            });
            
            document.getElementById('hint').addEventListener('click', function() {
                if (gameState.currentPlayer === 'white' && gameState.selectedPiece) {
                    // Show a random valid move as a hint
                    if (gameState.validMoves.length > 0) {
                        const hint = gameState.validMoves[Math.floor(Math.random() * gameState.validMoves.length)];
                        alert(`Hint: Try moving to ${String.fromCharCode(97 + hint.file)}${8 - hint.rank}`);
                    }
                } else {
                    alert('Select one of your pieces first to get a hint.');
                }
            });
            
            document.getElementById('flip-board').addEventListener('click', function() {
                gameState.boardFlipped = !gameState.boardFlipped;
                const board = document.getElementById('chess-board');
                
                if (gameState.boardFlipped) {
                    board.style.transform = 'rotate(180deg)';
                } else {
                    board.style.transform = 'rotate(0deg)';
                }
            });

            // Initialize the game
            initBoard();
        });
    </script>
</body>
</html>
