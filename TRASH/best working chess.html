<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WEBXOS AI CHESS - Quantum Training</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
        }

        body {
            background: #000;
            color: #39ff14;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Scanlines effect */
        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 100;
        }

        .header {
            background: rgba(0, 0, 0, 0.9);
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #39ff14;
            box-shadow: 0 0 10px #39ff14;
            z-index: 100;
            height: 70px;
            flex-shrink: 0;
        }

        .logo {
            display: flex;
            align-items: center;
        }

        .logo h1 {
            font-size: 18px;
            font-weight: 700;
            text-shadow: 0 0 10px #39ff14;
            margin-right: 10px;
        }

        .version {
            background: rgba(57, 255, 20, 0.2);
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 9px;
            color: #39ff14;
            text-shadow: 0 0 5px #39ff14;
        }

        .nav-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: flex-end;
            max-width: 70%;
        }

        .nav-btn {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #39ff14;
            color: #39ff14;
            padding: 5px 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 10px;
            text-shadow: 0 0 5px #39ff14;
            box-shadow: 0 0 5px rgba(57, 255, 20, 0.5);
            white-space: nowrap;
        }

        .nav-btn:hover {
            background: rgba(57, 255, 20, 0.2);
            box-shadow: 0 0 10px #39ff14;
        }

        .nav-btn.info {
            border-color: #00ffff;
            color: #00ffff;
        }

        .nav-btn.reset {
            border-color: #ff3333;
            color: #ff3333;
        }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
            height: calc(100vh - 220px);
        }

        .game-container {
            flex: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
            height: 100%;
        }

        #chessboard-3d {
            width: 90%;
            height: 90%;
            position: relative;
        }

        .status-sidebar {
            width: 300px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            border-left: 1px solid #39ff14;
            box-shadow: -5px 0 20px rgba(57, 255, 20, 0.3);
            position: relative;
            height: 100%;
            flex-shrink: 0;
            overflow: hidden;
        }

        /* Status Panel Styles */
        .status-panel {
            background: rgba(10, 15, 10, 0.8);
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #39ff14;
            box-shadow: 0 0 10px rgba(57, 255, 20, 0.3);
            flex-shrink: 0;
        }

        .status-panel h2 {
            font-size: 16px;
            margin-bottom: 10px;
            color: #39ff14;
            text-shadow: 0 0 5px #39ff14;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .status-item {
            display: flex;
            flex-direction: column;
        }

        .status-label {
            font-size: 10px;
            color: #88ff88;
            margin-bottom: 2px;
            text-shadow: 0 0 3px #88ff88;
        }

        .status-value {
            font-size: 14px;
            font-weight: 600;
            color: #39ff14;
            text-shadow: 0 0 5px #39ff14;
        }

        /* Activity Panel */
        .activity-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: rgba(10, 15, 10, 0.8);
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #39ff14;
            box-shadow: 0 0 10px rgba(57, 255, 20, 0.3);
            overflow: hidden;
        }

        .activity-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .activity-title {
            font-size: 16px;
            color: #39ff14;
            text-shadow: 0 0 5px #39ff14;
        }

        .activity-clear {
            background: none;
            border: 1px solid #39ff14;
            color: #39ff14;
            padding: 3px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.3s ease;
        }

        .activity-clear:hover {
            background: rgba(57, 255, 20, 0.2);
        }

        .activity-log {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding-right: 5px;
            height: 80px;
            max-height: 80px;
        }

        .activity-entry {
            font-size: 11px;
            line-height: 1.3;
            padding: 5px;
            background: rgba(20, 30, 20, 0.5);
            border-radius: 3px;
            border-left: 2px solid #39ff14;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }

        /* Training Controls */
        .training-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .training-buttons {
            display: flex;
            gap: 10px;
        }

        .training-btn {
            flex: 1;
            background: linear-gradient(135deg, #000, #0a2a0a);
            border: 1px solid #39ff14;
            color: #39ff14;
            padding: 12px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 10px rgba(57, 255, 20, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            text-shadow: 0 0 5px #39ff14;
        }

        .training-btn:hover {
            background: rgba(57, 255, 20, 0.2);
            box-shadow: 0 0 15px #39ff14;
        }

        .training-btn.active {
            background: rgba(57, 255, 20, 0.3);
            box-shadow: 0 0 20px #39ff14;
        }

        .training-btn.start {
            border-color: #39ff14;
            color: #39ff14;
        }

        .training-btn.start.active {
            background: rgba(57, 255, 20, 0.3);
            box-shadow: 0 0 20px #39ff14;
        }

        .training-btn.stop {
            border-color: #ff3333;
            color: #ff3333;
        }

        .training-btn.stop.active {
            background: rgba(255, 51, 51, 0.3);
            box-shadow: 0 0 15px #ff3333;
        }

        .training-btn.reset {
            border-color: #ffff00;
            color: #ffff00;
            background: linear-gradient(135deg, #000, #2a2a00);
        }

        .training-btn.reset:hover {
            background: rgba(255, 255, 0, 0.2);
            box-shadow: 0 0 15px #ffff00;
        }

        /* AI Thinking Indicator */
        .ai-thinking {
            display: none;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: rgba(20, 30, 20, 0.6);
            border-radius: 4px;
            margin-top: 8px;
            border: 1px solid #39ff14;
            box-shadow: 0 0 5px rgba(57, 255, 20, 0.3);
            height: 30px;
        }

        .ai-thinking.active {
            display: flex;
        }

        .thinking-dots {
            display: flex;
            gap: 3px;
        }

        .thinking-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #39ff14;
            animation: pulse 1.5s infinite ease-in-out;
            box-shadow: 0 0 5px #39ff14;
        }

        .thinking-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .thinking-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.2); opacity: 1; }
        }

        /* Footer with QNN Grids */
        .footer {
            background: rgba(0, 0, 0, 0.95);
            padding: 15px 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-top: 1px solid #39ff14;
            box-shadow: 0 0 10px #39ff14;
            height: 150px;
            flex-shrink: 0;
            position: relative;
        }

        .copyright {
            position: absolute;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #39ff14;
            text-shadow: 0 0 5px #39ff14;
            opacity: 0.7;
        }

        /* QNN Parameter Grids */
        .qnn-grids {
            display: flex;
            gap: 20px;
            width: 100%;
            height: 100%;
            max-width: 800px;
        }

        .qnn-grid {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: rgba(10, 15, 10, 0.8);
            border: 1px solid #39ff14;
            border-radius: 4px;
            padding: 10px;
            box-shadow: 0 0 10px rgba(57, 255, 20, 0.3);
            height: 120px;
        }

        .qnn-header {
            text-align: center;
            margin-bottom: 10px;
            font-size: 14px;
            text-shadow: 0 0 5px #39ff14;
            height: 20px;
        }

        .qnn-canvas-container {
            flex: 1;
            position: relative;
            border: 1px solid #39ff14;
            background: #000;
            height: 70px;
        }

        .qnn-canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .qnn-values {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 10px;
            height: 15px;
        }

        /* Loading Screen */
        .loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }

        .loading-logo {
            font-size: 36px;
            font-weight: 700;
            background: linear-gradient(90deg, #39ff14, #88ff88);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: 15px;
            text-shadow: 0 0 10px #39ff14;
        }

        .loading-bar-container {
            width: 250px;
            height: 5px;
            background: rgba(57, 255, 20, 0.2);
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #39ff14, #88ff88);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px #39ff14;
        }

        .loading-text {
            font-size: 14px;
            color: #88ff88;
            text-shadow: 0 0 5px #88ff88;
        }

        /* Scoreboard Popup */
        .scoreboard-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            height: 400px;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #39ff14;
            border-radius: 8px;
            box-shadow: 0 0 20px #39ff14;
            z-index: 1000;
            overflow: hidden;
        }

        .scoreboard-popup.active {
            display: flex;
            flex-direction: column;
        }

        .scoreboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: rgba(10, 15, 10, 0.8);
            border-bottom: 1px solid #39ff14;
        }

        .scoreboard-title {
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 5px #39ff14;
            color: #39ff14;
        }

        .scoreboard-close {
            background: none;
            border: none;
            color: #ff3333;
            font-size: 20px;
            cursor: pointer;
            text-shadow: 0 0 5px #ff3333;
            transition: all 0.3s ease;
        }

        .scoreboard-close:hover {
            transform: scale(1.2);
        }

        .scoreboard-content {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .agent-score {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: rgba(20, 30, 20, 0.6);
            border-radius: 4px;
            border: 1px solid #39ff14;
        }

        .agent-name {
            font-size: 16px;
            font-weight: bold;
        }

        .agent-stats {
            display: flex;
            gap: 15px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-value {
            font-size: 18px;
            font-weight: bold;
        }

        .stat-label {
            font-size: 10px;
            color: #88ff88;
        }

        .agent-management {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
        }

        .agent-management-btn {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #39ff14;
            color: #39ff14;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
            text-shadow: 0 0 5px #39ff14;
            box-shadow: 0 0 5px rgba(57, 255, 20, 0.5);
        }

        .agent-management-btn:hover {
            background: rgba(57, 255, 20, 0.2);
            box-shadow: 0 0 10px #39ff14;
        }

        .recommendation {
            text-align: center;
            padding: 10px;
            background: rgba(57, 255, 20, 0.2);
            border-radius: 4px;
            border: 1px solid #39ff14;
            margin-top: 10px;
        }

        .overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
        }

        .overlay.active {
            display: block;
        }

        /* Quantum Manual Popup */
        .quantum-manual {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 700px;
            height: 500px;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ffff;
            border-radius: 8px;
            box-shadow: 0 0 20px #00ffff;
            z-index: 1000;
            overflow: hidden;
        }

        .quantum-manual.active {
            display: flex;
            flex-direction: column;
        }

        .manual-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: rgba(10, 20, 20, 0.8);
            border-bottom: 1px solid #00ffff;
        }

        .manual-title {
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 5px #00ffff;
            color: #00ffff;
        }

        .manual-close {
            background: none;
            border: none;
            color: #ff3333;
            font-size: 20px;
            cursor: pointer;
            text-shadow: 0 0 5px #ff3333;
            transition: all 0.3s ease;
        }

        .manual-close:hover {
            transform: scale(1.2);
        }

        .manual-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .manual-section {
            margin-bottom: 15px;
        }

        .manual-section h3 {
            font-size: 16px;
            color: #00ffff;
            margin-bottom: 8px;
            text-shadow: 0 0 5px #00ffff;
            border-bottom: 1px solid #00ffff;
            padding-bottom: 5px;
        }

        .manual-section p {
            font-size: 12px;
            line-height: 1.4;
            margin-bottom: 8px;
        }

        .manual-section ul {
            margin-left: 20px;
            font-size: 12px;
            line-height: 1.4;
        }

        .manual-section li {
            margin-bottom: 5px;
        }

        /* Error Message */
        .error-message {
            display: none;
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 10px 15px;
            border-radius: 4px;
            border: 1px solid #ff3333;
            box-shadow: 0 0 10px #ff3333;
            z-index: 1001;
            max-width: 300px;
        }

        .error-message.active {
            display: block;
            animation: fadeInOut 3s ease;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(-10px); }
            10% { opacity: 1; transform: translateY(0); }
            90% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-10px); }
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(20, 30, 20, 0.3);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(57, 255, 20, 0.5);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(57, 255, 20, 0.7);
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .main-container {
                flex-direction: column;
                height: calc(100vh - 220px);
            }
            
            .status-sidebar {
                width: 100%;
                height: 40%;
                border-left: none;
                border-top: 1px solid #39ff14;
                box-shadow: 0 -5px 20px rgba(57, 255, 20, 0.3);
            }
            
            .game-container {
                height: 60%;
            }
            
            .nav-buttons {
                max-width: 65%;
            }
            
            .nav-btn {
                font-size: 9px;
                padding: 4px 6px;
            }
        }

        @media (max-width: 768px) {
            .header {
                padding: 8px 10px;
                height: 80px;
            }
            
            .logo h1 {
                font-size: 14px;
            }
            
            .nav-buttons {
                max-width: 60%;
                gap: 4px;
            }
            
            .nav-btn {
                font-size: 8px;
                padding: 3px 5px;
            }
            
            .footer {
                height: 120px;
                padding: 10px 15px;
            }
            
            .qnn-grid {
                height: 100px;
            }
            
            .qnn-header {
                font-size: 12px;
            }
            
            .quantum-manual {
                width: 90%;
                height: 80%;
            }
            
            .scoreboard-popup {
                width: 90%;
                height: 80%;
            }
            
            .training-btn {
                font-size: 12px;
                padding: 10px;
            }
            
            .status-sidebar {
                padding: 10px;
            }
            
            .status-panel, .activity-panel {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="overlay" id="overlay"></div>
    
    <!-- Quantum Manual Popup -->
    <div class="quantum-manual" id="quantumManual">
        <div class="manual-header">
            <div class="manual-title">QUANTUM CHESS MANUAL</div>
            <button class="manual-close" id="closeManual">✕</button>
        </div>
        <div class="manual-content">
            <div class="manual-section">
                <h3>QUANTUM TRAINING INSTRUCTIONS</h3>
                <ol>
                    <li>Click START to begin continuous quantum training</li>
                    <li>Let the system run for extended periods to maximize learning</li>
                    <li>Use the XY grids below to adjust QNN parameters in real-time</li>
                    <li>Check the scoreboard to see which agent is performing better</li>
                    <li>Export the best-performing agent for future use</li>
                </ol>
            </div>
            
            <div class="manual-section">
                <h3>QUANTUM CHESS OVERVIEW</h3>
                <p>Welcome to WEBXOS AI CHESS, a revolutionary quantum chess training system where AI agents compete and evolve using Quantum Neural Networks (QNNs).</p>
                <p>This system allows two QNN agents to train against each other, continuously improving their strategies through quantum computing principles.</p>
            </div>
            
            <div class="manual-section">
                <h3>QUANTUM PARAMETERS EXPLAINED</h3>
                <p><strong>Entanglement:</strong> Determines how strongly the agent's decision-making is connected across the board. Higher values create more coordinated strategies.</p>
                <p><strong>Superposition:</strong> Controls the agent's ability to consider multiple potential moves simultaneously. Higher values increase strategic diversity.</p>
                <p>Adjust these parameters by clicking on the QNN grids at the bottom of the screen.</p>
            </div>
            
            <div class="manual-section">
                <h3>AGENT MANAGEMENT</h3>
                <p><strong>Export Agents:</strong> Save trained agents to JSON files for later use. The system will prompt you to download the agent data.</p>
                <p><strong>Upload Agents:</strong> Load previously trained agents to continue their training or test them against other agents.</p>
                <p>Agents are saved with their QNN parameters, performance history, and training logs.</p>
            </div>
            
            <div class="manual-section">
                <h3>PERFORMANCE METRICS</h3>
                <p>The system tracks:</p>
                <ul>
                    <li><strong>Wins/Losses:</strong> Track record of each agent</li>
                    <li><strong>Score Percentage:</strong> Overall performance rating</li>
                    <li><strong>Training Iterations:</strong> Number of moves analyzed</li>
                    <li><strong>Active Agent:</strong> Which QNN is currently thinking</li>
                </ul>
            </div>
        </div>
    </div>
    
    <!-- Scoreboard Popup -->
    <div class="scoreboard-popup" id="scoreboardPopup">
        <div class="scoreboard-header">
            <div class="scoreboard-title">QUANTUM AGENT SCOREBOARD</div>
            <button class="scoreboard-close" id="closeScoreboard">✕</button>
        </div>
        <div class="scoreboard-content">
            <div class="agent-score">
                <div class="agent-name">GREEN QNN</div>
                <div class="agent-stats">
                    <div class="stat-item">
                        <div class="stat-value" id="greenWins">12</div>
                        <div class="stat-label">WINS</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="greenLosses">8</div>
                        <div class="stat-label">LOSSES</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="greenScore">64%</div>
                        <div class="stat-label">SCORE</div>
                    </div>
                </div>
            </div>
            <div class="agent-score">
                <div class="agent-name">BLACK QNN</div>
                <div class="agent-stats">
                    <div class="stat-item">
                        <div class="stat-value" id="blackWins">8</div>
                        <div class="stat-label">WINS</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="blackLosses">12</div>
                        <div class="stat-label">LOSSES</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="blackScore">36%</div>
                        <div class="stat-label">SCORE</div>
                    </div>
                </div>
            </div>
            
            <div class="agent-management">
                <button class="agent-management-btn" id="exportGreenBtn">EXPORT GREEN AGENT</button>
                <button class="agent-management-btn" id="exportBlackBtn">EXPORT BLACK AGENT</button>
            </div>
            <div class="agent-management">
                <button class="agent-management-btn" id="uploadGreenBtn">UPLOAD GREEN AGENT</button>
                <button class="agent-management-btn" id="uploadBlackBtn">UPLOAD BLACK AGENT</button>
            </div>
            
            <div class="recommendation" id="recommendation">
                <strong>RECOMMENDATION:</strong> Export the GREEN QNN agent for best performance
            </div>
        </div>
    </div>

    <!-- Error Message -->
    <div class="error-message" id="errorMessage">
        <span id="errorText">Error message will appear here</span>
    </div>

    <div class="loading-screen" id="loadingScreen">
        <div class="loading-logo">WEBXOS AI CHESS</div>
        <div class="loading-bar-container">
            <div class="loading-bar" id="loadingBar"></div>
        </div>
        <div class="loading-text" id="loadingText">Initializing Quantum Neural Networks...</div>
    </div>

    <div class="header">
        <div class="logo">
            <h1>WEBXOS AI CHESS</h1>
            <span class="version">QNN v4.0</span>
        </div>
        <div class="nav-buttons">
            <button class="nav-btn reset" id="resetBtn">RESET</button>
            <button class="nav-btn info" id="infoBtn">INFO</button>
            <button class="nav-btn" id="scoreboardBtn">SCOREBOARD</button>
        </div>
    </div>

    <div class="main-container">
        <div class="game-container">
            <div id="chessboard-3d">
                <!-- 3D chessboard will be rendered here -->
            </div>
        </div>
        <div class="status-sidebar">
            <div class="status-panel">
                <h2>QUANTUM TRAINING STATUS</h2>
                <div class="status-grid">
                    <div class="status-item">
                        <span class="status-label">Training Mode</span>
                        <span class="status-value" id="gameMode">QNN vs QNN</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Training Iterations</span>
                        <span class="status-value" id="moveCount">0</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Training Status</span>
                        <span class="status-value" id="gameStatus">READY</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Active Agent</span>
                        <span class="status-value" id="currentPlayer">-</span>
                    </div>
                </div>
            </div>

            <div class="training-controls">
                <h2>QUANTUM TRAINING CONTROLS</h2>
                <div class="training-buttons">
                    <button class="training-btn start" id="startBtn">START TRAINING</button>
                    <button class="training-btn stop" id="stopBtn">STOP TRAINING</button>
                    <button class="training-btn reset" id="sidebarResetBtn">RESET</button>
                </div>
                <div class="ai-thinking" id="aiThinking">
                    <span>QNN Processing:</span>
                    <div class="thinking-dots">
                        <div class="thinking-dot"></div>
                        <div class="thinking-dot"></div>
                        <div class="thinking-dot"></div>
                    </div>
                    <span id="thinkingAI">Quantum AI</span>
                </div>
            </div>

            <div class="activity-panel">
                <div class="activity-header">
                    <div class="activity-title">ACTIVITY LOG</div>
                    <button class="activity-clear" id="clearLogBtn">CLEAR</button>
                </div>
                <div class="activity-log" id="activityLog">
                    <div class="activity-entry">System initialized and ready</div>
                    <div class="activity-entry">QNN parameters calibrated</div>
                    <div class="activity-entry">Quantum training environment loaded</div>
                </div>
            </div>
        </div>
    </div>

    <div class="footer">
        <div class="qnn-grids">
            <div class="qnn-grid">
                <div class="qnn-header">GREEN QNN PARAMETERS</div>
                <div class="qnn-canvas-container">
                    <canvas class="qnn-canvas" id="greenQnnCanvas" width="200" height="100"></canvas>
                </div>
                <div class="qnn-values">
                    <span>Entanglement: <span id="greenEntanglement">0.73</span></span>
                    <span>Superposition: <span id="greenSuperposition">0.61</span></span>
                </div>
            </div>
            <div class="qnn-grid">
                <div class="qnn-header">BLACK QNN PARAMETERS</div>
                <div class="qnn-canvas-container">
                    <canvas class="qnn-canvas" id="blackQnnCanvas" width="200" height="100"></canvas>
                </div>
                <div class="qnn-values">
                    <span>Entanglement: <span id="blackEntanglement">0.68</span></span>
                    <span>Superposition: <span id="blackSuperposition">0.55</span></span>
                </div>
            </div>
        </div>
        <div class="copyright">WEBXOS © 2025-2026 | Quantum Neural Network Training System</div>
    </div>

    <script>
        // Game state variables
        let gameMode = 'ai-vs-ai';
        let currentPlayer = 'green';
        let moveCount = 0;
        let gameActive = false;
        let boardState = [];
        let autoPlayInterval = null;
        let aiStrength = 7;
        let gameSpeed = 8;
        let trainingGames = Infinity;
        let gamesCompleted = 0;
        let isTraining = false;
        let trainingInterval = null;
        let trainingLog = [];
        
        // Agent performance tracking
        let agentPerformance = {
            green: { wins: 0, losses: 0, score: 0 },
            black: { wins: 0, losses: 0, score: 0 }
        };
        
        // Three.js variables
        let scene, camera, renderer, controls;
        let chessboard, pieces = [];
        let selectedPiece = null;
        let possibleMoves = [];

        // QNN Parameters
        let greenQnnParams = { entanglement: 0.73, superposition: 0.61 };
        let blackQnnParams = { entanglement: 0.68, superposition: 0.55 };
        let greenCanvas, blackCanvas;
        let greenCtx, blackCtx;

        // Activity log
        let activityLog = [
            "System initialized and ready",
            "QNN parameters calibrated", 
            "Quantum training environment loaded"
        ];

        // Initialize the application
        function init() {
            updateLoading("Initializing Quantum Processors...", 30);
            
            // Initialize 3D chessboard
            init3DChessboard();
            
            updateLoading("Calibrating QNN Parameters...", 60);
            setupQnnCanvases();
            setupEventListeners();
            
            updateLoading("Preparing Quantum Training...", 90);
            initializeBoard();
            
            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loadingScreen').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.display = 'none';
                    updateGameInfo();
                }, 500);
            }, 1000);
        }

        function updateLoading(text, progress) {
            document.getElementById('loadingText').textContent = text;
            document.getElementById('loadingBar').style.width = `${progress}%`;
        }

        // Initialize 3D chessboard with Three.js
        function init3DChessboard() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 15);
            camera.lookAt(0, 0, 0);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(document.getElementById('chessboard-3d').clientWidth, 
                            document.getElementById('chessboard-3d').clientHeight);
            document.getElementById('chessboard-3d').appendChild(renderer.domElement);
            
            // Add orbit controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x222222, 1);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0x39ff14, 0.8);
            directionalLight.position.set(10, 20, 10);
            scene.add(directionalLight);
            
            const pointLight = new THREE.PointLight(0x39ff14, 0.5, 100);
            pointLight.position.set(0, 10, 0);
            scene.add(pointLight);
            
            // Create chessboard
            createChessboard3D();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Start animation loop
            animate();
        }
        
        function createChessboard3D() {
            // Create board base
            const boardGeometry = new THREE.BoxGeometry(18, 0.5, 18);
            const boardMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x111111,
                roughness: 0.8,
                metalness: 0.2
            });
            chessboard = new THREE.Mesh(boardGeometry, boardMaterial);
            chessboard.position.y = -0.25;
            scene.add(chessboard);
            
            // Create squares
            const squareGeometry = new THREE.BoxGeometry(2, 0.1, 2);
            const lightMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a3d1a,
                roughness: 0.6,
                metalness: 0.3,
                emissive: 0x0a2a0a
            });
            const darkMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x000000,
                roughness: 0.6,
                metalness: 0.3,
                emissive: 0x061006
            });
            
            for (let x = 0; x < 8; x++) {
                for (let z = 0; z < 8; z++) {
                    const isLight = (x + z) % 2 === 0;
                    const material = isLight ? lightMaterial : darkMaterial;
                    const square = new THREE.Mesh(squareGeometry, material);
                    square.position.set((x - 3.5) * 2, 0, (z - 3.5) * 2);
                    square.userData = { x: x, z: z, isSquare: true };
                    scene.add(square);
                }
            }
            
            // Add board border with neon effect
            const borderGeometry = new THREE.BoxGeometry(18.2, 0.6, 18.2);
            const borderMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x39ff14,
                roughness: 0.3,
                metalness: 0.7,
                emissive: 0x0a3a0a
            });
            const border = new THREE.Mesh(borderGeometry, borderMaterial);
            border.position.y = -0.3;
            scene.add(border);
            
            // Create initial pieces
            createPieces3D();
        }
        
        function createPieces3D() {
            // Define piece geometries
            const pieceGeometries = {
                pawn: new THREE.CylinderGeometry(0.6, 0.8, 1.6, 16),
                rook: new THREE.CylinderGeometry(0.8, 0.8, 1.6, 16),
                knight: new THREE.ConeGeometry(0.8, 1.6, 16),
                bishop: new THREE.ConeGeometry(0.6, 1.6, 16),
                queen: new THREE.SphereGeometry(0.8, 16, 16),
                king: new THREE.CylinderGeometry(0.6, 0.8, 2, 16)
            };
            
            // Define materials for green and black pieces
            const greenMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x39ff14,
                roughness: 0.2,
                metalness: 0.8,
                emissive: 0x0a3a0a
            });
            
            const blackMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x111111,
                roughness: 0.2,
                metalness: 0.8,
                emissive: 0x050505
            });
            
            // Set up initial piece positions
            const initialPositions = [
                // Black pieces (back row)
                { type: 'rook', color: 'black', x: 0, z: 0 },
                { type: 'knight', color: 'black', x: 1, z: 0 },
                { type: 'bishop', color: 'black', x: 2, z: 0 },
                { type: 'queen', color: 'black', x: 3, z: 0 },
                { type: 'king', color: 'black', x: 4, z: 0 },
                { type: 'bishop', color: 'black', x: 5, z: 0 },
                { type: 'knight', color: 'black', x: 6, z: 0 },
                { type: 'rook', color: 'black', x: 7, z: 0 },
                
                // Black pawns
                { type: 'pawn', color: 'black', x: 0, z: 1 },
                { type: 'pawn', color: 'black', x: 1, z: 1 },
                { type: 'pawn', color: 'black', x: 2, z: 1 },
                { type: 'pawn', color: 'black', x: 3, z: 1 },
                { type: 'pawn', color: 'black', x: 4, z: 1 },
                { type: 'pawn', color: 'black', x: 5, z: 1 },
                { type: 'pawn', color: 'black', x: 6, z: 1 },
                { type: 'pawn', color: 'black', x: 7, z: 1 },
                
                // Green pieces (back row)
                { type: 'rook', color: 'green', x: 0, z: 7 },
                { type: 'knight', color: 'green', x: 1, z: 7 },
                { type: 'bishop', color: 'green', x: 2, z: 7 },
                { type: 'queen', color: 'green', x: 3, z: 7 },
                { type: 'king', color: 'green', x: 4, z: 7 },
                { type: 'bishop', color: 'green', x: 5, z: 7 },
                { type: 'knight', color: 'green', x: 6, z: 7 },
                { type: 'rook', color: 'green', x: 7, z: 7 },
                
                // Green pawns
                { type: 'pawn', color: 'green', x: 0, z: 6 },
                { type: 'pawn', color: 'green', x: 1, z: 6 },
                { type: 'pawn', color: 'green', x: 2, z: 6 },
                { type: 'pawn', color: 'green', x: 3, z: 6 },
                { type: 'pawn', color: 'green', x: 4, z: 6 },
                { type: 'pawn', color: 'green', x: 5, z: 6 },
                { type: 'pawn', color: 'green', x: 6, z: 6 },
                { type: 'pawn', color: 'green', x: 7, z: 6 }
            ];
            
            // Create pieces
            initialPositions.forEach(pos => {
                const geometry = pieceGeometries[pos.type];
                const material = pos.color === 'green' ? greenMaterial : blackMaterial;
                const piece = new THREE.Mesh(geometry, material);
                
                piece.position.set((pos.x - 3.5) * 2, 1, (pos.z - 3.5) * 2);
                piece.userData = { 
                    type: pos.type, 
                    color: pos.color, 
                    x: pos.x, 
                    z: pos.z,
                    isPiece: true
                };
                
                scene.add(piece);
                pieces.push(piece);
            });
        }
        
        function onWindowResize() {
            camera.aspect = document.getElementById('chessboard-3d').clientWidth / 
                           document.getElementById('chessboard-3d').clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(document.getElementById('chessboard-3d').clientWidth, 
                           document.getElementById('chessboard-3d').clientHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            
            // Update QNN parameter displays
            updateQnnDisplays();
        }

        // Setup QNN parameter canvases
        function setupQnnCanvases() {
            greenCanvas = document.getElementById('greenQnnCanvas');
            blackCanvas = document.getElementById('blackQnnCanvas');
            greenCtx = greenCanvas.getContext('2d');
            blackCtx = blackCanvas.getContext('2d');
            
            // Set canvas size to match container
            greenCanvas.width = greenCanvas.parentElement.clientWidth;
            greenCanvas.height = greenCanvas.parentElement.clientHeight;
            blackCanvas.width = blackCanvas.parentElement.clientWidth;
            blackCanvas.height = blackCanvas.parentElement.clientHeight;
            
            // Add click handlers for parameter adjustment
            greenCanvas.addEventListener('click', (e) => adjustQnnParams(e, 'green'));
            blackCanvas.addEventListener('click', (e) => adjustQnnParams(e, 'black'));
            
            // Draw initial parameter grids
            drawQnnGrid(greenCtx, greenCanvas, 'green');
            drawQnnGrid(blackCtx, blackCanvas, 'black');
        }
        
        function drawQnnGrid(ctx, canvas, color) {
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            
            // Draw grid
            ctx.strokeStyle = color === 'green' ? '#39ff14' : '#39ff14';
            ctx.lineWidth = 1;
            
            // Vertical lines
            for (let x = 0; x <= width; x += width / 10) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let y = 0; y <= height; y += height / 10) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            // Draw current parameter point
            const params = color === 'green' ? greenQnnParams : blackQnnParams;
            const pointX = params.entanglement * width;
            const pointY = height - (params.superposition * height);
            
            ctx.fillStyle = color === 'green' ? '#39ff14' : '#39ff14';
            ctx.beginPath();
            ctx.arc(pointX, pointY, 5, 0, Math.PI * 2);
            ctx.fill();
            
            // Add glow effect
            ctx.shadowColor = color === 'green' ? '#39ff14' : '#39ff14';
            ctx.shadowBlur = 10;
            ctx.fill();
            ctx.shadowBlur = 0;
        }
        
        function adjustQnnParams(event, color) {
            try {
                const canvas = color === 'green' ? greenCanvas : blackCanvas;
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                const params = color === 'green' ? greenQnnParams : blackQnnParams;
                params.entanglement = Math.max(0, Math.min(1, x / canvas.width));
                params.superposition = Math.max(0, Math.min(1, 1 - (y / canvas.height)));
                
                // Update display
                document.getElementById(`${color}Entanglement`).textContent = params.entanglement.toFixed(2);
                document.getElementById(`${color}Superposition`).textContent = params.superposition.toFixed(2);
                
                // Redraw grid
                const ctx = color === 'green' ? greenCtx : blackCtx;
                drawQnnGrid(ctx, canvas, color);
                
                // Log parameter change
                addToLog(`${color.toUpperCase()} QNN parameters updated: Entanglement=${params.entanglement.toFixed(2)}, Superposition=${params.superposition.toFixed(2)}`);
                addActivity(`${color.toUpperCase()} QNN parameters adjusted`);
            } catch (error) {
                showError("Error adjusting QNN parameters: " + error.message);
            }
        }
        
        function updateQnnDisplays() {
            try {
                // Randomly fluctuate parameters slightly to simulate quantum behavior
                if (Math.random() < 0.05) {
                    greenQnnParams.entanglement += (Math.random() - 0.5) * 0.02;
                    greenQnnParams.entanglement = Math.max(0, Math.min(1, greenQnnParams.entanglement));
                    greenQnnParams.superposition += (Math.random() - 0.5) * 0.02;
                    greenQnnParams.superposition = Math.max(0, Math.min(1, greenQnnParams.superposition));
                    
                    document.getElementById('greenEntanglement').textContent = greenQnnParams.entanglement.toFixed(2);
                    document.getElementById('greenSuperposition').textContent = greenQnnParams.superposition.toFixed(2);
                    drawQnnGrid(greenCtx, greenCanvas, 'green');
                }
                
                if (Math.random() < 0.05) {
                    blackQnnParams.entanglement += (Math.random() - 0.5) * 0.02;
                    blackQnnParams.entanglement = Math.max(0, Math.min(1, blackQnnParams.entanglement));
                    blackQnnParams.superposition += (Math.random() - 0.5) * 0.02;
                    blackQnnParams.superposition = Math.max(0, Math.min(1, blackQnnParams.superposition));
                    
                    document.getElementById('blackEntanglement').textContent = blackQnnParams.entanglement.toFixed(2);
                    document.getElementById('blackSuperposition').textContent = blackQnnParams.superposition.toFixed(2);
                    drawQnnGrid(blackCtx, blackCanvas, 'black');
                }
            } catch (error) {
                // Handle errors in QNN display updates
                console.error("Error updating QNN displays:", error);
            }
        }

        function initializeBoard() {
            // Initialize an 8x8 board
            boardState = Array(8).fill().map(() => Array(8).fill(null));
            
            // Set up pawns
            for (let i = 0; i < 8; i++) {
                boardState[i][1] = { type: 'pawn', color: 'black' };
                boardState[i][6] = { type: 'pawn', color: 'green' };
            }
            
            // Set up other pieces
            const backRow = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
            for (let i = 0; i < 8; i++) {
                boardState[i][0] = { type: backRow[i], color: 'black' };
                boardState[i][7] = { type: backRow[i], color: 'green' };
            }
        }

        function setupEventListeners() {
            // Training buttons
            document.getElementById('startBtn').addEventListener('click', startTraining);
            document.getElementById('stopBtn').addEventListener('click', pauseTraining);
            
            // Header agent management buttons
            document.getElementById('exportGreenBtn').addEventListener('click', () => saveAgent('green'));
            document.getElementById('exportBlackBtn').addEventListener('click', () => saveAgent('black'));
            document.getElementById('uploadBlackBtn').addEventListener('click', () => uploadAgent('black'));
            document.getElementById('uploadGreenBtn').addEventListener('click', () => uploadAgent('green'));
            
            // Reset buttons
            document.getElementById('resetBtn').addEventListener('click', resetSystem);
            document.getElementById('sidebarResetBtn').addEventListener('click', resetSystem);
            
            // Activity log clear button
            document.getElementById('clearLogBtn').addEventListener('click', clearActivityLog);
            
            // Info button
            document.getElementById('infoBtn').addEventListener('click', showQuantumManual);
            document.getElementById('closeManual').addEventListener('click', hideQuantumManual);
            
            // Scoreboard button
            document.getElementById('scoreboardBtn').addEventListener('click', showScoreboard);
            document.getElementById('closeScoreboard').addEventListener('click', hideScoreboard);
            document.getElementById('overlay').addEventListener('click', () => {
                hideScoreboard();
                hideQuantumManual();
            });
            
            // Add click handler for 3D board
            renderer.domElement.addEventListener('click', onCanvasClick, false);
        }
        
        function showQuantumManual() {
            document.getElementById('quantumManual').classList.add('active');
            document.getElementById('overlay').classList.add('active');
        }
        
        function hideQuantumManual() {
            document.getElementById('quantumManual').classList.remove('active');
            document.getElementById('overlay').classList.remove('active');
        }
        
        function showScoreboard() {
            try {
                // Update scoreboard with current data
                document.getElementById('greenWins').textContent = agentPerformance.green.wins;
                document.getElementById('greenLosses').textContent = agentPerformance.green.losses;
                document.getElementById('greenScore').textContent = agentPerformance.green.score + '%';
                
                document.getElementById('blackWins').textContent = agentPerformance.black.wins;
                document.getElementById('blackLosses').textContent = agentPerformance.black.losses;
                document.getElementById('blackScore').textContent = agentPerformance.black.score + '%';
                
                // Update recommendation
                let recommendation = document.getElementById('recommendation');
                if (agentPerformance.green.score > agentPerformance.black.score) {
                    recommendation.innerHTML = '<strong>RECOMMENDATION:</strong> Export the GREEN QNN agent for best performance';
                } else {
                    recommendation.innerHTML = '<strong>RECOMMENDATION:</strong> Export the BLACK QNN agent for best performance';
                }
                
                document.getElementById('scoreboardPopup').classList.add('active');
                document.getElementById('overlay').classList.add('active');
            } catch (error) {
                showError("Error displaying scoreboard: " + error.message);
            }
        }
        
        function hideScoreboard() {
            document.getElementById('scoreboardPopup').classList.remove('active');
            document.getElementById('overlay').classList.remove('active');
        }
        
        function resetSystem() {
            pauseTraining();
            
            // Reset game state
            moveCount = 0;
            currentPlayer = 'green';
            gameActive = false;
            gamesCompleted = 0;
            isTraining = false;
            
            // Reset QNN parameters
            greenQnnParams = { entanglement: 0.73, superposition: 0.61 };
            blackQnnParams = { entanglement: 0.68, superposition: 0.55 };
            
            // Reset agent performance
            agentPerformance = {
                green: { wins: 0, losses: 0, score: 0 },
                black: { wins: 0, losses: 0, score: 0 }
            };
            
            // Reset training log
            trainingLog = [];
            
            // Reset UI displays
            document.getElementById('greenEntanglement').textContent = greenQnnParams.entanglement.toFixed(2);
            document.getElementById('greenSuperposition').textContent = greenQnnParams.superposition.toFixed(2);
            document.getElementById('blackEntanglement').textContent = blackQnnParams.entanglement.toFixed(2);
            document.getElementById('blackSuperposition').textContent = blackQnnParams.superposition.toFixed(2);
            
            // Redraw QNN grids
            drawQnnGrid(greenCtx, greenCanvas, 'green');
            drawQnnGrid(blackCtx, blackCanvas, 'black');
            
            // Reset 3D board
            reset3DBoard();
            
            // Update game info
            updateGameInfo();
            
            // Add activity log entry
            addActivity("System reset to initial state");
            
            // Show success message
            showError("System reset successfully");
        }
        
        function addActivity(message) {
            const timestamp = new Date().toLocaleTimeString();
            activityLog.push(`${timestamp}: ${message}`);
            
            // Keep log from growing too large
            if (activityLog.length > 50) {
                activityLog = activityLog.slice(-40);
            }
            
            updateActivityLog();
        }
        
        function updateActivityLog() {
            const logContainer = document.getElementById('activityLog');
            logContainer.innerHTML = '';
            
            // Add entries in reverse order (newest first)
            for (let i = activityLog.length - 1; i >= 0; i--) {
                const entry = document.createElement('div');
                entry.className = 'activity-entry';
                entry.textContent = activityLog[i];
                logContainer.appendChild(entry);
            }
        }
        
        function clearActivityLog() {
            activityLog = ["Activity log cleared"];
            updateActivityLog();
        }
        
        function saveAgent(color) {
            try {
                pauseTraining();
                
                const agentData = {
                    params: color === 'green' ? greenQnnParams : blackQnnParams,
                    performance: agentPerformance[color],
                    trainingLog: trainingLog,
                    gamesCompleted: gamesCompleted,
                    timestamp: new Date().toISOString(),
                    version: "QNN v4.0"
                };
                
                // Create a markdown file with instructions
                const markdownContent = `# Quantum Chess Agent - ${color.toUpperCase()}\n\n` +
                    `## Agent Information\n` +
                    `- Color: ${color}\n` +
                    `- Export Date: ${new Date().toISOString()}\n` +
                    `- Training Sessions: ${gamesCompleted}\n` +
                    `- Win Rate: ${agentPerformance[color].score}%\n\n` +
                    `## QNN Parameters\n` +
                    `- Entanglement: ${agentData.params.entanglement.toFixed(3)}\n` +
                    `- Superposition: ${agentData.params.superposition.toFixed(3)}\n\n` +
                    `## Usage Instructions\n` +
                    `1. Import this agent into WEBXOS AI CHESS using the "Upload Agent" button\n` +
                    `2. The agent will continue training with its learned parameters\n` +
                    `3. Monitor performance in the scoreboard\n` +
                    `4. Export again after further training to preserve improvements\n\n` +
                    `## Performance History\n` +
                    `- Wins: ${agentPerformance[color].wins}\n` +
                    `- Losses: ${agentPerformance[color].losses}\n` +
                    `- Score: ${agentPerformance[color].score}%\n\n` +
                    `*This agent was trained using Quantum Neural Network technology.*`;
                
                // Create JSON data
                const jsonData = JSON.stringify(agentData, null, 2);
                
                // Create a combined file with both markdown and JSON
                const combinedContent = markdownContent + "\n\n## RAW AGENT DATA (JSON)\n\n```json\n" + jsonData + "\n```";
                
                const blob = new Blob([combinedContent], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `quantum_chess_${color}_agent_${new Date().toISOString().slice(0, 10)}.md`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                addToLog(`${color.toUpperCase()} agent exported with full documentation`);
                addActivity(`${color.toUpperCase()} agent exported`);
                showError(`${color.toUpperCase()} agent successfully exported to downloads folder`);
            } catch (error) {
                showError("Error exporting agent: " + error.message);
            }
        }
        
        function uploadAgent(color) {
            try {
                pauseTraining();
                
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.md,.json,.txt';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const content = event.target.result;
                            let agentData;
                            
                            // Try to parse as JSON directly
                            try {
                                agentData = JSON.parse(content);
                            } catch (e) {
                                // If not pure JSON, try to extract JSON from markdown
                                const jsonMatch = content.match(/```json\n([\s\S]*?)\n```/);
                                if (jsonMatch && jsonMatch[1]) {
                                    agentData = JSON.parse(jsonMatch[1]);
                                } else {
                                    throw new Error("Invalid agent file format");
                                }
                            }
                            
                            // Validate agent data structure
                            if (!agentData.params || !agentData.params.entanglement || !agentData.params.superposition) {
                                throw new Error("Invalid agent data structure");
                            }
                            
                            if (color === 'green') {
                                greenQnnParams = agentData.params;
                                document.getElementById('greenEntanglement').textContent = greenQnnParams.entanglement.toFixed(2);
                                document.getElementById('greenSuperposition').textContent = greenQnnParams.superposition.toFixed(2);
                                drawQnnGrid(greenCtx, greenCanvas, 'green');
                            } else {
                                blackQnnParams = agentData.params;
                                document.getElementById('blackEntanglement').textContent = blackQnnParams.entanglement.toFixed(2);
                                document.getElementById('blackSuperposition').textContent = blackQnnParams.superposition.toFixed(2);
                                drawQnnGrid(blackCtx, blackCanvas, 'black');
                            }
                            
                            // Reset training data and start new game
                            trainingLog = [];
                            gamesCompleted = 0;
                            moveCount = 0;
                            reset3DBoard();
                            
                            addToLog(`${color.toUpperCase()} agent uploaded successfully`);
                            addActivity(`${color.toUpperCase()} agent uploaded`);
                            showError(`${color.toUpperCase()} agent successfully uploaded`);
                            
                            // Auto-start training with new agent
                            setTimeout(startTraining, 1000);
                        } catch (error) {
                            showError("Invalid agent file: " + error.message);
                        }
                    };
                    reader.readAsText(file);
                };
                input.click();
            } catch (error) {
                showError("Error uploading agent: " + error.message);
            }
        }
        
        function showError(message) {
            const errorElement = document.getElementById('errorMessage');
            const errorText = document.getElementById('errorText');
            errorText.textContent = message;
            errorElement.classList.add('active');
            
            setTimeout(() => {
                errorElement.classList.remove('active');
            }, 3000);
        }
        
        function onCanvasClick(event) {
            if (!gameActive || gameMode === 'ai-vs-ai') return;
            
            // Calculate mouse position in normalized device coordinates
            const mouse = new THREE.Vector2();
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Create raycaster
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            // Check for intersections
            const intersects = raycaster.intersectObjects(scene.children);
            
            if (intersects.length > 0) {
                const object = intersects[0].object;
                
                if (object.userData.isPiece) {
                    // If it's a piece of the current player's color
                    if (object.userData.color === currentPlayer) {
                        selectPiece(object);
                    }
                } else if (object.userData.isSquare && selectedPiece) {
                    // If it's a square and we have a selected piece
                    movePiece(object.userData.x, object.userData.z);
                }
            }
        }
        
        function selectPiece(piece) {
            // Deselect previous piece
            if (selectedPiece) {
                selectedPiece.material.emissive.setHex(0x000000);
            }
            
            // Select new piece
            selectedPiece = piece;
            selectedPiece.material.emissive.setHex(0x333333);
            
            // Calculate possible moves (simplified)
            calculatePossibleMoves(piece.userData.x, piece.userData.z);
            
            // Highlight possible moves
            highlightPossibleMoves();
        }
        
        function calculatePossibleMoves(x, z) {
            // Simplified move calculation
            possibleMoves = [];
            
            // For pawns
            if (selectedPiece.userData.type === 'pawn') {
                const direction = selectedPiece.userData.color === 'green' ? -1 : 1;
                
                // Forward move
                if (z + direction >= 0 && z + direction < 8 && !boardState[x][z + direction]) {
                    possibleMoves.push({ x: x, z: z + direction });
                }
                
                // Capture moves
                if (x > 0 && z + direction >= 0 && z + direction < 8 && 
                    boardState[x-1][z + direction] && 
                    boardState[x-1][z + direction].color !== selectedPiece.userData.color) {
                    possibleMoves.push({ x: x-1, z: z + direction });
                }
                
                if (x < 7 && z + direction >= 0 && z + direction < 8 && 
                    boardState[x+1][z + direction] && 
                    boardState[x+1][z + direction].color !== selectedPiece.userData.color) {
                    possibleMoves.push({ x: x+1, z: z + direction });
                }
            }
            
            // For other pieces, we'd implement more complex logic
            // This is a simplified version for demonstration
        }
        
        function highlightPossibleMoves() {
            // Remove previous highlights
            clearHighlights();
            
            // Add highlights for possible moves
            possibleMoves.forEach(move => {
                const squareGeometry = new THREE.PlaneGeometry(1.8, 1.8);
                const highlightMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x39ff14, 
                    transparent: true, 
                    opacity: 0.5,
                    side: THREE.DoubleSide
                });
                const highlight = new THREE.Mesh(squareGeometry, highlightMaterial);
                highlight.rotation.x = -Math.PI / 2;
                highlight.position.set((move.x - 3.5) * 2, 0.1, (move.z - 3.5) * 2);
                highlight.userData.isHighlight = true;
                scene.add(highlight);
            });
        }
        
        function clearHighlights() {
            scene.children.forEach(child => {
                if (child.userData.isHighlight) {
                    scene.remove(child);
                }
            });
        }
        
        function movePiece(x, z) {
            // Check if the move is valid
            const isValidMove = possibleMoves.some(move => move.x === x && move.z === z);
            
            if (isValidMove) {
                // Update board state
                const fromX = selectedPiece.userData.x;
                const fromZ = selectedPiece.userData.z;
                
                boardState[x][z] = {
                    type: selectedPiece.userData.type,
                    color: selectedPiece.userData.color
                };
                boardState[fromX][fromZ] = null;
                
                // Update piece position
                selectedPiece.position.set((x - 3.5) * 2, 1, (z - 3.5) * 2);
                selectedPiece.userData.x = x;
                selectedPiece.userData.z = z;
                
                // Switch player
                currentPlayer = currentPlayer === 'green' ? 'black' : 'green';
                moveCount++;
                
                // Update UI
                updateGameInfo();
                
                // Deselect piece and clear highlights
                selectedPiece.material.emissive.setHex(0x000000);
                selectedPiece = null;
                clearHighlights();
                
                // If in AI mode, trigger AI move
                if (gameMode === 'ai-vs-ai' && gameActive) {
                    setTimeout(makeAIMove, 500);
                }
            }
        }
        
        function addToLog(message) {
            const timestamp = new Date().toISOString();
            trainingLog.push(`${timestamp}: ${message}`);
            
            // Keep log from growing too large
            if (trainingLog.length > 1000) {
                trainingLog = trainingLog.slice(-500);
            }
        }

        function startTraining() {
            if (isTraining) return;
            
            isTraining = true;
            gameActive = true;
            gamesCompleted = 0;
            
            // Show training indicator
            document.getElementById('startBtn').classList.add('active');
            document.getElementById('stopBtn').classList.remove('active');
            
            // Start auto-play
            startAutoPlay();
            
            // Start training session counter
            trainingInterval = setInterval(() => {
                if (gamesCompleted < trainingGames) {
                    gamesCompleted++;
                    
                    // Update UI to show training progress
                    document.getElementById('gameStatus').textContent = 
                        `TRAINING: ${gamesCompleted}/${trainingGames === Infinity ? '∞' : trainingGames}`;
                    
                    // Update agent performance randomly (for demo)
                    if (gamesCompleted % 5 === 0) {
                        updateAgentPerformance();
                    }
                    
                    // Auto-adjust QNN parameters after each game
                    if (gamesCompleted % 10 === 0) {
                        autoAdjustQnnParams();
                    }
                    
                    if (gamesCompleted >= trainingGames && trainingGames !== Infinity) {
                        pauseTraining();
                        document.getElementById('gameStatus').textContent = 'TRAINING COMPLETE';
                    }
                }
            }, 1000);
            
            addToLog("Quantum training started");
            addActivity("Quantum training initiated");
        }

        function autoAdjustQnnParams() {
            // Auto-adjust QNN parameters based on performance
            const greenWinRate = agentPerformance.green.score / 100;
            const blackWinRate = agentPerformance.black.score / 100;
            
            // Adjust parameters for the winning agent to reinforce good strategies
            if (greenWinRate > blackWinRate) {
                // Green is winning - slightly adjust to reinforce
                greenQnnParams.entanglement += (Math.random() - 0.5) * 0.1;
                greenQnnParams.superposition += (Math.random() - 0.5) * 0.1;
                
                // Black needs more adjustment to catch up
                blackQnnParams.entanglement += (Math.random() - 0.7) * 0.15;
                blackQnnParams.superposition += (Math.random() - 0.7) * 0.15;
            } else {
                // Black is winning - slightly adjust to reinforce
                blackQnnParams.entanglement += (Math.random() - 0.5) * 0.1;
                blackQnnParams.superposition += (Math.random() - 0.5) * 0.1;
                
                // Green needs more adjustment to catch up
                greenQnnParams.entanglement += (Math.random() - 0.7) * 0.15;
                greenQnnParams.superposition += (Math.random() - 0.7) * 0.15;
            }
            
            // Ensure parameters stay within bounds
            greenQnnParams.entanglement = Math.max(0.1, Math.min(0.9, greenQnnParams.entanglement));
            greenQnnParams.superposition = Math.max(0.1, Math.min(0.9, greenQnnParams.superposition));
            blackQnnParams.entanglement = Math.max(0.1, Math.min(0.9, blackQnnParams.entanglement));
            blackQnnParams.superposition = Math.max(0.1, Math.min(0.9, blackQnnParams.superposition));
            
            // Update displays
            document.getElementById('greenEntanglement').textContent = greenQnnParams.entanglement.toFixed(2);
            document.getElementById('greenSuperposition').textContent = greenQnnParams.superposition.toFixed(2);
            document.getElementById('blackEntanglement').textContent = blackQnnParams.entanglement.toFixed(2);
            document.getElementById('blackSuperposition').textContent = blackQnnParams.superposition.toFixed(2);
            
            // Redraw grids
            drawQnnGrid(greenCtx, greenCanvas, 'green');
            drawQnnGrid(blackCtx, blackCanvas, 'black');
            
            addActivity("QNN parameters auto-adjusted based on performance");
        }

        function updateAgentPerformance() {
            // Randomly update agent performance for demo
            if (Math.random() > 0.5) {
                agentPerformance.green.wins++;
                addActivity("GREEN QNN wins a training match");
            } else {
                agentPerformance.black.wins++;
                addActivity("BLACK QNN wins a training match");
            }
            
            // Calculate scores
            const totalGames = agentPerformance.green.wins + agentPerformance.green.losses + 
                              agentPerformance.black.wins + agentPerformance.black.losses;
            
            if (totalGames > 0) {
                agentPerformance.green.score = Math.round((agentPerformance.green.wins / totalGames) * 100);
                agentPerformance.black.score = Math.round((agentPerformance.black.wins / totalGames) * 100);
            }
        }

        function startAutoPlay() {
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
            }
            
            autoPlayInterval = setInterval(() => {
                if (gameActive) {
                    makeAIMove();
                }
            }, 2000 / gameSpeed);
        }

        function makeAIMove() {
            if (!gameActive) return;
            
            // Show AI thinking indicator
            document.getElementById('aiThinking').classList.add('active');
            document.getElementById('thinkingAI').textContent = 
                currentPlayer === 'green' ? 'Quantum AI' : 'NeuralNet';
            
            // Simulate AI thinking time
            setTimeout(() => {
                // In a real implementation, this would use the AI to select a move
                // For now, we'll simulate a move
                simulateAIMove();
                
                // Hide AI thinking indicator
                document.getElementById('aiThinking').classList.remove('active');
            }, 1000 / gameSpeed);
        }

        function simulateAIMove() {
            // This is a simplified move simulation
            // In a real implementation, this would use proper chess logic
            
            // Find all pieces of the current player
            const currentPieces = pieces.filter(piece => 
                piece.userData.color === currentPlayer && 
                boardState[piece.userData.x][piece.userData.z] !== null
            );
            
            if (currentPieces.length === 0) {
                endGame();
                return;
            }
            
            // Select a random piece
            const randomPiece = currentPieces[Math.floor(Math.random() * currentPieces.length)];
            
            // Select a random valid move for that piece
            selectPiece(randomPiece);
            calculatePossibleMoves(randomPiece.userData.x, randomPiece.userData.z);
            
            if (possibleMoves.length > 0) {
                const randomMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                movePiece(randomMove.x, randomMove.z);
                addActivity(`${currentPlayer.toUpperCase()} QNN makes a move`);
            } else {
                // If no valid moves, try another piece
                simulateAIMove();
            }
            
            // Randomly end the game after some moves
            if (moveCount > 10 && Math.random() < 0.1) {
                endGame();
            }
        }

        function endGame() {
            gameActive = false;
            document.getElementById('gameStatus').textContent = 'GAME OVER';
            
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
                autoPlayInterval = null;
            }
            
            // Show result
            const results = ['Green QNN wins by checkmate', 'Black QNN wins by checkmate', 'Draw by stalemate'];
            const result = results[Math.floor(Math.random() * results.length)];
            
            // Update agent performance based on result
            if (result.includes('Green')) {
                agentPerformance.green.wins++;
                agentPerformance.black.losses++;
            } else if (result.includes('Black')) {
                agentPerformance.black.wins++;
                agentPerformance.green.losses++;
            }
            
            // Calculate scores
            const totalGames = agentPerformance.green.wins + agentPerformance.green.losses + 
                              agentPerformance.black.wins + agentPerformance.black.losses;
            
            if (totalGames > 0) {
                agentPerformance.green.score = Math.round((agentPerformance.green.wins / totalGames) * 100);
                agentPerformance.black.score = Math.round((agentPerformance.black.wins / totalGames) * 100);
            }
            
            // Log result
            addToLog(`Training session completed: ${result}`);
            addActivity(`Training session completed: ${result}`);
            
            // Auto-adjust QNN parameters after game completion
            autoAdjustQnnParams();
            
            // Reset for next game
            setTimeout(() => {
                resetGame();
                if (isTraining) {
                    startAutoPlay();
                }
            }, 2000);
        }

        function updateGameInfo() {
            document.getElementById('moveCount').textContent = moveCount;
            document.getElementById('gameStatus').textContent = gameActive ? 'RUNNING' : isTraining ? 'PAUSED' : 'READY';
            document.getElementById('currentPlayer').textContent = gameActive ? (currentPlayer === 'green' ? 'Green' : 'Black') : '-';
        }

        function pauseTraining() {
            if (!isTraining) return;
            
            isTraining = false;
            gameActive = false;
            clearInterval(trainingInterval);
            
            if (autoPlayInterval) {
                clearInterval(autoPlayInterval);
                autoPlayInterval = null;
            }
            
            document.getElementById('startBtn').classList.remove('active');
            document.getElementById('stopBtn').classList.add('active');
            
            addToLog("Training paused");
            addActivity("Training paused");
        }

        function resetGame() {
            // Reset game state
            moveCount = 0;
            currentPlayer = 'green';
            gameActive = isTraining;
            
            // Reset 3D board
            reset3DBoard();
            
            // Update game info
            updateGameInfo();
        }
        
        function reset3DBoard() {
            // Remove all pieces
            pieces.forEach(piece => scene.remove(piece));
            pieces = [];
            
            // Clear board state
            initializeBoard();
            
            // Recreate pieces
            createPieces3D();
        }

        // Start the application when the page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>