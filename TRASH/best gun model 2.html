<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Mars Battlefield FPS | GalaxyCraft Terrain Combat</title>
  <meta name="description" content="Experience intense FPS combat on the red planet with Mars Battlefield - a first-person terrain combat game.">
  <meta name="keywords" content="Mars, FPS, terrain combat, base defense, WebGL, drone swarm, GalaxyCraft">
  <meta name="author" content="WebXOS">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Orbitron', 'Courier New', monospace;
    }
    body {
      background: #000;
      color: #f55;
      height: 100vh;
      overflow: hidden;
      touch-action: none;
    }
    #gameCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }
    
    /* Crosshair */
    .crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 30px;
      height: 30px;
      z-index: 10;
      pointer-events: none;
    }
    .crosshair::before, .crosshair::after {
      content: '';
      position: absolute;
      background: #f55;
    }
    .crosshair::before {
      width: 20px;
      height: 2px;
      left: 5px;
      top: 14px;
    }
    .crosshair::after {
      width: 2px;
      height: 20px;
      left: 14px;
      top: 5px;
    }
    .crosshair.dot::before {
      width: 4px;
      height: 4px;
      left: 13px;
      top: 13px;
      border-radius: 50%;
    }
    .crosshair.dot::after {
      display: none;
    }
    
    /* Weapon HUD */
    .weapon-hud {
      position: fixed;
      bottom: 120px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 20;
    }
    .weapon-icon {
      font-size: 40px;
      margin-bottom: 10px;
      text-shadow: 0 0 10px rgba(255, 85, 85, 0.8);
    }
    .ammo-display {
      font-size: 24px;
      text-shadow: 0 0 5px rgba(255, 85, 85, 0.8);
    }
    
    /* Main UI */
    .ui-container {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      z-index: 20;
      padding: 15px;
      background: rgba(60, 20, 10, 0.7);
      border-radius: 20px;
      border: 2px solid #f55;
      backdrop-filter: blur(5px);
      transition: all 0.5s ease;
    }
    .ui-btn {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      background: linear-gradient(145deg, #502020, #301010);
      border: 2px solid #f55;
      color: #f55;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: 0 0 15px rgba(255, 85, 85, 0.5);
      transition: all 0.2s ease;
    }
    .ui-btn:hover {
      background: linear-gradient(145deg, #603030, #402020);
      box-shadow: 0 0 20px rgba(255, 85, 85, 0.8);
    }
    .ui-btn.active {
      background: linear-gradient(145deg, #ff3300, #cc2200);
      border-color: #ff3300;
      box-shadow: 0 0 20px rgba(255, 51, 0, 0.8);
      color: #fff;
    }
    .ui-btn .key {
      font-size: 20px;
      font-weight: bold;
      margin-bottom: 4px;
    }
    
    /* Combat Stats */
    .combat-stats {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border: 2px solid #f55;
      border-radius: 10px;
      font-size: 16px;
      color: #f55;
      z-index: 15;
    }
    .health-bar, .shield-bar {
      width: 200px;
      height: 20px;
      background: #333;
      border-radius: 10px;
      margin: 10px 0;
      overflow: hidden;
    }
    .health-fill {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, #f00, #ff3300);
      border-radius: 10px;
      transition: width 0.3s ease;
    }
    .shield-fill {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, #f85, #f55);
      border-radius: 10px;
      transition: width 0.3s ease;
    }
    .warning-alert {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 36px;
      color: #f00;
      text-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
      text-align: center;
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: 25;
      pointer-events: none;
    }
    .warning-alert.active {
      animation: alert-flash 0.5s infinite alternate;
    }
    @keyframes alert-flash {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    /* Currency Display */
    .currency-display {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border: 2px solid #f55;
      border-radius: 10px;
      font-size: 16px;
      color: #f55;
      z-index: 15;
      display: flex;
      align-items: center;
    }
    .currency-icon {
      color: #f55;
      font-size: 20px;
      margin-right: 10px;
    }
    
    /* Base Status */
    .base-status {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border: 2px solid #5a5;
      border-radius: 10px;
      font-size: 16px;
      color: #5a5;
      z-index: 15;
    }
    .base-health-bar {
      width: 200px;
      height: 20px;
      background: #333;
      border-radius: 10px;
      margin: 10px 0;
      overflow: hidden;
    }
    .base-health-fill {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, #5a5, #3c3);
      border-radius: 10px;
      transition: width 0.3s ease;
    }
    
    /* Main Menu */
    .main-menu {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(30, 10, 5, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      color: #f55;
    }
    .game-title {
      font-size: 60px;
      margin-bottom: 40px;
      text-shadow: 0 0 20px rgba(255, 85, 85, 0.8);
      letter-spacing: 4px;
    }
    .menu-options {
      display: flex;
      flex-direction: column;
      gap: 20px;
      width: 300px;
    }
    .menu-btn {
      padding: 15px 30px;
      background: linear-gradient(145deg, #502020, #301010);
      border: 2px solid #f55;
      color: #f55;
      font-size: 20px;
      text-align: center;
      cursor: pointer;
      border-radius: 10px;
      transition: all 0.3s ease;
    }
    .menu-btn:hover {
      background: linear-gradient(145deg, #603030, #402020);
      box-shadow: 0 0 20px rgba(255, 85, 85, 0.8);
      transform: translateY(-3px);
    }
    .settings-panel {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(60, 20, 10, 0.9);
      padding: 30px;
      border: 2px solid #f55;
      border-radius: 15px;
      width: 400px;
      display: none;
      z-index: 110;
    }
    .settings-panel h2 {
      margin-bottom: 20px;
      text-align: center;
    }
    .settings-row {
      display: flex;
      justify-content: space-between;
      margin: 15px 0;
    }
    .settings-row label {
      font-size: 18px;
    }
    .settings-row input {
      background: #402020;
      border: 1px solid #f55;
      color: #f55;
      padding: 5px 10px;
      border-radius: 5px;
      width: 80px;
    }
    .close-settings {
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      color: #f55;
      font-size: 20px;
      cursor: pointer;
    }
    
    /* Console Messages */
    .console-message {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 10px 20px;
      border: 2px solid #f55;
      border-radius: 10px;
      color: #f55;
      font-size: 18px;
      opacity: 0;
      transition: opacity 0.5s ease;
      z-index: 25;
    }
    .console-message.active {
      opacity: 1;
    }
    
    /* Hit Marker */
    .hit-marker {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 40px;
      height: 40px;
      border: 2px solid #f55;
      border-radius: 50%;
      z-index: 10;
      pointer-events: none;
      opacity: 0;
    }
    .hit-marker.active {
      animation: hitMarker 0.3s ease-out;
    }
    @keyframes hitMarker {
      0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
      100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
    }
    
    /* Damage Effect */
    .damage-effect {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 0, 0, 0.2);
      z-index: 5;
      pointer-events: none;
      opacity: 0;
    }
    .damage-effect.active {
      animation: damageFlash 0.3s ease-out;
    }
    @keyframes damageFlash {
      0% { opacity: 0.5; }
      100% { opacity: 0; }
    }
    
    /* Jetpack Indicator */
    .jetpack-indicator {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border: 2px solid #5af;
      border-radius: 10px;
      font-size: 16px;
      color: #5af;
      z-index: 15;
    }
    .jetpack-bar {
      width: 200px;
      height: 20px;
      background: #333;
      border-radius: 10px;
      margin: 10px 0;
      overflow: hidden;
    }
    .jetpack-fill {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, #5af, #35f);
      border-radius: 10px;
      transition: width 0.3s ease;
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      .ui-container {
        bottom: 10px;
        padding: 10px;
        gap: 10px;
      }
      .ui-btn {
        width: 60px;
        height: 60px;
        font-size: 10px;
      }
      .ui-btn .key {
        font-size: 16px;
      }
      .game-title {
        font-size: 40px;
      }
      .menu-btn {
        padding: 12px 24px;
        font-size: 18px;
      }
      .combat-stats {
        bottom: 100px;
        left: 10px;
        font-size: 14px;
        padding: 10px;
      }
      .health-bar, .shield-bar {
        width: 150px;
        height: 15px;
      }
      .base-status {
        top: 10px;
        left: 10px;
        padding: 10px;
        font-size: 14px;
      }
      .base-health-bar {
        width: 150px;
        height: 15px;
      }
      .weapon-hud {
        bottom: 100px;
      }
      .weapon-icon {
        font-size: 30px;
      }
      .ammo-display {
        font-size: 18px;
      }
      .jetpack-indicator {
        bottom: 100px;
        right: 10px;
        padding: 10px;
        font-size: 14px;
      }
      .jetpack-bar {
        width: 150px;
        height: 15px;
      }
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    
    <!-- Crosshair -->
    <div class="crosshair" id="crosshair"></div>
    
    <!-- Weapon HUD -->
    <div class="weapon-hud" id="weaponHud">
      <div class="weapon-icon" id="weaponIcon">🔫</div>
      <div class="ammo-display" id="ammoDisplay">∞/∞</div>
    </div>
    
    <!-- Hit Marker -->
    <div class="hit-marker" id="hitMarker"></div>
    
    <!-- Damage Effect -->
    <div class="damage-effect" id="damageEffect"></div>
    
    <!-- Combat Stats -->
    <div class="combat-stats">
      <div>WAVE: <span id="waveCount">1</span></div>
      <div>ENEMIES: <span id="enemyCount">0</span></div>
      <div>SCORE: <span id="combatScore">0</span></div>
      <div>HEALTH:</div>
      <div class="health-bar"><div class="health-fill" id="healthFill" style="width: 100%"></div></div>
      <div>SHIELD:</div>
      <div class="shield-bar"><div class="shield-fill" id="shieldFill" style="width: 100%"></div></div>
    </div>
    
    <!-- Base Status -->
    <div class="base-status">
      <div>BASE HEALTH:</div>
      <div class="base-health-bar"><div class="base-health-fill" id="baseHealthFill" style="width: 100%"></div></div>
      <div>ENEMY BASE: <span id="enemyBaseHealth">100</span>%</div>
    </div>
    
    <!-- Currency Display -->
    <div class="currency-display">
      <span class="currency-icon">$</span>
      <span id="currencyCount">0</span>
    </div>
    
    <!-- Jetpack Indicator -->
    <div class="jetpack-indicator">
      <div>JETPACK:</div>
      <div class="jetpack-bar"><div class="jetpack-fill" id="jetpackFill" style="width: 100%"></div></div>
    </div>
    
    <div class="warning-alert" id="warningAlert">INCOMING!</div>
    
    <!-- Main UI Controls -->
    <div class="ui-container">
      <div class="ui-btn" id="moveBtn">
        <div class="key">W</div>
        <div>MOVE</div>
      </div>
      <div class="ui-btn" id="jumpBtn">
        <div class="key">SPC</div>
        <div>JUMP</div>
      </div>
      <div class="ui-btn" id="reloadBtn">
        <div class="key">R</div>
        <div>RELOAD</div>
      </div>
      <div class="ui-btn" id="fireBtn">
        <div class="key">LMB</div>
        <div>FIRE</div>
      </div>
      <div class="ui-btn" id="sprintBtn">
        <div class="key">SHFT</div>
        <div>SPRINT</div>
      </div>
      <div class="ui-btn" id="menuBtn">
        <div class="key">ESC</div>
        <div>MENU</div>
      </div>
    </div>
    
    <!-- Console Messages -->
    <div class="console-message" id="consoleMessage"></div>
    
    <!-- Main Menu -->
    <div class="main-menu" id="mainMenu">
      <h1 class="game-title">MARS BATTLEFIELD FPS</h1>
      <div class="menu-options">
        <div class="menu-btn" id="startBtn">JOIN BATTLE</div>
        <div class="menu-btn" id="multiplayerBtn">MULTIPLAYER</div>
        <div class="menu-btn" id="settingsBtn">SETTINGS</div>
        <div class="menu-btn" id="quitBtn">QUIT</div>
      </div>
      
      <div class="settings-panel" id="settingsPanel">
        <button class="close-settings" id="closeSettings">X</button>
        <h2>GAME SETTINGS</h2>
        <div class="settings-row">
          <label>Mouse Sensitivity:</label>
          <input type="number" id="mouseSensitivity" value="0.003" step="0.001" min="0.001" max="0.01">
        </div>
        <div class="settings-row">
          <label>Invert Y-Axis:</label>
          <input type="checkbox" id="invertYAxis">
        </div>
        <div class="settings-row">
          <label>FOV:</label>
          <input type="range" id="fovSetting" min="60" max="110" value="90">
        </div>
        <div class="settings-row">
          <label>Sound Volume:</label>
          <input type="range" id="soundVolume" min="0" max="100" value="80">
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
    // Game state and configuration
    const GameState = {
      MENU: 0,
      PLAYING: 1,
      PAUSED: 2
    };
    
    let currentState = GameState.MENU;
    let mouseSensitivity = 0.003;
    let invertYAxis = false;
    let fov = 90;
    let scaleFactor = 0.7; // 30% smaller scale
    
    // Initialize Three.js
    let scene, camera, renderer;
    let player, weaponModel, enemies = [], projectiles = [], terrain = [], bases = [];
    let clock = new THREE.Clock();
    
    // Player controls state
    const controls = {
      forward: false,
      backward: false,
      left: false,
      right: false,
      jump: false,
      sprint: false,
      fire: false,
      reload: false,
      isGrounded: false,
      jetpack: false
    };
    
    // Weapon system
    const weapons = {
      current: 0,
      list: [
        {
          name: "Gatling Gun",
          damage: 100, // One-shot kill
          fireRate: 0.05,
          ammo: Infinity,
          maxAmmo: Infinity,
          reloadTime: 0,
          range: 500,
          icon: "🔫",
          isGatling: true
        }
      ]
    };
    
    // Player stats
    const playerStats = {
      health: 100,
      shield: 100,
      score: 0,
      currency: 0,
      wave: 1,
      speed: 5 * scaleFactor,
      sprintSpeed: 8 * scaleFactor,
      jumpStrength: 12 * scaleFactor, // Increased for jetpack
      gravity: 30 * scaleFactor,
      jetpackForce: 20 * scaleFactor,
      jetpackFuel: 100,
      jetpackFuelConsumption: 20, // Fuel used per second
      jetpackFuelRegen: 15, // Fuel regenerated per second
      velocity: new THREE.Vector3(),
      lastFire: 0,
      isReloading: false,
      invincible: false
    };
    
    // Base stats
    const baseStats = {
      health: 100,
      enemyBaseHealth: 100
    };
    
    // Initialize the game
    function init() {
      // Set up scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x331100);
      scene.fog = new THREE.Fog(0x552200, 50 * scaleFactor, 500 * scaleFactor);
      
      // Set up camera - First person view
      camera = new THREE.PerspectiveCamera(fov, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.rotation.order = 'YXZ';
      
      // Set up renderer
      renderer = new THREE.WebGLRenderer({ 
        canvas: document.getElementById('gameCanvas'),
        antialias: true,
        powerPreference: "high-performance"
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      
      // Add lighting
      const ambientLight = new THREE.AmbientLight(0x554433);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffddcc, 1);
      directionalLight.position.set(5, 10, 5);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 1024;
      directionalLight.shadow.mapSize.height = 1024;
      scene.add(directionalLight);
      
      // Create mars-like terrain
      createMarsTerrain();
      
      // Create bases
      createBases();
      
      // Create player
      createPlayer();
      
      // Create initial enemies
      spawnEnemyWave(5);
      
      // Set up event listeners
      setupEventListeners();
      
      // Start animation loop
      animate();
      
      // Show console message
      showConsoleMessage("Mars Battlefield FPS initialized. Ready for combat!");
    }
    
    // Create mars-like terrain
    function createMarsTerrain() {
      // Create ground plane
      const groundGeometry = new THREE.PlaneGeometry(1000 * scaleFactor, 1000 * scaleFactor, 50, 50);
      
      // Create vertex displacement for terrain
      const vertices = groundGeometry.attributes.position.array;
      for (let i = 0; i < vertices.length; i += 3) {
        // Add some random elevation to make it look like Mars terrain
        vertices[i + 2] = (Math.random() - 0.5) * 10 * scaleFactor;
      }
      groundGeometry.attributes.position.needsUpdate = true;
      groundGeometry.computeVertexNormals();
      
      const groundMaterial = new THREE.MeshStandardMaterial({
        color: 0xaa4422,
        roughness: 0.8,
        metalness: 0.2
      });
      
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -5 * scaleFactor;
      ground.receiveShadow = true;
      scene.add(ground);
      terrain.push(ground);
      
      // Add rocks and boulders
      for (let i = 0; i < 100; i++) {
        const rockSize = (0.5 + Math.random() * 3) * scaleFactor;
        const rockGeometry = new THREE.SphereGeometry(rockSize, 6, 6);
        const rockMaterial = new THREE.MeshStandardMaterial({
          color: 0x773322,
          roughness: 0.9,
          metalness: 0.1
        });
        
        const rock = new THREE.Mesh(rockGeometry, rockMaterial);
        rock.position.set(
          (Math.random() - 0.5) * 400 * scaleFactor,
          -5 * scaleFactor + rockSize,
          (Math.random() - 0.5) * 400 * scaleFactor
        );
        rock.rotation.set(
          Math.random() * Math.PI,
          Math.random() * Math.PI,
          Math.random() * Math.PI
        );
        rock.castShadow = true;
        scene.add(rock);
        terrain.push(rock);
      }
      
      // Add craters
      for (let i = 0; i < 20; i++) {
        const craterSize = (5 + Math.random() * 15) * scaleFactor;
        const craterGeometry = new THREE.SphereGeometry(craterSize, 16, 16);
        
        // Remove top half to create a crater shape
        const vertices = craterGeometry.attributes.position.array;
        for (let j = 0; j < vertices.length; j += 3) {
          if (vertices[j + 1] > 0) {
            vertices[j + 1] = 0;
          }
        }
        craterGeometry.attributes.position.needsUpdate = true;
        
        const craterMaterial = new THREE.MeshStandardMaterial({
          color: 0x993311,
          roughness: 0.9,
          metalness: 0.1,
          flatShading: true
        });
        
        const crater = new THREE.Mesh(craterGeometry, craterMaterial);
        crater.position.set(
          (Math.random() - 0.5) * 300 * scaleFactor,
          -5 * scaleFactor - craterSize * 0.5,
          (Math.random() - 0.5) * 300 * scaleFactor
        );
        crater.rotation.x = Math.PI;
        scene.add(crater);
        terrain.push(crater);
      }
      
      // Add some structures for cover
      for (let i = 0; i < 15; i++) {
        const structureWidth = (5 + Math.random() * 10) * scaleFactor;
        const structureHeight = (3 + Math.random() * 7) * scaleFactor;
        const structureDepth = (5 + Math.random() * 10) * scaleFactor;
        
        const structureGeometry = new THREE.BoxGeometry(structureWidth, structureHeight, structureDepth);
        const structureMaterial = new THREE.MeshStandardMaterial({
          color: 0x884422,
          roughness: 0.9,
          metalness: 0.1
        });
        
        const structure = new THREE.Mesh(structureGeometry, structureMaterial);
        structure.position.set(
          (Math.random() - 0.5) * 300 * scaleFactor,
          -5 * scaleFactor + structureHeight/2,
          (Math.random() - 0.5) * 300 * scaleFactor
        );
        structure.castShadow = true;
        structure.receiveShadow = true;
        scene.add(structure);
        terrain.push(structure);
      }
    }
    
    // Create bases
    function createBases() {
      // Player base
      const baseGeometry = new THREE.CylinderGeometry(15 * scaleFactor, 20 * scaleFactor, 10 * scaleFactor, 8);
      const baseMaterial = new THREE.MeshStandardMaterial({
        color: 0x3355ff,
        emissive: 0x1133aa,
        metalness: 0.7,
        roughness: 0.3
      });
      
      const playerBase = new THREE.Mesh(baseGeometry, baseMaterial);
      playerBase.position.set(-100 * scaleFactor, 0, 0);
      playerBase.castShadow = true;
      playerBase.receiveShadow = true;
      playerBase.isPlayerBase = true;
      scene.add(playerBase);
      bases.push(playerBase);
      
      // Enemy base
      const enemyBaseGeometry = new THREE.CylinderGeometry(15 * scaleFactor, 20 * scaleFactor, 10 * scaleFactor, 8);
      const enemyBaseMaterial = new THREE.MeshStandardMaterial({
        color: 0xff3333,
        emissive: 0xaa1111,
        metalness: 0.7,
        roughness: 0.3
      });
      
      const enemyBase = new THREE.Mesh(enemyBaseGeometry, enemyBaseMaterial);
      enemyBase.position.set(100 * scaleFactor, 0, 0);
      enemyBase.castShadow = true;
      enemyBase.receiveShadow = true;
      enemyBase.isEnemyBase = true;
      scene.add(enemyBase);
      bases.push(enemyBase);
    }
    
    // Create player
    function createPlayer() {
      player = new THREE.Object3D();
      player.position.set(0, 5 * scaleFactor, 0);
      scene.add(player);
      
      // Add camera to player
      camera.position.set(0, 1.6 * scaleFactor, 0); // Eye level
      player.add(camera);
      
      // Create a better assault rifle model
      createAssaultRifle();
      
      // Set up player physics
      player.velocity = new THREE.Vector3();
    }
    
    // Create a better assault rifle model
    function createAssaultRifle() {
      const group = new THREE.Group();
      
      // Main body
      const bodyGeometry = new THREE.BoxGeometry(0.4 * scaleFactor, 0.3 * scaleFactor, 1.8 * scaleFactor);
      const bodyMaterial = new THREE.MeshPhongMaterial({
        color: 0x3366ff,
        emissive: 0x113388,
        specular: 0x4488ff,
        shininess: 50
      });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.set(0.3 * scaleFactor, -0.4 * scaleFactor, -0.9 * scaleFactor);
      group.add(body);
      
      // Barrel
      const barrelGeometry = new THREE.CylinderGeometry(0.08 * scaleFactor, 0.08 * scaleFactor, 1.2 * scaleFactor, 12);
      const barrelMaterial = new THREE.MeshPhongMaterial({
        color: 0x888888,
        emissive: 0x333333,
        specular: 0xaaaaaa,
        shininess: 80
      });
      const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
      barrel.rotation.z = Math.PI / 2;
      barrel.position.set(0.3 * scaleFactor, -0.4 * scaleFactor, -1.8 * scaleFactor);
      group.add(barrel);
      
      // Magazine
      const magazineGeometry = new THREE.BoxGeometry(0.3 * scaleFactor, 0.5 * scaleFactor, 0.6 * scaleFactor);
      const magazineMaterial = new THREE.MeshPhongMaterial({
        color: 0x444444,
        emissive: 0x222222,
        specular: 0x666666,
        shininess: 30
      });
      const magazine = new THREE.Mesh(magazineGeometry, magazineMaterial);
      magazine.position.set(0.3 * scaleFactor, -0.7 * scaleFactor, -0.5 * scaleFactor);
      group.add(magazine);
      
      // Stock
      const stockGeometry = new THREE.BoxGeometry(0.3 * scaleFactor, 0.4 * scaleFactor, 0.6 * scaleFactor);
      const stockMaterial = new THREE.MeshPhongMaterial({
        color: 0x2255aa,
        emissive: 0x113366,
        specular: 0x4477cc,
        shininess: 40
      });
      const stock = new THREE.Mesh(stockGeometry, stockMaterial);
      stock.position.set(0.3 * scaleFactor, -0.35 * scaleFactor, 0.2 * scaleFactor);
      group.add(stock);
      
      // Handle
      const handleGeometry = new THREE.BoxGeometry(0.2 * scaleFactor, 0.6 * scaleFactor, 0.2 * scaleFactor);
      const handleMaterial = new THREE.MeshPhongMaterial({
        color: 0x888888,
        emissive: 0x444444,
        specular: 0xaaaaaa,
        shininess: 20
      });
      const handle = new THREE.Mesh(handleGeometry, handleMaterial);
      handle.position.set(0.3 * scaleFactor, -0.8 * scaleFactor, -1.0 * scaleFactor);
      group.add(handle);
      
      // Add the weapon to the camera
      camera.add(group);
      weaponModel = group;
    }
    
    // Spawn a wave of enemies
    function spawnEnemyWave(count) {
      for (let i = 0; i < count; i++) {
        const enemyGeometry = new THREE.ConeGeometry(1.2 * scaleFactor, 3 * scaleFactor, 8);
        const enemyMaterial = new THREE.MeshPhongMaterial({
          color: 0xff3333,
          emissive: 0xaa0000,
          specular: 0xff6666,
          shininess: 100
        });
        
        const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
        
        // Position enemies around the enemy base
        const angle = Math.random() * Math.PI * 2;
        const radius = 30 * scaleFactor;
        enemy.position.set(
          100 * scaleFactor + Math.cos(angle) * radius,
          1.5 * scaleFactor,
          Math.sin(angle) * radius
        );
        
        enemy.velocity = new THREE.Vector3();
        enemy.health = 100;
        enemy.attackCooldown = 0;
        enemy.attackDamage = 5;
        enemy.attackRange = 20 * scaleFactor;
        enemy.moveSpeed = 4 * scaleFactor;
        
        scene.add(enemy);
        enemies.push(enemy);
      }
      
      // Update enemy count display
      document.getElementById('enemyCount').textContent = enemies.length;
    }
    
    // Set up event listeners
    function setupEventListeners() {
      // Mouse movement for camera control
      document.addEventListener('mousemove', (event) => {
        if (currentState !== GameState.PLAYING) return;
        
        const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
        const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
        
        // Rotate player (yaw)
        player.rotation.y -= movementX * mouseSensitivity;
        
        // Rotate camera (pitch)
        const pitchChange = movementY * mouseSensitivity * (invertYAxis ? -1 : 1);
        camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x + pitchChange));
      });
      
      // Mouse click for firing
      document.addEventListener('mousedown', (event) => {
        if (currentState !== GameState.PLAYING) return;
        
        if (event.button === 0) { // Left click
          controls.fire = true;
          fireWeapon();
        }
      });
      
      document.addEventListener('mouseup', (event) => {
        if (event.button === 0) {
          controls.fire = false;
        }
      });
      
      // Keyboard controls
      document.addEventListener('keydown', (event) => {
        switch(event.code) {
          case 'KeyW': controls.forward = true; break;
          case 'KeyS': controls.backward = true; break;
          case 'KeyA': controls.left = true; break;
          case 'KeyD': controls.right = true; break;
          case 'ShiftLeft': controls.sprint = true; break;
          case 'Space': 
            if (currentState === GameState.PLAYING) {
              if (event.repeat) return;
              controls.jump = true;
              // Jetpack functionality
              if (!controls.isGrounded) {
                controls.jetpack = true;
              }
            }
            break;
          case 'KeyR': controls.reload = true; break;
          case 'Escape': togglePause(); break;
        }
      });
      
      document.addEventListener('keyup', (event) => {
        switch(event.code) {
          case 'KeyW': controls.forward = false; break;
          case 'KeyS': controls.backward = false; break;
          case 'KeyA': controls.left = false; break;
          case 'KeyD': controls.right = false; break;
          case 'ShiftLeft': controls.sprint = false; break;
          case 'Space': 
            controls.jump = false;
            controls.jetpack = false;
            break;
          case 'KeyR': controls.reload = false; break;
        }
      });
      
      // Touch controls for mobile
      document.addEventListener('touchstart', (event) => {
        if (currentState !== GameState.PLAYING) return;
        
        // Check if touch is on the fire button area
        const touchX = event.touches[0].clientX;
        const touchY = event.touches[0].clientY;
        
        if (touchX > window.innerWidth / 2 && touchY > window.innerHeight / 2) {
          controls.fire = true;
          fireWeapon();
        }
      });
      
      document.addEventListener('touchend', (event) => {
        controls.fire = false;
      });
      
      // Window resize handler
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
      
      // UI button handlers
      document.getElementById('startBtn').addEventListener('click', () => {
        currentState = GameState.PLAYING;
        document.getElementById('mainMenu').style.display = 'none';
      });
      
      document.getElementById('settingsBtn').addEventListener('click', () => {
        document.getElementById('settingsPanel').style.display = 'block';
      });
      
      document.getElementById('closeSettings').addEventListener('click', () => {
        document.getElementById('settingsPanel').style.display = 'none';
      });
      
      document.getElementById('quitBtn').addEventListener('click', () => {
        window.close();
      });
      
      // Apply settings
      document.getElementById('mouseSensitivity').addEventListener('change', (event) => {
        mouseSensitivity = parseFloat(event.target.value);
      });
      
      document.getElementById('invertYAxis').addEventListener('change', (event) => {
        invertYAxis = event.target.checked;
      });
      
      document.getElementById('fovSetting').addEventListener('change', (event) => {
        fov = parseInt(event.target.value);
        camera.fov = fov;
        camera.updateProjectionMatrix();
      });
    }
    
    // Fire weapon
    function fireWeapon() {
      const currentTime = clock.getElapsedTime();
      const weapon = weapons.list[weapons.current];
      
      // Check if weapon is ready to fire
      if (currentTime - playerStats.lastFire < weapon.fireRate) return;
      
      playerStats.lastFire = currentTime;
      
      // Create projectile
      const projectileGeometry = new THREE.SphereGeometry(0.2 * scaleFactor, 8, 8);
      const projectileMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        emissive: 0x0088ff
      });
      
      const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
      
      // Calculate starting position from the weapon's barrel
      const weaponWorldPos = new THREE.Vector3();
      weaponModel.getWorldPosition(weaponWorldPos);
      
      // Calculate direction from the camera
      const direction = new THREE.Vector3(0, 0, -1);
      direction.applyQuaternion(camera.quaternion);
      
      // Set projectile position and velocity
      projectile.position.copy(weaponWorldPos);
      projectile.velocity = direction.clone().multiplyScalar(100 * scaleFactor);
      projectile.damage = weapon.damage;
      projectile.owner = 'player';
      
      scene.add(projectile);
      projectiles.push(projectile);
      
      // Add muzzle flash effect
      const muzzleFlashGeometry = new THREE.SphereGeometry(0.5 * scaleFactor, 8, 8);
      const muzzleFlashMaterial = new THREE.MeshBasicMaterial({
        color: 0xffff00,
        transparent: true,
        opacity: 0.8
      });
      
      const muzzleFlash = new THREE.Mesh(muzzleFlashGeometry, muzzleFlashMaterial);
      muzzleFlash.position.copy(weaponWorldPos);
      muzzleFlash.scale.set(0.1, 0.1, 0.1);
      scene.add(muzzleFlash);
      
      // Animate muzzle flash
      const flashStartTime = currentTime;
      function animateMuzzleFlash() {
        const time = clock.getElapsedTime();
        const progress = (time - flashStartTime) * 10;
        
        if (progress < 1) {
          muzzleFlash.scale.set(progress, progress, progress);
          muzzleFlashMaterial.opacity = 0.8 * (1 - progress);
          requestAnimationFrame(animateMuzzleFlash);
        } else {
          scene.remove(muzzleFlash);
        }
      }
      animateMuzzleFlash();
      
      // Weapon recoil animation
      weaponModel.position.z += 0.1 * scaleFactor;
      setTimeout(() => {
        weaponModel.position.z -= 0.1 * scaleFactor;
      }, 50);
      
      // Play sound (placeholder)
      // playSound('fire');
    }
    
    // Update game state
    function update(deltaTime) {
      if (currentState !== GameState.PLAYING) return;
      
      // Update player movement
      updatePlayerMovement(deltaTime);
      
      // Update jetpack
      updateJetpack(deltaTime);
      
      // Update projectiles
      updateProjectiles(deltaTime);
      
      // Update enemies
      updateEnemies(deltaTime);
      
      // Check for collisions
      checkCollisions();
      
      // Update UI
      updateUI();
    }
    
    // Update player movement
    function updatePlayerMovement(deltaTime) {
      // Determine movement direction
      const moveSpeed = controls.sprint ? playerStats.sprintSpeed : playerStats.speed;
      const moveVector = new THREE.Vector3();
      
      if (controls.forward) moveVector.z -= 1;
      if (controls.backward) moveVector.z += 1;
      if (controls.left) moveVector.x -= 1;
      if (controls.right) moveVector.x += 1;
      
      // Normalize movement vector to prevent faster diagonal movement
      if (moveVector.length() > 0) {
        moveVector.normalize();
      }
      
      // Apply movement relative to player's rotation
      moveVector.applyQuaternion(player.quaternion);
      moveVector.multiplyScalar(moveSpeed * deltaTime);
      
      // Apply movement to player velocity
      playerStats.velocity.x = moveVector.x;
      playerStats.velocity.z = moveVector.z;
      
      // Apply gravity
      if (!controls.isGrounded && !controls.jetpack) {
        playerStats.velocity.y -= playerStats.gravity * deltaTime;
      }
      
      // Apply jetpack force
      if (controls.jetpack && playerStats.jetpackFuel > 0) {
        playerStats.velocity.y += playerStats.jetpackForce * deltaTime;
        playerStats.jetpackFuel -= playerStats.jetpackFuelConsumption * deltaTime;
        if (playerStats.jetpackFuel < 0) playerStats.jetpackFuel = 0;
      }
      
      // Apply jump
      if (controls.jump && controls.isGrounded) {
        playerStats.velocity.y = playerStats.jumpStrength;
        controls.isGrounded = false;
      }
      
      // Move player
      player.position.x += playerStats.velocity.x;
      player.position.y += playerStats.velocity.y;
      player.position.z += playerStats.velocity.z;
      
      // Check ground collision
      if (player.position.y <= 0) {
        player.position.y = 0;
        playerStats.velocity.y = 0;
        controls.isGrounded = true;
      }
      
      // Regenerate jetpack fuel when not in use
      if (!controls.jetpack && playerStats.jetpackFuel < 100) {
        playerStats.jetpackFuel += playerStats.jetpackFuelRegen * deltaTime;
        if (playerStats.jetpackFuel > 100) playerStats.jetpackFuel = 100;
      }
      
      // Keep player within bounds
      const maxBounds = 500 * scaleFactor;
      player.position.x = Math.max(-maxBounds, Math.min(maxBounds, player.position.x));
      player.position.z = Math.max(-maxBounds, Math.min(maxBounds, player.position.z));
    }
    
    // Update jetpack
    function updateJetpack(deltaTime) {
      // Jetpack is handled in updatePlayerMovement
      // This function is a placeholder for any additional jetpack logic
    }
    
    // Update projectiles
    function updateProjectiles(deltaTime) {
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const projectile = projectiles[i];
        
        // Move projectile
        projectile.position.add(projectile.velocity.clone().multiplyScalar(deltaTime));
        
        // Check if projectile is out of range
        if (projectile.position.length() > 1000 * scaleFactor) {
          scene.remove(projectile);
          projectiles.splice(i, 1);
          continue;
        }
        
        // Check for collisions with terrain
        for (const terrainObject of terrain) {
          const terrainBounds = new THREE.Box3().setFromObject(terrainObject);
          if (terrainBounds.containsPoint(projectile.position)) {
            scene.remove(projectile);
            projectiles.splice(i, 1);
            break;
          }
        }
      }
    }
    
    // Update enemies
    function updateEnemies(deltaTime) {
      for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        
        // Move towards player
        const direction = new THREE.Vector3();
        direction.subVectors(player.position, enemy.position).normalize();
        
        // Apply movement
        enemy.velocity.x = direction.x * enemy.moveSpeed;
        enemy.velocity.z = direction.z * enemy.moveSpeed;
        
        enemy.position.x += enemy.velocity.x * deltaTime;
        enemy.position.z += enemy.velocity.z * deltaTime;
        
        // Keep enemy on ground
        enemy.position.y = 1.5 * scaleFactor;
        
        // Rotate to face player
        enemy.lookAt(player.position);
        
        // Attack if in range
        const distanceToPlayer = enemy.position.distanceTo(player.position);
        if (distanceToPlayer < enemy.attackRange) {
          enemy.attackCooldown -= deltaTime;
          if (enemy.attackCooldown <= 0) {
            // Attack player
            if (!playerStats.invincible) {
              playerStats.health -= enemy.attackDamage;
              showDamageEffect();
              
              if (playerStats.health <= 0) {
                gameOver();
              }
            }
            
            enemy.attackCooldown = 1; // 1 second cooldown
          }
        }
        
        // Check if enemy is dead
        if (enemy.health <= 0) {
          scene.remove(enemy);
          enemies.splice(i, 1);
          playerStats.score += 100;
          playerStats.currency += 10;
          
          // Show hit marker
          showHitMarker();
        }
      }
      
      // Spawn new wave if all enemies are defeated
      if (enemies.length === 0) {
        playerStats.wave++;
        spawnEnemyWave(5 + playerStats.wave);
        showWarningAlert("INCOMING WAVE " + playerStats.wave);
      }
      
      // Update enemy count display
      document.getElementById('enemyCount').textContent = enemies.length;
    }
    
    // Check for collisions
    function checkCollisions() {
      // Check projectile collisions
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const projectile = projectiles[i];
        
        // Player projectiles hitting enemies
        if (projectile.owner === 'player') {
          for (const enemy of enemies) {
            const distance = projectile.position.distanceTo(enemy.position);
            if (distance < 2 * scaleFactor) {
              // Hit enemy
              enemy.health -= projectile.damage;
              
              // Remove projectile
              scene.remove(projectile);
              projectiles.splice(i, 1);
              
              // Show hit marker
              showHitMarker();
              
              break;
            }
          }
        }
      }
    }
    
    // Update UI
    function updateUI() {
      // Update health and shield bars
      document.getElementById('healthFill').style.width = playerStats.health + '%';
      document.getElementById('shieldFill').style.width = playerStats.shield + '%';
      document.getElementById('jetpackFill').style.width = playerStats.jetpackFuel + '%';
      document.getElementById('baseHealthFill').style.width = baseStats.health + '%';
      
      // Update score and currency
      document.getElementById('combatScore').textContent = playerStats.score;
      document.getElementById('currencyCount').textContent = playerStats.currency;
      document.getElementById('waveCount').textContent = playerStats.wave;
    }
    
    // Show hit marker
    function showHitMarker() {
      const hitMarker = document.getElementById('hitMarker');
      hitMarker.classList.add('active');
      setTimeout(() => {
        hitMarker.classList.remove('active');
      }, 300);
    }
    
    // Show damage effect
    function showDamageEffect() {
      const damageEffect = document.getElementById('damageEffect');
      damageEffect.classList.add('active');
      setTimeout(() => {
        damageEffect.classList.remove('active');
      }, 300);
    }
    
    // Show warning alert
    function showWarningAlert(message) {
      const alert = document.getElementById('warningAlert');
      alert.textContent = message;
      alert.classList.add('active');
      setTimeout(() => {
        alert.classList.remove('active');
      }, 3000);
    }
    
    // Show console message
    function showConsoleMessage(message) {
      const consoleMessage = document.getElementById('consoleMessage');
      consoleMessage.textContent = message;
      consoleMessage.classList.add('active');
      setTimeout(() => {
        consoleMessage.classList.remove('active');
      }, 5000);
    }
    
    // Toggle pause
    function togglePause() {
      if (currentState === GameState.PLAYING) {
        currentState = GameState.PAUSED;
        document.getElementById('mainMenu').style.display = 'flex';
      } else if (currentState === GameState.PAUSED) {
        currentState = GameState.PLAYING;
        document.getElementById('mainMenu').style.display = 'none';
      }
    }
    
    // Game over
    function gameOver() {
      showConsoleMessage("MISSION FAILED! Score: " + playerStats.score);
      currentState = GameState.MENU;
      document.getElementById('mainMenu').style.display = 'flex';
      
      // Reset game state
      resetGame();
    }
    
    // Reset game
    function resetGame() {
      // Remove all enemies and projectiles
      for (const enemy of enemies) {
        scene.remove(enemy);
      }
      enemies = [];
      
      for (const projectile of projectiles) {
        scene.remove(projectile);
      }
      projectiles = [];
      
      // Reset player stats
      playerStats.health = 100;
      playerStats.shield = 100;
      playerStats.score = 0;
      playerStats.currency = 0;
      playerStats.wave = 1;
      playerStats.jetpackFuel = 100;
      
      // Reset base stats
      baseStats.health = 100;
      baseStats.enemyBaseHealth = 100;
      
      // Reset player position
      player.position.set(0, 5 * scaleFactor, 0);
      player.rotation.set(0, 0, 0);
      camera.rotation.set(0, 0, 0);
      
      // Spawn new enemies
      spawnEnemyWave(5);
    }
    
    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      
      const deltaTime = Math.min(clock.getDelta(), 0.1); // Cap delta time to prevent physics issues
      
      update(deltaTime);
      
      renderer.render(scene, camera);
    }
    
    // Initialize the game when the window loads
    window.addEventListener('load', init);
  </script>
</body>
</html>