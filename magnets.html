<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MAGNET DATASETS by webXOS 2026</title>
    <link rel="manifest" href="manifest.json">
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            background: #000;
            color: #0f0;
            font-family: 'VT323', monospace;
            font-size: 16px;
            line-height: 1.2;
            overflow: hidden;
            height: 100vh;
        }
        
        /* CRT Screen Effect */
        .crt::before {
            content: " ";
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%),
                        linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            z-index: 999;
        }
        
        .crt::after {
            content: " ";
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: rgba(18, 16, 16, 0.1);
            opacity: 0.3;
            pointer-events: none;
            animation: flicker 0.15s infinite;
            z-index: 998;
        }
        
        @keyframes flicker {
            0% { opacity: 0.27861; }
            5% { opacity: 0.34769; }
            10% { opacity: 0.23604; }
            15% { opacity: 0.90626; }
            20% { opacity: 0.18128; }
            25% { opacity: 0.83891; }
            30% { opacity: 0.65583; }
            35% { opacity: 0.67807; }
            40% { opacity: 0.26559; }
            45% { opacity: 0.84693; }
            50% { opacity: 0.96019; }
            55% { opacity: 0.08594; }
            60% { opacity: 0.20313; }
            65% { opacity: 0.71988; }
            70% { opacity: 0.53455; }
            75% { opacity: 0.37288; }
            80% { opacity: 0.71428; }
            85% { opacity: 0.70419; }
            90% { opacity: 0.7003; }
            95% { opacity: 0.36108; }
            100% { opacity: 0.24387; }
        }
        
        /* Main Terminal Grid */
        .terminal-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            grid-template-rows: auto 1fr;
            height: 100vh;
            padding: 15px;
            gap: 10px;
            background: #000;
        }
        
        /* System Header */
        .system-header {
            grid-column: 1 / -1;
            border: 1px solid #0f0;
            padding: 8px 15px;
            background: rgba(0, 10, 0, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        .system-header::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, #0f0, transparent);
            animation: scanline 3s linear infinite;
        }
        
        @keyframes scanline {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .system-title {
            font-size: 1.8em;
            text-shadow: 0 0 8px #0f0;
            letter-spacing: 2px;
            text-transform: uppercase;
            text-align: center;
        }
        
        .system-status {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 0.9em;
        }
        
        .status-led {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .led-online { background: #0f0; box-shadow: 0 0 5px #0f0; animation: blink 1s infinite; }
        .led-active { background: #0f0; box-shadow: 0 0 5px #0f0; }
        .led-standby { background: #333; }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        /* Main Control Panel */
        .control-panel {
            border: 1px solid #0f0;
            background: rgba(0, 5, 0, 0.8);
            padding: 10px;
            overflow-y: auto;
            position: relative;
        }
        
        .control-panel::before {
            content: "CONTROL";
            position: absolute;
            top: -8px;
            left: 15px;
            background: #000;
            padding: 0 8px;
            font-size: 0.9em;
            color: #0f0;
        }
        
        /* Visualization Panel */
        .visualization-panel {
            border: 1px solid #0f0;
            background: #000;
            position: relative;
            overflow: hidden;
        }
        
        .visualization-panel::before {
            content: "VISUALIZER";
            position: absolute;
            top: -8px;
            left: 15px;
            background: #000;
            padding: 0 8px;
            font-size: 0.9em;
            color: #0f0;
            z-index: 2;
        }
        
        #visual-canvas {
            width: 100%;
            height: 100%;
            background: #000;
        }
        
        /* Data Log Panel */
        .log-panel {
            grid-column: 1 / -1;
            border: 1px solid #0f0;
            background: rgba(0, 8, 0, 0.7);
            height: 180px;
            padding: 8px;
            font-family: 'VT323', monospace;
            font-size: 0.8em;
            overflow-y: scroll;
            position: relative;
        }
        
        .log-panel::before {
            content: "SYSTEM LOG";
            position: absolute;
            top: -8px;
            left: 15px;
            background: #000;
            padding: 0 8px;
            font-size: 0.9em;
            color: #0f0;
        }
        
        .log-entry {
            margin-bottom: 2px;
            padding-left: 5px;
            border-left: 1px solid #0f0;
            animation: logAppear 0.2s ease-out;
        }
        
        @keyframes logAppear {
            from { opacity: 0; transform: translateY(3px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .log-time {
            color: #080;
            margin-right: 8px;
        }
        
        .log-info { color: #0f0; }
        .log-warning { color: #ff0; }
        .log-error { color: #f00; }
        .log-success { color: #0f0; }
        
        /* Terminal Input */
        .terminal-input {
            display: flex;
            margin-top: 5px;
            border-top: 1px solid #0f0;
            padding-top: 5px;
        }
        
        .prompt {
            color: #0f0;
            margin-right: 5px;
        }
        
        #commandInput {
            background: transparent;
            border: none;
            color: #0f0;
            font-family: 'VT323', monospace;
            font-size: 0.9em;
            flex: 1;
            outline: none;
        }
        
        /* Retro Buttons */
        .btn-retro {
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            font-family: 'VT323', monospace;
            font-size: 1em;
            padding: 5px 10px;
            margin: 3px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-retro:hover {
            background: #001100;
            box-shadow: 0 0 8px rgba(0, 255, 0, 0.3);
        }
        
        .btn-retro:active {
            background: #002200;
        }
        
        /* Progress Bar */
        .progress-bar {
            height: 12px;
            background: rgba(0, 10, 0, 0.5);
            border: 1px solid #0f0;
            margin: 8px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #080, #0f0);
            width: 0%;
            transition: width 0.3s;
        }
        
        /* Fullscreen Button */
        .btn-fullscreen {
            position: fixed;
            bottom: 10px;
            right: 10px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #0f0;
            color: #0f0;
            font-size: 1.2em;
            width: 40px;
            height: 40px;
            cursor: pointer;
            transition: all 0.3s;
            opacity: 0.7;
        }
        
        .btn-fullscreen:hover {
            opacity: 1;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
        }
        
        /* Export Modal */
        .export-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            background: rgba(0, 8, 0, 0.95);
            border: 1px solid #0f0;
            padding: 15px;
            z-index: 2000;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.3);
            display: none;
        }
        
        .export-header {
            font-size: 1.2em;
            color: #0f0;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .file-structure {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #0f0;
            padding: 10px;
            margin: 15px 0;
            font-size: 0.8em;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .file-item {
            margin: 3px 0;
            padding-left: 15px;
        }
        
        .file-item::before {
            content: ">";
            margin-right: 5px;
            color: #080;
        }
        
        .btn-export {
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 8px 20px;
            font-size: 1em;
            cursor: pointer;
            width: 100%;
            margin-top: 15px;
            text-transform: uppercase;
        }
        
        .btn-export:hover {
            background: #001100;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
        }
        
        /* Overlay */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: none;
        }
        
        /* Stats */
        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin: 10px 0;
        }
        
        .stat-item {
            background: rgba(0, 10, 0, 0.3);
            border: 1px solid #0f0;
            padding: 6px;
        }
        
        .stat-label {
            font-size: 0.8em;
            color: #080;
        }
        
        .stat-value {
            font-size: 1.1em;
            color: #0f0;
        }
        
        /* Command Groups */
        .command-group {
            margin: 10px 0;
            padding: 8px;
            border: 1px solid rgba(0, 255, 0, 0.2);
            background: rgba(0, 10, 0, 0.2);
        }
        
        .command-group-title {
            color: #0f0;
            font-size: 1em;
            margin-bottom: 8px;
            padding-bottom: 3px;
            border-bottom: 1px solid #0f0;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(0, 10, 0, 0.3);
        }
        
        ::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 0, 0.2);
            border: 1px solid #0f0;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 255, 0, 0.3);
        }
        
        /* Responsive */
        @media (max-width: 1024px) {
            .terminal-grid {
                grid-template-columns: 1fr;
                grid-template-rows: auto 300px 250px 150px;
            }
            
            .control-panel {
                max-height: 250px;
            }
            
            .export-modal {
                width: 90%;
            }
        }
    </style>
</head>
<body class="crt">
    <!-- Minimal Fullscreen Button -->
    <button class="btn-fullscreen" onclick="toggleFullscreen()" title="FULLSCREEN">‚õ∂</button>
    
    <!-- Main Terminal -->
    <div class="terminal-grid">
        <!-- System Header -->
        <div class="system-header">
            <div class="system-title">
                MAGNET DATASETS by webXOS
            </div>
            <div class="system-status">
                <div>
                    <span class="status-led led-online"></span>SYSTEM: <span id="sysStatus">ONLINE</span>
                    <span class="status-led" style="margin-left: 15px;"></span>SAMPLES: <span id="sampleCount">0</span>
                    <span class="status-led" style="margin-left: 15px;"></span>BUFFER: <span id="bufferSize">0KB</span>
                </div>
                <div>
                    <span class="status-led led-active"></span>TIME: <span id="systemTime">00:00:00</span>
                    <span class="status-led" style="margin-left: 15px;"></span>WORKERS: <span id="workerCount">0/8</span>
                </div>
            </div>
        </div>
        
        <!-- Control Panel -->
        <div class="control-panel">
            <div class="command-group">
                <div class="command-group-title">DATASET GENERATORS</div>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px;">
                    <button class="btn-retro" onclick="toggleWorker('dipole')">
                        <span class="status-led" id="dipoleLed"></span> DIPOLE
                    </button>
                    <button class="btn-retro" onclick="toggleWorker('solenoid')">
                        <span class="status-led" id="solenoidLed"></span> SOLENOID
                    </button>
                    <button class="btn-retro" onclick="toggleWorker('permanent')">
                        <span class="status-led" id="permanentLed"></span> PERMANENT
                    </button>
                    <button class="btn-retro" onclick="toggleWorker('electro')">
                        <span class="status-led" id="electroLed"></span> ELECTRO
                    </button>
                    <button class="btn-retro" onclick="toggleWorker('toroid')">
                        <span class="status-led" id="toroidLed"></span> TOROIDAL
                    </button>
                    <button class="btn-retro" onclick="toggleWorker('anisotropic')">
                        <span class="status-led" id="anisotropicLed"></span> ANISOTROPIC
                    </button>
                    <button class="btn-retro" onclick="toggleWorker('halbach')">
                        <span class="status-led" id="halbachLed"></span> HALBACH
                    </button>
                    <button class="btn-retro" onclick="toggleWorker('custom')">
                        <span class="status-led" id="customLed"></span> CUSTOM
                    </button>
                </div>
            </div>
            
            <div class="command-group">
                <div class="command-group-title">CONTROLS</div>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px;">
                    <button class="btn-retro" onclick="startCollection()">
                        ‚ñ∂ START
                    </button>
                    <button class="btn-retro" onclick="stopCollection()">
                        ‚è∏ STOP
                    </button>
                    <button class="btn-retro" onclick="clearData()">
                        CLEAR
                    </button>
                    <button class="btn-retro" onclick="showExportModal()">
                        EXPORT
                    </button>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="collectionProgress" style="width: 0%"></div>
                </div>
            </div>
            
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-label">DATA POINTS</div>
                    <div class="stat-value" id="dataPoints">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">THROUGHPUT</div>
                    <div class="stat-value" id="throughput">0/s</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">MEM USAGE</div>
                    <div class="stat-value" id="memory">64KB</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">FILE SIZE</div>
                    <div class="stat-value" id="fileSize">0MB</div>
                </div>
            </div>
        </div>
        
        <!-- Visualization Panel -->
        <div class="visualization-panel">
            <div id="visual-canvas"></div>
            <div style="position: absolute; bottom: 5px; left: 10px; color: #0f0; font-size: 0.7em;">
                WIREFRAME VISUALIZER @ 60FPS
            </div>
        </div>
        
        <!-- System Log with Terminal Input -->
        <div class="log-panel" id="logPanel">
            <div class="log-entry">
                <span class="log-time">[00:00:00]</span>
                <span class="log-success">SYSTEM INITIALIZED</span>
            </div>
            <div class="log-entry">
                <span class="log-time">[00:00:01]</span>
                <span class="log-info">MAGNET DATASETS v1.0 READY</span>
            </div>
            <div class="log-entry">
                <span class="log-time">[00:00:02]</span>
                <span class="log-info">TYPE /help FOR COMMANDS</span>
            </div>
        </div>
    </div>
    
    <!-- Terminal Input -->
    <div class="terminal-input" style="position: fixed; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.9); padding: 5px 15px; border-top: 1px solid #0f0;">
        <span class="prompt">webXOS></span>
        <input type="text" id="commandInput" placeholder="Type /help for commands..." onkeypress="handleCommand(event)">
    </div>
    
    <!-- Export Modal -->
    <div class="overlay" id="exportOverlay" onclick="hideExportModal()"></div>
    <div class="export-modal" id="exportModal">
        <div class="export-header">EXPORT HUGGING FACE DATASET</div>
        
        <div style="margin: 10px 0;">
            <div style="color: #0f0; margin-bottom: 5px;">DATASET NAME:</div>
            <input type="text" id="datasetName" value="magnet_dataset" 
                   style="background: #000; color: #0f0; border: 1px solid #0f0; padding: 5px; width: 100%;">
        </div>
        
        <div style="margin: 10px 0;">
            <div style="color: #0f0; margin-bottom: 5px;">FORMAT:</div>
            <select id="exportFormat" style="background: #000; color: #0f0; border: 1px solid #0f0; padding: 5px; width: 100%;">
                <option value="jsonl">JSON Lines (.jsonl) - Recommended</option>
                <option value="parquet">Apache Parquet (.parquet)</option>
                <option value="csv">CSV (.csv)</option>
            </select>
        </div>
        
        <div class="file-structure" id="fileStructure">
            <div class="file-item">magnet_dataset.zip</div>
            <div class="file-item">README.md</div>
            <div class="file-item">data/</div>
            <div class="file-item" style="padding-left: 30px;">train-00001-of-00001.jsonl</div>
            <div class="file-item">dataset_infos.json</div>
        </div>
        
        <div style="margin: 10px 0; color: #080; font-size: 0.9em;">
            <div>üìÅ <strong>Hugging Face Compatible Structure:</strong></div>
            <div style="margin-top: 5px;">‚Ä¢ Uses correct sharded JSONL format</div>
            <div>‚Ä¢ Proper dataset_infos.json with correct splits</div>
            <div>‚Ä¢ Follows HF dataset library standards</div>
        </div>
        
        <button class="btn-export" onclick="exportDataset()">
            GENERATE .ZIP FOR HUGGING FACE
        </button>
    </div>
    
    <script>
        // Global State
        const systemState = {
            workers: {},
            datasets: {},
            isCollecting: false,
            startTime: Date.now(),
            totalSamples: 0,
            activeWorkers: 0
        };
        
        // Three.js Visualization
        let scene, camera, renderer;
        let animationId;
        
        function initVisualization() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(document.getElementById('visual-canvas').clientWidth, 
                           document.getElementById('visual-canvas').clientHeight);
            renderer.setClearColor(0x000000);
            document.getElementById('visual-canvas').appendChild(renderer.domElement);
            
            camera.position.z = 15;
            
            // Simple wireframe grid
            const gridSize = 20;
            const gridDivisions = 20;
            const gridGeometry = new THREE.PlaneGeometry(gridSize, gridSize, gridDivisions, gridDivisions);
            const gridMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x002200,
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });
            const grid = new THREE.Mesh(gridGeometry, gridMaterial);
            grid.rotation.x = -Math.PI / 2;
            scene.add(grid);
            
            // Simple points
            const pointsGeometry = new THREE.BufferGeometry();
            const pointsCount = 200;
            const positions = new Float32Array(pointsCount * 3);
            
            for (let i = 0; i < pointsCount * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 15;
            }
            
            pointsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const pointsMaterial = new THREE.PointsMaterial({
                color: 0x00ff00,
                size: 0.05,
                transparent: true,
                opacity: 0.5
            });
            
            const points = new THREE.Points(pointsGeometry, pointsMaterial);
            scene.add(points);
            
            // Start animation
            animateVisualization();
        }
        
        function animateVisualization() {
            animationId = requestAnimationFrame(animateVisualization);
            
            scene.children.forEach(child => {
                if (child.isPoints) {
                    child.rotation.y += 0.001;
                    child.rotation.x += 0.0005;
                }
            });
            
            renderer.render(scene, camera);
        }
        
        // Initialize Web Workers
        function initWorkers() {
            const workerTypes = [
                'dipole', 'solenoid', 'permanent', 'electro',
                'toroid', 'anisotropic', 'halbach', 'custom'
            ];
            
            workerTypes.forEach(type => {
                const workerCode = `
                    self.onmessage = function(e) {
                        const { command, params } = e.data;
                        
                        if (command === 'start') {
                            this.interval = setInterval(() => {
                                const data = generateData('${type}');
                                self.postMessage({ type: 'data', data });
                            }, 50);
                        }
                        
                        if (command === 'stop') {
                            clearInterval(this.interval);
                        }
                    };
                    
                    function generateData(type) {
                        const timestamp = Date.now();
                        const x = (Math.random() - 0.5) * 10;
                        const y = (Math.random() - 0.5) * 10;
                        const z = (Math.random() - 0.5) * 10;
                        
                        let field = [0, 0, 0];
                        let strength = 0;
                        
                        switch(type) {
                            case 'dipole':
                                field = [
                                    (Math.random() - 0.5) * 2,
                                    (Math.random() - 0.5) * 2,
                                    (Math.random() - 0.5) * 2
                                ];
                                strength = Math.sqrt(field[0]**2 + field[1]**2 + field[2]**2);
                                break;
                                
                            case 'solenoid':
                                field = [
                                    (Math.random() - 0.5) * 0.5,
                                    (Math.random() - 0.5) * 1.5,
                                    (Math.random() - 0.5) * 0.5
                                ];
                                strength = Math.abs(field[1]);
                                break;
                                
                            case 'permanent':
                                field = [
                                    (Math.random() - 0.5) * 3,
                                    (Math.random() - 0.5) * 3,
                                    (Math.random() - 0.5) * 3
                                ];
                                strength = Math.sqrt(field[0]**2 + field[1]**2 + field[2]**2);
                                break;
                                
                            case 'electro':
                                const current = 1 + Math.random();
                                field = [
                                    (Math.random() - 0.5) * current,
                                    (Math.random() - 0.5) * current,
                                    (Math.random() - 0.5) * current
                                ];
                                strength = current;
                                break;
                                
                            case 'toroid':
                                field = [
                                    (Math.random() - 0.5) * 0.3,
                                    (Math.random() - 0.5) * 0.8,
                                    (Math.random() - 0.5) * 0.3
                                ];
                                strength = Math.sqrt(field[0]**2 + field[1]**2 + field[2]**2);
                                break;
                                
                            case 'anisotropic':
                                field = [
                                    (Math.random() - 0.5) * 2.5,
                                    (Math.random() - 0.5) * 1.0,
                                    (Math.random() - 0.5) * 0.5
                                ];
                                strength = Math.abs(field[0]);
                                break;
                                
                            case 'halbach':
                                field = [
                                    (Math.random() - 0.5) * 4,
                                    (Math.random() - 0.5) * 4,
                                    (Math.random() - 0.5) * 4
                                ];
                                strength = Math.sqrt(field[0]**2 + field[1]**2 + field[2]**2) * 1.5;
                                break;
                                
                            case 'custom':
                                field = [
                                    Math.sin(x) * Math.cos(z),
                                    Math.cos(x) * Math.sin(z),
                                    Math.sin(y) * Math.cos(x)
                                ];
                                strength = Math.sqrt(field[0]**2 + field[1]**2 + field[2]**2);
                                break;
                        }
                        
                        return {
                            timestamp: timestamp,
                            type: type,
                            position: [x, y, z],
                            field: field,
                            strength: strength
                        };
                    }
                `;
                
                const blob = new Blob([workerCode], { type: 'application/javascript' });
                const worker = new Worker(URL.createObjectURL(blob));
                
                worker.onmessage = (e) => {
                    if (e.data.type === 'data' && systemState.isCollecting) {
                        handleWorkerData(type, e.data.data);
                    }
                };
                
                systemState.workers[type] = {
                    worker: worker,
                    active: false,
                    data: []
                };
            });
        }
        
        // Handle data from workers
        function handleWorkerData(type, data) {
            if (!systemState.datasets[type]) {
                systemState.datasets[type] = [];
            }
            
            systemState.datasets[type].push(data);
            systemState.totalSamples++;
            
            if (systemState.totalSamples % 100 === 0) {
                updateStats();
                logData(`${type}: ${systemState.datasets[type].length} samples`);
            }
        }
        
        // Toggle worker on/off
        function toggleWorker(type) {
            const worker = systemState.workers[type];
            const led = document.getElementById(`${type}Led`);
            
            if (worker.active) {
                worker.worker.postMessage({ command: 'stop' });
                worker.active = false;
                led.className = 'status-led';
                systemState.activeWorkers--;
                logInfo(`${type} stopped`);
            } else {
                worker.worker.postMessage({ command: 'start' });
                worker.active = true;
                led.className = 'status-led led-active';
                systemState.activeWorkers++;
                logInfo(`${type} started`);
            }
            
            document.getElementById('workerCount').textContent = `${systemState.activeWorkers}/8`;
            updateStats();
        }
        
        // Start data collection
        function startCollection() {
            systemState.isCollecting = true;
            systemState.startTime = Date.now();
            document.getElementById('sysStatus').textContent = 'COLLECTING';
            logSuccess('Collection started');
            
            Object.keys(systemState.workers).forEach(type => {
                if (systemState.workers[type].active) {
                    systemState.workers[type].worker.postMessage({ command: 'start' });
                }
            });
        }
        
        // Stop data collection
        function stopCollection() {
            systemState.isCollecting = false;
            document.getElementById('sysStatus').textContent = 'ONLINE';
            logWarning('Collection stopped');
            
            Object.keys(systemState.workers).forEach(type => {
                systemState.workers[type].worker.postMessage({ command: 'stop' });
            });
        }
        
        // Clear all data
        function clearData() {
            Object.keys(systemState.datasets).forEach(type => {
                systemState.datasets[type] = [];
            });
            systemState.totalSamples = 0;
            systemState.startTime = Date.now();
            updateStats();
            logInfo('Data cleared');
        }
        
        // Update statistics
        function updateStats() {
            document.getElementById('dataPoints').textContent = systemState.totalSamples.toLocaleString();
            document.getElementById('sampleCount').textContent = systemState.totalSamples.toLocaleString();
            
            const elapsed = (Date.now() - systemState.startTime) / 1000;
            const throughput = elapsed > 0 ? Math.round(systemState.totalSamples / elapsed) : 0;
            document.getElementById('throughput').textContent = `${throughput}/s`;
            
            const avgSampleSize = 128;
            const totalSize = systemState.totalSamples * avgSampleSize;
            const sizeMB = (totalSize / (1024 * 1024)).toFixed(2);
            document.getElementById('fileSize').textContent = `${sizeMB}MB`;
            document.getElementById('bufferSize').textContent = `${Math.round(totalSize / 1024)}KB`;
            
            const progress = Math.min((systemState.totalSamples / 50000) * 100, 100);
            document.getElementById('collectionProgress').style.width = `${progress}%`;
            
            const memory = 64 + Math.floor(totalSize / 1024);
            document.getElementById('memory').textContent = `${Math.min(memory, 1024)}KB`;
        }
        
        // Logging functions
        function logInfo(message) {
            addLog(message, 'info');
        }
        
        function logWarning(message) {
            addLog(message, 'warning');
        }
        
        function logError(message) {
            addLog(message, 'error');
        }
        
        function logSuccess(message) {
            addLog(message, 'success');
        }
        
        function logData(message) {
            if (Math.random() < 0.1) {
                addLog(message, 'info');
            }
        }
        
        function addLog(message, type) {
            const logPanel = document.getElementById('logPanel');
            const time = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<span class="log-time">[${time}]</span> <span class="log-${type}">${message}</span>`;
            
            logPanel.appendChild(entry);
            logPanel.scrollTop = logPanel.scrollHeight;
            
            const entries = logPanel.querySelectorAll('.log-entry');
            if (entries.length > 30) {
                entries[0].remove();
            }
        }
        
        // Export Modal Functions
        function showExportModal() {
            if (systemState.totalSamples === 0) {
                logError('No data to export');
                return;
            }
            
            document.getElementById('exportOverlay').style.display = 'block';
            document.getElementById('exportModal').style.display = 'block';
            updateFileStructure();
        }
        
        function hideExportModal() {
            document.getElementById('exportOverlay').style.display = 'none';
            document.getElementById('exportModal').style.display = 'none';
        }
        
        function updateFileStructure() {
            const structure = document.getElementById('fileStructure');
            const name = document.getElementById('datasetName').value || 'magnet_dataset';
            const format = document.getElementById('exportFormat').value;
            
            let html = `<div class="file-item">${name}.zip</div>`;
            html += `<div class="file-item">README.md</div>`;
            html += `<div class="file-item">data/</div>`;
            
            if (format === 'jsonl') {
                html += `<div class="file-item" style="padding-left: 30px;">train-00001-of-00001.jsonl</div>`;
            } else if (format === 'parquet') {
                html += `<div class="file-item" style="padding-left: 30px;">train-00001-of-00001.parquet</div>`;
            } else {
                html += `<div class="file-item" style="padding-left: 30px;">train.csv</div>`;
            }
            
            html += `<div class="file-item">dataset_infos.json</div>`;
            
            structure.innerHTML = html;
        }
        
        // Convert to JSON Lines format (one JSON object per line)
        function convertToJSONL(data) {
            return data.map(item => JSON.stringify(item)).join('\n');
        }
        
        // Convert to CSV format
        function convertToCSV(data) {
            if (data.length === 0) return '';
            
            const headers = ['timestamp', 'type', 'position_x', 'position_y', 'position_z', 'field_x', 'field_y', 'field_z', 'strength'];
            const rows = data.map(item => {
                return [
                    item.timestamp,
                    item.type,
                    item.position[0],
                    item.position[1],
                    item.position[2],
                    item.field[0],
                    item.field[1],
                    item.field[2],
                    item.strength
                ].join(',');
            });
            
            return [headers.join(','), ...rows].join('\n');
        }
        
        // Export dataset as .zip - FIXED Hugging Face Compatibility v4.0
        async function exportDataset() {
            logInfo('Generating Hugging Face compatible dataset...');
            
            const zip = new JSZip();
            const datasetName = document.getElementById('datasetName').value || 'magnet_dataset';
            const format = document.getElementById('exportFormat').value;
            
            // Create data directory
            const dataFolder = zip.folder("data");
            
            // Combine all data from all workers
            const allData = [];
            Object.keys(systemState.datasets).forEach(type => {
                if (systemState.datasets[type].length > 0) {
                    allData.push(...systemState.datasets[type]);
                }
            });
            
            // Shuffle data for better distribution
            const shuffledData = [...allData].sort(() => Math.random() - 0.5);
            
            // Create train split file based on format
            if (format === 'jsonl') {
                // JSON Lines format (recommended for HF)
                const jsonlContent = convertToJSONL(shuffledData);
                dataFolder.file("train-00001-of-00001.jsonl", jsonlContent);
            } else if (format === 'parquet') {
                // Parquet format would require a library, using JSONL for now
                const jsonlContent = convertToJSONL(shuffledData);
                dataFolder.file("train-00001-of-00001.jsonl", jsonlContent);
            } else {
                // CSV format
                const csvContent = convertToCSV(shuffledData);
                dataFolder.file("train.csv", csvContent);
            }
            
            // Create README.md with dataset card format
            const readme = `---
language: en
license: apache-2.0
task_categories:
- physics
- machine-learning
tags:
- physics
- magnetic-fields
- simulation
- science
---

# Dataset Card for ${datasetName.toUpperCase()}

## Dataset Description

- **Homepage:** https://github.com/webxos/magnet-datasets
- **Repository:** https://huggingface.co/datasets/webxos/${datasetName}
- **Paper:** N/A
- **Point of Contact:** webXOS Team

### Dataset Summary

Magnetic field simulation dataset generated by webXOS MAGNET DATASETS v4.0. This dataset contains simulated magnetic field measurements for various magnet configurations.

### Supported Tasks and Leaderboards

- Magnetic field prediction
- Physics simulation
- Scientific machine learning
- Sensor calibration

### Languages

English

## Dataset Structure

### Data Instances

Each instance contains:
- timestamp: Generation timestamp
- type: Magnet type (dipole, solenoid, etc.)
- position: [x, y, z] coordinates in meters
- field: [Bx, By, Bz] magnetic field vector in Tesla
- strength: Magnitude of magnetic field in Tesla

### Data Splits

The dataset has only a train split with ${shuffledData.length.toLocaleString()} examples.

## Dataset Creation

### Curation Rationale

This dataset was created to provide high-quality simulated magnetic field data for machine learning research in physics and engineering.

### Source Data

Synthetic data generated using physics-based simulations.

### Annotations

No annotations, only raw simulation data.

### Personal and Sensitive Information

None.

## Considerations for Using the Data

### Social Impact of Dataset

This dataset enables research in electromagnetic field prediction and physics-informed machine learning.

### Discussion of Biases

The data is synthetic and evenly distributed across magnet types.

### Other Known Limitations

Data is simulated and may not match real-world measurements exactly.

## Additional Information

### Dataset Curators

webXOS Team

### Licensing Information

Apache 2.0

### Citation Information

\`\`\`bibtex
@dataset{webxos_magnet_2026,
  title = {Magnetic Field Dataset},
  author = {webXOS},
  year = {2026},
  publisher = {Hugging Face},
  version = {4.0.0}
}
\`\`\`

### Contributions

Thanks to the webXOS team for creating this dataset.`;
            
            zip.file("README.md", readme);
            
            // Create CORRECT dataset_infos.json - FIXED FORMAT v4.0
            const datasetInfos = {
                [datasetName]: {
                    description: "Magnetic field simulation dataset",
                    citation: "@dataset{webxos_magnet_2026,\n  title = {Magnetic Field Dataset},\n  author = {webXOS},\n  year = {2026}\n}",
                    homepage: "https://huggingface.co/datasets/webxos/" + datasetName,
                    license: "apache-2.0",
                    features: {
                        timestamp: {
                            dtype: "int64",
                            id: null,
                            _type: "Value"
                        },
                        type: {
                            dtype: "string",
                            id: null,
                            _type: "Value"
                        },
                        position: {
                            feature: {
                                dtype: "float64",
                                id: null,
                                _type: "Value"
                            },
                            id: null,
                            _type: "Sequence"
                        },
                        field: {
                            feature: {
                                dtype: "float64",
                                id: null,
                                _type: "Value"
                            },
                            id: null,
                            _type: "Sequence"
                        },
                        strength: {
                            dtype: "float64",
                            id: null,
                            _type: "Value"
                        }
                    },
                    post_processed: null,
                    supervised_keys: null,
                    task_templates: [],
                    builder_name: "webxos_magnet",
                    config_name: datasetName,
                    version: {
                        version_str: "4.0.0",
                        major: 4,
                        minor: 0,
                        patch: 0
                    },
                    splits: {
                        train: {
                            name: "train",
                            num_bytes: shuffledData.length * 128,
                            num_examples: shuffledData.length,
                            dataset_name: datasetName
                        }
                    },
                    download_size: shuffledData.length * 128,
                    dataset_size: shuffledData.length * 128
                }
            };
            
            zip.file("dataset_infos.json", JSON.stringify(datasetInfos, null, 2));
            
            // Create a simple metadata file
            const metadata = {
                dataset_name: datasetName,
                version: "4.0.0",
                created_at: new Date().toISOString(),
                total_samples: shuffledData.length,
                magnet_types: Object.keys(systemState.datasets).filter(type => systemState.datasets[type].length > 0),
                data_format: format === 'jsonl' ? 'jsonl' : format,
                huggingface_compatible: true,
                fix_applied: "v4.0 - Fixed dataset_infos.json structure for HF compatibility"
            };
            
            zip.file("metadata.json", JSON.stringify(metadata, null, 2));
            
            // Generate and download zip
            const content = await zip.generateAsync({ type: "blob" });
            const blobUrl = URL.createObjectURL(content);
            const a = document.createElement('a');
            a.href = blobUrl;
            a.download = `${datasetName}_hf_v4_${Date.now()}.zip`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(blobUrl);
            
            const sizeMB = (content.size / (1024*1024)).toFixed(2);
            logSuccess(`‚úÖ Hugging Face dataset exported: ${datasetName}.zip (${sizeMB} MB)`);
            logInfo(`üìÅ Files: README.md, dataset_infos.json, data/train-*.jsonl`);
            logInfo(`‚úÖ Fixed HF compatibility issues - v4.0`);
            logInfo(`‚úÖ post_processed set to null`);
            logInfo(`‚úÖ supervised_keys set to null`);
            logInfo(`‚úÖ Removed length from Sequence features`);
            hideExportModal();
        }
        
        // Terminal Commands
        function handleCommand(event) {
            if (event.key === 'Enter') {
                const input = document.getElementById('commandInput');
                const command = input.value.trim().toLowerCase();
                input.value = '';
                
                if (!command) return;
                
                logInfo(`> ${command}`);
                
                const parts = command.split(' ');
                const cmd = parts[0];
                
                switch(cmd) {
                    case '/help':
                        showHelp();
                        break;
                    case '/start':
                        startCollection();
                        break;
                    case '/stop':
                        stopCollection();
                        break;
                    case '/clear':
                        clearData();
                        break;
                    case '/export':
                        showExportModal();
                        break;
                    case '/hfexport':
                        showExportModal();
                        break;
                    case '/workers':
                        if (parts[1] === 'list') {
                            listWorkers();
                        } else if (parts[1] === 'start') {
                            if (parts[2]) toggleWorker(parts[2]);
                        } else if (parts[1] === 'stop') {
                            if (parts[2]) {
                                const worker = systemState.workers[parts[2]];
                                if (worker && worker.active) {
                                    toggleWorker(parts[2]);
                                }
                            }
                        } else {
                            logInfo('Usage: /workers [list|start|stop] [type]');
                        }
                        break;
                    case '/status':
                        showStatus();
                        break;
                    case '/samples':
                        logInfo(`Total samples: ${systemState.totalSamples}`);
                        break;
                    case '/fixhf':
                        logInfo('Hugging Face export FIXED in v4.0');
                        logInfo('Fixed post_processed: null');
                        logInfo('Fixed supervised_keys: null');
                        logInfo('Fixed Sequence features (removed length)');
                        break;
                    default:
                        logError(`Unknown command: ${cmd}. Type /help for commands.`);
                }
            }
        }
        
        function showHelp() {
            logInfo('=== AVAILABLE COMMANDS ===');
            logInfo('/help - Show this help');
            logInfo('/start - Start data collection');
            logInfo('/stop - Stop data collection');
            logInfo('/clear - Clear all data');
            logInfo('/export - Export Hugging Face dataset (FIXED v4.0)');
            logInfo('/hfexport - Same as /export');
            logInfo('/workers list - List available workers');
            logInfo('/workers start [type] - Start worker type');
            logInfo('/workers stop [type] - Stop worker type');
            logInfo('/status - Show system status');
            logInfo('/samples - Show sample count');
            logInfo('/fixhf - Info about HF fixes');
        }
        
        function listWorkers() {
            logInfo('=== WORKER TYPES ===');
            const types = ['dipole', 'solenoid', 'permanent', 'electro', 'toroid', 'anisotropic', 'halbach', 'custom'];
            types.forEach(type => {
                const worker = systemState.workers[type];
                const status = worker && worker.active ? 'ACTIVE' : 'STANDBY';
                logInfo(`${type}: ${status}`);
            });
        }
        
        function showStatus() {
            logInfo('=== SYSTEM STATUS ===');
            logInfo(`Active workers: ${systemState.activeWorkers}/8`);
            logInfo(`Total samples: ${systemState.totalSamples}`);
            logInfo(`Collection: ${systemState.isCollecting ? 'RUNNING' : 'STOPPED'}`);
            
            const elapsed = (Date.now() - systemState.startTime) / 1000;
            const throughput = elapsed > 0 ? Math.round(systemState.totalSamples / elapsed) : 0;
            logInfo(`Throughput: ${throughput}/s`);
            
            const totalSize = systemState.totalSamples * 128;
            const sizeMB = (totalSize / (1024 * 1024)).toFixed(2);
            logInfo(`Estimated size: ${sizeMB} MB`);
            logInfo(`HF Export: FIXED v4.0 (dataset_infos.json corrected)`);
        }
        
        // Fullscreen toggle
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    logError(`Fullscreen error: ${err.message}`);
                });
            } else {
                document.exitFullscreen();
            }
        }
        
        // System clock
        function updateClock() {
            const now = new Date();
            const timeStr = now.toLocaleTimeString();
            document.getElementById('systemTime').textContent = timeStr;
        }
        
        // Initialize system
        function initSystem() {
            // Initialize visualization
            initVisualization();
            
            // Initialize workers
            initWorkers();
            
            // Start system clock
            setInterval(updateClock, 1000);
            updateClock();
            
            // Update stats every 2 seconds
            setInterval(updateStats, 2000);
            
            // Start with dipole worker
            setTimeout(() => {
                toggleWorker('dipole');
                toggleWorker('solenoid');
            }, 1000);
            
            logInfo("System initialized v4.0");
            logInfo("Type /help for commands");
            logInfo("‚úÖ Hugging Face export FIXED v4.0");
            logInfo("Fixed dataset_infos.json structure");
            logInfo("post_processed: null, supervised_keys: null");
        }
        
        // Window resize handler
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = document.getElementById('visual-canvas').clientWidth / 
                               document.getElementById('visual-canvas').clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(document.getElementById('visual-canvas').clientWidth,
                               document.getElementById('visual-canvas').clientHeight);
            }
        });
        
        // Start system when page loads
        window.addEventListener('load', initSystem);
        
        // Export modal event delegation
        document.getElementById('exportModal').addEventListener('click', (e) => {
            e.stopPropagation();
        });
        
        // Focus command input on click
        document.getElementById('commandInput').focus();
        
        // Make functions globally available
        window.toggleWorker = toggleWorker;
        window.startCollection = startCollection;
        window.stopCollection = stopCollection;
        window.clearData = clearData;
        window.showExportModal = showExportModal;
        window.hideExportModal = hideExportModal;
        window.exportDataset = exportDataset;
        window.toggleFullscreen = toggleFullscreen;
        window.handleCommand = handleCommand;
    </script>
</body>
</html>