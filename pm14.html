<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes" />
  <title>EDTVIDE v2 | webXOS 2025</title>
  <meta name="theme-color" content="#000000" />
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Press Start 2P', cursive; image-rendering: pixelated; }
    body { background: #000; color: #0f0; overflow: hidden; height: 100vh; user-select: none; -webkit-tap-highlight-color: transparent; }
    #appContainer { position: relative; width: 100%; height: 100vh; overflow: hidden; }

    .matrix-grid {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: linear-gradient(rgba(0,255,0,0.1) 1px, transparent 1px),
                  linear-gradient(90deg, rgba(0,255,0,0.1) 1px, transparent 1px);
      background-size: 16px 16px; opacity: 0.3;
    }
    .crt-overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: linear-gradient(to bottom, transparent 50%, rgba(0,20,0,0.1) 50%);
      background-size: 100% 4px; z-index: 5; pointer-events: none;
      animation: scanline 8s linear infinite;
    }
    @keyframes scanline { 0% { background-position: 0 0; } 100% { background-position: 0 100%; } }

    #visualizationContainer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; }
    #sceneClickArea { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 3; cursor: grab; }
    #sceneClickArea:active { cursor: grabbing; }

    /* Top Banner */
    .top-banner {
      position: absolute; top: 0; left: 0; width: 100%; height: 40px;
      background: rgba(255, 0, 255, 0.9); border-bottom: 2px solid #f0f;
      display: flex; align-items: center; justify-content: center; z-index: 12;
      animation: glitch 3s infinite;
    }
    @keyframes glitch {
      0%,100%{transform:translateX(0)} 5%{transform:translateX(-2px)} 10%{transform:translateX(2px)}
      15%{transform:translateX(-1px)} 20%{transform:translateX(1px)} 25%,50%{transform:translateX(0)}
      55%{transform:translateX(-1px) skewX(-2deg)} 60%{transform:translateX(1px) skewX(2deg)}
      65%{transform:translateX(-1px) skewX(-1deg)} 70%{transform:translateX(1px) skewX(1deg)} 75%{transform:translateX(0)}
    }
    .top-banner-text { font-size: 11px; color: #000; text-shadow: 1px 1px 0 #fff; letter-spacing: 1px; }

    /* Corner Buttons - Mobile First */
    .corner-btn {
      position: absolute; width: 80px; height: 60px; font-size: 9px;
      background: #000; border: 3px solid; color: inherit; cursor: pointer;
      display: flex; align-items: center; justify-content: center; text-align: center;
      box-shadow: 3px 3px 0 #000; transform: skew(-2deg); transition: all 0.15s; touch-action: none;
      z-index: 11;
    }
    .corner-btn:hover, .corner-btn:active { background: inherit; color: #000; }

    #liveBtn     { top: 50px; left: 10px; border-color: #0ff; color: #0ff; }
    #liveBtn.active { background: #0ff; color: #000; }
    #exportBtn   { top: 50px; right: 10px; border-color: #ff0; color: #ff0; }
    #zoomInBtn   { bottom: 20px; left: 10px; border-color: #0f0; color: #0f0; }
    #zoomOutBtn  { bottom: 20px; right: 10px; border-color: #f00; color: #f00; }
    #resetBtn    { bottom: 90px; left: 50%; transform: translateX(-50%) skew(-2deg); border-color: #ff0; color: #ff0; width: 100px; }

    /* PIP Face View */
    .ppv-face-view {
      position: absolute; top: 50px; right: 10px; width: 120px; height: 90px;
      background: #000; border: 2px solid #0ff; z-index: 15; overflow: hidden; cursor: pointer;
      transition: all 0.3s ease;
    }
    .ppv-face-view.expanded { width: 280px; height: 210px; z-index: 20; top: 50%; left: 50%; transform: translate(-50%, -50%); }
    .ppv-canvas { width: 100%; height: 100%; }

    /* Status & Timer */
    .neurots-status { position: absolute; top: 100px; left: 10px; font-size: 8px; color: #0ff; z-index: 11; background: rgba(0,0,0,0.7); padding: 5px; border: 1px solid #0ff; }
    .timer-panel { position: absolute; top: 135px; left: 10px; font-size: 9px; color: #ff0; z-index: 11; background: rgba(0,0,0,0.7); padding: 6px; border: 1px solid #ff0; }

    /* JSON Panel */
    .json-panel {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.95); border: 3px solid #0ff; padding: 15px; z-index: 30;
      width: 90%; max-width: 500px; display: none; border-radius: 4px;
    }
    .json-title { font-size: 11px; color: #0ff; margin-bottom: 10px; text-align: center; }
    .json-content { width: 100%; height: 200px; background: #000; border: 2px solid #0f0; color: #0f0; font-size: 7px; padding: 8px; margin-bottom: 10px; overflow: auto; font-family: monospace; white-space: pre-wrap; }
    .json-btn { width: 110px; height: 36px; background: #000; border: 2px solid #0f0; color: #0f0; font-size: 9px; cursor: pointer; margin: 0 auto; display: flex; align-items: center; justify-content: center; }
    .json-btn:hover, .json-btn:active { background: #0f0; color: #000; }

    /* Mobile Adjustments */
    @media (max-width: 767px) {
      .corner-btn { width: 70px; height: 55px; font-size: 8px; }
      #resetBtn { bottom: 80px; width: 90px; }
      .ppv-face-view { width: 100px; height: 75px; }
      .ppv-face-view.expanded { width: 260px; height: 195px; }
      .top-banner-text { font-size: 10px; }
    }
  </style>
</head>
<body>
<div id="appContainer">
  <div class="matrix-grid"></div>
  <div class="crt-overlay"></div>

  <!-- Top Banner -->
  <div class="top-banner">
    <div class="top-banner-text">EDTVIDE v2 | DIGITAL TWIN</div>
  </div>

  <!-- Corner Buttons -->
  <button id="liveBtn" class="corner-btn">LIVE</button>
  <button id="exportBtn" class="corner-btn">EXPORT</button>
  <button id="zoomInBtn" class="corner-btn">ZOOM IN</button>
  <button id="zoomOutBtn" class="corner-btn">ZOOM OUT</button>
  <button id="resetBtn" class="corner-btn">RESET</button>

  <!-- PIP Face View -->
  <div class="ppv-face-view" id="ppvFaceView">
    <canvas class="ppv-canvas" id="ppvCanvas"></canvas>
  </div>

  <!-- Status & Timer -->
  <div class="neurots-status" id="neurotsStatus">EDTVIDE: READY</div>
  <div class="timer-panel" id="timerPanel">
    TRAINING: <span id="timerDisplay">400</span>s<br>
    ENTITIES: <span id="entityCount">0</span>/400
  </div>

  <!-- JSON Export Panel -->
  <div class="json-panel" id="jsonPanel">
    <div class="json-title">DIGITAL TWIN DATA</div>
    <div class="json-content" id="jsonContent"></div>
    <button class="json-btn" id="copyJsonBtn">COPY JSON</button>
  </div>

  <!-- 3D Scene -->
  <div id="visualizationContainer">
    <canvas id="visualizationCanvas"></canvas>
    <div id="sceneClickArea"></div>
  </div>
</div>

<script>
  // === EMBEDDED SERVICE WORKER ===
  const swCode = `
    let twinModel = { entities: [], version: 0 };

    self.addEventListener('message', async (e) => {
      if (!e.data) return;

      if (e.data.type === 'RETRAIN') {
        twinModel.entities.push(e.data.entity);
        twinModel.version++;
        console.log('[SW] Retrained on', e.data.entity.type, '| Total:', twinModel.entities.length);
        // Simulate ML update
        await new Promise(r => setTimeout(r, 50));
        self.clients.matchAll().then(clients => {
          clients.forEach(c => c.postMessage({ type: 'MODEL_UPDATED', count: twinModel.entities.length }));
        });
      }

      if (e.data.type === 'TRAIN_COMPLETE') {
        console.log('[SW] Digital Twin Training Complete:', e.data.data.entities.length, 'entities');
        twinModel = { ...twinModel, final: e.data.data, trainedAt: new Date().toISOString() };
      }
    });

    self.addEventListener('install', () => self.skipWaiting());
    self.addEventListener('activate', () => self.clients.claim());
  `;

  // Register inline SW
  if ('serviceWorker' in navigator) {
    const blob = new Blob([swCode], { type: 'application/javascript' });
    const swUrl = URL.createObjectURL(blob);
    navigator.serviceWorker.register(swUrl).then(reg => {
      console.log('Embedded SW registered');
    }).catch(err => console.log('SW registration failed:', err));
  }

  // === CORE VARIABLES ===
  let scene, cam, ren, clock;
  let userObj, compassArrow;
  let faceDirection = 0, userDetected = false;
  let stream, faceMesh, camera;
  let isProcessing = false;
  let processingTimer = 400;
  let timerInterval = null;
  let animationId = null;
  let cameraDistance = 6;
  let cameraAngleX = 0, cameraAngleY = 0;
  let isDragging = false;
  let lastMouseX = 0, lastMouseY = 0;
  let lastTouchX = 0, lastTouchY = 0;

  // Digital Twin DB
  let db;
  const DB_NAME = 'EDTVIDE_TwinDB';
  const STORE_NAME = 'entities';
  let entityCache = [];
  const MAX_ENTITIES = 400;

  // Scene Data
  let sceneData = { user: {x:0,y:0,z:0,faceYaw:0}, entities: [], timestamp: null };

  // DOM
  const $ = s => document.querySelector(s);

  // === INIT ===
  function init() {
    initDB();
    init3D();
    setupFaceDetection();
    setupEventListeners();
    animate();

    // Listen for SW model updates
    navigator.serviceWorker.addEventListener('message', e => {
      if (e.data.type === 'MODEL_UPDATED') {
        $('#entityCount').textContent = e.data.count;
      }
    });
  }

  // === INDEXEDDB ===
  function initDB() {
    const request = indexedDB.open(DB_NAME, 1);
    request.onupgradeneeded = e => {
      db = e.target.result;
      db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true })
        .createIndex('type', 'type');
    };
    request.onsuccess = e => { 
      db = e.target.result; 
      loadCachedEntities(); 
    };
    request.onerror = () => console.error("IndexedDB error");
  }

  function loadCachedEntities() {
    const tx = db.transaction(STORE_NAME, 'readonly');
    const store = tx.objectStore(STORE_NAME);
    const req = store.getAll();
    req.onsuccess = () => {
      entityCache = req.result;
      entityCache.forEach(addEntityToScene);
      $('#entityCount').textContent = entityCache.length;
    };
  }

  function addEntityToDB(entity) {
    if (entityCache.length >= MAX_ENTITIES) return;
    const tx = db.transaction(STORE_NAME, 'readwrite');
    tx.objectStore(STORE_NAME).add(entity);
    tx.oncomplete = () => {
      entityCache.push(entity);
      addEntityToScene(entity);
      notifySW({ type: 'RETRAIN', entity });
    };
  }

  // === NOTIFY SW ===
  function notifySW(message) {
    if (navigator.serviceWorker.controller) {
      navigator.serviceWorker.controller.postMessage(message);
    }
  }

  // === 3D SCENE ===
  function init3D() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    updateCameraPosition();

    const canvas = $('#visualizationCanvas');
    ren = new THREE.WebGLRenderer({ canvas, antialias: false, powerPreference: "high-performance" });
    ren.setSize(window.innerWidth, window.innerHeight);
    ren.setPixelRatio(1);

    clock = new THREE.Clock();

    scene.add(new THREE.AmbientLight(0x003300));
    const dir = new THREE.DirectionalLight(0x00ff00, 0.3);
    dir.position.set(5, 10, 5);
    scene.add(dir);

    const grid = new THREE.GridHelper(20, 20, 0x004400, 0x002200);
    scene.add(grid);

    userObj = createUserMesh();
    userObj.position.set(0, 0, 0);
    scene.add(userObj);

    compassArrow = createCompassArrow();
    compassArrow.position.set(0, 0.3, 0);
    scene.add(compassArrow);

    cam.lookAt(0, 0, 0);
  }

  function createUserMesh() {
    const group = new THREE.Group();
    const head = new THREE.Mesh(
      new THREE.SphereGeometry(0.2, 8, 6),
      new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true })
    );
    head.position.y = 0.2;
    group.add(head);
    return group;
  }

  function createCompassArrow() {
    const group = new THREE.Group();
    const body = new THREE.Mesh(
      new THREE.CylinderGeometry(0.02, 0.02, 0.4, 8),
      new THREE.MeshBasicMaterial({ color: 0xff0000 })
    );
    body.position.y = 0.2;
    group.add(body);
    const head = new THREE.Mesh(
      new THREE.ConeGeometry(0.05, 0.1, 8),
      new THREE.MeshBasicMaterial({ color: 0xff0000 })
    );
    head.position.y = 0.45;
    group.add(head);
    return group;
  }

  function updateCameraPosition() {
    const x = cameraDistance * Math.sin(cameraAngleY) * Math.cos(cameraAngleX);
    const y = cameraDistance * Math.sin(cameraAngleX) + 2;
    const z = cameraDistance * Math.cos(cameraAngleY) * Math.cos(cameraAngleX);
    cam.position.set(x, y, z);
    cam.lookAt(0, 0, 0);
  }

  // === ENTITY CREATION ===
  function addEntityToScene(entity) {
    const size = entity.size || 0.15;
    const geom = new THREE.SphereGeometry(size, 6, 6);
    const mat = new THREE.MeshBasicMaterial({
      color: entity.type === 'wall' ? 0x00ff00 : 0xff0000,
      wireframe: entity.type === 'wall'
    });
    const mesh = new THREE.Mesh(geom, mat);
    mesh.position.set(entity.x, entity.y, entity.z);
    mesh.userData = { id: entity.id, type: entity.type };
    scene.add(mesh);
    sceneData.entities.push({ ...entity, mesh });
  }

  function sampleLargeObject(landmarks) {
    if (entityCache.length >= MAX_ENTITIES) return;

    const nose = landmarks[1];
    const faceCenter = { x: nose.x, y: nose.y, z: nose.z };

    const yawRad = -faceDirection * Math.PI / 180;
    const distance = 2.0 + Math.random() * 3.0;
    const worldX = Math.sin(yawRad) * distance;
    const worldZ = Math.cos(yawRad) * distance;
    const worldY = (0.5 - faceCenter.y) * 4;

    const isWall = Math.abs(faceCenter.z) > 0.1 || worldY > 1.5 || Math.random() > 0.6;

    const entity = {
      x: worldX, y: worldY, z: worldZ,
      type: isWall ? 'wall' : 'furniture',
      size: isWall ? 0.3 : 0.2,
      confidence: 0.7 + Math.random() * 0.3,
      timestamp: Date.now()
    };

    addEntityToDB(entity);
  }

  // === FACE MESH ===
  function setupFaceDetection() {
    faceMesh = new FaceMesh({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
    });
    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });
    faceMesh.onResults(onFaceMeshResults);
  }

  function onFaceMeshResults(results) {
    userDetected = results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0;

    const ppvCanvas = $('#ppvCanvas');
    const ctx = ppvCanvas.getContext('2d');
    ctx.clearRect(0, 0, ppvCanvas.width, ppvCanvas.height);

    if (results.image) {
      ctx.drawImage(results.image, 0, 0, ppvCanvas.width, ppvCanvas.height);
    }

    if (userDetected && isProcessing) {
      const landmarks = results.multiFaceLandmarks[0];
      drawConnectors(ctx, landmarks, FACEMESH_FACE_OVAL, { color: '#00ff00', lineWidth: 2 });

      const left = landmarks[234], right = landmarks[454];
      const yaw = Math.atan2(right.x - left.x, right.z - left.z) * 180 / Math.PI;
      faceDirection = yaw;

      compassArrow.rotation.y = -yaw * Math.PI / 180;
      userObj.rotation.y = -yaw * Math.PI / 180;

      sceneData.user.faceYaw = yaw;

      if (processingTimer % 2 === 0) {
        sampleLargeObject(landmarks);
      }

      $('#neurotsStatus').textContent = `TRAINING: ${entityCache.length}/400`;
    } else {
      $('#neurotsStatus').textContent = userDetected ? 'TRACKING FACE' : 'NO FACE';
    }
  }

  // === WEBCAM ===
  function startWebcam() {
    if (stream) return;
    navigator.mediaDevices.getUserMedia({
      video: { facingMode: 'environment', width: { ideal: 640 }, height: { ideal: 480 } }
    }).then(s => {
      stream = s;
      const video = document.createElement('video');
      video.srcObject = stream;
      video.autoplay = true;
      video.playsInline = true;
      video.style.display = 'none';
      document.body.appendChild(video);

      camera = new Camera(video, {
        onFrame: async () => await faceMesh.send({ image: video }),
        width: 640, height: 480
      });
      camera.start();

      const ppv = $('#ppvCanvas');
      ppv.width = $('#ppvFaceView').clientWidth;
      ppv.height = $('#ppvFaceView').clientHeight;

      startProcessing();
    }).catch(err => {
      $('#neurotsStatus').textContent = 'CAMERA DENIED';
      console.error(err);
    });
  }

  function startProcessing() {
    isProcessing = true;
    processingTimer = 400;
    $('#liveBtn').classList.add('active');
    $('#liveBtn').textContent = 'LIVE';
    $('#timerDisplay').textContent = '400';

    timerInterval = setInterval(() => {
      processingTimer--;
      $('#timerDisplay').textContent = processingTimer;
      if (processingTimer <= 0) finishProcessing();
    }, 1000);
  }

  function finishProcessing() {
    isProcessing = false;
    clearInterval(timerInterval);
    $('#liveBtn').classList.remove('active');
    $('#liveBtn').textContent = 'LIVE';
    $('#neurotsStatus').textContent = 'TWIN READY';
    sceneData.timestamp = new Date().toISOString();
    notifySW({ type: 'TRAIN_COMPLETE', data: sceneData });
  }

  function exportScene() {
    sceneData.entities = entityCache;
    const json = JSON.stringify(sceneData, null, 2);
    $('#jsonContent').textContent = json;
    $('#jsonPanel').style.display = 'block';
  }

  function copyJSON() {
    navigator.clipboard.writeText($('#jsonContent').textContent).then(() => {
      alert('Digital Twin JSON copied!');
    });
  }

  // === EVENT LISTENERS ===
  function setupEventListeners() {
    $('#liveBtn').addEventListener('click', () => !isProcessing && startWebcam());
    $('#exportBtn').addEventListener('click', exportScene);
    $('#copyJsonBtn').addEventListener('click', copyJSON);
    $('#zoomInBtn').addEventListener('click', () => { cameraDistance = Math.max(1.5, cameraDistance * 0.8); updateCameraPosition(); });
    $('#zoomOutBtn').addEventListener('click', () => { cameraDistance = Math.min(15, cameraDistance * 1.2); updateCameraPosition(); });
    $('#resetBtn').addEventListener('click', () => { cameraDistance = 6; cameraAngleX = cameraAngleY = 0; updateCameraPosition(); });

    $('#ppvFaceView').addEventListener('click', () => {
      $('#ppvFaceView').classList.toggle('expanded');
      const c = $('#ppvCanvas');
      c.width = $('#ppvFaceView').clientWidth;
      c.height = $('#ppvFaceView').clientHeight;
    });

    const area = $('#sceneClickArea');
    area.addEventListener('mousedown', e => { isDragging = true; lastMouseX = e.clientX; lastMouseY = e.clientY; });
    document.addEventListener('mousemove', e => {
      if (!isDragging) return;
      cameraAngleY += (e.clientX - lastMouseX) * 0.01;
      cameraAngleX = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraAngleX - (e.clientY - lastMouseY) * 0.01));
      lastMouseX = e.clientX; lastMouseY = e.clientY;
      updateCameraPosition();
    });
    document.addEventListener('mouseup', () => isDragging = false);

    area.addEventListener('touchstart', e => { if (e.touches.length === 1) { isDragging = true; lastTouchX = e.touches[0].clientX; lastTouchY = e.touches[0].clientY; e.preventDefault(); } });
    area.addEventListener('touchmove', e => {
      if (isDragging && e.touches.length === 1) {
        cameraAngleY += (e.touches[0].clientX - lastTouchX) * 0.01;
        cameraAngleX = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraAngleX - (e.touches[0].clientY - lastTouchY) * 0.01));
        lastTouchX = e.touches[0].clientX; lastTouchY = e.touches[0].clientY;
        updateCameraPosition();
        e.preventDefault();
      }
    });
    area.addEventListener('touchend', () => isDragging = false);

    window.addEventListener('resize', () => {
      cam.aspect = window.innerWidth / window.innerHeight;
      cam.updateProjectionMatrix();
      ren.setSize(window.innerWidth, window.innerHeight);
      const c = $('#ppvCanvas');
      c.width = $('#ppvFaceView').clientWidth;
      c.height = $('#ppvFaceView').clientHeight;
    });
  }

  function animate() {
    animationId = requestAnimationFrame(animate);
    ren.render(scene, cam);
  }

  window.addEventListener('load', init);
</script>
</body>
</html>
