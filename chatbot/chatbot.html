<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <meta name="description" content="WebXOS Searchbot 2025: Search and decode innovative web apps, AI tools, games, and utilities across the WebXOS platform with multi-agent support.">
    <meta name="keywords" content="webXOS, searchbot, web applications 2025, AI tools, web games, online utilities, digital solutions, webXOS AI, webXOS search, AI agents, browser-based tools, innovative web apps, digital experience, web development, AI-powered search, online games, modular web tools, sustainable web solutions, carbon footprint tools, webXOS research, exoskeleton AI technology, green energy, web design, front end, sustainable software, AI, machine learning, eco-friendly tech, web interfaces, user experience, UX design, web technology, AI-driven search, browser-based applications, digital innovation, web utilities, sustainable design, green technology, front-end development, AI applications, web accessibility, interactive web, modern web design, eco-conscious software, AI research, digital transformation, web performance, sustainable digital tools, low-carbon tech, web app development, AI-enhanced tools, online platforms, futuristic web solutions, green computing">
    <meta name="robots" content="index, follow">
    <meta name="author" content="webXOS">
    <meta property="og:title" content="WebXOS Searchbot 2025 - Search & Decode Web Apps">
    <meta property="og:description" content="Explore WebXOS Searchbot 2025 with multi-agent search and decoding for web applications, AI tools, games, and utilities.">
    <meta property="og:url" content="https://webxos.netlify.app/chatbot/chatbot.html">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="webXOS">
    <meta property="og:locale" content="en_US">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@webxos">
    <meta name="twitter:creator" content="@webxos">
    <meta name="twitter:title" content="WebXOS Searchbot 2025 - Search & Decode Web Apps">
    <meta name="twitter:description" content="Discover WebXOS Searchbot 2025 for multi-agent searching and decoding of innovative web applications and games.">
    <link rel="canonical" href="https://webxos.netlify.app/chatbot/chatbot.html">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Orbitron:wght@400;700&family=VT323&display=swap">
    <link rel="stylesheet" href="/chatbot/static/style.css">
    <link rel="manifest" href="/manifest.json">
    <link rel="icon" href="/chatbot/static/icon.png">
    <title>WebXOS Searchbot 2025</title>
</head>
<body>
    <canvas id="neuralCanvas" style="pointer-events: none;"></canvas>
    <div class="container">
        <h1 class="title">WebXOS Searchbot</h1>
        <div id="chatbox">
            <div id="messages"></div>
            <div id="status"></div>
            <div class="input-group">
                <input type="text" id="userInput" placeholder="Search WebXOS, /decode, or /agent1-4...">
                <button id="searchButton">Go</button>
            </div>
            <div id="pagination" class="pagination-group"></div>
            <div id="loading" class="loading-spinner"></div>
        </div>
    </div>
    <div id="certificateModal" class="certificate-modal">
        <div class="certificate-container">
            <div class="certificate" id="certificate">
                <h2 class="certificate-title" id="certificateTitle"></h2>
                <div id="certificateContent"></div>
            </div>
        </div>
    </div>
    <div class="copyright">Copyright webXOS 2025</div>
    <script src="/chatbot/static/fuse.min.js"></script>
    <script src="/chatbot/static/neurots.js"></script>
    <script src="/chatbot/static/agent1.js"></script>
    <script src="/chatbot/static/agent2.js"></script>
    <script src="/chatbot/static/agent3.js"></script>
    <script src="/chatbot/static/agent4.js"></script>
    <script>
        const CACHE_NAME = 'webxos-searchbot-v13';
        let cachedContent = {};
        const BOT_VERSION = '1.1.3';
        const RESULTS_PER_PAGE = 5;
        let currentPage = 0;
        let currentResults = [];
        let activeAgents = [];

        // Initialize cache and neurots
        window.addEventListener('load', async () => {
            const messages = document.getElementById('messages');
            try {
                const cache = await caches.open(CACHE_NAME);
                let indexErrors = [];
                try {
                    const response = await fetch('/site_index.json', { cache: 'no-cache' });
                    if (!response.ok) throw new Error(`HTTP ${response.status} ${response.statusText}. Ensure site_index.json is in root.`);
                    const siteIndex = await response.json();
                    if (!siteIndex || !Array.isArray(siteIndex) || siteIndex.length === 0) {
                        throw new Error('site_index.json is empty or invalid.');
                    }
                    await cache.put('/site_index.json', new Response(JSON.stringify(siteIndex)));
                    cachedContent['site_index'] = siteIndex;
                    siteIndex.forEach(item => {
                        if (!item.path || !item.source || !item.text || !item.text.keywords || !Array.isArray(item.text.keywords) || item.text.keywords.length === 0) {
                            indexErrors.push(`Invalid content for ${item.path}`);
                        }
                    });
                } catch (error) {
                    const cachedIndex = await cache.match('/site_index.json');
                    if (cachedIndex) {
                        cachedContent['site_index'] = await cachedIndex.json();
                        indexErrors.push(`Used cached site_index.json due to: ${error.message}`);
                    } else {
                        indexErrors.push(`Failed to fetch site_index.json: ${error.message}`);
                    }
                }
                if (indexErrors.length > 0) {
                    messages.innerHTML += `<p><b>Index Errors:</b> ${indexErrors.join('; ')}</p>`;
                    updateStatus('Warning: Issues during index initialization.', false, indexErrors.join('; '));
                } else {
                    updateStatus(`Success: Indexed ${cachedContent['site_index'].length} files.`);
                }
            } catch (error) {
                messages.innerHTML += `<p><b>Index Error:</b> ${error.message}</p>`;
                updateStatus('Error: Failed to initialize index.', true, error.stack || error.message);
            }
            try {
                initNeurots();
            } catch (error) {
                console.error('Neurots initialization failed:', error);
                messages.innerHTML += `<p><b>Error:</b> Failed to initialize neural dots. ${error.message}</p>`;
                updateStatus('Error: Neural dots failed to initialize.', true, error.stack || error.message);
            }
            document.getElementById('userInput').addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    searchQuery();
                }
            });
            document.getElementById('searchButton').addEventListener('click', searchQuery);
        });

        function updateStatus(message, isError = false, details = '') {
            const status = document.getElementById('status');
            const timestamp = new Date().toLocaleTimeString();
            status.innerHTML = `<span class="${isError ? 'error' : 'success'}">${message}${isError || details ? `<br><small>Details: ${details} [${timestamp}]</small>` : ''}</span>`;
            status.style.display = 'block';
            setTimeout(() => status.style.display = 'none', 7000);
        }

        // Decoding functions
        function hexToString(hex) {
            let str = '';
            for (let i = 0; i < hex.length; i += 2) {
                str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
            }
            return str;
        }

        function decodeWebXOS(code) {
            if (!code || typeof code !== 'string' || !code.startsWith('WEBXOS-')) {
                return { success: false, message: "ERROR: Invalid WebXOS code format. Must start with 'WEBXOS-'", decoded: null };
            }
            const parts = code.split('-');
            if (parts.length !== 6) {
                return { success: false, message: `ERROR: Invalid code structure. Expected 6 parts, got ${parts.length}`, decoded: null };
            }
            const [prefix, timestamp, encodedMessage, random1, random2, checksum] = parts;
            try {
                const decoded = hexToString(encodedMessage);
                const expectedChecksum = (decoded.length * 17).toString(36).toUpperCase().padStart(4, '0');
                if (checksum !== expectedChecksum) {
                    return { success: false, message: `ERROR: Checksum mismatch. Expected ${expectedChecksum}, got ${checksum}`, decoded: null };
                }
                return { success: true, message: `DECODED MESSAGE: ${decoded}`, decoded: decoded, timestamp: parseInt(timestamp, 36) };
            } catch (e) {
                return { success: false, message: `ERROR: Decoding failed. ${e.message}`, decoded: null };
            }
        }

        function parseGameData(decoded) {
            const data = {};
            const pairs = decoded.split(';');
            pairs.forEach(pair => {
                const [key, value] = pair.split(':');
                if (key && value) data[key.trim()] = value.trim();
            });
            if (Object.keys(data).length === 0 && !isNaN(parseFloat(decoded))) {
                data.Time = decoded;
                data.WPM = 'N/A';
                data.Lang = 'Unknown';
            }
            return data;
        }

        function wrapScrambleChars(text, isScore = false, isEmoji = false) {
            if (isEmoji) return `<span class="emoji-reward">${text}</span>`;
            return text.split('').map((char, index) => `<span class="scramble-char" style="${isScore ? 'font-size: 22px; text-shadow: 0 0 8px #00ff00;' : ''}">${char}</span>`).join('');
        }

        function displayWithScramble(element, text, isScore = false, isEmoji = false) {
            if (isEmoji) {
                element.innerHTML = `<span class="emoji-reward">${text}</span>`;
                return;
            }
            element.innerHTML = wrapScrambleChars(text, isScore, isEmoji);
            const spans = element.querySelectorAll('.scramble-char');
            const chars = text.split('');
            spans.forEach((span, index) => {
                span.textContent = getRandomDigit();
                span.classList.add('dissolving');
                span.style.setProperty('--rand-x', Math.random());
                span.style.setProperty('--rand-y', Math.random());
            });
            let rebuildIndex = 0;
            const rebuildInterval = setInterval(() => {
                if (rebuildIndex >= spans.length) {
                    clearInterval(rebuildInterval);
                    return;
                }
                const span = spans[rebuildIndex];
                span.textContent = chars[rebuildIndex] || ' ';
                span.classList.remove('dissolving');
                span.classList.add('rebuilding');
                span.style.setProperty('--rand-x', Math.random());
                span.style.setProperty('--rand-y', Math.random());
                setTimeout(() => span.classList.remove('rebuilding'), 1400);
                rebuildIndex++;
            }, 25);
        }

        function getRandomDigit() {
            return String.fromCharCode(48 + Math.floor(Math.random() * 10));
        }

        function showCertificate(data, result) {
            const game = data.Game || 'Code Crunch';
            const certificateTitle = document.getElementById('certificateTitle');
            const certificateContent = document.getElementById('certificateContent');
            const certificate = document.getElementById('certificate');
            const certificateModal = document.getElementById('certificateModal');
            const certificateContainer = document.querySelector('.certificate-container');
            certificate.classList.remove('spinning');

            displayWithScramble(certificateTitle, game === 'Code Crunch' ? 'Code Crunch Certificate' : game);

            if (game === 'WebX Universe') {
                const content = `
                    <p>Name: ${data.Name}</p>
                    <p>Level: ${data.Level}</p>
                    <p>XP: ${data.XP || '0'}</p>
                    <p>Resources: ${data.Resources}</p>`;
                certificateContent.innerHTML = content;
                certificateContent.querySelectorAll('p').forEach(p => displayWithScramble(p, p.textContent));
            } else if (game === 'Arachnid') {
                const content = `
                    <p class="score-display">Score: ${data.Score}</p>
                    <p>Time: ${data.TimeElapsed}</p>
                    <p><a href="https://arachnid-leaderboard.com">Leaderboard - Coming Soon</a></p>`;
                certificateContent.innerHTML = content;
                displayWithScramble(certificateContent.querySelector('.score-display'), `Score: ${data.Score}`, true);
                displayWithScramble(certificateContent.querySelector('p:not(.score-display):nth-child(2)'), `Time: ${data.TimeElapsed}`);
                displayWithScramble(certificateContent.querySelector('p:last-child'), certificateContent.querySelector('p:last-child').textContent);
            } else if (game === 'Emoji Quest') {
                const emojis = ['üèÜ', 'üéñÔ∏è', '‚ú®', 'ü™ê', '‚ö°'];
                const rewardEmoji = emojis[Math.floor(Math.random() * emojis.length)];
                const content = `
                    <p class="emoji-reward">${rewardEmoji}</p>
                    <p>Level: ${data.Level}</p>
                    <p>Gold: ${data.Gold}</p>
                    <p>Total XP: ${data.TotalXP}</p>
                    <p>Time: ${data.TimeElapsed}</p>`;
                certificateContent.innerHTML = content;
                displayWithScramble(certificateContent.querySelector('.emoji-reward'), rewardEmoji, false, true);
                certificateContent.querySelectorAll('p:not(.emoji-reward)').forEach(p => displayWithScramble(p, p.textContent));
            } else {
                const wpm = data.WPM || 'N/A';
                const lang = data.Lang || 'Unknown';
                const time = data.Time || result.decoded;
                const content = `
                    <p>Average WPM: ${wpm}</p>
                    <p>Language: ${lang}</p>
                    <p>Total Time: ${time} seconds</p>`;
                certificateContent.innerHTML = content;
                certificateContent.querySelectorAll('p').forEach(p => displayWithScramble(p, p.textContent));
            }

            setTimeout(() => {
                const titleRect = certificateTitle.getBoundingClientRect();
                const contentRect = certificateContent.getBoundingClientRect();
                const padding = 30;
                const newWidth = Math.max(260, titleRect.width + padding * 2);
                const newHeight = Math.max(260, titleRect.height + contentRect.height + padding * 2);
                const maxWidth = 600;
                const maxHeight = 600;
                certificate.style.width = `${Math.min(newWidth, maxWidth)}px`;
                certificate.style.height = `${Math.min(newHeight, maxHeight)}px`;
                certificateContainer.style.width = `${Math.min(newWidth + 40, maxWidth + 40)}px`;
                certificateContainer.style.height = `${Math.min(newHeight + 40, maxHeight + 40)}px`;
            }, 100);

            certificateModal.style.display = 'flex';
            certificate.addEventListener('click', () => {
                certificate.classList.remove('spinning');
                void certificate.offsetWidth;
                certificate.classList.add('spinning');
                displayWithScramble(certificateTitle, certificateTitle.textContent);
                certificateContent.querySelectorAll('p').forEach(p => {
                    const isScore = p.classList.contains('score-display');
                    const isEmoji = p.classList.contains('emoji-reward');
                    displayWithScramble(p, p.textContent, isScore, isEmoji);
                });
            }, { once: true });
            certificateModal.addEventListener('click', (e) => {
                if (e.target === certificateModal) {
                    certificateModal.style.display = 'none';
                    certificate.classList.remove('spinning');
                }
            }, { once: true });
        }

        function displayResults(results, agentName) {
            const messages = document.getElementById('messages');
            currentResults = results;
            currentPage = 0;
            const start = currentPage * RESULTS_PER_PAGE;
            const end = Math.min(start + RESULTS_PER_PAGE, results.length);
            const colorClass = agentName === 'All Agents' ? '' : `${agentName.toLowerCase()}-color`;
            messages.innerHTML += `<p class="${colorClass}"><b>${agentName} Results:</b> Found ${results.length} results.</p>`;
            for (let i = start; i < end; i++) {
                const { item, matches, agent } = results[i];
                const resultColorClass = agent ? `${agent.toLowerCase()}-color` : colorClass;
                matches.forEach(match => {
                    const snippet = match.value.slice(Math.max(0, match.indices[0][0] - 50), match.indices[0][1] + 50);
                    const url = `https://webxos.netlify.app${item.path}`;
                    messages.innerHTML += `<p class="${resultColorClass}"><b>${agent || agentName} Result (<a href="${url}" target="_blank">${item.source}</a>):</b> ...${snippet}...</p>`;
                });
            }
            updatePaginationControls(results.length);
            messages.scrollTop = messages.scrollHeight;
        }

        function updatePaginationControls(totalResults) {
            const pagination = document.getElementById('pagination');
            const totalPages = Math.ceil(totalResults / RESULTS_PER_PAGE);
            pagination.innerHTML = `
                <button id="prevPage" ${currentPage === 0 ? 'disabled' : ''}>Previous</button>
                <span>Page ${currentPage + 1} of ${totalPages}</span>
                <button id="nextPage" ${currentPage >= totalPages - 1 ? 'disabled' : ''}>Next</button>`;
            document.getElementById('prevPage')?.addEventListener('click', () => {
                if (currentPage > 0) {
                    currentPage--;
                    showPage(currentResults, activeAgents[0] || 'All Agents');
                }
            });
            document.getElementById('nextPage')?.addEventListener('click', () => {
                if (currentPage < Math.ceil(totalResults / RESULTS_PER_PAGE) - 1) {
                    currentPage++;
                    showPage(currentResults, activeAgents[0] || 'All Agents');
                }
            });
        }

        function showPage(results, agentName) {
            const messages = document.getElementById('messages');
            const start = currentPage * RESULTS_PER_PAGE;
            const end = Math.min(start + RESULTS_PER_PAGE, results.length);
            const colorClass = agentName === 'All Agents' ? '' : `${agentName.toLowerCase()}-color`;
            messages.innerHTML = `<p class="${colorClass}"><b>${agentName} Results:</b> Found ${results.length} results.</p>`;
            for (let i = start; i < end; i++) {
                const { item, matches, agent } = results[i];
                const resultColorClass = agent ? `${agent.toLowerCase()}-color` : colorClass;
                matches.forEach(match => {
                    const snippet = match.value.slice(Math.max(0, match.indices[0][0] - 50), match.indices[0][1] + 50);
                    const url = `https://webxos.netlify.app${item.path}`;
                    messages.innerHTML += `<p class="${resultColorClass}"><b>${agent || agentName} Result (<a href="${url}" target="_blank">${item.source}</a>):</b> ...${snippet}...</p>`;
                });
            }
            updatePaginationControls(results.length);
            messages.scrollTop = messages.scrollHeight;
        }

        async function searchQuery() {
            const query = document.getElementById('userInput').value.trim().toLowerCase();
            const messages = document.getElementById('messages');
            const loading = document.getElementById('loading');
            if (!query) {
                updateStatus('Error: Empty input.', true, 'Please enter a search term, /decode, or /agent1-4.');
                return;
            }
            let colorClass = '';
            if (query.startsWith('/agent1')) colorClass = 'agent1-color';
            else if (query.startsWith('/agent2')) colorClass = 'agent2-color';
            else if (query.startsWith('/agent3')) colorClass = 'agent3-color';
            else if (query.startsWith('/agent4')) colorClass = 'agent4-color';
            messages.innerHTML += `<p class="${colorClass}"><b>You:</b> ${query}</p>`;
            loading.style.display = 'block';
            setAgentsActive(false);
            console.log('Resetting all agents');

            try {
                // Handle commands
                if (query.startsWith('/')) {
                    const [command, ...args] = query.split(' ');
                    const argString = args.join(' ');
                    switch (command) {
                        case '/help':
                            messages.innerHTML += `
                                <p><b>Commands:</b></p>
                                <p><b>/help</b> - Show this menu.</p>
                                <p><b>/clear</b> - Clear chatbox.</p>
                                <p><b>/stats</b> - Show indexing stats.</p>
                                <p><b>/version</b> - Show bot version.</p>
                                <p><b>/decode [code]</b> - Decode WebXOS serial code.</p>
                                <p><b>/agent1-4 [query]</b> - Search with specific agent.</p>
                                <p><b>search [term]</b> - Search with all agents.</p>`;
                            updateStatus('Success: Help menu displayed.');
                            break;
                        case '/clear':
                            messages.innerHTML = '';
                            updateStatus('Success: Chatbox cleared.');
                            break;
                        case '/stats':
                            const indexedFiles = cachedContent['site_index']?.length || 0;
                            const totalKeywords = cachedContent['site_index']?.reduce((sum, item) => sum + (item.text?.keywords?.length || 0), 0) || 0;
                            messages.innerHTML += `<p><b>Stats:</b> Indexed ${indexedFiles} files with ${totalKeywords} keywords.</p>`;
                            updateStatus('Success: Indexing stats displayed.');
                            break;
                        case '/version':
                            messages.innerHTML += `<p><b>Version:</b> WebXOS Searchbot v${BOT_VERSION}</p>`;
                            updateStatus('Success: Version displayed.');
                            break;
                        case '/decode':
                            if (!argString) {
                                messages.innerHTML += `<p><b>Error:</b> No code provided. Use /decode [WEBXOS-code].</p>`;
                                updateStatus('Error: No code provided.', true);
                                break;
                            }
                            console.log('Activating all agents for /decode');
                            setAgentsActive(true);
                            const result = decodeWebXOS(argString);
                            if (result.success && result.decoded) {
                                messages.innerHTML += `<p><b>Decode Result:</b> ${result.message}</p>`;
                                showCertificate(parseGameData(result.decoded), result);
                                updateStatus('Success: Code decoded.');
                            } else {
                                messages.innerHTML += `<p><b>Decode Error:</b> ${result.message}</p>`;
                                updateStatus('Error: Decoding failed.', true, result.message);
                            }
                            break;
                        case '/agent1':
                        case '/agent2':
                        case '/agent3':
                        case '/agent4':
                            if (!argString) {
                                const agentName = command.slice(1).toUpperCase();
                                messages.innerHTML += `<p class="${command.slice(1).toLowerCase()}-color"><b>${agentName}:</b> How can I help you?</p>`;
                                console.log(`Activating ${agentName}`);
                                setAgentsActive(false, command.slice(1));
                                updateStatus(`Success: ${agentName} activated.`);
                                break;
                            }
                            activeAgents = [command.slice(1).toUpperCase()];
                            console.log(`Activating ${command.slice(1).toUpperCase()} for search`);
                            setAgentsActive(false, command.slice(1));
                            const agentFn = window[command.slice(1) + 'Search'];
                            if (!agentFn) throw new Error(`Agent function ${command.slice(1)}Search not found.`);
                            const agentResults = await agentFn(argString, cachedContent['site_index'] || []);
                            displayResults(agentResults, command.slice(1).toUpperCase());
                            updateStatus(`Success: Search completed by ${command.slice(1).toUpperCase()}.`);
                            break;
                        default:
                            messages.innerHTML += `<p><b>Error:</b> Unknown command "${command}". Type /help for commands.</p>`;
                            updateStatus('Error: Unknown command.', true);
                    }
                } else {
                    // Default search with all agents
                    activeAgents = ['Agent1', 'Agent2', 'Agent3', 'Agent4'];
                    console.log('Activating all agents for default search');
                    setAgentsActive(true);
                    let allResults = [];
                    for (const agent of ['agent1', 'agent2', 'agent3', 'agent4']) {
                        const agentFn = window[agent + 'Search'];
                        if (!agentFn) throw new Error(`Agent function ${agent}Search not found.`);
                        const agentResults = await agentFn(query, cachedContent['site_index'] || []);
                        agentResults.forEach(result => result.agent = agent.toUpperCase());
                        allResults = [...allResults, ...agentResults];
                    }
                    allResults.sort((a, b) => a.score - b.score);
                    if (allResults.length === 0) {
                        messages.innerHTML += `<p><b>Search Result:</b> No results found for "${query}". Try a different query.</p>`;
                        updateStatus('Success: Search completed. No results found.');
                    } else {
                        displayResults(allResults, 'All Agents');
                        updateStatus(`Success: Search completed. Found ${allResults.length} results.`);
                    }
                }
            } catch (error) {
                messages.innerHTML += `<p><b>Error:</b> ${error.message}</p>`;
                updateStatus('Error: Search failed.', true, error.stack || error.message);
            } finally {
                loading.style.display = 'none';
                document.getElementById('userInput').value = '';
                messages.scrollTop = messages.scrollHeight;
                console.log('Resetting all agents after query');
                setAgentsActive(false);
            }
        }
    </script>
</body>
</html>
