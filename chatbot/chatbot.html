<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <meta name="description" content="WebXOS Searchbot 2025: Search innovative web apps, AI tools, games, and utilities across the WebXOS platform and GitHub repository.">
    <meta name="keywords" content="webXOS, searchbot, web applications 2025, AI tools, web games, online utilities, digital solutions, webXOS AI, webXOS search, AI agents, browser-based tools, innovative web apps, digital experience, web development, AI-powered search, online games, modular web tools, sustainable web solutions, carbon footprint tools, webXOS research, exoskeleton AI technology, green energy, web design, front end, sustainable software, AI, machine learning, eco-friendly tech, web interfaces, user experience, UX design, web technology, AI-driven search, browser-based applications, digital innovation, web utilities, sustainable design, green technology, front-end development, AI applications, web accessibility, interactive web, modern web design, eco-conscious software, AI research, digital transformation, web performance, sustainable digital tools, low-carbon tech, web app development, AI-enhanced tools, online platforms, futuristic web solutions, green computing">
    <meta name="robots" content="index, follow">
    <meta name="author" content="webXOS">
    <meta property="og:title" content="WebXOS Searchbot 2025 - Search Web Apps & AI Tools">
    <meta property="og:description" content="Explore WebXOS Searchbot 2025 to find cutting-edge web applications, AI agents, games, and utilities across the WebXOS platform and GitHub repository.">
    <meta property="og:url" content="https://webxos.netlify.app/chatbot/chatbot.html">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="webXOS">
    <meta property="og:locale" content="en_US">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@webxos">
    <meta name="twitter:creator" content="@webxos">
    <meta name="twitter:title" content="WebXOS Searchbot 2025 - Search Web Apps & AI Tools">
    <meta name="twitter:description" content="Discover WebXOS Searchbot 2025 for searching innovative web applications, AI tools, games, and utilities.">
    <link rel="canonical" href="https://webxos.netlify.app/chatbot/chatbot.html">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap">
    <link rel="stylesheet" href="/chatbot/static/style.css">
    <link rel="manifest" href="/manifest.json">
    <link rel="icon" href="/chatbot/static/icon.png">
    <title>WebXOS Searchbot 2025</title>
</head>
<body>
    <div class="container">
        <h1 class="title">WebXOS Searchbot</h1>
        <div id="chatbox">
            <div id="messages"></div>
            <div id="status"></div>
            <div class="input-group">
                <input type="text" id="userInput" placeholder="Search WebXOS or GitHub...">
                <button onclick="searchQuery()">Search</button>
            </div>
            <div id="loading" class="loading-spinner"></div>
        </div>
    </div>
    <div id="neuralNetwork">
        <div class="neural-link" id="neural1"></div>
        <div class="neural-link" id="neural2"></div>
        <div class="neural-link" id="neural3"></div>
        <div class="neural-link" id="neural4"></div>
    </div>
    <div class="copyright">Copyright webXOS 2025</div>
    <script src="/chatbot/static/fuse.min.js"></script>
    <script>
        // Cache for offline support
        const CACHE_NAME = 'webxos-searchbot-v2';
        let cachedContent = {};

        // List of Netlify site paths to search (based on provided HTML)
        const sitePaths = [
            '/index.html',
            '/moreinfo.html',
            '/ai.html',
            '/tools.html',
            '/games.html',
            '/radical.html',
            '/greenstudy.html',
            '/copyright.html',
            '/chatbot/chatbot.html',
            '/chatbot/static/style.css'
        ];

        // Initialize cache on page load
        window.addEventListener('load', async () => {
            try {
                const cache = await caches.open(CACHE_NAME);
                for (const path of sitePaths) {
                    const response = await cache.match(path);
                    if (response) cachedContent[path] = await response.text();
                }
                const githubResponse = await cache.match('/github-repo-files');
                if (githubResponse) cachedContent['github-repo-files'] = await githubResponse.json();
            } catch (error) {
                updateStatus('Error: Failed to initialize cache.', true, error.stack || error.message);
            }
            simulateNeuralActivity(false); // Initial neural dot positions
        });

        function updateStatus(message, isError = false, details = '') {
            const status = document.getElementById('status');
            const timestamp = new Date().toLocaleTimeString();
            status.innerHTML = `
                <span class="${isError ? 'error' : 'success'}">
                    ${message}${isError && details ? `<br><small>Details: ${details} [${timestamp}]</small>` : ''}
                </span>`;
            status.style.display = 'block';
            setTimeout(() => status.style.display = 'none', 7000);
        }

        // Neural network animation
        function simulateNeuralActivity(isSearching) {
            const links = document.querySelectorAll('.neural-link');
            if (isSearching) {
                links.forEach((link, index) => {
                    const angle = (index * 90 + Date.now() / 10) % 360;
                    const radius = 50 + Math.sin(Date.now() / 1000) * 20;
                    const x = 50 + radius * Math.cos(angle * Math.PI / 180);
                    const y = 50 + radius * Math.sin(angle * Math.PI / 180);
                    link.style.left = `${x}%`;
                    link.style.top = `${y}%`;
                    link.style.animation = 'orbit 2s linear infinite';
                });
            } else {
                links.forEach((link, index) => {
                    link.style.left = `${20 + index * 20}%`;
                    link.style.top = `${10 + index * 20}%`;
                    link.style.animation = 'pulse 2s infinite ease-in-out';
                });
            }
        }

        async function fetchGitHubFiles() {
            const githubApiUrl = 'https://api.github.com/repos/webxos/webxos/contents';
            const token = 'GITHUB_TOKEN'; // Replace with Netlify env variable or remove for unauthenticated
            const headers = token ? { Authorization: `token ${token}` } : {};
            let allFiles = [];

            async function fetchContents(url) {
                try {
                    const response = await fetch(url, { headers });
                    if (!response.ok) {
                        throw new Error(`GitHub API fetch failed: HTTP ${response.status} ${response.statusText}`);
                    }
                    const data = await response.json();
                    for (const item of data) {
                        if (item.type === 'file' && /\.(html|md|js|css|json)$/i.test(item.name)) {
                            const fileResponse = await fetch(item.download_url, { headers });
                            if (!fileResponse.ok) {
                                throw new Error(`File fetch failed: ${item.download_url} HTTP ${fileResponse.status}`);
                            }
                            allFiles.push({
                                text: await fileResponse.text(),
                                source: `GitHub: ${item.path}`
                            });
                        } else if (item.type === 'dir') {
                            await fetchContents(item.url);
                        }
                    }
                } catch (error) {
                    throw error;
                }
            }

            try {
                await fetchContents(githubApiUrl);
                const cache = await caches.open(CACHE_NAME);
                await cache.put('/github-repo-files', new Response(JSON.stringify(allFiles)));
                cachedContent['github-repo-files'] = allFiles;
                return allFiles;
            } catch (error) {
                if (cachedContent['github-repo-files']) {
                    updateStatus('Warning: Using cached GitHub files.', false, error.message);
                    return cachedContent['github-repo-files'];
                }
                throw error;
            }
        }

        async function searchQuery() {
            const query = document.getElementById('userInput').value.trim();
            const messages = document.getElementById('messages');
            const loading = document.getElementById('loading');
            if (!query) {
                updateStatus('Error: Empty search query.', true, 'Please enter a search term.');
                return;
            }
            messages.innerHTML += `<p><b>You:</b> ${query}</p>`;
            loading.style.display = 'block';
            simulateNeuralActivity(true); // Start neural dot animations

            try {
                const cache = await caches.open(CACHE_NAME);
                let searchItems = [];

                // Fetch Netlify site files
                for (const path of sitePaths) {
                    try {
                        const response = await fetch(path, { cache: 'no-cache' });
                        if (!response.ok) {
                            throw new Error(`Fetch failed for ${path}: HTTP ${response.status} ${response.statusText}`);
                        }
                        const text = await response.text();
                        await cache.put(path, new Response(text));
                        cachedContent[path] = text;
                        searchItems.push({ text, source: `Site: ${path}` });
                    } catch (error) {
                        if (cachedContent[path]) {
                            searchItems.push({ text: cachedContent[path], source: `Site (cached): ${path}` });
                            updateStatus(`Warning: Using cached content for ${path}.`, false, error.message);
                        } else {
                            updateStatus(`Error: Failed to fetch ${path}.`, true, error.message);
                        }
                    }
                }

                // Fetch GitHub repo files
                let githubFiles = [];
                try {
                    githubFiles = await fetchGitHubFiles();
                } catch (error) {
                    updateStatus('Error: Failed to fetch GitHub files.', true, error.message);
                }
                searchItems = searchItems.concat(githubFiles);

                // Fuzzy search with Fuse.js
                const fuseOptions = {
                    includeScore: true,
                    includeMatches: true,
                    threshold: 0.3,
                    keys: ['text']
                };
                const fuse = new Fuse(searchItems, fuseOptions);
                const results = fuse.search(query);

                if (results.length > 0) {
                    results.forEach(result => {
                        const { item, matches } = result;
                        matches.forEach(match => {
                            const snippet = match.value.slice(Math.max(0, match.indices[0][0] - 50), match.indices[0][1] + 50);
                            messages.innerHTML += `
                                <p><b>Result (${item.source}):</b> ...${snippet}...</p>`;
                        });
                    });
                } else {
                    messages.innerHTML += `<p><b>Search Result:</b> No results found for "${query}".</p>`;
                }
                updateStatus('Success: Search completed.');
            } catch (error) {
                const errorDetails = error.message.includes('fetch') ?
                    'Check Netlify redirects in netlify.toml, ensure site paths are correct, or verify GitHub API token.'
                    : `Unexpected error: ${error.stack || error.message}`;
                messages.innerHTML += `<p><b>Search Error:</b> ${error.message}</p>`;
                updateStatus(`Error: ${error.message}`, true, errorDetails);
            } finally {
                loading.style.display = 'none';
                document.getElementById('userInput').value = '';
                messages.scrollTop = messages.scrollHeight;
                simulateNeuralActivity(false); // Reset neural dots
            }
        }
    </script>
</body>
</html>
