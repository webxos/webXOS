<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <meta name="description" content="WebXOS Searchbot 2025: Search innovative web apps, AI tools, games, and utilities across the WebXOS platform with neural dot visualization.">
    <meta name="keywords" content="webXOS, searchbot, web applications 2025, AI tools, web games, online utilities, digital solutions, webXOS AI, webXOS search, browser-based tools, innovative web apps, digital experience, web development, AI-powered search, online games, modular web tools, sustainable web solutions, carbon footprint tools, webXOS research, exoskeleton AI technology, green energy, web design, front end, sustainable software, AI, machine learning, eco-friendly tech, web interfaces, user experience, UX design, web technology, AI-driven search, browser-based applications, digital innovation, web utilities, sustainable design, green technology, front-end development, AI applications, web accessibility, interactive web, modern web design, eco-conscious software, AI research, digital transformation, web performance, sustainable digital tools, low-carbon tech, web app development, AI-enhanced tools, online platforms, futuristic web solutions, green computing">
    <meta name="robots" content="index, follow">
    <meta name="author" content="webXOS">
    <meta property="og:title" content="WebXOS Searchbot 2025 - Search Web Apps">
    <meta property="og:description" content="Explore WebXOS Searchbot 2025 for searching innovative web applications, AI tools, and games with neural dot visualization.">
    <meta property="og:url" content="https://webxos.netlify.app/chatbot/static/chatbot.html">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="webXOS">
    <meta property="og:locale" content="en_US">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@webxos">
    <meta name="twitter:creator" content="@webxos">
    <meta name="twitter:title" content="WebXOS Searchbot 2025 - Search Web Apps">
    <meta name="twitter:description" content="Discover WebXOS Searchbot 2025 for searching innovative web applications and games with neural dot visualization.">
    <link rel="canonical" href="https://webxos.netlify.app/chatbot/static/chatbot.html">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=OCR-A&display=swap">
    <link rel="stylesheet" href="/chatbot/static/style.css">
    <link rel="manifest" href="/manifest.json">
    <link rel="icon" href="/chatbot/static/icon.png">
    <title>WebXOS Searchbot 2025</title>
    <script src="/chatbot/static/fuse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun@0.2020/gun.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/compromise@14/builds/compromise.min.js"></script>
    <script src="/chatbot/static/sync.js"></script>
    <script src="/chatbot/static/nlp.js"></script>
    <script src="/chatbot/static/agent1.js"></script>
    <script src="/chatbot/static/agent2.js"></script>
    <script src="/chatbot/static/agent3.js"></script>
    <script src="/chatbot/static/agent4.js"></script>
    <script src="/chatbot/static/agentic.js"></script>
    <script src="/chatbot/static/neurots.js"></script>
    <style>
        .error-details {
            display: none;
            background: #0f0f0f;
            border: 1px solid #00ff00;
            padding: 10px;
            margin-top: 5px;
            font-family: 'Courier New', monospace;
            color: #00ff00;
            font-size: 12px;
            white-space: pre-wrap;
            max-height: 200px;
            overflow-y: auto;
        }
        .error-toggle {
            cursor: pointer;
            color: #00ff00;
            text-decoration: underline;
        }
        .error-toggle:hover {
            color: #00ffff;
        }
        @media (max-width: 600px) {
            .error-details {
                font-size: 10px;
                max-height: 150px;
            }
        }
    </style>
</head>
<body>
    <canvas id="neuralCanvas" style="pointer-events: none;"></canvas>
    <h1 class="title">WebXOS Searchbot</h1>
    <div class="input-container">
        <div id="status" class="error-message"></div>
        <div id="chatbox">
            <div id="messages"></div>
            <div class="input-group">
                <input type="text" id="userInput" placeholder="Search WebXOS or /agent1-4, /agentic...">
                <button id="searchButton">Search</button>
                <button id="clearButton">Clear</button>
            </div>
            <div id="loading" class="loading-spinner"></div>
        </div>
    </div>
    <footer>
        <div class="copyright">Copyright webXOS 2025</div>
    </footer>
    <script>
        const CACHE_NAME = 'webxos-searchbot-v18';
        let cachedContent = { site_index: [] };
        const BOT_VERSION = '1.1.8';
        let activeAgents = [];
        const errorLog = JSON.parse(sessionStorage.getItem('errorLog') || '[]');
        const BASE_URL = window.location.origin;

        function updateStatus(message, isError = false, details = '') {
            const status = document.getElementById('status');
            const timestamp = new Date().toLocaleTimeString();
            status.innerHTML = `<span class="${isError ? 'error' : 'success'}">${message}${isError || details ? `<br><small>Details: ${details} [${timestamp}]</small>` : ''}</span>`;
            status.classList.add('show');
            setTimeout(() => status.classList.remove('show'), 3000);
            if (isError && details) {
                errorLog.push({ message, details, stack: new Error().stack, timestamp: new Date().toISOString(), baseUrl: BASE_URL });
                sessionStorage.setItem('errorLog', JSON.stringify(errorLog.slice(-10)));
            }
        }

        function displayHelpMenu() {
            const messages = document.getElementById('messages');
            messages.innerHTML += `
                <p><b>Commands:</b></p>
                <p><b>/help</b> - Show this menu.</p>
                <p><b>/clear</b> - Clear chatbox and reset neural dots.</p>
                <p><b>/stats</b> - Show indexing stats.</p>
                <p><b>/version</b> - Show bot version.</p>
                <p><b>/agent1-4</b> - Activate specific agent and neural pattern.</p>
                <p><b>/agentic</b> - Activate unified mode with all agents.</p>
                <p><b>/debug</b> - Display recent error tracebacks.</p>
                <p><b>search [term]</b> - Search WebXOS content.</p>`;
            if (typeof syncResults === 'function') {
                syncResults('agentic', '/help', [{ item: { text: { content: 'Help menu displayed' } } }]);
            } else {
                updateStatus('Error: syncResults not defined.', true, 'Ensure /chatbot/static/sync.js is loaded. Check Network tab in DevTools.');
            }
            messages.scrollTop = messages.scrollHeight;
        }

        function clearChat() {
            const messages = document.getElementById('messages');
            messages.innerHTML = '';
            activeAgents = [];
            setAgentsActive(false);
            updateStatus('Success: Chatbox cleared.');
            messages.scrollTop = messages.scrollHeight;
        }

        function displayResults(results, agent = '') {
            const messages = document.getElementById('messages');
            if (results.length === 0) {
                messages.innerHTML += `<p><b>${agent ? agent.toUpperCase() + ': ' : 'Search Result:'}</b> No results found.</p>`;
                updateStatus(`Success: ${agent ? agent.toUpperCase() + ' search' : 'Search'} completed. No results found.`);
            } else {
                messages.innerHTML += `<p><b>${agent ? agent.toUpperCase() + ': ' : 'Search Results:'}</b> Found ${results.length} results.</p>`;
                results.forEach(({ item }) => {
                    const url = `https://webxos.netlify.app${item.path || ''}`;
                    messages.innerHTML += `<p><b>${agent ? agent.toUpperCase() + ': ' : 'Result:'} (<a href="${url}" target="_blank">${item.source || 'WebXOS'}</a>)</b> ${item.text.content}</p>`;
                });
                updateStatus(`Success: ${agent ? agent.toUpperCase() + ' search' : 'Search'} completed. Found ${results.length} results.`);
            }
            if (typeof syncResults === 'function') {
                syncResults(agent || 'search', document.getElementById('userInput').value, results);
            } else {
                updateStatus('Error: syncResults not defined.', true, 'Ensure /chatbot/static/sync.js is loaded. Check Network tab in DevTools.');
            }
            messages.scrollTop = messages.scrollHeight;
        }

        function displayDebugLog() {
            const messages = document.getElementById('messages');
            messages.innerHTML += `<p><b>Debug Log:</b></p>`;
            if (errorLog.length === 0) {
                messages.innerHTML += `<p>No errors logged.</p>`;
            } else {
                errorLog.forEach((log, index) => {
                    const id = `error-${index}`;
                    messages.innerHTML += `
                        <p><span class="error-toggle" onclick="toggleError('${id}')">[${log.timestamp}] ${log.message} (Base: ${log.baseUrl})</span></p>
                        <div id="${id}" class="error-details">${log.details}\n${log.stack}</div>`;
                });
            }
            if (typeof syncResults === 'function') {
                syncResults('agentic', '/debug', [{ item: { text: { content: 'Debug log displayed' } } }]);
            } else {
                updateStatus('Error: syncResults not defined.', true, 'Ensure /chatbot/static/sync.js is loaded. Check Network tab in DevTools.');
            }
            messages.scrollTop = messages.scrollHeight;
        }

        function toggleError(id) {
            const element = document.getElementById(id);
            element.style.display = element.style.display === 'block' ? 'none' : 'block';
        }

        async function tryFetchIndex(paths) {
            for (const path of paths) {
                try {
                    const response = await fetch(path, { cache: 'no-cache' });
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText} at ${path}`);
                    }
                    const contentType = response.headers.get('content-type');
                    if (!contentType || !contentType.includes('application/json')) {
                        const text = await response.text();
                        throw new Error(`Expected JSON, received ${contentType || 'unknown'} at ${path}: ${text.slice(0, 50)}...`);
                    }
                    const data = await response.json();
                    if (!data.site_index || !Array.isArray(data.site_index)) {
                        throw new Error(`Invalid site_index.json format at ${path}`);
                    }
                    return data;
                } catch (error) {
                    updateStatus('Error: Failed to load index.', true, `${error.message}\nCheck ${BASE_URL}${path} in Netlify or add site_index.json to /chatbot/static. Run /debug for traceback.`);
                }
            }
            throw new Error('All fetch attempts failed');
        }

        async function searchQuery() {
            const query = document.getElementById('userInput').value.trim().toLowerCase();
            const messages = document.getElementById('messages');
            const loading = document.getElementById('loading');
            if (!query) {
                updateStatus('Error: Empty input.', true, 'Please enter a search term or command.');
                return;
            }
            let colorClass = '';
            if (query.startsWith('/agent1')) colorClass = 'agent1-color';
            else if (query.startsWith('/agent2')) colorClass = 'agent2-color';
            else if (query.startsWith('/agent3')) colorClass = 'agent3-color';
            else if (query.startsWith('/agent4')) colorClass = 'agent4-color';
            else if (query.startsWith('/agentic')) colorClass = 'agent1-color';
            messages.innerHTML += `<p class="${colorClass}"><b>You:</b> ${query}</p>`;
            loading.style.display = 'block';

            try {
                if (query.startsWith('/')) {
                    const [command, ...args] = query.split(' ');
                    const searchTerm = args.join(' ').trim();
                    switch (command) {
                        case '/help':
                            displayHelpMenu();
                            setAgentsActive(false);
                            break;
                        case '/clear':
                            clearChat();
                            break;
                        case '/stats':
                            const indexedFiles = cachedContent['site_index']?.length || 0;
                            messages.innerHTML += `<p><b>Stats:</b> Indexed ${indexedFiles} files.</p>`;
                            updateStatus('Success: Indexing stats displayed.');
                            setAgentsActive(false);
                            break;
                        case '/version':
                            messages.innerHTML += `<p><b>Version:</b> WebXOS Searchbot v${BOT_VERSION}</p>`;
                            updateStatus('Success: Version displayed.');
                            setAgentsActive(false);
                            break;
                        case '/debug':
                            displayDebugLog();
                            setAgentsActive(false);
                            break;
                        case '/agent1':
                        case '/agent2':
                        case '/agent3':
                        case '/agent4':
                            const agentName = command.slice(1);
                            activeAgents = [agentName];
                            setAgentsActive(true, agentName);
                            if (searchTerm) {
                                const results = await window[`${agentName}Search`](searchTerm, cachedContent['site_index']);
                                displayResults(results, agentName);
                            } else {
                                messages.innerHTML += `<p class="${agentName}-color"><b>${agentName.toUpperCase()}:</b> ${agentName.toUpperCase()} checking in. Enter a query or more features coming soon.</p>`;
                                updateStatus(`Success: ${agentName.toUpperCase()} activated.`);
                            }
                            break;
                        case '/agentic':
                            activeAgents = ['agent1', 'agent2', 'agent3', 'agent4'];
                            setAgentsActive(true, 'agentic');
                            if (searchTerm) {
                                const results = await agenticSearch(searchTerm, cachedContent['site_index']);
                                displayResults(results, 'Agentic');
                            } else {
                                messages.innerHTML += `<p class="agent1-color"><b>AGENTIC:</b> Unified mode activated. Enter a query to search with all agents.</p>`;
                                updateStatus('Success: Agentic mode activated.');
                            }
                            break;
                        default:
                            messages.innerHTML += `<p><b>Error:</b> Unknown command "${command}". Type /help for commands.</p>`;
                            updateStatus('Error: Unknown command.', true);
                            setAgentsActive(false);
                    }
                } else {
                    const fuse = new Fuse(cachedContent['site_index'] || [], {
                        keys: ['text.content'],
                        threshold: 0.4,
                        includeMatches: true
                    });
                    const results = fuse.search(query);
                    displayResults(results);
                }
            } catch (error) {
                messages.innerHTML += `<p><b>Error:</b> ${error.message}</p>`;
                updateStatus('Error: Search failed.', true, error.stack || error.message);
                setAgentsActive(false);
            } finally {
                loading.style.display = 'none';
                document.getElementById('userInput').value = '';
                messages.scrollTop = messages.scrollHeight;
            }
        }

        window.addEventListener('load', async () => {
            const messages = document.getElementById('messages');
            const userInput = document.getElementById('userInput');
            const searchButton = document.getElementById('searchButton');
            const clearButton = document.getElementById('clearButton');

            userInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    searchQuery();
                }
            });
            searchButton.addEventListener('click', () => {
                console.log('Search button clicked');
                searchQuery();
            });
            clearButton.addEventListener('click', () => {
                console.log('Clear button clicked');
                clearChat();
            });

            const cache = await caches.open(CACHE_NAME);
            try {
                cachedContent = await tryFetchIndex([
                    '/chatbot/static/site_index.json',
                    './site_index.json',
                    '/site_index.json',
                    '/chatbot/site_index.json'
                ]);
                await cache.put('/chatbot/static/site_index.json', new Response(JSON.stringify(cachedContent)));
                updateStatus(`Success: Indexed ${cachedContent['site_index'].length} files`);
            } catch (error) {
                const cachedIndex = await cache.match('/chatbot/static/site_index.json');
                if (cachedIndex) {
                    cachedContent['site_index'] = await cachedIndex.json();
                    updateStatus(`Success: Loaded ${cachedContent['site_index'].length} cached files`);
                } else {
                    updateStatus('Error: Failed to load index.', true, `${error.message}\nEnsure site_index.json exists at /chatbot/static/site_index.json in your Netlify deployment (https://app.netlify.com). Run /debug for traceback.`);
                }
            }
            try {
                if (typeof initGun !== 'function') {
                    throw new Error('initGun not defined. Ensure /chatbot/static/sync.js is loaded.');
                }
                initGun();
                initNLP();
                displayHelpMenu();
            } catch (error) {
                updateStatus('Error: Initialization failed.', true, `${error.message}\nCheck /chatbot/static/sync.js and /chatbot/static/nlp.js in Netlify.`);
            }
        });
    </script>
</body>
</html>
