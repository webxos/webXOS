<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <meta name="description" content="WebXOS Searchbot 2025: Search innovative web apps, AI tools, games, and utilities across the WebXOS platform with neural dot visualization.">
    <meta name="keywords" content="webXOS, searchbot, web applications 2025, AI tools, web games, online utilities, digital solutions, webXOS AI, webXOS search, browser-based tools, innovative web apps, digital experience, web development, AI-powered search, online games, modular web tools, sustainable web solutions, carbon footprint tools, webXOS research, exoskeleton AI technology, green energy, web design, front end, sustainable software, AI, machine learning, eco-friendly tech, web interfaces, user experience, UX design, web technology, AI-driven search, browser-based applications, digital innovation, web utilities, sustainable design, green technology, front-end development, AI applications, web accessibility, interactive web, modern web design, eco-conscious software, AI research, digital transformation, web performance, sustainable digital tools, low-carbon tech, web app development, AI-enhanced tools, online platforms, futuristic web solutions, green computing">
    <meta name="robots" content="index, follow">
    <meta name="author" content="webXOS">
    <meta property="og:title" content="WebXOS Searchbot 2025 - Search Web Apps">
    <meta property="og:description" content="Explore WebXOS Searchbot 2025 for searching innovative web applications, AI tools, and games with neural dot visualization.">
    <meta property="og:url" content="https://webxos.netlify.app/chatbot/chatbot.html">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="webXOS">
    <meta property="og:locale" content="en_US">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@webxos">
    <meta name="twitter:creator" content="@webxos">
    <meta name="twitter:title" content="WebXOS Searchbot 2025 - Search Web Apps">
    <meta name="twitter:description" content="Discover WebXOS Searchbot 2025 for searching innovative web applications and games with neural dot visualization.">
    <link rel="canonical" href="https://webxos.netlify.app/chatbot/chatbot.html">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=OCR-A&display=swap">
    <link rel="stylesheet" href="/chatbot/static/style.css">
    <link rel="manifest" href="/manifest.json">
    <link rel="icon" href="/chatbot/static/icon.png">
    <title>WebXOS Searchbot 2025</title>
    <style>
        body {
            background: #000;
            color: #0f0;
            font-family: 'Orbitron', monospace;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #neuralCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        .title {
            font-family: 'OCR-A', monospace;
            font-size: 2.5em;
            text-align: center;
            color: #0f0;
            text-shadow: 0 0 10px #0f0;
            margin: 20px 0;
        }
        .input-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        #chatbox {
            background: rgba(0, 255, 0, 0.1);
            border: 2px solid #0f0;
            padding: 20px;
        }
        #messages {
            max-height: 400px;
            overflow-y: auto;
            padding: 10px;
            background: #000;
            border: 1px solid #0f0;
            margin-bottom: 10px;
        }
        #messages p {
            margin: 5px 0;
            line-height: 1.4;
        }
        .input-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        #userInput {
            flex-grow: 1;
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px;
            font-family: 'OCR-A', monospace;
            font-size: 1em;
        }
        #userInput:focus {
            outline: none;
            box-shadow: 0 0 5px #0f0;
        }
        button {
            background: #0f0;
            color: #000;
            border: none;
            padding: 10px 20px;
            font-family: 'Orbitron', monospace;
            font-size: 1em;
            cursor: pointer;
        }
        button:hover {
            background: #00cc00;
        }
        .error-message {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #000;
            color: #f00;
            padding: 10px;
            display: none;
            max-width: 300px;
        }
        .error-message.show {
            display: block;
        }
        .error { color: #f00; }
        .success { color: #0f0; }
        .agent1-color { color: #ff0; }
        .agent2-color { color: #0ff; }
        .agent3-color { color: #f0f; }
        .agent4-color { color: #f00; }
        .custom-agent-color { color: #00ff00; }
        .loading-spinner {
            display: none;
            text-align: center;
            color: #0f0;
            font-size: 1em;
            margin-top: 10px;
        }
        .loading-spinner::before {
            content: '⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏';
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { content: '⠋'; }
            10% { content: '⠙'; }
            20% { content: '⠹'; }
            30% { content: '⠸'; }
            40% { content: '⠼'; }
            50% { content: '⠴'; }
            60% { content: '⠦'; }
            70% { content: '⠧'; }
            80% { content: '⠇'; }
            90% { content: '⠏'; }
        }
        footer {
            text-align: center;
            color: #0f0;
            font-family: 'Orbitron', monospace;
            margin-top: 20px;
            font-size: 0.9em;
        }
        @media (max-width: 600px) {
            .title { font-size: 1.8em; }
            .input-container { padding: 10px; }
            #chatbox { padding: 10px; }
            #userInput { font-size: 0.9em; }
            button { padding: 8px 16px; font-size: 0.9em; }
        }
    </style>
</head>
<body>
    <canvas id="neuralCanvas" style="pointer-events: none;"></canvas>
    <h1 class="title">WebXOS Searchbot 2025</h1>
    <div class="input-container">
        <div id="status" class="error-message"></div>
        <div id="chatbox">
            <div id="messages"></div>
            <div class="input-group">
                <input type="text" id="userInput" placeholder="Search WebXOS or /agent1-4...">
                <button id="searchButton">Search</button>
                <button id="clearButton">Clear</button>
                <button id="authButton">Authenticate</button>
                <button id="importButton">Import</button>
                <input type="file" id="fileInput" accept=".md" style="display: none;">
            </div>
            <div id="loading" class="loading-spinner"></div>
        </div>
    </div>
    <footer>
        <div class="copyright">Copyright webXOS 2025</div>
    </footer>
    <script src="/chatbot/static/fuse.min.js"></script>
    <script src="/chatbot/static/neurots.js" defer></script>
    <script>
        const CACHE_NAME = 'webxos-searchbot-v25';
        const BOT_VERSION = '1.2.13';
        let cachedContent = { site_index: [] };
        let activeAgents = [];
        let customAgents = {};
        let isOffline = !navigator.onLine;
        const VIAL_BACKEND = 'https://webxos.netlify.app/vial/ping';
        const FALLBACK_BACKEND = 'https://webxos.netlify.app/.netlify/functions/ping';
        const MAX_RETRIES = 3;
        const RETRY_DELAY = 2000;

        // IndexedDB for error logging
        let db;
        const dbRequest = indexedDB.open('WebXOSLogs', 1);
        dbRequest.onupgradeneeded = event => {
            db = event.target.result;
            db.createObjectStore('errors', { keyPath: 'timestamp' });
        };
        dbRequest.onsuccess = event => {
            db = event.target.result;
        };

        // Load script with error handling
        function loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.async = true;
                script.onload = () => {
                    console.log(`Script loaded: ${src}`);
                    resolve();
                };
                script.onerror = () => {
                    fetch(src, { method: 'HEAD' })
                        .then(response => reject(new Error(`Failed to load script: ${src}. Status: ${response.status}`)))
                        .catch(() => reject(new Error(`Failed to load script: ${src}. Network error or file not found.`)));
                };
                document.head.appendChild(script);
            });
        }

        // Service Worker registration
        async function registerServiceWorker() {
            if (!('serviceWorker' in navigator)) {
                logError('Service Worker not supported', null, 'navigator.serviceWorker');
                updateStatus('Error: Browser does not support Service Worker.', true, 'Offline functionality limited.');
                return;
            }
            if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                logError('Service Worker requires HTTPS or localhost', null, 'registerServiceWorker');
                updateStatus('Error: Service Worker requires secure context.', true, 'Use HTTPS or localhost.');
                return;
            }

            async function attemptRegistration(path, retryCount) {
                try {
                    const swCheck = await fetch(path, { method: 'HEAD' });
                    if (!swCheck.ok) throw new Error(`HTTP ${swCheck.status}: sw.js not found`);
                    const registration = await navigator.serviceWorker.register(path, { scope: '/chatbot/' });
                    console.log('Service Worker registered:', registration.scope);
                    updateStatus('Success: Service Worker registered.', false);
                    return registration;
                } catch (err) {
                    const errorDetails = err.message.includes('404') ? 'sw.js not found at /chatbot/sw.js.' : err.message.includes('CORS') ? 'CORS policy blocked.' : err.message;
                    const guidance = 'Ensure /chatbot/sw.js exists at https://webxos.netlify.app/chatbot/sw.js.';
                    logError(`Service Worker registration failed: ${path}`, err, path, null, null, `${errorDetails} ${guidance}`);
                    if (retryCount < MAX_RETRIES) {
                        await new Promise(resolve => setTimeout(resolve, Math.pow(2, retryCount) * 1000));
                        return attemptRegistration(path, retryCount + 1);
                    } else {
                        logError('Service Worker registration failed after retries', err, path, null, null, `${errorDetails} ${guidance}`);
                        updateStatus('Error: Failed to register Service Worker.', true, `${errorDetails} Check Netlify deploy logs.`);
                        isOffline = true;
                        return null;
                    }
                }
            }

            try {
                await attemptRegistration('/chatbot/sw.js', 0);
            } catch (err) {
                console.warn('Service Worker registration failed. Using offline mode.');
                isOffline = true;
            }
        }

        // Error logging to IndexedDB
        function logError(message, error, endpoint, response, requestDetails, contentPreview) {
            const stack = error && error.stack ? error.stack : 'No stack trace';
            const timestamp = new Date().toISOString();
            const responseDetails = response ? `Status: ${response.status || 'unknown'}, Response: ${JSON.stringify(response.data || response.statusText || 'No response')}` : 'No response';
            const logEntry = `[${timestamp}] ${message}\nEndpoint: ${endpoint}\nStack: ${stack}\nResponse: ${responseDetails}`;
            console.error(logEntry);
            if (db) {
                const tx = db.transaction(['errors'], 'readwrite');
                tx.objectStore('errors').add({ timestamp, message: logEntry });
            }
            return logEntry;
        }

        // Update status
        function updateStatus(message, isError = false, details = '') {
            const status = document.getElementById('status');
            const timestamp = new Date().toLocaleTimeString();
            status.innerHTML = `<span class="${isError ? 'error' : 'success'}">${message}${isError || details ? `<br><small>Details: ${details} [${timestamp}]</small>` : ''}</span>`;
            status.classList.add('show');
            setTimeout(() => status.classList.remove('show'), 5000);
        }

        // Test backend connectivity with retries and detailed error reporting
        async function testBackend(endpoint, retryCount = 0) {
            try {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 5000);
                const response = await fetch(endpoint, { 
                    method: 'GET', 
                    headers: { 'Content-Type': 'application/json' },
                    signal: controller.signal
                });
                clearTimeout(timeout);
                const text = await response.text();
                let data;
                try {
                    data = JSON.parse(text);
                } catch (e) {
                    data = text;
                }
                return { status: response.status, data, contentType: response.headers.get('content-type') || 'unknown' };
            } catch (error) {
                if (error.name === 'AbortError') {
                    const errorMsg = `Request to ${endpoint} timed out after 5 seconds`;
                    if (retryCount < MAX_RETRIES) {
                        await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));
                        return testBackend(endpoint, retryCount + 1);
                    }
                    return { status: null, error: errorMsg, contentType: 'unknown', data: '' };
                }
                const errorMsg = error.message.includes('Failed to fetch') ? `Network error: Unable to reach ${endpoint}` : error.message;
                if (retryCount < MAX_RETRIES) {
                    await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));
                    return testBackend(endpoint, retryCount + 1);
                }
                return { status: null, error: errorMsg, contentType: 'unknown', data: '' };
            }
        }

        // Validate JSON
        function isValidJSON(text) {
            if (!text || typeof text !== 'string' || !text.trim()) return false;
            if (text.startsWith('<!DOCTYPE html') || text.startsWith('<html')) return false;
            try {
                JSON.parse(text);
                return true;
            } catch (e) {
                return false;
            }
        }

        // Parse Markdown with YAML front matter
        function parseMarkdownAgent(mdContent) {
            const yamlMatch = mdContent.match(/^---\n([\s\S]*?)\n---/);
            if (!yamlMatch) return null;
            const yamlContent = yamlMatch[1];
            const lines = yamlContent.split('\n');
            let agent = {};
            let currentKey = null;
            lines.forEach(line => {
                if (line.includes(':')) {
                    const [key, value] = line.split(':').map(s => s.trim());
                    currentKey = key;
                    if (key === 'agent') {
                        agent = { name: '', pattern: '', color: '' };
                    } else if (currentKey === 'agent') {
                        agent[key] = value;
                    }
                }
            });
            if (!agent.name || !agent.pattern || !agent.color) return null;
            if (agent.name.toLowerCase().startsWith('wallet') || agent.pattern.toLowerCase().includes('wallet')) return null; // Ignore wallet data
            return agent;
        }

        // Load site index
        async function loadSiteIndex() {
            try {
                const response = await fetch('/site_index.json', { cache: 'no-cache' });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const text = await response.text();
                if (!isValidJSON(text)) {
                    logError('Invalid JSON in site_index.json', null, '/site_index.json', { status: response.status, data: text.slice(0, 500) });
                    updateStatus('Error: Invalid site_index.json.', true, 'Check server configuration.');
                    cachedContent.site_index = [
                        {
                            path: '/example',
                            source: 'Example Page',
                            text: { content: 'This is an example page for testing WebXOS search.', keywords: ['example', 'test', 'webxos'] }
                        }
                    ];
                    return;
                }
                cachedContent.site_index = JSON.parse(text);
                if ('caches' in window) {
                    const cache = await caches.open(CACHE_NAME);
                    await cache.put('/site_index.json', new Response(JSON.stringify(cachedContent.site_index)));
                }
                updateStatus(`Success: Indexed ${cachedContent.site_index.length} files.`, false);
            } catch (error) {
                logError('Failed to load site_index.json', error, '/site_index.json');
                updateStatus('Error: Failed to load site index.', true, 'Using fallback index.');
                cachedContent.site_index = [
                    {
                        path: '/example',
                        source: 'Example Page',
                        text: { content: 'This is an example page for testing WebXOS search.', keywords: ['example', 'test', 'webxos'] }
                    }
                ];
            }
        }

        // Show help menu
        function showHelp() {
            const messages = document.getElementById('messages');
            let customCommands = '';
            Object.keys(customAgents).forEach(agentName => {
                customCommands += `<p><b>/${agentName}</b> - Activate custom ${agentName} pattern.</p>`;
            });
            messages.innerHTML = `
                <p><b>Commands:</b></p>
                <p><b>/help</b> - Show this menu.</p>
                <p><b>/clear</b> - Clear chatbox and reset neural dots.</p>
                <p><b>/stats</b> - Show indexing stats.</p>
                <p><b>/version</b> - Show bot version.</p>
                <p><b>/agent1</b> - Activate Agent 1 helix pattern.</p>
                <p><b>/agent2</b> - Activate Agent 2 cube pattern.</p>
                <p><b>/agent3</b> - Activate Agent 3 torus pattern.</p>
                <p><b>/agent4</b> - Activate Agent 4 star pattern.</p>
                ${customCommands}
                <p><b>/dna</b> - Display collaborative DNA-like agent network.</p>
                <p><b>/galaxy</b> - Display galaxy simulation.</p>
                <p><b>search [term]</b> - Search WebXOS content.</p>`;
            messages.scrollTop = messages.scrollHeight;
        }

        // Authenticate (verify backend connectivity)
        async function authenticate() {
            const messages = document.getElementById('messages');
            const loading = document.getElementById('loading');
            loading.style.display = 'block';
            let vialResponse = await testBackend(VIAL_BACKEND);
            let errorMsg = '';
            let guidance = 'Check Netlify Functions logs at https://app.netlify.com/sites/webxos/functions/ping.';
            
            if (vialResponse.status === 200 && isValidJSON(vialResponse.data) && JSON.parse(vialResponse.data).status === 'ok') {
                messages.innerHTML += `<p><b>System:</b> Backend connection verified.</p>`;
                updateStatus('Success: Connected to search bot backend.', false);
            } else {
                if (vialResponse.status === 404) {
                    errorMsg = `HTTP 404: /vial/ping not found`;
                    guidance += ' Ensure ping.js is in /functions/ping.js, netlify.toml sets functions = "functions", and redirect rule is set. Redeploy with `netlify deploy --prod --force`.';
                    // Try fallback endpoint
                    vialResponse = await testBackend(FALLBACK_BACKEND);
                    if (vialResponse.status === 200 && isValidJSON(vialResponse.data) && JSON.parse(vialResponse.data).status === 'ok') {
                        messages.innerHTML += `<p><b>System:</b> Fallback endpoint /.netlify/functions/ping verified. Update VIAL_BACKEND to ${FALLBACK_BACKEND}.</p>`;
                        updateStatus('Success: Fallback backend connected.', false, 'Update VIAL_BACKEND in chatbot.html.');
                    } else {
                        errorMsg += `; Fallback /.netlify/functions/ping also failed (HTTP ${vialResponse.status || 'unknown'}: ${vialResponse.data.slice(0, 100)})`;
                        guidance += ' Verify function deployment in Netlify dashboard > Functions.';
                    }
                } else if (vialResponse.status === 500) {
                    errorMsg = `HTTP 500: Server error at /vial/ping`;
                    guidance += ' Check function logs for runtime errors in ping.js.';
                } else if (vialResponse.status === null) {
                    errorMsg = vialResponse.error;
                    guidance += ' Verify network connectivity and Netlify deploy status.';
                } else {
                    errorMsg = `HTTP ${vialResponse.status}: ${vialResponse.data.slice(0, 100)}`;
                    guidance += ' Inspect response in browser DevTools and function logs.';
                }
                logError('Backend connection failed', new Error(errorMsg), VIAL_BACKEND, vialResponse, null, vialResponse.data.slice(0, 500));
                messages.innerHTML += `<p class="error"><b>Error:</b> Failed to connect to backend: ${errorMsg}</p>`;
                updateStatus('Error: Backend connection failed.', true, guidance);
            }
            loading.style.display = 'none';
            messages.scrollTop = messages.scrollHeight;
        }

        // Import Markdown file
        function importFile() {
            const fileInput = document.getElementById('fileInput');
            fileInput.click();
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            const messages = document.getElementById('messages');
            if (!file || !file.name.endsWith('.md')) {
                updateStatus('Error: Invalid file.', true, 'Please select a .md file.');
                messages.innerHTML += `<p class="error"><b>Error:</b> Please select a .md file.</p>`;
                return;
            }
            const reader = new FileReader();
            reader.onload = async (e) => {
                const text = e.target.result;
                const agent = parseMarkdownAgent(text);
                if (!agent) {
                    updateStatus('Error: Invalid agent format.', true, 'Ensure .md file has valid YAML front matter.');
                    messages.innerHTML += `<p class="error"><b>Error:</b> Invalid agent format in .md file.</p>`;
                    return;
                }
                customAgents[agent.name] = agent;
                window.customAgents[agent.name] = agent; // Expose to neurots.js
                messages.innerHTML += `<p><b>System:</b> Imported custom agent: ${agent.name}.</p>`;
                updateStatus(`Success: Imported agent ${agent.name}.`, false);
                showHelp();
            };
            reader.readAsText(file);
        }

        // Search query
        async function searchQuery() {
            const query = document.getElementById('userInput').value.trim().toLowerCase();
            const messages = document.getElementById('messages');
            const loading = document.getElementById('loading');
            if (!query) {
                updateStatus('Error: Empty input.', true, 'Please enter a search term or /agent1-4.');
                return;
            }
            let colorClass = '';
            if (query.startsWith('/agent1')) colorClass = 'agent1-color';
            else if (query.startsWith('/agent2')) colorClass = 'agent2-color';
            else if (query.startsWith('/agent3')) colorClass = 'agent3-color';
            else if (query.startsWith('/agent4')) colorClass = 'agent4-color';
            else if (query.startsWith('/') && customAgents[query.slice(1)]) colorClass = 'custom-agent-color';
            messages.innerHTML += `<p class="${colorClass}"><b>You:</b> ${query}</p>`;
            loading.style.display = 'block';

            try {
                if (query.startsWith('/')) {
                    const command = query.split(' ')[0];
                    let vialResponse = { status: null };
                    if (['/agent1', '/agent2', '/agent3', '/agent4', '/dna', '/galaxy'].includes(command) || customAgents[command.slice(1)]) {
                        vialResponse = await testBackend(VIAL_BACKEND);
                        if (isOffline || vialResponse.status !== 200 || !isValidJSON(vialResponse.data) || JSON.parse(vialResponse.data).status !== 'ok') {
                            let errorMsg = isOffline ? 'Offline mode' : vialResponse.status ? `HTTP ${vialResponse.status}: ${vialResponse.data.slice(0, 100)}` : vialResponse.error;
                            let guidance = 'Check Netlify Functions logs at https://app.netlify.com/sites/webxos/functions/ping.';
                            if (vialResponse.status === 404) {
                                errorMsg = `HTTP 404: /vial/ping not found`;
                                guidance += ' Ensure ping.js is in /functions/ping.js, netlify.toml sets functions = "functions", and redirect rule is set. Redeploy with `netlify deploy --prod --force`.';
                                // Try fallback
                                vialResponse = await testBackend(FALLBACK_BACKEND);
                                if (vialResponse.status === 200 && isValidJSON(vialResponse.data) && JSON.parse(vialResponse.data).status === 'ok') {
                                    errorMsg += `; Fallback /.netlify/functions/ping succeeded`;
                                    guidance = `Update VIAL_BACKEND to ${FALLBACK_BACKEND} in chatbot.html.`;
                                } else {
                                    errorMsg += `; Fallback /.netlify/functions/ping failed (HTTP ${vialResponse.status || 'unknown'})`;
                                    guidance += ' Verify function deployment in Netlify dashboard > Functions.';
                                }
                            } else if (vialResponse.status === 500) {
                                errorMsg = `HTTP 500: Server error at /vial/ping`;
                                guidance += ' Check function logs for runtime errors.';
                            }
                            updateStatus('Error: Agent feature disabled.', true, `Requires online mode and vial backend. ${errorMsg} ${guidance}`);
                            messages.innerHTML += `<p class="error"><b>Error:</b> Agent feature requires online mode and vial backend: ${errorMsg}</p>`;
                            setAgentsActive(false);
                            loading.style.display = 'none';
                            return;
                        }
                    }
                    switch (command) {
                        case '/help':
                            showHelp();
                            updateStatus('Success: Help menu displayed.', false);
                            setAgentsActive(false);
                            break;
                        case '/clear':
                            messages.innerHTML = '';
                            activeAgents = [];
                            setAgentsActive(false);
                            updateStatus('Success: Chatbox cleared.', false);
                            showHelp();
                            break;
                        case '/stats':
                            const wyjaśnionePliki = cachedContent.site_index?.length || 0;
                            const totalKeywords = cachedContent.site_index?.reduce((sum, item) => sum + (item.text?.keywords?.length || 0), 0) || 0;
                            messages.innerHTML += `<p><b>Stats:</b> Indexed ${wyjaśnionePliki} files with ${totalKeywords} keywords.</p>`;
                            updateStatus('Success: Indexing stats displayed.', false);
                            setAgentsActive(false);
                            break;
                        case '/version':
                            messages.innerHTML += `<p><b>Version:</b> WebXOS Searchbot v${BOT_VERSION}</p>`;
                            updateStatus('Success: Version displayed.', false);
                            setAgentsActive(false);
                            break;
                        case '/agent1':
                        case '/agent2':
                        case '/agent3':
                        case '/agent4':
                            activeAgents = [command.slice(1)];
                            setAgentsActive(true, activeAgents, false, false);
                            messages.innerHTML += `<p class="${command.slice(1)-color}"><b>${command.slice(1).toUpperCase()}:</b> ${command.slice(1).toUpperCase()} pattern activated.</p>`;
                            updateStatus(`Success: ${command.slice(1).toUpperCase()} activated.`, false);
                            break;
                        case '/dna':
                            activeAgents = ['agent1', 'agent2', 'agent3', 'agent4', ...Object.keys(customAgents)];
                            setAgentsActive(true, activeAgents, true, false);
                            messages.innerHTML += `<p><b>System:</b> Collaborative DNA-like agent network activated.</p>`;
                            updateStatus('Success: DNA activated.', false);
                            break;
                        case '/galaxy':
                            activeAgents = [];
                            setAgentsActive(true, [], false, true);
                            messages.innerHTML += `<p><b>System:</b> Galaxy simulation activated.</p>`;
                            updateStatus('Success: Galaxy activated.', false);
                            break;
                        default:
                            if (customAgents[command.slice(1)]) {
                                activeAgents = [command.slice(1)];
                                setAgentsActive(true, activeAgents, false, false);
                                messages.innerHTML += `<p class="custom-agent-color"><b>${command.slice(1).toUpperCase()}:</b> Custom ${command.slice(1).toUpperCase()} pattern activated.</p>`;
                                updateStatus(`Success: Custom ${command.slice(1).toUpperCase()} activated.`, false);
                            } else {
                                messages.innerHTML += `<p class="error"><b>Error:</b> Unknown command "${command}". Type /help for commands.</p>`;
                                updateStatus('Error: Unknown command.', true);
                                setAgentsActive(false);
                            }
                    }
                } else {
                    const fuse = new Fuse(cachedContent.site_index || [], {
                        keys: ['text.content', 'text.keywords'],
                        threshold: 0.4,
                        includeMatches: true
                    });
                    const results = fuse.search(query);
                    if (results.length === 0) {
                        messages.innerHTML += `<p><b>Search Result:</b> No results found for "${query}". Try a different query.</p>`;
                        updateStatus('Success: Search completed. No results found.', false);
                    } else {
                        messages.innerHTML += `<p><b>Search Results:</b> Found ${results.length} results.</p>`;
                        results.forEach(({ item, matches }) => {
                            matches.forEach(match => {
                                const snippet = match.value.slice(Math.max(0, match.indices[0][0] - 50), match.indices[0][1] + 50);
                                const url = `https://webxos.netlify.app${item.path}`;
                                messages.innerHTML += `<p><b>Result (<a href="${url}" target="_blank">${item.source}</a>):</b> ...${snippet}...</p>`;
                            });
                        });
                        updateStatus(`Success: Search completed. Found ${results.length} results.`, false);
                    }
                    setAgentsActive(false);
                }
            } catch (error) {
                logError('Search failed', error, 'searchQuery');
                messages.innerHTML += `<p class="error"><b>Error:</b> ${error.message}</p>`;
                updateStatus('Error: Search failed.', true, error.message);
                setAgentsActive(false);
            } finally {
                loading.style.display = 'none';
                document.getElementById('userInput').value = '';
                messages.scrollTop = messages.scrollHeight;
            }
        }

        // Initialize app
        async function initializeApp() {
            updateStatus('Initializing WebXOS Searchbot...', false);
            window.addEventListener('online', () => {
                isOffline = false;
                updateStatus('Online: Connecting to backend.', false);
                loadSiteIndex();
            });
            window.addEventListener('offline', () => {
                isOffline = true;
                updateStatus('Offline: Using cached data.', true);
            });

            try {
                await loadScript('/chatbot/static/neurots.js');
                if (typeof window.initNeurots !== 'function') {
                    await loadScript('https://cdn.jsdelivr.net/gh/webxos/webxos@latest/chatbot/static/neurots.js');
                    if (typeof window.initNeurots !== 'function') {
                        throw new Error('initNeurots function not defined after loading neurots.js');
                    }
                }
                initNeurots();
                console.log('Neurots initialized successfully');
            } catch (error) {
                logError('Neurots initialization failed', error, '/chatbot/static/neurots.js');
                updateStatus('Error: Neural dots failed to initialize.', true, error.message);
            }

            showHelp();
            await registerServiceWorker();
            await loadSiteIndex();
        }

        // Event listeners
        window.addEventListener('load', initializeApp);
        document.getElementById('userInput').addEventListener('keydown', event => {
            if (event.key === 'Enter') {
                event.preventDefault();
                searchQuery();
            }
        });
        document.getElementById('searchButton').addEventListener('click', () => {
            console.log('Search button clicked');
            searchQuery();
        });
        document.getElementById('clearButton').addEventListener('click', () => {
            console.log('Clear button clicked');
            document.getElementById('messages').innerHTML = '';
            activeAgents = [];
            setAgentsActive(false);
            showHelp();
            updateStatus('Success: Chatbox cleared.', false);
        });
        document.getElementById('authButton').addEventListener('click', () => {
            console.log('Authenticate button clicked');
            authenticate();
        });
        document.getElementById('importButton').addEventListener('click', () => {
            console.log('Import button clicked');
            importFile();
        });
        document.getElementById('fileInput').addEventListener('change', handleFileSelect);
    </script>
</body>
</html>
