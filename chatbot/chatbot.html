<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <meta name="description" content="WebXOS Searchbot 2025: Search innovative web apps, AI tools, games, and utilities across the WebXOS platform.">
    <meta name="keywords" content="webXOS, searchbot, web applications 2025, AI tools, web games, online utilities, digital solutions, webXOS AI, webXOS search, AI agents, browser-based tools, innovative web apps, digital experience, web development, AI-powered search, online games, modular web tools, sustainable web solutions, carbon footprint tools, webXOS research, exoskeleton AI technology, green energy, web design, front end, sustainable software, AI, machine learning, eco-friendly tech, web interfaces, user experience, UX design, web technology, AI-driven search, browser-based applications, digital innovation, web utilities, sustainable design, green technology, front-end development, AI applications, web accessibility, interactive web, modern web design, eco-conscious software, AI research, digital transformation, web performance, sustainable digital tools, low-carbon tech, web app development, AI-enhanced tools, online platforms, futuristic web solutions, green computing">
    <meta name="robots" content="index, follow">
    <meta name="author" content="webXOS">
    <meta property="og:title" content="WebXOS Searchbot 2025 - Search Web Apps & AI Tools">
    <meta property="og:description" content="Explore WebXOS Searchbot 2025 to find cutting-edge web applications, AI agents, games, and utilities across the WebXOS platform.">
    <meta property="og:url" content="https://webxos.netlify.app/chatbot/chatbot.html">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="webXOS">
    <meta property="og:locale" content="en_US">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@webxos">
    <meta name="twitter:creator" content="@webxos">
    <meta name="twitter:title" content="WebXOS Searchbot 2025 - Search Web Apps & AI Tools">
    <meta name="twitter:description" content="Discover WebXOS Searchbot 2025 for searching innovative web applications, AI tools, games, and utilities.">
    <link rel="canonical" href="https://webxos.netlify.app/chatbot/chatbot.html">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap">
    <link rel="stylesheet" href="/chatbot/static/style.css">
    <link rel="manifest" href="/manifest.json">
    <link rel="icon" href="/chatbot/static/icon.png">
    <title>WebXOS Searchbot 2025</title>
</head>
<body>
    <div class="container">
        <h1 class="title">WebXOS Searchbot</h1>
        <div id="chatbox">
            <div id="messages"></div>
            <div id="status"></div>
            <div class="input-group">
                <input type="text" id="userInput" placeholder="Search WebXOS...">
                <button onclick="searchQuery()">Search</button>
            </div>
            <div id="loading" class="loading-spinner"></div>
        </div>
    </div>
    <div id="neuralNetwork">
        <div class="neural-link" id="neural1"></div>
        <div class="neural-link" id="neural2"></div>
        <div class="neural-link" id="neural3"></div>
        <div class="neural-link" id="neural4"></div>
    </div>
    <div class="copyright">Copyright webXOS 2025</div>
    <script src="/chatbot/static/fuse.min.js"></script>
    <script>
        // Cache for offline support
        const CACHE_NAME = 'webxos-searchbot-v4';
        let cachedContent = {};

        // Initialize cache with site_index.json
        window.addEventListener('load', async () => {
            const messages = document.getElementById('messages');
            try {
                const cache = await caches.open(CACHE_NAME);
                let indexErrors = [];

                // Fetch site_index.json
                try {
                    const response = await fetch('/site_index.json', { cache: 'no-cache' });
                    if (!response.ok) {
                        const errorText = await response.text().catch(() => 'No response text');
                        throw new Error(`HTTP ${response.status} ${response.statusText}. Details: ${errorText}`);
                    }
                    const siteIndex = await response.json();
                    if (!siteIndex || !Array.isArray(siteIndex) || siteIndex.length === 0) {
                        throw new Error('site_index.json is empty or invalid');
                    }
                    await cache.put('/site_index.json', new Response(JSON.stringify(siteIndex)));
                    cachedContent['site_index'] = siteIndex;

                    // Validate content
                    siteIndex.forEach(item => {
                        if (!item.path || !item.source || !item.text || !item.text.trim()) {
                            indexErrors.push(`Invalid or empty content for ${item.path}`);
                        }
                    });
                } catch (error) {
                    const cachedIndex = await cache.match('/site_index.json');
                    if (cachedIndex) {
                        cachedContent['site_index'] = await cachedIndex.json();
                        indexErrors.push(`Used cached site_index.json due to: ${error.message}`);
                    } else {
                        indexErrors.push(`Failed to fetch site_index.json: ${error.message}`);
                    }
                }

                if (indexErrors.length > 0) {
                    messages.innerHTML += `<p><b>Index Initialization Errors:</b> ${indexErrors.join('; ')}</p>`;
                    updateStatus('Warning: Issues during index initialization.', false, indexErrors.join('; '));
                } else {
                    updateStatus(`Success: Indexed ${cachedContent['site_index'].length} files.`);
                }
            } catch (error) {
                messages.innerHTML += `<p><b>Index Initialization Error:</b> ${error.message}</p>`;
                updateStatus('Error: Failed to initialize index.', true, error.stack || error.message);
            }
            simulateNeuralActivity(false); // Initial neural dot positions
        });

        function updateStatus(message, isError = false, details = '') {
            const status = document.getElementById('status');
            const timestamp = new Date().toLocaleTimeString();
            status.innerHTML = `
                <span class="${isError ? 'error' : 'success'}">
                    ${message}${isError || details ? `<br><small>Details: ${details} [${timestamp}]</small>` : ''}
                </span>`;
            status.style.display = 'block';
            setTimeout(() => status.style.display = 'none', 7000);
        }

        // Neural network animation
        function simulateNeuralActivity(isSearching) {
            const links = document.querySelectorAll('.neural-link');
            if (isSearching) {
                links.forEach((link, index) => {
                    const angle = (index * 90 + Date.now() / 10) % 360;
                    const radius = 50 + Math.sin(Date.now() / 1000) * 20;
                    const x = 50 + radius * Math.cos(angle * Math.PI / 180);
                    const y = 50 + radius * Math.sin(angle * Math.PI / 180);
                    link.style.left = `${x}%`;
                    link.style.top = `${y}%`;
                    link.style.animation = 'orbit 2s linear infinite';
                });
            } else {
                links.forEach((link, index) => {
                    link.style.left = `${20 + index * 20}%`;
                    link.style.top = `${10 + index * 20}%`;
                    link.style.animation = 'pulse 2s infinite ease-in-out';
                });
            }
        }

        async function searchQuery() {
            const query = document.getElementById('userInput').value.trim();
            const messages = document.getElementById('messages');
            const loading = document.getElementById('loading');
            if (!query) {
                updateStatus('Error: Empty search query.', true, 'Please enter a search term.');
                return;
            }
            messages.innerHTML += `<p><b>You:</b> ${query}</p>`;
            loading.style.display = 'block';
            simulateNeuralActivity(true); // Start neural dot animations

            try {
                // Use cached site_index.json
                let searchItems = cachedContent['site_index'] || [];
                if (!searchItems.length) {
                    const cache = await caches.open(CACHE_NAME);
                    const cachedIndex = await cache.match('/site_index.json');
                    if (cachedIndex) {
                        searchItems = await cachedIndex.json();
                        cachedContent['site_index'] = searchItems;
                    } else {
                        // Fallback: Try fetching site_index.json again
                        const response = await fetch('/site_index.json', { cache: 'no-cache' });
                        if (!response.ok) {
                            throw new Error(`Failed to fetch site_index.json: HTTP ${response.status}`);
                        }
                        searchItems = await response.json();
                        if (!siteIndex || !Array.isArray(searchItems)) {
                            throw new Error('site_index.json is empty or invalid');
                        }
                        await cache.put('/site_index.json', new Response(JSON.stringify(searchItems)));
                        cachedContent['site_index'] = searchItems;
                    }
                }

                // Log indexing status
                if (searchItems.length === 0) {
                    throw new Error('No files indexed for search. Ensure site_index.json exists and contains valid content.');
                }
                messages.innerHTML += `<p><b>Search Info:</b> Indexed ${searchItems.length} files for query "${query}".</p>`;

                // Fuzzy search with Fuse.js
                const fuseOptions = {
                    includeScore: true,
                    includeMatches: true,
                    threshold: 0.4,
                    keys: ['text']
                };
                const fuse = new Fuse(searchItems, fuseOptions);
                const results = fuse.search(query);

                if (results.length > 0) {
                    results.forEach(result => {
                        const { item, matches } = result;
                        matches.forEach(match => {
                            const snippet = match.value.slice(Math.max(0, match.indices[0][0] - 50), match.indices[0][1] + 50);
                            messages.innerHTML += `
                                <p><b>Result (${item.source}):</b> ...${snippet}...</p>`;
                        });
                    });
                    messages.innerHTML += `<p><b>Search Info:</b> Found ${results.length} results for "${query}".</p>`;
                } else {
                    messages.innerHTML += `<p><b>Search Result:</b> No results found for "${query}". Try a different query or check site_index.json content.</p>`;
                }
                updateStatus(`Success: Search completed. Indexed ${searchItems.length} files, found ${results.length} results.`);
            } catch (error) {
                const errorDetails = error.message.includes('fetch') ?
                    'Check if site_index.json is deployed in the Netlify publish directory (/). Ensure all HTML, .py, and .md files are included in the repository.'
                    : `Unexpected error: ${error.stack || error.message}`;
                messages.innerHTML += `<p><b>Search Error:</b> ${error.message}</p>`;
                updateStatus(`Error: ${error.message}`, true, errorDetails);
            } finally {
                loading.style.display = 'none';
                document.getElementById('userInput').value = '';
                messages.scrollTop = messages.scrollHeight;
                simulateNeuralActivity(false); // Reset neural dots
            }
        }
    </script>
</body>
</html>
