<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <meta name="description" content="WebXOS Searchbot 2025: Search innovative web apps, AI tools, games, and utilities across the WebXOS platform and GitHub repository.">
    <meta name="keywords" content="webXOS, searchbot, web applications 2025, AI tools, web games, online utilities, digital solutions, webXOS AI, webXOS search, AI agents, browser-based tools, innovative web apps, digital experience, web development, AI-powered search, online games, modular web tools, sustainable web solutions, carbon footprint tools, webXOS research, exoskeleton AI technology, green energy, web design, front end, sustainable software, AI, machine learning, eco-friendly tech, web interfaces, user experience, UX design, web technology, AI-driven search, browser-based applications, digital innovation, web utilities, sustainable design, green technology, front-end development, AI applications, web accessibility, interactive web, modern web design, eco-conscious software, AI research, digital transformation, web performance, sustainable digital tools, low-carbon tech, web app development, AI-enhanced tools, online platforms, futuristic web solutions, green computing">
    <meta name="robots" content="index, follow">
    <meta name="author" content="webXOS">
    <meta property="og:title" content="WebXOS Searchbot 2025 - Search Web Apps & AI Tools">
    <meta property="og:description" content="Explore WebXOS Searchbot 2025 to find cutting-edge web applications, AI agents, games, and utilities across the WebXOS platform and GitHub repository.">
    <meta property="og:url" content="https://webxos.netlify.app/chatbot/chatbot.html">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="webXOS">
    <meta property="og:locale" content="en_US">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@webxos">
    <meta name="twitter:creator" content="@webxos">
    <meta name="twitter:title" content="WebXOS Searchbot 2025 - Search Web Apps & AI Tools">
    <meta name="twitter:description" content="Discover WebXOS Searchbot 2025 for searching innovative web applications, AI tools, games, and utilities.">
    <link rel="canonical" href="https://webxos.netlify.app/chatbot/chatbot.html">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap">
    <link rel="stylesheet" href="/chatbot/static/style.css">
    <link rel="manifest" href="/manifest.json">
    <link rel="icon" href="/chatbot/static/icon.png">
    <title>WebXOS Searchbot 2025</title>
</head>
<body>
    <div class="container">
        <h1 class="title">WebXOS Searchbot</h1>
        <div id="chatbox">
            <div id="messages"></div>
            <div id="status"></div>
            <div class="input-group">
                <input type="text" id="userInput" placeholder="Search WebXOS or GitHub...">
                <button onclick="searchQuery()">Search</button>
            </div>
            <div id="loading" class="loading-spinner"></div>
        </div>
    </div>
    <div id="neuralNetwork">
        <div class="neural-link" id="neural1"></div>
        <div class="neural-link" id="neural2"></div>
        <div class="neural-link" id="neural3"></div>
        <div class="neural-link" id="neural4"></div>
    </div>
    <div class="copyright">Copyright webXOS 2025</div>
    <script src="/chatbot/static/fuse.min.js"></script>
    <script>
        // Cache for offline support
        const CACHE_NAME = 'webxos-searchbot-v3';
        let cachedContent = {};

        // List of Netlify site paths to search
        const sitePaths = [
            '/index.html',
            '/moreinfo.html',
            '/ai.html',
            '/tools.html',
            '/games.html',
            '/radical.html',
            '/greenstudy.html',
            '/copyright.html',
            '/chatbot/chatbot.html',
            '/chatbot/static/style.css'
        ];

        // Initialize cache and attempt fetching content
        window.addEventListener('load', async () => {
            const messages = document.getElementById('messages');
            try {
                const cache = await caches.open(CACHE_NAME);
                let cacheErrors = [];

                // Fetch and cache site files
                for (const path of sitePaths) {
                    try {
                        const response = await fetch(path, { cache: 'no-cache' });
                        if (!response.ok) {
                            const errorText = await response.text().catch(() => 'No response text');
                            throw new Error(`HTTP ${response.status} ${response.statusText}. Details: ${errorText}`);
                        }
                        const text = await response.text();
                        if (!text.trim()) {
                            cacheErrors.push(`Empty content for ${path}`);
                            continue;
                        }
                        await cache.put(path, new Response(text));
                        cachedContent[path] = text;
                    } catch (error) {
                        const cachedResponse = await cache.match(path);
                        if (cachedResponse) {
                            cachedContent[path] = await cachedResponse.text();
                            cacheErrors.push(`Used cached content for ${path} due to: ${error.message}`);
                        } else {
                            cacheErrors.push(`Failed to fetch ${path}: ${error.message}`);
                        }
                    }
                }

                // Fetch and cache GitHub files
                let githubFiles = [];
                try {
                    githubFiles = await fetchGitHubFiles();
                    await cache.put('/github-repo-files', new Response(JSON.stringify(githubFiles)));
                    cachedContent['github-repo-files'] = githubFiles;
                } catch (error) {
                    const cachedGithub = await cache.match('/github-repo-files');
                    if (cachedGithub) {
                        cachedContent['github-repo-files'] = await cachedGithub.json();
                        cacheErrors.push(`Used cached GitHub files due to: ${error.message}`);
                    } else {
                        cacheErrors.push(`Failed to fetch GitHub files: ${error.message}`);
                    }
                }

                if (cacheErrors.length > 0) {
                    messages.innerHTML += `<p><b>Cache Initialization Errors:</b> ${cacheErrors.join('; ')}</p>`;
                    updateStatus('Warning: Issues during cache initialization.', false, cacheErrors.join('; '));
                } else {
                    updateStatus('Success: Cache initialized with all files.');
                }
            } catch (error) {
                messages.innerHTML += `<p><b>Cache Initialization Error:</b> ${error.message}</p>`;
                updateStatus('Error: Failed to initialize cache.', true, error.stack || error.message);
            }
            simulateNeuralActivity(false); // Initial neural dot positions
        });

        function updateStatus(message, isError = false, details = '') {
            const status = document.getElementById('status');
            const timestamp = new Date().toLocaleTimeString();
            status.innerHTML = `
                <span class="${isError ? 'error' : 'success'}">
                    ${message}${isError || details ? `<br><small>Details: ${details} [${timestamp}]</small>` : ''}
                </span>`;
            status.style.display = 'block';
            setTimeout(() => status.style.display = 'none', 7000);
        }

        // Neural network animation
        function simulateNeuralActivity(isSearching) {
            const links = document.querySelectorAll('.neural-link');
            if (isSearching) {
                links.forEach((link, index) => {
                    const angle = (index * 90 + Date.now() / 10) % 360;
                    const radius = 50 + Math.sin(Date.now() / 1000) * 20;
                    const x = 50 + radius * Math.cos(angle * Math.PI / 180);
                    const y = 50 + radius * Math.sin(angle * Math.PI / 180);
                    link.style.left = `${x}%`;
                    link.style.top = `${y}%`;
                    link.style.animation = 'orbit 2s linear infinite';
                });
            } else {
                links.forEach((link, index) => {
                    link.style.left = `${20 + index * 20}%`;
                    link.style.top = `${10 + index * 20}%`;
                    link.style.animation = 'pulse 2s infinite ease-in-out';
                });
            }
        }

        async function fetchGitHubFiles() {
            const githubApiUrl = 'https://api.github.com/repos/webxos/webxos/contents';
            const token = 'GITHUB_TOKEN'; // Replace with Netlify env variable or remove for unauthenticated
            const headers = token ? { Authorization: `token ${token}` } : {};
            let allFiles = [];
            let githubErrors = [];

            async function fetchContents(url, path = '') {
                try {
                    const response = await fetch(url, { headers });
                    if (!response.ok) {
                        const errorText = await response.text().catch(() => 'No response text');
                        if (response.status === 403) {
                            throw new Error(`GitHub API rate limit exceeded. Add a personal access token in Netlify environment variables.`);
                        } else if (response.status === 401) {
                            throw new Error(`Invalid GitHub API token. Check GITHUB_TOKEN in Netlify environment variables.`);
                        } else {
                            throw new Error(`GitHub API fetch failed for ${url}: HTTP ${response.status} ${response.statusText}. Details: ${errorText}`);
                        }
                    }
                    const data = await response.json();
                    for (const item of data) {
                        if (item.type === 'file' && /\.(html|md|js|css|json)$/i.test(item.name)) {
                            try {
                                const fileResponse = await fetch(item.download_url, { headers });
                                if (!fileResponse.ok) {
                                    githubErrors.push(`Failed to fetch ${item.path}: HTTP ${fileResponse.status} ${fileResponse.statusText}`);
                                    continue;
                                }
                                const text = await fileResponse.text();
                                if (!text.trim()) {
                                    githubErrors.push(`Empty content for ${item.path}`);
                                    continue;
                                }
                                allFiles.push({
                                    text,
                                    source: `GitHub: ${item.path}`
                                });
                            } catch (fileError) {
                                githubErrors.push(`Error fetching ${item.path}: ${fileError.message}`);
                            }
                        } else if (item.type === 'dir') {
                            await fetchContents(item.url, `${path}/${item.name}`);
                        }
                    }
                } catch (error) {
                    githubErrors.push(error.message);
                }
            }

            try {
                await fetchContents(githubApiUrl);
                if (githubErrors.length > 0) {
                    document.getElementById('messages').innerHTML += `<p><b>GitHub Errors:</b> ${githubErrors.join('; ')}</p>`;
                    updateStatus('Warning: Some GitHub files failed to fetch.', false, githubErrors.join('; '));
                }
                if (allFiles.length === 0 && githubErrors.length > 0) {
                    throw new Error('No GitHub files fetched successfully. See details above.');
                }
                return allFiles;
            } catch (error) {
                throw error;
            }
        }

        async function searchQuery() {
            const query = document.getElementById('userInput').value.trim();
            const messages = document.getElementById('messages');
            const loading = document.getElementById('loading');
            if (!query) {
                updateStatus('Error: Empty search query.', true, 'Please enter a search term.');
                return;
            }
            messages.innerHTML += `<p><b>You:</b> ${query}</p>`;
            loading.style.display = 'block';
            simulateNeuralActivity(true); // Start neural dot animations

            try {
                const cache = await caches.open(CACHE_NAME);
                let searchItems = [];
                let siteErrors = [];

                // Fetch Netlify site files
                for (const path of sitePaths) {
                    try {
                        const response = await fetch(path, { cache: 'no-cache' });
                        if (!response.ok) {
                            const errorText = await response.text().catch(() => 'No response text');
                            throw new Error(`HTTP ${response.status} ${response.statusText}. Details: ${errorText}`);
                        }
                        const text = await response.text();
                        if (!text.trim()) {
                            siteErrors.push(`Empty content for ${path}`);
                            continue;
                        }
                        await cache.put(path, new Response(text));
                        cachedContent[path] = text;
                        searchItems.push({ text, source: `Site: ${path}` });
                    } catch (error) {
                        if (cachedContent[path]) {
                            searchItems.push({ text: cachedContent[path], source: `Site (cached): ${path}` });
                            siteErrors.push(`Used cached content for ${path} due to: ${error.message}`);
                        } else {
                            siteErrors.push(`Failed to fetch ${path}: ${error.message}`);
                        }
                    }
                }

                if (siteErrors.length > 0) {
                    messages.innerHTML += `<p><b>Site Fetch Errors:</b> ${siteErrors.join('; ')}</p>`;
                    updateStatus('Warning: Some site files failed to fetch.', false, siteErrors.join('; '));
                }

                // Fetch GitHub repo files
                let githubFiles = [];
                try {
                    githubFiles = await fetchGitHubFiles();
                    searchItems = searchItems.concat(githubFiles);
                } catch (error) {
                    messages.innerHTML += `<p><b>GitHub Fetch Error:</b> ${error.message}</p>`;
                    updateStatus('Error: Failed to fetch GitHub files.', true, error.message);
                }

                // Log indexing status
                if (searchItems.length === 0) {
                    throw new Error('No files indexed for search. Check site paths in sitePaths array and GitHub API configuration.');
                }
                messages.innerHTML += `<p><b>Search Info:</b> Indexed ${searchItems.length} files for query "${query}".</p>`;

                // Fuzzy search with Fuse.js
                const fuseOptions = {
                    includeScore: true,
                    includeMatches: true,
                    threshold: 0.4,
                    keys: ['text']
                };
                const fuse = new Fuse(searchItems, fuseOptions);
                const results = fuse.search(query);

                if (results.length > 0) {
                    results.forEach(result => {
                        const { item, matches } = result;
                        matches.forEach(match => {
                            const snippet = match.value.slice(Math.max(0, match.indices[0][0] - 50), match.indices[0][1] + 50);
                            messages.innerHTML += `
                                <p><b>Result (${item.source}):</b> ...${snippet}...</p>`;
                        });
                    });
                    messages.innerHTML += `<p><b>Search Info:</b> Found ${results.length} results for "${query}".</p>`;
                } else {
                    messages.innerHTML += `<p><b>Search Result:</b> No results found for "${query}". Try a different query or check file availability in Netlify and GitHub.</p>`;
                }
                updateStatus(`Success: Search completed. Indexed ${searchItems.length} files, found ${results.length} results.`);
            } catch (error) {
                const errorDetails = error.message.includes('fetch') ?
                    'Check Netlify redirects in netlify.toml, verify site paths in sitePaths array, or ensure GitHub API token is set in Netlify environment variables.'
                    : `Unexpected error: ${error.stack || error.message}`;
                messages.innerHTML += `<p><b>Search Error:</b> ${error.message}</p>`;
                updateStatus(`Error: ${error.message}`, true, errorDetails);
            } finally {
                loading.style.display = 'none';
                document.getElementById('userInput').value = '';
                messages.scrollTop = messages.scrollHeight;
                simulateNeuralActivity(false); // Reset neural dots
            }
        }
    </script>
</body>
</html>
