<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <meta name="description" content="WebXOS Searchbot 2025: Search innovative web apps, AI tools, games, and utilities across the WebXOS platform with neural dot visualization and Vial integration.">
    <meta name="keywords" content="webXOS, searchbot, web applications 2025, AI tools, web games, online utilities, digital solutions, webXOS AI, webXOS search, browser-based tools, innovative web apps, digital experience, web development, AI-powered search, online games, modular web tools, sustainable web solutions, carbon footprint tools, webXOS research, exoskeleton AI technology, green energy, web design, front end, sustainable software, AI, machine learning, eco-friendly tech, web interfaces, user experience, UX design, web technology, AI-driven search, browser-based applications, digital innovation, web utilities, sustainable design, green technology, front-end development, AI applications, web accessibility, interactive web, modern web design, eco-conscious software, AI research, digital transformation, web performance, sustainable digital tools, low-carbon tech, web app development, AI-enhanced tools, online platforms, futuristic web solutions, green computing, vial, quantum reasoning, agentic search">
    <meta name="robots" content="index, follow">
    <meta name="author" content="webXOS">
    <meta property="og:title" content="WebXOS Searchbot 2025 - Search Web Apps with Vial">
    <meta property="og:description" content="Explore WebXOS Searchbot 2025 with Vial integration for searching innovative web applications, AI tools, and games with neural dot visualization and quantum reasoning.">
    <meta property="og:url" content="https://webxos.netlify.app/chatbot/chatbot.html">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="webXOS">
    <meta property="og:locale" content="en_US">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@webxos">
    <meta name="twitter:creator" content="@webxos">
    <meta name="twitter:title" content="WebXOS Searchbot 2025 - Search Web Apps with Vial">
    <meta name="twitter:description" content="Discover WebXOS Searchbot 2025 with Vial integration for searching innovative web applications and games with neural dot visualization and quantum reasoning.">
    <link rel="canonical" href="https://webxos.netlify.app/chatbot/chatbot.html">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=OCR-A&display=swap">
    <link rel="stylesheet" href="/chatbot/static/style.css">
    <link rel="manifest" href="/manifest.json">
    <link rel="icon" href="/chatbot/static/icon.png">
    <title>WebXOS Searchbot 2025</title>
    <style>
        body {
            background: #000;
            color: #0f0;
            font-family: 'OCR-A', 'Courier New', monospace;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #neuralCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        .title {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5em;
            text-align: center;
            color: #0f0;
            text-shadow: 0 0 10px #0f0;
            margin: 20px 0;
        }
        .input-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        #chatbox {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 15px;
            box-shadow: 0 0 10px #0f0;
        }
        #messages {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 10px;
            background: #000;
            border: 1px solid #0f0;
        }
        #messages p {
            margin: 5px 0;
            word-wrap: break-word;
        }
        .input-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        #userInput {
            flex-grow: 1;
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px;
            font-family: 'OCR-A', 'Courier New', monospace;
            font-size: 1em;
        }
        #userInput:focus {
            outline: none;
            box-shadow: 0 0 5px #0f0;
        }
        button {
            background: #0f0;
            color: #000;
            border: none;
            padding: 10px 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1em;
            cursor: pointer;
            transition: background 0.3s;
        }
        button:hover {
            background: #00cc00;
            box-shadow: 0 0 5px #0f0;
        }
        .error-message {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #f00;
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
        .error-message.show {
            display: block;
        }
        .error-message .error {
            color: #f00;
        }
        .error-message .success {
            color: #0f0;
        }
        .error-text {
            color: #f00;
        }
        .loading-spinner {
            display: none;
            text-align: center;
            color: #0f0;
            font-size: 1.2em;
        }
        .loading-spinner::before {
            content: '⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏';
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { content: '⠋'; }
            10% { content: '⠙'; }
            20% { content: '⠹'; }
            30% { content: '⠸'; }
            40% { content: '⠼'; }
            50% { content: '⠴'; }
            60% { content: '⠦'; }
            70% { content: '⠧'; }
            80% { content: '⠇'; }
            90% { content: '⠏'; }
        }
        .vial1-color { color: #ff0; }
        .vial2-color { color: #0ff; }
        .vial3-color { color: #f0f; }
        .vial4-color { color: #f00; }
        footer {
            text-align: center;
            color: #0f0;
            margin-top: 20px;
            font-size: 0.9em;
        }
        @media (max-width: 600px) {
            .title { font-size: 1.5em; }
            .input-container { padding: 10px; }
            #chatbot { padding: 10px; }
            #userInput { font-size: 0.9em; }
            button { padding: 8px 15px; font-size: 0.9em; }
        }
    </style>
</head>
<body>
    <canvas id="neuralCanvas" style="pointer-events: none;"></canvas>
    <h1 class="title">WebXOS Searchbot with Vial</h1>
    <div class="input-container">
        <div id="status" class="error-message"></div>
        <div id="chatbox">
            <div id="messages"></div>
            <div class="input-group">
                <input type="text" id="userInput" placeholder="Search WebXOS or /vial1-4, /dna, /galaxy, /troubleshoot...">
                <button id="searchButton">Search</button>
                <button id="clearButton">Clear</button>
                <button id="authButton">Authenticate</button>
                <button id="importButton">Import</button>
            </div>
            <div id="loading" class="loading-spinner"></div>
            <input type="file" id="fileInput" accept=".md" style="display: none;">
        </div>
    </div>
    <footer>
        <div class="copyright">Copyright webXOS 2025</div>
    </footer>
    <script src="/chatbot/static/fuse.min.js"></script>
    <script>
        const CACHE_NAME = 'webxos-searchbot-v23'; // Incremented for SW fix
        let cachedContent = { site_index: [] };
        const BOT_VERSION = '1.2.7'; // Incremented for SW fix
        let activeVials = [];
        let isAuthenticated = false;
        let authToken = null;
        let errorLog = [];
        let isInitializing = false;
        let isOffline = false;
        const networkId = 'webxos';
        let authRetries = 0;
        let scriptRetries = 0;
        let swRetries = 0;
        const MAX_RETRIES = 3;
        const VIAL_BACKEND = 'http://localhost:5000/vial';
        const DEFAULT_SITE_INDEX = []; // Offline fallback for site_index.json
        const SW_LOCAL_PATH = '/chatbot/sw.js';
        const SW_CDN_PATH_1 = 'https://cdn.jsdelivr.net/gh/webxos/webxos@latest/chatbot/sw.js';
        const SW_CDN_PATH_2 = 'https://unpkg.com/webxos@latest/chatbot/sw.js';

        // Service Worker registration with enhanced error handling
        async function registerServiceWorker() {
            if (!('serviceWorker' in navigator)) {
                const logEntry = logErrorToFile('Service Worker not supported', null, 'navigator.serviceWorker', null);
                displayError('Browser does not support Service Worker', logEntry + '<br>Offline functionality limited.');
                return;
            }
            if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                const logEntry = logErrorToFile('Service Worker requires HTTPS or localhost', null, 'registerServiceWorker', null);
                displayError('Service Worker requires secure context', logEntry + '<br>Use HTTPS or localhost.');
                return;
            }

            async function attemptRegistration(path, retryCount) {
                try {
                    console.log(`Attempting Service Worker registration: ${path} (Retry ${retryCount}/${MAX_RETRIES})`);
                    const registration = await navigator.serviceWorker.register(path, { scope: '/chatbot/' });
                    console.log('Service Worker registered:', registration.scope);
                    swRetries = 0;
                    updateStatus('Success: Service Worker registered.', false);
                    return registration;
                } catch (err) {
                    const isFetchError = err.message.includes('Failed to fetch');
                    const isCorsError = err.message.includes('CORS') || err.message.includes('cross-origin');
                    const is404 = err.message.includes('404');
                    const errorDetails = isFetchError ? 'Likely file not found or network issue.' : isCorsError ? 'CORS policy blocked request.' : is404 ? 'File not found (404).' : err.message;
                    const cfGuidance = path.includes('cdn') ? 'Check CDN availability or repository.' : 'Check Cloudflare page rules and cache for /chatbot/sw.js.';
                    const logEntry = logErrorToFile(
                        `Service Worker registration failed: ${path}`,
                        err,
                        path,
                        null,
                        null,
                        `${errorDetails} ${cfGuidance}`
                    );
                    displayError('Service Worker registration failed', `${logEntry}<br>${errorDetails} Retrying...`);
                    if (retryCount < MAX_RETRIES) {
                        swRetries++;
                        await new Promise(resolve => setTimeout(resolve, Math.pow(2, retryCount) * 1000));
                        return attemptRegistration(path, retryCount + 1);
                    } else if (path === SW_LOCAL_PATH) {
                        console.warn('Local Service Worker failed, trying CDN 1:', SW_CDN_PATH_1);
                        swRetries = 0;
                        return attemptRegistration(SW_CDN_PATH_1, 0);
                    } else if (path === SW_CDN_PATH_1) {
                        console.warn('CDN 1 failed, trying CDN 2:', SW_CDN_PATH_2);
                        swRetries = 0;
                        return attemptRegistration(SW_CDN_PATH_2, 0);
                    } else {
                        const finalLogEntry = logErrorToFile(
                            'Service Worker registration failed after retries',
                            err,
                            path,
                            null,
                            null,
                            `${errorDetails} ${cfGuidance} Ensure /chatbot/sw.js exists and is accessible.`
                        );
                        displayError(
                            'Failed to register Service Worker',
                            `${finalLogEntry}<br>${errorDetails} Run /troubleshoot for guidance.`
                        );
                        throw err;
                    }
                }
            }

            try {
                await attemptRegistration(SW_LOCAL_PATH, 0);
            } catch (err) {
                console.warn('Service Worker registration failed. Proceeding with limited offline support.');
            }
        }

        // Offline detection
        function updateOnlineStatus() {
            isOffline = !navigator.onLine;
            if (isOffline) {
                updateStatus('Offline: Using cached data.', true);
                cachedContent['site_index'] = DEFAULT_SITE_INDEX;
                setAgentsActive(false);
            } else {
                updateStatus('Online: Connecting to backend.', false);
            }
        }
        window.addEventListener('online', updateOnlineStatus);
        window.addEventListener('offline', updateOnlineStatus);

        // Error logging
        function logErrorToFile(message, error, endpoint, response, requestDetails, contentPreview) {
            const stack = error && error.stack ? error.stack : 'No stack trace';
            const timestamp = new Date().toISOString();
            const headers = response && response.headers ? Object.fromEntries(Object.entries(response.headers)) : {};
            const responseDetails = response ? `Status: ${response.status || 'unknown'}, Headers: ${JSON.stringify(headers)}, Response: ${JSON.stringify(response.data || response.statusText || 'No response')}` : 'No response';
            const reqDetails = requestDetails ? `Request: ${JSON.stringify(requestDetails)}` : 'No request details';
            const content = contentPreview ? `Content Preview: ${contentPreview.slice(0, 500)}` : 'No content preview';
            const logEntry = `[${timestamp}] ${message}\nEndpoint: ${endpoint}\nStack: ${stack}\nResponse: ${responseDetails}\n${reqDetails}\n${content}`;
            console.error(logEntry);
            errorLog.push(logEntry);
            if (!isOffline) {
                fetch('/chatbot/log_error', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ timestamp, message: logEntry })
                }).catch(err => {
                    console.warn('Failed to log error to server: ' + err.message);
                });
            }
            return logEntry;
        }

        // Display error in chatbox
        function displayError(message, details) {
            const messages = document.getElementById('messages');
            messages.innerHTML += `<p class="error-text"><b>Error [${new Date().toLocaleTimeString()}]:</b> ${message}<br><small>${details}</small></p>`;
            messages.scrollTop = messages.scrollHeight;
            updateStatus(`Error: ${message}`, true, details);
        }

        // Fallback neural visuals
        function setAgentsActive(isActive, vials = [], isDNA = false, isGalaxy = false) {
            try {
                if (typeof window.setAgentsActive === 'function') {
                    window.setAgentsActive(isActive, vials, isDNA, isGalaxy);
                    return;
                }
            } catch (e) {
                const logEntry = logErrorToFile('setAgentsActive error', e, 'setAgentsActive', null);
                displayError('Failed to activate neural visuals', logEntry);
            }
            const canvas = document.getElementById('neuralCanvas');
            const ctx = canvas.getContext('2d');
            if (!isActive || isOffline) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                return;
            }
            const colorMap = {
                'vial1': '#ff0',
                'vial2': '#0ff',
                'vial3': '#f0f',
                'vial4': '#f00'
            };
            const fillColor = isDNA ? '#0f0' : isGalaxy ? '#f0f' : (vials.length && colorMap[vials[0]]) ? colorMap[vials[0]] : '#0f0';
            ctx.fillStyle = fillColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            logErrorToFile('Using fallback setAgentsActive: ' + fillColor, null, 'setAgentsActive', null);
        }

        // Load script with retry
        function loadScript(src, retryCount = 0) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.async = true;
                script.onload = () => {
                    console.log('Script loaded: ' + src);
                    scriptRetries = 0;
                    resolve();
                };
                script.onerror = () => {
                    const error = new Error('Failed to load script: ' + src);
                    const logEntry = logErrorToFile('Script load error', error, src, null);
                    if (retryCount < MAX_RETRIES) {
                        scriptRetries++;
                        console.log(`Retrying script load (${retryCount + 1}/${MAX_RETRIES}): ${src}`);
                        setTimeout(() => loadScript(src, retryCount + 1).then(resolve).catch(reject), Math.pow(2, retryCount) * 1000);
                    } else {
                        displayError('Failed to load script after retries', logEntry);
                        reject(error);
                    }
                };
                document.head.appendChild(script);
            });
        }

        // Test backend connectivity
        async function testBackend(endpoint) {
            try {
                const response = await fetch(endpoint, {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' }
                });
                const contentType = response.headers.get('content-type') || 'unknown';
                const headers = {};
                response.headers.forEach((value, key) => { headers[key] = value; });
                const text = await response.text();
                return { status: response.status, data: text, contentType, headers };
            } catch (error) {
                return { status: null, error: error.message, contentType: 'unknown', data: '', headers: {} };
            }
        }

        // Validate JSON
        function isValidJSON(text) {
            if (!text || typeof text !== 'string' || !text.trim()) return false;
            if (text.startsWith('<!DOCTYPE html') || text.startsWith('<html')) return false;
            try {
                JSON.parse(text);
                return true;
            } catch (e) {
                return false;
            }
        }

        // Validate .md file
        function validateMdFile(content, filename) {
            if (!content.includes('## Vial Data')) {
                return { valid: false, reason: `Missing '## Vial Data' section in ${filename}` };
            }
            if (!content.includes('wallet')) {
                return { valid: false, reason: `Missing 'wallet' field in ${filename}` };
            }
            const jsonMatch = content.match(/```json\n([\s\S]*?)\n```/);
            if (!jsonMatch || !jsonMatch[1]) {
                return { valid: false, reason: `Missing or invalid JSON block in ${filename}` };
            }
            try {
                JSON.parse(jsonMatch[1]);
            } catch (e) {
                return { valid: false, reason: `Invalid JSON in ${filename}: ${e.message}` };
            }
            return { valid: true };
        }

        // Check vial agent states
        async function checkVialAgents(vialName) {
            if (isOffline) {
                const logEntry = logErrorToFile('Offline: Cannot check vial agents', null, `${VIAL_BACKEND}/get_agents`, null);
                displayError('Offline: Cannot verify vial agents', logEntry);
                return false;
            }
            try {
                const response = await fetch(`${VIAL_BACKEND}/get_agents`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + authToken
                    }
                });
                if (!response.ok) throw new Error(`Vial agent check failed: ${response.statusText}`);
                const agents = await response.json();
                const isActive = agents[vialName] && agents[vialName].status === 'active';
                if (!isActive) {
                    const logEntry = logErrorToFile(`Vial ${vialName} not active`, null, `${VIAL_BACKEND}/get_agents`, { status: response.status, data: JSON.stringify(agents) });
                    displayError(`Vial ${vialName} is not active`, logEntry);
                }
                return isActive;
            } catch (error) {
                const logEntry = logErrorToFile('Vial agent check error', error, `${VIAL_BACKEND}/get_agents`, { status: error.status, data: error.message });
                displayError(`Failed to check vial ${vialName} status`, logEntry);
                return false;
            }
        }

        // Troubleshoot command
        async function troubleshoot() {
            const messages = document.getElementById('messages');
            messages.innerHTML += `<p class="error-text"><b>Troubleshooting [${new Date().toLocaleTimeString()}]:</b> Starting diagnostics...</p>`;
            let steps = [];

            // Check offline status
            if (isOffline) {
                steps.push('1. Offline: Using cached data. Limited functionality available.');
            } else {
                steps.push('1. Online: Checking backend connectivity.');
            }

            // Check authentication
            if (!isAuthenticated) {
                steps.push('2. Not authenticated. Click "Authenticate" button or run /authenticate.');
            } else {
                steps.push('2. Authenticated with token: ' + authToken.slice(0, 8) + '...');
            }

            // Test /chatbot/ connectivity
            const chatbotResponse = await testBackend('/chatbot/ping');
            if (isOffline) {
                steps.push('3. Offline: Cannot connect to /chatbot/. Using cached responses.');
            } else if (chatbotResponse.status === 200) {
                steps.push('3. /chatbot/ backend connected successfully.');
            } else {
                steps.push('3. /chatbot/ backend not connected. Ensure server.py is running on port 5001.');
                logErrorToFile('Chatbot backend ping failed', null, '/chatbot/ping', chatbotResponse, null, chatbotResponse.data.slice(0, 500));
            }

            // Test /vial/ connectivity
            const vialResponse = await testBackend(`${VIAL_BACKEND}/ping`);
            if (isOffline) {
                steps.push('4. Offline: Cannot connect to /vial/. Vial commands disabled.');
            } else if (vialResponse.status === 200) {
                steps.push('4. /vial/ backend connected successfully.');
            } else {
                steps.push('4. /vial/ backend not connected. Ensure vial_server.py is running on port 5000.');
                logErrorToFile('Vial backend ping failed', null, `${VIAL_BACKEND}/ping`, vialResponse, null, vialResponse.data.slice(0, 500));
            }

            // Test /site_index.json
            const indexResponse = await testBackend('/site_index.json');
            const isCloudflare = indexResponse.headers && (indexResponse.headers['server'] === 'cloudflare' || indexResponse.headers['cf-ray']);
            if (isOffline) {
                steps.push('5. Offline: Using default empty site_index.');
            } else if (indexResponse.status === 200) {
                if (!indexResponse.data || !indexResponse.data.trim()) {
                    steps.push('5. /site_index.json returned empty response. Check if file exists on server.');
                    logErrorToFile('Empty response for site_index.json', null, '/site_index.json', indexResponse, { url: '/site_index.json' }, '');
                } else if (indexResponse.data.startsWith('<!DOCTYPE html') || indexResponse.data.startsWith('<html')) {
                    const cfGuidance = isCloudflare ? ' Check Cloudflare page rules and cache settings for /site_index.json.' : '';
                    steps.push(`5. /site_index.json returned HTML instead of JSON. Check server.py routing or Netlify static file configuration.${cfGuidance} Content preview: ${indexResponse.data.slice(0, 500)}`);
                    logErrorToFile('HTML response for site_index.json', null, '/site_index.json', indexResponse, { url: '/site_index.json' }, indexResponse.data.slice(0, 500));
                } else if (indexResponse.contentType.includes('application/json')) {
                    if (isValidJSON(indexResponse.data)) {
                        steps.push('5. /site_index.json loaded successfully with valid JSON.');
                    } else {
                        const preview = indexResponse.data.slice(0, 500);
                        steps.push(`5. /site_index.json loaded but invalid JSON. Content preview: ${preview}`);
                        logErrorToFile('Invalid JSON in site_index.json', null, '/site_index.json', indexResponse, { url: '/site_index.json' }, preview);
                    }
                } else {
                    const cfGuidance = isCloudflare ? ' Check Cloudflare for incorrect caching or page rules.' : '';
                    steps.push(`5. /site_index.json loaded but incorrect content-type: ${indexResponse.contentType}.${cfGuidance} Update server.py to set Content-Type: application/json.`);
                    logErrorToFile('Invalid content-type for site_index.json', null, '/site_index.json', indexResponse, { url: '/site_index.json' }, indexResponse.data.slice(0, 500));
                }
            } else {
                const cfGuidance = isCloudflare ? ' Check Cloudflare proxy settings and DNS configuration.' : '';
                steps.push(`5. Failed to load /site_index.json. Status: ${indexResponse.status || 'unknown'}. Ensure file exists and server.py is running. Check CORS headers.${cfGuidance}`);
                logErrorToFile('Failed to load site_index.json', null, '/site_index.json', indexResponse, { url: '/site_index.json' }, indexResponse.data.slice(0, 500));
            }

            // Test /chatbot/static/neurots.js
            const neurotsResponse = await testBackend('/chatbot/static/neurots.js');
            if (isOffline) {
                steps.push('6. Offline: Using cached neurots.js.');
            } else if (neurotsResponse.status === 200 && neurotsResponse.contentType.includes('javascript')) {
                steps.push('6. /chatbot/static/neurots.js loaded successfully.');
            } else {
                const cfGuidance = isCloudflare ? ' Check Cloudflare cache and page rules for /chatbot/static/neurots.js.' : '';
                steps.push(`6. Failed to load /chatbot/static/neurots.js. Status: ${neurotsResponse.status || 'unknown'}. Ensure file exists in /chatbot/static/.${cfGuidance}`);
                logErrorToFile('Neurots.js load failed', null, '/chatbot/static/neurots.js', neurotsResponse, { url: '/chatbot/static/neurots.js' }, neurotsResponse.data.slice(0, 500));
            }

            // Test Service Worker
            if (!navigator.serviceWorker.controller) {
                const cfGuidance = isCloudflare ? ' Check Cloudflare page rules and cache settings for /chatbot/sw.js.' : '';
                steps.push(`7. Service Worker not active. Ensure /chatbot/sw.js exists and is accessible. Verify path and MIME type (application/javascript).${cfGuidance}`);
                steps.push('7.1. Check local path: /chatbot/sw.js (https://webxos.netlify.app/chatbot/sw.js).');
                steps.push('7.2. Check CDN 1: ' + SW_CDN_PATH_1);
                steps.push('7.3. Check CDN 2: ' + SW_CDN_PATH_2);
                steps.push('7.4. Ensure Content-Type: application/javascript in server or Netlify config.');
                steps.push('7.5. Verify HTTPS or localhost (Service Workers require secure context).');
                logErrorToFile('Service Worker not active', null, SW_LOCAL_PATH, null);
            } else {
                steps.push('7. Service Worker active and registered. Scope: ' + navigator.serviceWorker.controller.scriptURL);
            }

            // Display steps
            messages.innerHTML += `<p class="error-text"><b>Troubleshooting Steps:</b><br>${steps.join('<br>')}</p>`;
            if (steps.length > 1 && (isOffline || !isAuthenticated || chatbotResponse.status !== 200 || vialResponse.status !== 200 || indexResponse.status !== 200 || !isValidJSON(indexResponse.data) || neurotsResponse.status !== 200 || !navigator.serviceWorker.controller)) {
                let nextActions = [
                    isOffline ? '- Go online to restore full functionality.' : '- Ensure server.py and vial_server.py are running.',
                    '- Verify /site_index.json exists and contains valid JSON (use a JSON validator).',
                    '- Check server.py or Netlify routing for /site_index.json to ensure it serves the correct file.',
                    '- Ensure /chatbot/static/neurots.js exists and is accessible.',
                    '- Ensure /chatbot/sw.js exists at https://webxos.netlify.app/chatbot/sw.js.',
                    '- Verify Content-Type: application/json for /site_index.json and application/javascript for /chatbot/sw.js.',
                    '- Enable CORS headers if needed (Access-Control-Allow-Origin: *).',
                    '- Check CDNs: ' + SW_CDN_PATH_1 + ', ' + SW_CDN_PATH_2,
                    '- Check errorlog.md for details.'
                ];
                if (isCloudflare) {
                    nextActions.push('- Check Cloudflare page rules, cache, and DNS settings for /site_index.json, /chatbot/static/neurots.js, and /chatbot/sw.js.');
                }
                messages.innerHTML += `<p class="error-text"><b>Next Actions:</b><br>${nextActions.join('<br>')}</p>`;
            }
            messages.scrollTop = messages.scrollHeight;
            updateStatus('Troubleshooting completed.', false);
        }

        // Authenticate with exponential backoff
        function authenticate() {
            if (isAuthenticated) {
                updateStatus('Success: Already authenticated.');
                return Promise.resolve(true);
            }
            if (isOffline) {
                const logEntry = logErrorToFile('Offline: Cannot authenticate', null, '/chatbot/authenticate', null);
                displayError('Offline: Authentication unavailable', logEntry);
                return Promise.resolve(false);
            }
            return new Promise((resolve, reject) => {
                function attemptAuth(retryCount) {
                    fetch('/chatbot/authenticate', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ network: networkId, session: 'chatbot_session_' + Date.now() })
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Authentication failed: ${response.statusText} (${response.status})`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        authToken = data.token;
                        isAuthenticated = true;
                        authRetries = 0;
                        updateStatus('Success: Authenticated with backend.');
                        resolve(true);
                    })
                    .catch(error => {
                        authRetries++;
                        const logEntry = logErrorToFile('Authentication error', error, '/chatbot/authenticate', { status: error.status, data: error.message });
                        displayError('Authentication failed', logEntry);
                        if (authRetries < MAX_RETRIES) {
                            setTimeout(() => attemptAuth(authRetries), Math.pow(2, authRetries) * 1000);
                        } else {
                            displayError('Authentication failed after retries', 'Run /troubleshoot for guidance.');
                            reject(error);
                        }
                    });
                }
                attemptAuth(0);
            });
        }

        // Import .md file
        function importVialFile() {
            if (!isAuthenticated) {
                const logEntry = logErrorToFile('Not authenticated for import', null, 'fileInput', null);
                displayError('Not authenticated', 'Click Authenticate button or run /troubleshoot.');
                return;
            }
            if (isOffline) {
                const logEntry = logErrorToFile('Offline: Cannot import files', null, 'fileInput', null);
                displayError('Offline: File import unavailable', logEntry);
                return;
            }
            const fileInput = document.getElementById('fileInput');
            fileInput.click();
        }

        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file || !file.name.endsWith('.md')) {
                const logEntry = logErrorToFile('Invalid file import attempt', null, 'fileInput', null);
                displayError('Invalid file. Please upload a .md file.', logEntry);
                return;
            }
            const reader = new FileReader();
            reader.onload = async function(e) {
                const content = e.target.result;
                const validation = validateMdFile(content, file.name);
                if (!validation.valid) {
                    const logEntry = logErrorToFile('Invalid .md format', null, 'fileInput', null, null, validation.reason);
                    displayError('Invalid .md file', logEntry);
                    return;
                }
                try {
                    const response = await fetch('/chatbot/train_vials', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': 'Bearer ' + authToken
                        },
                        body: JSON.stringify({ network_id: networkId, content, filename: file.name })
                    });
                    if (!response.ok) throw new Error('Import failed: ' + response.statusText);
                    const data = await response.json();
                    updateStatus('Success: Imported ' + file.name + '. Balance: ' + data.balance_earned);
                    const messages = document.getElementById('messages');
                    messages.innerHTML += '<p><b>System:</b> Imported ' + file.name + ' and trained vials.</p>';
                    messages.scrollTop = messages.scrollHeight;
                    activeVials = ['vial1', 'vial2', 'vial3', 'vial4'];
                    setAgentsActive(true, activeVials, false, false);
                } catch (error) {
                    const logEntry = logErrorToFile('Import error', error, '/chatbot/train_vials', { status: error.status, data: error.message });
                    displayError('Import failed', logEntry);
                }
            };
            reader.readAsText(file);
        }

        // Show help menu
        function showHelp() {
            const messages = document.getElementById('messages');
            messages.innerHTML = [
                '<p><b>Commands:</b></p>',
                '<p><b>/help</b> - Show this menu.</p>',
                '<p><b>/clear</b> - Clear chatbox and reset neural dots.</p>',
                '<p><b>/stats</b> - Show indexing and vial stats.</p>',
                '<p><b>/version</b> - Show bot version.</p>',
                '<p><b>/troubleshoot</b> - Diagnose connectivity, authentication, and index issues.</p>',
                '<p><b>/vial1</b> - Activate Vial 1 helix pattern.</p>',
                '<p><b>/vial2</b> - Activate Vial 2 cube pattern.</p>',
                '<p><b>/vial3</b> - Activate Vial 3 torus pattern.</p>',
                '<p><b>/vial4</b> - Activate Vial 4 star pattern.</p>',
                '<p><b>/dna</b> - Activate collaborative DNA-like quantum reasoning network.</p>',
                '<p><b>/galaxy</b> - Activate agentic galaxy web crawl search network.</p>',
                '<p><b>search [term]</b> - Search WebXOS content.</p>',
                isOffline ? '<p class="error-text"><b>Note:</b> Offline mode active. Limited functionality.</p>' : ''
            ].join('');
            messages.scrollTop = messages.scrollHeight;
        }

        // Initialize app
        function initializeApp() {
            if (isInitializing) {
                const logEntry = logErrorToFile('Initialization skipped: Already in progress', null, 'initializeApp', null);
                displayError('Initialization already in progress', logEntry);
                return;
            }
            isInitializing = true;
            updateOnlineStatus();
            const messages = document.getElementById('messages');
            let indexErrors = [];

            function loadSiteIndex() {
                if (isOffline) {
                    cachedContent['site_index'] = DEFAULT_SITE_INDEX;
                    const logEntry = logErrorToFile('Offline: Using default site_index', null, '/site_index.json', null);
                    displayError('Offline: Using empty site index', logEntry);
                    return Promise.resolve();
                }
                return caches.open(CACHE_NAME).then(cache => {
                    return fetch('/site_index.json', { cache: 'no-cache' })
                        .then(response => {
                            const contentType = response.headers.get('content-type') || 'unknown';
                            const headers = {};
                            response.headers.forEach((value, key) => { headers[key] = value; });
                            const isCloudflare = headers['server'] === 'cloudflare' || headers['cf-ray'];
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status} ${response.statusText}`);
                            }
                            return response.text().then(text => {
                                let siteIndex;
                                if (!text || !text.trim()) {
                                    const logEntry = logErrorToFile(
                                        'Empty response for site_index.json',
                                        null,
                                        '/site_index.json',
                                        { status: response.status, headers, data: 'Empty response' },
                                        { url: '/site_index.json', headers: { 'Content-Type': contentType } },
                                        ''
                                    );
                                    throw new Error(`site_index.json returned empty response: ${logEntry}`);
                                }
                                if (text.startsWith('<!DOCTYPE html') || text.startsWith('<html')) {
                                    const cfGuidance = isCloudflare ? ' Likely caused by Cloudflare page rules or caching.' : '';
                                    const logEntry = logErrorToFile(
                                        'HTML response for site_index.json',
                                        null,
                                        '/site_index.json',
                                        { status: response.status, headers, data: 'HTML content received' },
                                        { url: '/site_index.json', headers: { 'Content-Type': contentType } },
                                        text.slice(0, 500)
                                    );
                                    throw new Error(`site_index.json returned HTML: ${logEntry}${cfGuidance}`);
                                }
                                try {
                                    siteIndex = JSON.parse(text);
                                } catch (e) {
                                    throw Object.assign(new Error(`Failed to parse site_index.json: ${e.message}`), { data: text });
                                }
                                if (!contentType.includes('application/json')) {
                                    const cfGuidance = isCloudflare ? ' Check Cloudflare for incorrect caching or page rules.' : '';
                                    const logEntry = logErrorToFile(
                                        'Invalid content-type for site_index.json',
                                        null,
                                        '/site_index.json',
                                        { status: response.status, headers, data: contentType },
                                        { url: '/site_index.json', headers: { 'Content-Type': contentType } },
                                        text.slice(0, 500)
                                    );
                                    displayError(`Warning: Incorrect content-type for site_index.json${cfGuidance}`, logEntry);
                                }
                                if (!siteIndex || !Array.isArray(siteIndex) || siteIndex.length === 0) {
                                    throw new Error('site_index.json is empty or invalid.');
                                }
                                cachedContent['site_index'] = siteIndex;
                                return cache.put('/site_index.json', new Response(JSON.stringify(siteIndex)));
                            });
                        })
                        .then(() => {
                            cachedContent['site_index'].forEach(item => {
                                if (!item.path || !item.source || !item.text || !item.text.keywords || !Array.isArray(item.text.keywords) || item.text.keywords.length === 0) {
                                    indexErrors.push('Invalid content for ' + item.path);
                                }
                            });
                            if (indexErrors.length > 0) {
                                const logEntry = logErrorToFile('Index errors', null, '/site_index.json', { status: null, data: indexErrors.join('; ') });
                                messages.innerHTML += `<p class="error-text"><b>Index Errors:</b> ${indexErrors.join('; ')}</p>`;
                                updateStatus('Warning: Issues during index initialization.', false, indexErrors.join('; '));
                            } else {
                                updateStatus('Success: Indexed ' + cachedContent['site_index'].length + ' files.');
                            }
                        })
                        .catch(error => {
                            return cache.match('/site_index.json').then(cachedIndex => {
                                if (cachedIndex) {
                                    return cachedIndex.json().then(data => {
                                        cachedContent['site_index'] = data;
                                        indexErrors.push('Used cached site_index.json due to: ' + error.message);
                                        messages.innerHTML += `<p class="error-text"><b>Index Errors:</b> ${indexErrors.join('; ')}</p>`;
                                        updateStatus('Warning: Using cached site index.', false, indexErrors.join('; '));
                                    }).catch(e => {
                                        const logEntry = logErrorToFile('Cached index parse error', e, '/site_index.json', null);
                                        displayError('Failed to parse cached index', logEntry);
                                        cachedContent['site_index'] = DEFAULT_SITE_INDEX;
                                    });
                                } else {
                                    const logEntry = logErrorToFile('No cached site_index.json', error, '/site_index.json', null);
                                    displayError('Failed to load site index', logEntry + '<br>Run /troubleshoot for guidance.');
                                    cachedContent['site_index'] = DEFAULT_SITE_INDEX;
                                }
                            });
                        });
                });
            }

            function loadNeurots() {
                if (isOffline) {
                    const logEntry = logErrorToFile('Offline: Using cached neurots.js', null, '/chatbot/static/neurots.js', null);
                    displayError('Offline: Neural visuals limited', logEntry);
                    setAgentsActive(false);
                    return Promise.resolve();
                }
                const cdnUrl = 'https://cdn.jsdelivr.net/gh/webxos/webxos@latest/chatbot/static/neurots.js';
                const localUrl = '/chatbot/static/neurots.js';
                return loadScript(cdnUrl).then(() => {
                    if (typeof window.initNeurots === 'function') {
                        try {
                            initNeurots();
                            console.log('Neurots initialized successfully from CDN');
                            return;
                        } catch (e) {
                            throw new Error('initNeurots failed after loading from CDN: ' + e.message);
                        }
                    } else {
                        throw new Error('initNeurots function not defined after loading from CDN');
                    }
                }).catch(error => {
                    const logEntry = logErrorToFile('CDN neurots.js error', error, cdnUrl, null);
                    console.warn('CDN failed, attempting local neurots.js');
                    return loadScript(localUrl).then(() => {
                        if (typeof window.initNeurots === 'function') {
                            try {
                                initNeurots();
                                console.log('Neurots initialized successfully from local');
                            } catch (e) {
                                throw new Error('initNeurots failed after loading from local: ' + e.message);
                            }
                        } else {
                            throw new Error('initNeurots function not defined after loading from local');
                        }
                    }).catch(error => {
                        const logEntry = logErrorToFile('Local neurots.js error', error, localUrl, null);
                        displayError('Failed to initialize neural dots', logEntry + '<br>Run /troubleshoot for guidance.');
                        setAgentsActive(false);
                    });
                });
            }

            loadSiteIndex().then(() => {
                showHelp();
                return loadNeurots();
            }).then(() => {
                return registerServiceWorker();
            }).catch(error => {
                const logEntry = logErrorToFile('Initialization error', error, 'initializeApp', null);
                displayError('Failed to initialize app', logEntry);
                showHelp();
            }).finally(() => {
                isInitializing = false;
            });
        }

        window.addEventListener('load', initializeApp);

        function updateStatus(message, isError, details = '') {
            const status = document.getElementById('status');
            const timestamp = new Date().toLocaleTimeString();
            status.innerHTML = `<span class="${isError ? 'error' : 'success'}">${message}${isError || details ? '<br><small>Details: ' + details + ' [' + timestamp + ']</small>' : ''}</span>`;
            status.classList.add('show');
            setTimeout(() => { status.classList.remove('show'); }, 3000);
            if (isError || details) {
                logErrorToFile(message, null, 'status', { status: null, data: details });
            }
        }

        function clearChat() {
            const messages = document.getElementById('messages');
            messages.innerHTML = '';
            activeVials = [];
            setAgentsActive(false);
            updateStatus('Success: Chatbox cleared.');
            showHelp();
            messages.scrollTop = messages.scrollHeight;
            if (isAuthenticated && !isOffline) {
                fetch('/chatbot/reset_vials', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + authToken
                    }
                }).catch(error => {
                    const logEntry = logErrorToFile('Reset vials error', error, '/chatbot/reset_vials', { status: error.status, data: error.message });
                    displayError('Failed to reset vials', logEntry);
                });
            }
        }

        function displayResults(results, isGalaxy) {
            const messages = document.getElementById('messages');
            messages.innerHTML += `<p><b>${isGalaxy ? 'Galaxy Search Results' : 'Search Results'}:</b> Found ${results.length} results${isGalaxy ? ' via agentic web crawl.' : '.'}</p>`;
            results.forEach(result => {
                result.matches.forEach(match => {
                    const snippet = match.value.slice(Math.max(0, match.indices[0][0] - 50), match.indices[0][1] + 50);
                    const url = 'https://webxos.netlify.app' + result.item.path;
                    messages.innerHTML += `<p><b>Result (<a href="${url}" target="_blank">${result.item.source}</a>):</b> ...${snippet}...</p>`;
                });
            });
            messages.scrollTop = messages.scrollHeight;
        }

        function galaxySearch(query) {
            if (!isAuthenticated) {
                const logEntry = logErrorToFile('Not authenticated for galaxy search', null, '/chatbot/galaxy_search', null);
                displayError('Please authenticate for galaxy search', 'Run /troubleshoot for guidance.');
                return Promise.resolve([]);
            }
            if (isOffline) {
                const logEntry = logErrorToFile('Offline: Galaxy search unavailable', null, '/chatbot/galaxy_search', null);
                displayError('Offline: Galaxy search disabled', logEntry);
                return Promise.resolve([]);
            }
            return fetch('/chatbot/galaxy_search', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer ' + authToken
                },
                body: JSON.stringify({ query, vials: activeVials })
            })
            .then(response => {
                if (!response.ok) throw new Error('Galaxy search failed: ' + response.statusText);
                return response.json();
            })
            .then(results => {
                return results;
            })
            .catch(error => {
                const logEntry = logErrorToFile('Galaxy search error', error, '/chatbot/galaxy_search', { status: error.status, data: error.message });
                displayError('Galaxy search failed', logEntry);
                return [];
            });
        }

        function dnaReasoning(query) {
            if (!isAuthenticated) {
                const logEntry = logErrorToFile('Not authenticated for DNA mode', null, '/chatbot/dna_reasoning', null);
                displayError('Please authenticate for DNA mode', 'Run /troubleshoot for guidance.');
                return Promise.resolve([]);
            }
            if (isOffline) {
                const logEntry = logErrorToFile('Offline: DNA reasoning unavailable', null, '/chatbot/dna_reasoning', null);
                displayError('Offline: DNA reasoning disabled', logEntry);
                return Promise.resolve([]);
            }
            return fetch('/chatbot/dna_reasoning', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer ' + authToken
                },
                body: JSON.stringify({ query, vials: activeVials })
            })
            .then(response => {
                if (!response.ok) throw new Error('DNA reasoning failed: ' + response.statusText);
                return response.json();
            })
            .then(results => {
                return results;
            })
            .catch(error => {
                const logEntry = logErrorToFile('DNA reasoning error', error, '/chatbot/dna_reasoning', { status: error.status, data: error.message });
                displayError('DNA reasoning failed', logEntry);
                return [];
            });
        }

        function searchQuery() {
            const query = document.getElementById('userInput').value.trim().toLowerCase();
            const messages = document.getElementById('messages');
            const loading = document.getElementById('loading');
            if (!query) {
                const logEntry = logErrorToFile('Empty input', null, 'searchQuery', null);
                displayError('Empty input', 'Please enter a search term or /vial1-4, /dna, /galaxy, /troubleshoot.');
                return;
            }
            let colorClass = '';
            if (query.startsWith('/vial1')) colorClass = 'vial1-color';
            else if (query.startsWith('/vial2')) colorClass = 'vial2-color';
            else if (query.startsWith('/vial3')) colorClass = 'vial3-color';
            else if (query.startsWith('/vial4')) colorClass = 'vial4-color';
            messages.innerHTML += `<p class="${colorClass}"><b>You:</b> ${query}</p>`;
            loading.style.display = 'block';

            try {
                if (query.startsWith('/')) {
                    const command = query.split(' ')[0];
                    switch (command) {
                        case '/help':
                            showHelp();
                            updateStatus('Success: Help menu displayed.');
                            setAgentsActive(false);
                            break;
                        case '/clear':
                            clearChat();
                            break;
                        case '/stats':
                            const indexedFiles = cachedContent['site_index'] ? cachedContent['site_index'].length : 0;
                            const totalKeywords = cachedContent['site_index'] ? cachedContent['site_index'].reduce((sum, item) => {
                                return sum + (item.text && item.text.keywords ? item.text.keywords.length : 0);
                            }, 0) : 0;
                            messages.innerHTML += `<p><b>Stats:</b> Indexed ${indexedFiles} files with ${totalKeywords} keywords.</p>`;
                            if (isAuthenticated && !isOffline) {
                                fetch('/chatbot/get_vials', {
                                    headers: { 'Authorization': 'Bearer ' + authToken }
                                })
                                .then(response => {
                                    if (!response.ok) throw new Error('Failed to get vial states');
                                    return response.json();
                                })
                                .then(vialStates => {
                                    messages.innerHTML += `<p><b>Vial States:</b> ${JSON.stringify(vialStates)}</p>`;
                                    messages.scrollTop = messages.scrollHeight;
                                })
                                .catch(error => {
                                    const logEntry = logErrorToFile('Get vial states error', error, '/chatbot/get_vials', { status: error.status, data: error.message });
                                    displayError('Failed to get vial states', logEntry);
                                });
                            } else if (isOffline) {
                                messages.innerHTML += '<p class="error-text"><b>Vial States:</b> Unavailable offline.</p>';
                            }
                            updateStatus('Success: Indexing stats displayed.');
                            setAgentsActive(false);
                            break;
                        case '/version':
                            messages.innerHTML += `<p><b>Version:</b> WebXOS Searchbot v${BOT_VERSION}</p>`;
                            updateStatus('Success: Version displayed.');
                            setAgentsActive(false);
                            break;
                        case '/troubleshoot':
                            troubleshoot();
                            break;
                        case '/vial1':
                        case '/vial2':
                        case '/vial3':
                        case '/vial4':
                            if (!isAuthenticated) {
                                const logEntry = logErrorToFile('Not authenticated for vial activation', null, command, null);
                                displayError('Please authenticate to activate vials', 'Run /troubleshoot for guidance.');
                                break;
                            }
                            if (isOffline) {
                                const logEntry = logErrorToFile('Offline: Vial activation unavailable', null, command, null);
                                displayError('Offline: Vial activation disabled', logEntry);
                                break;
                            }
                            const vialName = command.slice(1);
                            checkVialAgents(vialName).then(isActive => {
                                if (isActive) {
                                    activeVials = [vialName];
                                    console.log('Activating ' + vialName.toUpperCase());
                                    setAgentsActive(true, [vialName], false, false);
                                    messages.innerHTML += `<p class="${vialName}-color"><b>${vialName.toUpperCase()}:</b> ${vialName.toUpperCase()} pattern activated.</p>`;
                                    updateStatus('Success: ' + vialName.toUpperCase() + ' activated.');
                                }
                            });
                            break;
                        case '/dna':
                            if (!isAuthenticated) {
                                const logEntry = logErrorToFile('Not authenticated for DNA mode', null, '/chatbot/dna_reasoning', null);
                                displayError('Please authenticate for DNA mode', 'Run /troubleshoot for guidance.');
                                break;
                            }
                            if (isOffline) {
                                const logEntry = logErrorToFile('Offline: DNA mode unavailable', null, '/chatbot/dna_reasoning', null);
                                displayError('Offline: DNA mode disabled', logEntry);
                                break;
                            }
                            activeVials = ['vial1', 'vial2', 'vial3', 'vial4'];
                            Promise.all(activeVials.map(checkVialAgents)).then(results => {
                                if (results.every(r => r)) {
                                    setAgentsActive(true, activeVials, true, false);
                                    messages.innerHTML += '<p><b>System:</b> Collaborative DNA-like quantum reasoning network activated.</p>';
                                    dnaReasoning(query.split(' ').slice(1).join(' ')).then(results => {
                                        if (results.length > 0) {
                                            messages.innerHTML += `<p><b>DNA Reasoning Results:</b> ${results.join('<br>')}</p>`;
                                            messages.scrollTop = messages.scrollHeight;
                                        }
                                    });
                                    updateStatus('Success: DNA activated.');
                                }
                            });
                            break;
                        case '/galaxy':
                            if (!isAuthenticated) {
                                const logEntry = logErrorToFile('Not authenticated for galaxy mode', null, '/chatbot/galaxy_search', null);
                                displayError('Please authenticate for galaxy mode', 'Run /troubleshoot for guidance.');
                                break;
                            }
                            if (isOffline) {
                                const logEntry = logErrorToFile('Offline: Galaxy mode unavailable', null, '/chatbot/galaxy_search', null);
                                displayError('Offline: Galaxy mode disabled', logEntry);
                                break;
                            }
                            activeVials = ['vial1', 'vial2', 'vial3', 'vial4'];
                            Promise.all(activeVials.map(checkVialAgents)).then(results => {
                                if (results.every(r => r)) {
                                    setAgentsActive(true, activeVials, false, true);
                                    messages.innerHTML += '<p><b>System:</b> Agentic galaxy search network activated.</p>';
                                    galaxySearch(query.split(' ').slice(1).join(' ')).then(results => {
                                        displayResults(results, true);
                                    });
                                    updateStatus('Success: Galaxy activated.');
                                }
                            });
                            break;
                        default:
                            messages.innerHTML += `<p class="error-text"><b>Error:</b> Unknown command "${command}". Type /help for commands.</p>`;
                            updateStatus('Error: Unknown command.', true);
                            setAgentsActive(false);
                    }
                } else {
                    let results;
                    if (activeVials.length > 0 && query && isAuthenticated && !isOffline) {
                        results = galaxySearch(query);
                    } else {
                        const fuse = new Fuse(cachedContent['site_index'] || [], {
                            keys: ['text.content', 'text.keywords'],
                            threshold: 0.4,
                            includeMatches: true
                        });
                        results = Promise.resolve(fuse.search(query));
                    }
                    results.then(data => {
                        if (data.length === 0) {
                            messages.innerHTML += `<p><b>Search Result:</b> No results found for "${query}". Try a different query.</p>`;
                            updateStatus('Success: Search completed. No results found.');
                        } else {
                            displayResults(data, activeVials.length > 0 && isAuthenticated);
                            updateStatus('Success: Search completed. Found ' + data.length + ' results.');
                        }
                        setAgentsActive(false);
                    })
                    .catch(error => {
                        const logEntry = logErrorToFile('Search error', error, 'searchQuery', { status: error.status, data: error.message });
                        displayError('Search failed', logEntry);
                        setAgentsActive(false);
                    })
                    .finally(() => {
                        loading.style.display = 'none';
                        document.getElementById('userInput').value = '';
                        messages.scrollTop = messages.scrollHeight;
                    });
                }
            } catch (error) {
                const logEntry = logErrorToFile('Search error', error, 'searchQuery', { status: error.status, data: error.message });
                displayError('Search failed', logEntry);
                setAgentsActive(false);
                loading.style.display = 'none';
                document.getElementById('userInput').value = '';
                messages.scrollTop = messages.scrollHeight;
            }
        }

        document.getElementById('userInput').addEventListener('keydown', event => {
            if (event.key === 'Enter') {
                event.preventDefault();
                searchQuery();
            }
        });
        document.getElementById('searchButton').addEventListener('click', () => {
            console.log('Search button clicked');
            searchQuery();
        });
        document.getElementById('clearButton').addEventListener('click', () => {
            console.log('Clear button clicked');
            clearChat();
        });
        document.getElementById('authButton').addEventListener('click', () => {
            console.log('Auth button clicked');
            authenticate();
        });
        document.getElementById('importButton').addEventListener('click', () => {
            console.log('Import button clicked');
            importVialFile();
        });
        document.getElementById('fileInput').addEventListener('change', handleFileImport);
    </script>
</body>
</html>
