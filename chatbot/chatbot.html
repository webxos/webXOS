<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <meta name="description" content="WebXOS Searchbot 2025: Search innovative web apps, AI tools, games, and utilities across the WebXOS platform with neural dot visualization.">
    <meta name="keywords" content="webXOS, searchbot, web applications 2025, AI tools, web games, online utilities, digital solutions, webXOS AI, webXOS search, browser-based tools, innovative web apps, digital experience, web development, AI-powered search, online games, modular web tools, sustainable web solutions, carbon footprint tools, webXOS research, exoskeleton AI technology, green energy, web design, front end, sustainable software, AI, machine learning, eco-friendly tech, web interfaces, user experience, UX design, web technology, AI-driven search, browser-based applications, digital innovation, web utilities, sustainable design, green technology, front-end development, AI applications, web accessibility, interactive web, modern web design, eco-conscious software, AI research, digital transformation, web performance, sustainable digital tools, low-carbon tech, web app development, AI-enhanced tools, online platforms, futuristic web solutions, green computing">
    <meta name="robots" content="index, follow">
    <meta name="author" content="webXOS">
    <meta property="og:title" content="WebXOS Searchbot 2025 - Search Web Apps">
    <meta property="og:description" content="Explore WebXOS Searchbot 2025 for searching innovative web applications, AI tools, and games with neural dot visualization.">
    <meta property="og:url" content="https://webxos.netlify.app/chatbot/chatbot.html">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="webXOS">
    <meta property="og:locale" content="en_US">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@webxos">
    <meta name="twitter:creator" content="@webxos">
    <meta name="twitter:title" content="WebXOS Searchbot 2025 - Search Web Apps">
    <meta name="twitter:description" content="Discover WebXOS Searchbot 2025 for searching innovative web applications and games with neural dot visualization.">
    <link rel="canonical" href="https://webxos.netlify.app/chatbot/chatbot.html">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=OCR-A&display=swap">
    <link rel="stylesheet" href="/chatbot/static/style.css">
    <link rel="manifest" href="/manifest.json">
    <link rel="icon" href="/chatbot/static/icon.png">
    <title>WebXOS Searchbot 2025</title>
</head>
<body>
    <canvas id="neuralCanvas" style="pointer-events: none;"></canvas>
    <h1 class="title">WebXOS Searchbot</h1>
    <div class="input-container">
        <div id="status" class="error-message"></div>
        <div id="chatbox">
            <div id="messages"></div>
            <div class="input-group">
                <input type="text" id="userInput" placeholder="Search WebXOS or /agent1-4 or /mcp...">
                <button id="searchButton">Search</button>
                <button id="clearButton">Clear</button>
            </div>
            <div id="loading" class="loading-spinner"></div>
        </div>
    </div>
    <div id="mcpPopup" class="popup hidden">
        <div class="popup-content mcp-color">
            <canvas id="mcpLeftCanvas" class="mcp-visualizer"></canvas>
            <canvas id="mcpRightCanvas" class="mcp-visualizer"></canvas>
            <button class="close-popup" onclick="closePopup('mcpPopup')">X</button>
            <h2>MCP Control Panel</h2>
            <div id="mcpStats">
                <p><b>Active Agents:</b> <span id="activeAgents">0</span></p>
                <p><b>Task Queue:</b> <span id="taskQueue">0</span></p>
                <p><b>API Calls:</b> <span id="apiCalls">0</span></p>
                <p><b>Errors:</b> <span id="errorCount">0</span></p>
            </div>
            <div id="apiOutputs">
                <h3>API Outputs</h3>
                <div id="agent1Output"></div>
                <div id="agent2Output"></div>
                <div id="agent3Output"></div>
                <div id="agent4Output"></div>
            </div>
            <div class="mcp-controls">
                <button onclick="mcp.handleMCPCommand('status')">Status</button>
                <button onclick="mcp.handleMCPCommand('learn', ['on'])">Learn On</button>
                <button onclick="mcp.handleMCPCommand('learn', ['off'])">Learn Off</button>
                <button onclick="mcp.handleMCPCommand('reset')">Reset</button>
                <button onclick="mcp.handleMCPCommand('visualize', ['workflow'])">Visualize Workflow</button>
                <button onclick="mcp.handleMCPCommand('assign', ['all', 'filter', 'category:games'])">Filter Games</button>
                <button onclick="mcp.handleMCPCommand('assign', ['all', 'cluster'])">Cluster Results</button>
                <button onclick="mcp.handleMCPCommand('assign', ['all', 'respond'])">Generate Response</button>
                <button onclick="mcp.handleMCPCommand('assign', ['all', 'suggest'])">Suggest Queries</button>
                <button onclick="mcp.handleMCPCommand('assign', ['all', 'output'])">Generate API Output</button>
            </div>
        </div>
    </div>
    <div id="agent1Popup" class="popup hidden">
        <div class="popup-content agent1-color">
            <button class="close-popup" onclick="closePopup('agent1Popup')">X</button>
            <h2>Agent1 Configuration</h2>
            <label>API URL: <input type="text" id="agent1ApiUrl" placeholder="https://api.example.com"></label>
            <label>API Key: <input type="text" id="agent1ApiKey" placeholder="Your API Key"></label>
            <label>Credentials: <input type="text" id="agent1Credentials" placeholder="Optional"></label>
            <button onclick="saveAgentConfig('agent1')">Save</button>
        </div>
    </div>
    <div id="agent2Popup" class="popup hidden">
        <div class="popup-content agent2-color">
            <button class="close-popup" onclick="closePopup('agent2Popup')">X</button>
            <h2>Agent2 Configuration</h2>
            <label>API URL: <input type="text" id="agent2ApiUrl" placeholder="https://api.example.com"></label>
            <label>API Key: <input type="text" id="agent2ApiKey" placeholder="Your API Key"></label>
            <label>Credentials: <input type="text" id="agent2Credentials" placeholder="Optional"></label>
            <button onclick="saveAgentConfig('agent2')">Save</button>
        </div>
    </div>
    <div id="agent3Popup" class="popup hidden">
        <div class="popup-content agent3-color">
            <button class="close-popup" onclick="closePopup('agent3Popup')">X</button>
            <h2>Agent3 Configuration</h2>
            <label>API URL: <input type="text" id="agent3ApiUrl" placeholder="https://api.example.com"></label>
            <label>API Key: <input type="text" id="agent1ApiKey" placeholder="Your API Key"></label>
            <label>Credentials: <input type="text" id="agent1Credentials" placeholder="Optional"></label>
            <button onclick="saveAgentConfig('agent3')">Save</button>
        </div>
    </div>
    <div id="agent4Popup" class="popup hidden">
        <div class="popup-content agent4-color">
            <button class="close-popup" onclick="closePopup('agent4Popup')">X</button>
            <h2>Agent4 Configuration</h2>
            <label>API URL: <input type="text" id="agent4ApiUrl" placeholder="https://api.example.com"></label>
            <label>API Key: <input type="text" id="agent4ApiKey" placeholder="Your API Key"></label>
            <label>Credentials: <input type="text" id="agent4Credentials" placeholder="Optional"></label>
            <button onclick="saveAgentConfig('agent4')">Save</button>
        </div>
    </div>
    <footer>
        <div class="copyright">Copyright webXOS 2025</div>
    </footer>
    <script src="/chatbot/static/fuse.min.js"></script>
    <script src="/chatbot/static/sanitize.js"></script>
    <script src="/chatbot/static/mcp.js"></script>
    <script src="/chatbot/static/neurots.js" defer></script>
    <script>
        const CACHE_NAME = 'webxos-searchbot-v20';
        let cachedContent = {};
        const BOT_VERSION = '1.2.0';
        let activeAgents = [];

        function loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.async = true;
                script.onload = () => {
                    console.log(`Script loaded: ${src}`);
                    resolve();
                };
                script.onerror = () => {
                    fetch(src, { method: 'HEAD' })
                        .then(response => {
                            reject(new Error(`Failed to load script: ${src}. Status: ${response.status} ${response.statusText}`));
                        })
                        .catch(() => reject(new Error(`Failed to load script: ${src}. Network error or file not found.`)));
                };
                document.head.appendChild(script);
            });
        }

        function closePopup(popupId) {
            document.getElementById(popupId).classList.add('hidden');
            if (popupId === 'mcpPopup') {
                stopMcpVisualizer();
            }
        }

        function saveAgentConfig(agent) {
            const config = {
                apiUrl: sanitizeInput(document.getElementById(`${agent}ApiUrl`).value),
                apiKey: sanitizeInput(document.getElementById(`${agent}ApiKey`).value),
                credentials: sanitizeInput(document.getElementById(`${agent}Credentials`).value)
            };
            if (!config.apiUrl || !/^https?:\/\//.test(config.apiUrl)) {
                updateStatus('Error: Invalid API URL.', true, 'URL must start with http:// or https://');
                mcp.incrementErrorCount();
                return;
            }
            sessionStorage.setItem(`${agent}Config`, JSON.stringify(config));
            updateStatus(`Success: ${agent} API config saved.`);
            closePopup(`${agent}Popup`);
        }

        function displayApiOutput(agent, output) {
            const outputDiv = document.getElementById(`${agent}Output`);
            if (output.error) {
                outputDiv.innerHTML = `<p class="${agent}-color"><b>${agent.toUpperCase()} Output:</b> Error - ${sanitizeInput(output.error)}</p>`;
            } else {
                const blob = new Blob([JSON.stringify(output, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                outputDiv.innerHTML = `<p class="${agent}-color"><b>${agent.toUpperCase()} Output:</b> <a href="${url}" download="${agent}_output.json">Download JSON</a> | <a href="/.netlify/functions/output?agent=${agent}" target="_blank">API Endpoint</a></p>`;
            }
        }

        window.addEventListener('load', async () => {
            const messages = document.getElementById('messages');
            try {
                const cache = await caches.open(CACHE_NAME);
                let indexErrors = [];
                try {
                    const response = await fetch('/site_index.json', { cache: 'no-cache' });
                    if (!response.ok) throw new Error(`HTTP ${response.status} ${response.statusText}. Ensure site_index.json is in root.`);
                    const siteIndex = await response.json();
                    if (!siteIndex || !Array.isArray(siteIndex) || siteIndex.length === 0) {
                        throw new Error('site_index.json is empty or invalid.');
                    }
                    await cache.put('/site_index.json', new Response(JSON.stringify(siteIndex)));
                    cachedContent['site_index'] = siteIndex;
                    siteIndex.forEach(item => {
                        if (!item.path || !item.source || !item.text || !item.text.keywords || !Array.isArray(item.text.keywords) || item.text.keywords.length === 0) {
                            indexErrors.push(`Invalid content for ${item.path}`);
                        }
                    });
                } catch (error) {
                    const cachedIndex = await cache.match('/site_index.json');
                    if (cachedIndex) {
                        cachedContent['site_index'] = await cachedIndex.json();
                        indexErrors.push(`Used cached site_index.json due to: ${error.message}`);
                    } else {
                        indexErrors.push(`Failed to fetch site_index.json: ${error.message}`);
                    }
                }
                if (indexErrors.length > 0) {
                    messages.innerHTML += `<p><b>Index Errors:</b> ${indexErrors.join('; ')}</p>`;
                    updateStatus('Warning: Issues during index initialization.', false, indexErrors.join('; '));
                } else {
                    updateStatus(`Success: Indexed ${cachedContent['site_index'].length} files.`);
                }
            } catch (error) {
                messages.innerHTML += `<p><b>Index Error:</b> ${error.message}</p>`;
                updateStatus('Error: Failed to initialize index.', true, error.stack || error.message);
                mcp.incrementErrorCount();
            }

            try {
                await loadScript('/chatbot/static/neurots.js');
                if (typeof window.initNeurots === 'function') {
                    initNeurots();
                    console.log('Neurots initialized successfully');
                } else {
                    console.warn('initNeurots not defined, attempting fallback');
                    await loadScript('https://cdn.jsdelivr.net/gh/webxos/webxos@latest/chatbot/static/neurots.js');
                    if (typeof window.initNeurots === 'function') {
                        initNeurots();
                        console.log('Neurots initialized successfully from CDN');
                    } else {
                        throw new Error('initNeurots function not defined after loading neurots.js from CDN');
                    }
                }
            } catch (error) {
                console.error('Neurots initialization failed:', error);
                messages.innerHTML += `<p><b>Error:</b> Failed to initialize neural dots. ${error.message}</p>`;
                updateStatus('Error: Neural dots failed to initialize.', true, error.stack || error.message);
                mcp.incrementErrorCount();
            }

            const userInput = document.getElementById('userInput');
            const searchButton = document.getElementById('searchButton');
            const clearButton = document.getElementById('clearButton');
            userInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    searchQuery();
                }
            });
            searchButton.addEventListener('click', () => {
                console.log('Search button clicked');
                searchQuery();
            });
            clearButton.addEventListener('click', () => {
                console.log('Clear button clicked');
                clearChat();
            });
        });

        function updateStatus(message, isError = false, details = '') {
            const status = document.getElementById('status');
            const timestamp = new Date().toLocaleTimeString();
            status.innerHTML = `<span class="${isError ? 'error' : 'success'}">${message}${isError || details ? `<br><small>Details: ${details} [${timestamp}]</small>` : ''}</span>`;
            status.classList.add('show');
            setTimeout(() => status.classList.remove('show'), 3000);
        }

        function clearChat() {
            const messages = document.getElementById('messages');
            messages.innerHTML = '';
            activeAgents = [];
            setAgentsActive(false);
            updateStatus('Success: Chatbox cleared.');
            messages.scrollTop = messages.scrollHeight;
            document.getElementById('agent1Output').innerHTML = '';
            document.getElementById('agent2Output').innerHTML = '';
            document.getElementById('agent3Output').innerHTML = '';
            document.getElementById('agent4Output').innerHTML = '';
        }

        function displayResults(results) {
            const messages = document.getElementById('messages');
            messages.innerHTML += `<p><b>Search Results:</b> Found ${results.length} results.</p>`;
            results.forEach(({ item, matches }) => {
                matches.forEach(match => {
                    const snippet = match.value.slice(Math.max(0, match.indices[0][0] - 50), match.indices[0][1] + 50);
                    const url = `https://webxos.netlify.app${item.path}`;
                    messages.innerHTML += `<p><b>Result (<a href="${url}" target="_blank">${item.source}</a>):</b> ...${sanitizeInput(snippet)}...</p>`;
                });
            });
            messages.scrollTop = messages.scrollHeight;
        }

        async function searchQuery() {
            const query = sanitizeInput(document.getElementById('userInput').value.trim().toLowerCase());
            const messages = document.getElementById('messages');
            const loading = document.getElementById('loading');
            if (!query) {
                updateStatus('Error: Empty input.', true, 'Please enter a search term or /agent1-4 or /mcp.');
                mcp.incrementErrorCount();
                return;
            }
            let colorClass = '';
            if (query.startsWith('/agent1')) colorClass = 'agent1-color';
            else if (query.startsWith('/agent2')) colorClass = 'agent2-color';
            else if (query.startsWith('/agent3')) colorClass = 'agent3-color';
            else if (query.startsWith('/agent4')) colorClass = 'agent4-color';
            else if (query.startsWith('/mcp')) colorClass = 'mcp-color';
            messages.innerHTML += `<p class="${colorClass}"><b>You:</b> ${query}</p>`;
            loading.style.display = 'block';

            try {
                if (query.startsWith('/')) {
                    const [command, ...args] = query.split(' ');
                    if (command === '/mcp') {
                        document.getElementById('mcpPopup').classList.remove('hidden');
                        startMcpVisualizer();
                        const mcpCommand = args[0] || 'status';
                        const mcpArgs = args.slice(1);
                        messages.innerHTML += mcp.handleMCPCommand(mcpCommand, mcpArgs);
                        updateStatus(`Success: MCP command ${mcpCommand} executed.`);
                    } else if (command.match(/^\/agent[1-4]$/)) {
                        const agent = command.slice(1);
                        document.getElementById(`${agent}Popup`).classList.remove('hidden');
                        messages.innerHTML += `<p class="${agent}-color"><b>${agent.toUpperCase()}:</b> Configuration popup opened.</p>`;
                        updateStatus(`Success: ${agent.toUpperCase()} configuration opened.`);
                    } else {
                        switch (command) {
                            case '/help':
                                messages.innerHTML += `
                                    <p><b>WebXOS Searchbot Help:</b></p>
                                    <p><b>Overview:</b> Searchbot 2025 uses 4 agents to search WebXOS content and external APIs. Agents collaborate via a quantum-inspired neural network, visualized as neural dots.</p>
                                    <p><b>Commands:</b></p>
                                    <p><b>/help</b> - Show this menu.</p>
                                    <p><b>/clear</b> - Clear chatbox and reset neural dots.</p>
                                    <p><b>/stats</b> - Show indexing stats.</p>
                                    <p><b>/version</b> - Show bot version.</p>
                                    <p><b>/agent1-4</b> - Open agent configuration popup to set API URL, key, and credentials.</p>
                                    <p><b>/mcp [command]</b> - Open MCP panel to control agents (commands: status, assign, chain, learn, reset, visualize, filter, cluster, respond, suggest, output).</p>
                                    <p><b>search [term]</b> - Search WebXOS content in site_index.json.</p>
                                    <p><b>Agent Tasks:</b> Process (search + API data), Fetch (API calls), Summarize (shorten data), Visualize (neural canvas), Filter (by metadata), Cluster (group results), Respond (conversational reply), Validate (check syntax), Suggest (autocomplete), Output (generate API JSON).</p>
                                    <p><b>MCP Usage:</b> Type /mcp to open the control panel. Use buttons to assign tasks, view API outputs, or manage agents. Outputs are downloadable or accessible via /.netlify/functions/output?agent=[agent].</p>
                                    <p><b>Usage Guide:</b> Enter a search term or command. Configure agents with /agent1-4. Use /mcp to manage tasks and view API outputs. Check neural dots for agent activity.</p>`;
                                updateStatus('Success: Help menu displayed.');
                                setAgentsActive(false);
                                break;
                            case '/clear':
                                clearChat();
                                break;
                            case '/stats':
                                const indexedFiles = cachedContent['site_index']?.length || 0;
                                const totalKeywords = cachedContent['site_index']?.reduce((sum, item) => sum + (item.text?.keywords?.length || 0), 0) || 0;
                                messages.innerHTML += `<p><b>Stats:</b> Indexed ${indexedFiles} files with ${totalKeywords} keywords.</p>`;
                                updateStatus('Success: Indexing stats displayed.');
                                setAgentsActive(false);
                                break;
                            case '/version':
                                messages.innerHTML += `<p><b>Version:</b> WebXOS Searchbot v${BOT_VERSION}</p>`;
                                updateStatus('Success: Version displayed.');
                                setAgentsActive(false);
                                break;
                            default:
                                messages.innerHTML += `<p><b>Error:</b> Unknown command "${command}". Type /help for commands.</p>`;
                                updateStatus('Error: Unknown command.', true);
                                mcp.incrementErrorCount();
                                setAgentsActive(false);
                        }
                    }
                } else {
                    const fuse = new Fuse(cachedContent['site_index'] || [], {
                        keys: ['text.content', 'text.keywords'],
                        threshold: 0.4,
                        includeMatches: true
                    });
                    const results = fuse.search(query);
                    if (results.length === 0) {
                        messages.innerHTML += `<p><b>Search Result:</b> No results found for "${query}". Try a different query.</p>`;
                        updateStatus('Success: Search completed. No results found.');
                    } else {
                        displayResults(results);
                        updateStatus(`Success: Search completed. Found ${results.length} results.`);
                    }
                    setAgentsActive(false);
                    mcp.dispatchTask('all', 'process', { query, results });
                }
            } catch (error) {
                messages.innerHTML += `<p><b>Error:</b> ${error.message}</p>`;
                updateStatus('Error: Search failed.', true, error.stack || error.message);
                mcp.incrementErrorCount();
            } finally {
                loading.style.display = 'none';
                document.getElementById('userInput').value = '';
                messages.scrollTop = messages.scrollHeight;
            }
        }
    </script>
</body>
</html>
