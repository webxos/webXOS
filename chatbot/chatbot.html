<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <meta name="description" content="WebXOS Searchbot 2025: Search innovative web apps, AI tools, games, and utilities across the WebXOS platform with neural dot visualization.">
    <meta name="keywords" content="webXOS, searchbot, web applications 2025, AI tools, web games, online utilities, digital solutions, webXOS AI, webXOS search, browser-based tools, innovative web apps, digital experience, web development, AI-powered search, online games, modular web tools, sustainable web solutions, carbon footprint tools, webXOS research, exoskeleton AI technology, green energy, web design, front end, sustainable software, AI, machine learning, eco-friendly tech, web interfaces, user experience, UX design, web technology, AI-driven search, browser-based applications, digital innovation, web utilities, sustainable design, green technology, front-end development, AI applications, web accessibility, interactive web, modern web design, eco-conscious software, AI research, digital transformation, web performance, sustainable digital tools, low-carbon tech, web app development, AI-enhanced tools, online platforms, futuristic web solutions, green computing">
    <meta name="robots" content="index, follow">
    <meta name="author" content="webXOS">
    <meta property="og:title" content="WebXOS Searchbot 2025 - Search Web Apps">
    <meta property="og:description" content="Explore WebXOS Searchbot 2025 for searching innovative web applications, AI tools, and games with neural dot visualization.">
    <meta property="og:url" content="https://webxos.netlify.app/chatbot/chatbot.html">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="webXOS">
    <meta property="og:locale" content="en_US">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@webxos">
    <meta name="twitter:creator" content="@webxos">
    <meta name="twitter:title" content="WebXOS Searchbot 2025 - Search Web Apps">
    <meta name="twitter:description" content="Discover WebXOS Searchbot 2025 for searching innovative web applications and games with neural dot visualization.">
    <link rel="canonical" href="https://webxos.netlify.app/chatbot/chatbot.html">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Orbitron:wght@400;700&family=VT323&display=swap">
    <link rel="stylesheet" href="/chatbot/static/style.css">
    <link rel="manifest" href="/manifest.json">
    <link rel="icon" href="/chatbot/static/icon.png">
    <title>WebXOS Searchbot 2025</title>
</head>
<body>
    <canvas id="neuralCanvas" style="pointer-events: none;"></canvas>
    <div class="container">
        <h1 class="title">WebXOS Searchbot</h1>
        <div id="chatbox">
            <div id="messages"></div>
            <div class="input-group">
                <input type="text" id="userInput" placeholder="Search WebXOS or /agent1-4...">
                <button id="searchButton">Go</button>
            </div>
            <div id="pagination" class="pagination-group"></div>
            <div id="loading" class="loading-spinner"></div>
        </div>
    </div>
    <div id="status" class="status-bar"></div>
    <div class="copyright">Copyright webXOS 2025</div>
    <script src="/chatbot/static/fuse.min.js"></script>
    <script src="/chatbot/static/neurots.js" defer></script>
    <script>
        const CACHE_NAME = 'webxos-searchbot-v16';
        let cachedContent = {};
        const BOT_VERSION = '1.1.6';
        const RESULTS_PER_PAGE = 5;
        let currentPage = 0;
        let currentResults = [];
        let activeAgents = [];

        // Load script with detailed error handling
        function loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.async = true;
                script.onload = () => {
                    console.log(`Script loaded: ${src}`);
                    resolve();
                };
                script.onerror = () => {
                    fetch(src, { method: 'HEAD' })
                        .then(response => {
                            reject(new Error(`Failed to load script: ${src}. Status: ${response.status} ${response.statusText}`));
                        })
                        .catch(() => reject(new Error(`Failed to load script: ${src}. Network error or file not found.`)));
                };
                document.head.appendChild(script);
            });
        }

        // Initialize cache and neurots
        window.addEventListener('load', async () => {
            const messages = document.getElementById('messages');
            try {
                const cache = await caches.open(CACHE_NAME);
                let indexErrors = [];
                try {
                    const response = await fetch('/site_index.json', { cache: 'no-cache' });
                    if (!response.ok) throw new Error(`HTTP ${response.status} ${response.statusText}. Ensure site_index.json is in root.`);
                    const siteIndex = await response.json();
                    if (!siteIndex || !Array.isArray(siteIndex) || siteIndex.length === 0) {
                        throw new Error('site_index.json is empty or invalid.');
                    }
                    await cache.put('/site_index.json', new Response(JSON.stringify(siteIndex)));
                    cachedContent['site_index'] = siteIndex;
                    siteIndex.forEach(item => {
                        if (!item.path || !item.source || !item.text || !item.text.keywords || !Array.isArray(item.text.keywords) || item.text.keywords.length === 0) {
                            indexErrors.push(`Invalid content for ${item.path}`);
                        }
                    });
                } catch (error) {
                    const cachedIndex = await cache.match('/site_index.json');
                    if (cachedIndex) {
                        cachedContent['site_index'] = await cachedIndex.json();
                        indexErrors.push(`Used cached site_index.json due to: ${error.message}`);
                    } else {
                        indexErrors.push(`Failed to fetch site_index.json: ${error.message}`);
                    }
                }
                if (indexErrors.length > 0) {
                    messages.innerHTML += `<p><b>Index Errors:</b> ${indexErrors.join('; ')}</p>`;
                    updateStatus('Warning: Issues during index initialization.', false, indexErrors.join('; '));
                } else {
                    updateStatus(`Success: Indexed ${cachedContent['site_index'].length} files.`);
                }
            } catch (error) {
                messages.innerHTML += `<p><b>Index Error:</b> ${error.message}</p>`;
                updateStatus('Error: Failed to initialize index.', true, error.stack || error.message);
            }

            // Load neurots.js with fallback
            try {
                await loadScript('/chatbot/static/neurots.js');
                if (typeof window.initNeurots === 'function') {
                    initNeurots();
                    console.log('Neurots initialized successfully');
                } else {
                    console.warn('initNeurots not defined, attempting fallback');
                    await loadScript('https://cdn.jsdelivr.net/gh/webxos/webxos@latest/chatbot/static/neurots.js');
                    if (typeof window.initNeurots === 'function') {
                        initNeurots();
                        console.log('Neurots initialized successfully from CDN');
                    } else {
                        throw new Error('initNeurots function not defined after loading neurots.js from CDN');
                    }
                }
            } catch (error) {
                console.error('Neurots initialization failed:', error);
                messages.innerHTML += `<p><b>Error:</b> Failed to initialize neural dots. ${error.message}</p>`;
                updateStatus('Error: Neural dots failed to initialize.', true, error.stack || error.message);
            }

            // Add UI event listeners with debug logging
            const userInput = document.getElementById('userInput');
            const searchButton = document.getElementById('searchButton');
            userInput.addEventListener('keydown', (event) => {
                console.log('Keydown event on userInput:', event.key);
                if (event.key === 'Enter') {
                    event.preventDefault();
                    searchQuery();
                }
            });
            searchButton.addEventListener('click', () => {
                console.log('Search button clicked');
                searchQuery();
            });
        });

        function updateStatus(message, isError = false, details = '') {
            const status = document.getElementById('status');
            const timestamp = new Date().toLocaleTimeString();
            status.innerHTML = `<span class="${isError ? 'error' : 'success'}">${message}${isError || details ? `<br><small>Details: ${details} [${timestamp}]</small>` : ''}</span>`;
            status.classList.add('show');
            setTimeout(() => status.classList.remove('show'), 7000);
        }

        function displayResults(results) {
            const messages = document.getElementById('messages');
            currentResults = results;
            currentPage = 0;
            const start = currentPage * RESULTS_PER_PAGE;
            const end = Math.min(start + RESULTS_PER_PAGE, results.length);
            messages.innerHTML += `<p><b>Search Results:</b> Found ${results.length} results.</p>`;
            for (let i = start; i < end; i++) {
                const { item, matches } = results[i];
                matches.forEach(match => {
                    const snippet = match.value.slice(Math.max(0, match.indices[0][0] - 50), match.indices[0][1] + 50);
                    const url = `https://webxos.netlify.app${item.path}`;
                    messages.innerHTML += `<p><b>Result (<a href="${url}" target="_blank">${item.source}</a>):</b> ...${snippet}...</p>`;
                });
            }
            updatePaginationControls(results.length);
            messages.scrollTop = messages.scrollHeight;
        }

        function updatePaginationControls(totalResults) {
            const pagination = document.getElementById('pagination');
            const totalPages = Math.ceil(totalResults / RESULTS_PER_PAGE);
            pagination.innerHTML = `
                <button id="prevPage" ${currentPage === 0 ? 'disabled' : ''}>Previous</button>
                <span>Page ${currentPage + 1} of ${totalPages}</span>
                <button id="nextPage" ${currentPage >= totalPages - 1 ? 'disabled' : ''}>Next</button>`;
            document.getElementById('prevPage')?.addEventListener('click', () => {
                console.log('Previous button clicked');
                if (currentPage > 0) {
                    currentPage--;
                    showPage(currentResults);
                }
            });
            document.getElementById('nextPage')?.addEventListener('click', () => {
                console.log('Next button clicked');
                if (currentPage < Math.ceil(totalResults / RESULTS_PER_PAGE) - 1) {
                    currentPage++;
                    showPage(currentResults);
                }
            });
        }

        function showPage(results) {
            const messages = document.getElementById('messages');
            const start = currentPage * RESULTS_PER_PAGE;
            const end = Math.min(start + RESULTS_PER_PAGE, results.length);
            messages.innerHTML = `<p><b>Search Results:</b> Found ${results.length} results.</p>`;
            for (let i = start; i < end; i++) {
                const { item, matches } = results[i];
                matches.forEach(match => {
                    const snippet = match.value.slice(Math.max(0, match.indices[0][0] - 50), match.indices[0][1] + 50);
                    const url = `https://webxos.netlify.app${item.path}`;
                    messages.innerHTML += `<p><b>Result (<a href="${url}" target="_blank">${item.source}</a>):</b> ...${snippet}...</p>`;
                });
            }
            updatePaginationControls(results.length);
            messages.scrollTop = messages.scrollHeight;
        }

        async function searchQuery() {
            const query = document.getElementById('userInput').value.trim().toLowerCase();
            const messages = document.getElementById('messages');
            const loading = document.getElementById('loading');
            if (!query) {
                updateStatus('Error: Empty input.', true, 'Please enter a search term or /agent1-4.');
                return;
            }
            let colorClass = '';
            if (query.startsWith('/agent1')) colorClass = 'agent1-color';
            else if (query.startsWith('/agent2')) colorClass = 'agent2-color';
            else if (query.startsWith('/agent3')) colorClass = 'agent3-color';
            else if (query.startsWith('/agent4')) colorClass = 'agent4-color';
            messages.innerHTML += `<p class="${colorClass}"><b>You:</b> ${query}</p>`;
            loading.style.display = 'block';
            setAgentsActive(false);

            try {
                // Handle commands
                if (query.startsWith('/')) {
                    const [command, ...args] = query.split(' ');
                    const argString = args.join(' ');
                    switch (command) {
                        case '/help':
                            messages.innerHTML += `
                                <p><b>Commands:</b></p>
                                <p><b>/help</b> - Show this menu.</p>
                                <p><b>/clear</b> - Clear chatbox.</p>
                                <p><b>/stats</b> - Show indexing stats.</p>
                                <p><b>/version</b> - Show bot version.</p>
                                <p><b>/agent1-4</b> - Activate specific agent and dot animation.</p>
                                <p><b>search [term]</b> - Search WebXOS content.</p>`;
                            updateStatus('Success: Help menu displayed.');
                            break;
                        case '/clear':
                            messages.innerHTML = '';
                            updateStatus('Success: Chatbox cleared.');
                            break;
                        case '/stats':
                            const indexedFiles = cachedContent['site_index']?.length || 0;
                            const totalKeywords = cachedContent['site_index']?.reduce((sum, item) => sum + (item.text?.keywords?.length || 0), 0) || 0;
                            messages.innerHTML += `<p><b>Stats:</b> Indexed ${indexedFiles} files with ${totalKeywords} keywords.</p>`;
                            updateStatus('Success: Indexing stats displayed.');
                            break;
                        case '/version':
                            messages.innerHTML += `<p><b>Version:</b> WebXOS Searchbot v${BOT_VERSION}</p>`;
                            updateStatus('Success: Version displayed.');
                            break;
                        case '/agent1':
                        case '/agent2':
                        case '/agent3':
                        case '/agent4':
                            const agentName = command.slice(1).toUpperCase();
                            activeAgents = [agentName];
                            console.log(`Activating ${agentName}`);
                            setAgentsActive(false, agentName.toLowerCase());
                            messages.innerHTML += `<p class="${command.slice(1).toLowerCase()}-color"><b>${agentName}:</b> ${agentName} checking in.</p>`;
                            updateStatus(`Success: ${agentName} activated.`);
                            break;
                        default:
                            messages.innerHTML += `<p><b>Error:</b> Unknown command "${command}". Type /help for commands.</p>`;
                            updateStatus('Error: Unknown command.', true);
                    }
                } else {
                    // Search with Fuse.js
                    const fuse = new Fuse(cachedContent['site_index'] || [], {
                        keys: ['text.content', 'text.keywords'],
                        threshold: 0.4,
                        includeMatches: true
                    });
                    const results = fuse.search(query);
                    if (results.length === 0) {
                        messages.innerHTML += `<p><b>Search Result:</b> No results found for "${query}". Try a different query.</p>`;
                        updateStatus('Success: Search completed. No results found.');
                    } else {
                        displayResults(results);
                        updateStatus(`Success: Search completed. Found ${results.length} results.`);
                    }
                }
            } catch (error) {
                messages.innerHTML += `<p><b>Error:</b> ${error.message}</p>`;
                updateStatus('Error: Search failed.', true, error.stack || error.message);
            } finally {
                loading.style.display = 'none';
                document.getElementById('userInput').value = '';
                messages.scrollTop = messages.scrollHeight;
                if (!query.startsWith('/agent')) {
                    console.log('Resetting all agents after query');
                    setAgentsActive(false);
                }
            }
        }
    </script>
</body>
</html>
