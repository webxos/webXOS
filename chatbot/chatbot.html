<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <meta name="description" content="WebXOS Searchbot 2025: Search innovative web apps, AI tools, games, and utilities across the WebXOS platform with neural dot visualization.">
    <meta name="keywords" content="webXOS, searchbot, web applications 2025, AI tools, web games, online utilities, digital solutions, webXOS AI, webXOS search, browser-based tools, innovative web apps, digital experience, web development, AI-powered search, online games, modular web tools, sustainable web solutions, carbon footprint tools, webXOS research, exoskeleton AI technology, green energy, web design, front end, sustainable software, AI, machine learning, eco-friendly tech, web interfaces, user experience, UX design, web technology, AI-driven search, browser-based applications, digital innovation, web utilities, sustainable design, green technology, front-end development, AI applications, web accessibility, interactive web, modern web design, eco-conscious software, AI research, digital transformation, web performance, sustainable digital tools, low-carbon tech, web app development, AI-enhanced tools, online platforms, futuristic web solutions, green computing">
    <meta name="robots" content="index, follow">
    <meta name="author" content="webXOS">
    <meta property="og:title" content="WebXOS Searchbot 2025 - Search Web Apps">
    <meta property="og:description" content="Explore WebXOS Searchbot 2025 for searching innovative web applications, AI tools, and games with neural dot visualization.">
    <meta property="og:url" content="https://webxos.netlify.app/chatbot/chatbot.html">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="webXOS">
    <meta property="og:locale" content="en_US">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@webxos">
    <meta name="twitter:creator" content="@webxos">
    <meta name="twitter:title" content="WebXOS Searchbot 2025 - Search Web Apps">
    <meta name="twitter:description" content="Discover WebXOS Searchbot 2025 for searching innovative web applications and games with neural dot visualization.">
    <link rel="canonical" href="https://webxos.netlify.app/chatbot/chatbot.html">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=OCR-A&display=swap">
    <link rel="stylesheet" href="/chatbot/static/style.css">
    <link rel="manifest" href="/manifest.json">
    <link rel="icon" href="/chatbot/static/icon.png">
    <title>WebXOS Searchbot 2025</title>
    <style>
        body {
            background: #000;
            color: #0f0;
            font-family: 'Orbitron', monospace;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #neuralCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        .title {
            font-family: 'OCR-A', monospace;
            font-size: 2.5em;
            text-align: center;
            color: #0f0;
            text-shadow: 0 0 10px #0f0;
            margin: 20px 0;
        }
        .input-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        #chatbox {
            background: rgba(0, 255, 0, 0.1);
            border: 2px solid #0f0;
            padding: 20px;
        }
        #messages {
            max-height: 400px;
            overflow-y: auto;
            padding: 10px;
            background: #000;
            border: 1px solid #0f0;
            margin-bottom: 10px;
        }
        #messages p {
            margin: 5px 0;
            line-height: 1.4;
        }
        .input-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        #userInput {
            flex-grow: 1;
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px;
            font-family: 'OCR-A', monospace;
            font-size: 1em;
        }
        #userInput:focus {
            outline: none;
            box-shadow: 0 0 5px #0f0;
        }
        button {
            background: #0f0;
            color: #000;
            border: none;
            padding: 10px 20px;
            font-family: 'Orbitron', monospace;
            font-size: 1em;
            cursor: pointer;
        }
        button:hover {
            background: #00cc00;
        }
        .error-message {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #000;
            color: #f00;
            padding: 10px;
            display: none;
            max-width: 300px;
        }
        .error-message.show {
            display: block;
        }
        .error { color: #f00; }
        .success { color: #0f0; }
        .agent1-color { color: #ff0; }
        .agent2-color { color: #0ff; }
        .agent3-color { color: #f0f; }
        .agent4-color { color: #f00; }
        .custom-agent-color { color: #00ff00; }
        .loading-spinner {
            display: none;
            text-align: center;
            color: #0f0;
            font-size: 1em;
            margin-top: 10px;
        }
        .loading-spinner::before {
            content: '⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏';
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { content: '⠋'; }
            10% { content: '⠙'; }
            20% { content: '⠹'; }
            30% { content: '⠸'; }
            40% { content: '⠼'; }
            50% { content: '⠴'; }
            60% { content: '⠦'; }
            70% { content: '⠧'; }
            80% { content: '⠇'; }
            90% { content: '⠏'; }
        }
        footer {
            text-align: center;
            color: #0f0;
            font-family: 'Orbitron', monospace;
            margin-top: 20px;
            font-size: 0.9em;
        }
        @media (max-width: 600px) {
            .title { font-size: 1.8em; }
            .input-container { padding: 10px; }
            #chatbox { padding: 10px; }
            #userInput { font-size: 0.9em; }
            button { padding: 8px 16px; font-size: 0.9em; }
        }
    </style>
</head>
<body>
    <canvas id="neuralCanvas" style="pointer-events: none;"></canvas>
    <h1 class="title">WebXOS Searchbot</h1>
    <div class="input-container">
        <div id="status" class="error-message"></div>
        <div id="chatbox">
            <div id="messages"></div>
            <div class="input-group">
                <input type="text" id="userInput" placeholder="Search WebXOS or /agent1-4...">
                <button id="searchButton">Search</button>
                <button id="clearButton">Clear</button>
                <button id="authButton">Authenticate</button>
                <button id="importButton">Import</button>
                <input type="file" id="fileInput" accept=".md" style="display: none;">
            </div>
            <div id="loading" class="loading-spinner"></div>
        </div>
    </div>
    <footer>
        <div class="copyright">Copyright webXOS 2025</div>
    </footer>
    <script src="/chatbot/static/fuse.min.js"></script>
    <script src="/chatbot/static/neurots.js" defer></script>
    <script>
        const CACHE_NAME = 'webxos-searchbot-v25';
        const BOT_VERSION = '1.2.19';
        let cachedContent = { site_index: [] };
        let activeAgents = [];
        let customAgents = {};
        let isOffline = !navigator.onLine;

        // Sanitize input/output to prevent XSS
        function sanitizeInput(input) {
            if (typeof input !== 'string') return '';
            const div = document.createElement('div');
            div.textContent = input;
            return div.innerHTML.replace(/[<>]/g, '');
        }

        // Sanitize JSON response
        function sanitizeResponse(data) {
            if (typeof data === 'string') {
                return data.replace(/[<>"';&]/g, '');
            } else if (typeof data === 'object' && data !== null) {
                return JSON.parse(JSON.stringify(data, (key, value) => 
                    typeof value === 'string' ? sanitizeInput(value) : value
                ));
            }
            return data;
        }

        // IndexedDB for error logging
        let db;
        const dbRequest = indexedDB.open('WebXOSLogs', 1);
        dbRequest.onupgradeneeded = event => {
            db = event.target.result;
            db.createObjectStore('errors', { keyPath: 'timestamp' });
        };
        dbRequest.onsuccess = event => {
            db = event.target.result;
        };

        // Load script with error handling
        function loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.async = true;
                script.onload = () => {
                    console.log(`Script loaded: ${src}`);
                    resolve();
                };
                script.onerror = () => {
                    fetch(src, { method: 'HEAD' })
                        .then(response => reject(new Error(`Failed to load script: ${src}. Status: ${response.status}`)))
                        .catch(() => reject(new Error(`Failed to load script: ${src}. Network error or file not found.`)));
                };
                document.head.appendChild(script);
            });
        }

        // Service Worker registration
        async function registerServiceWorker() {
            if (!('serviceWorker' in navigator)) {
                logError('Service Worker not supported', null, 'navigator.serviceWorker');
                updateStatus('Error: Browser does not support Service Worker.', true, 'Offline functionality limited.');
                return;
            }
            if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                logError('Service Worker requires HTTPS or localhost', null, 'registerServiceWorker');
                updateStatus('Error: Service Worker requires secure context.', true, 'Use HTTPS or localhost.');
                return;
            }

            try {
                const swCheck = await fetch('/chatbot/sw.js', { method: 'HEAD' });
                if (!swCheck.ok) throw new Error(`HTTP ${swCheck.status}: sw.js not found`);
                const registration = await navigator.serviceWorker.register('/chatbot/sw.js', { scope: '/chatbot/' });
                console.log('Service Worker registered:', registration.scope);
                updateStatus('Success: Service Worker registered.', false);
            } catch (err) {
                const errorDetails = err.message.includes('404') ? 'sw.js not found at /chatbot/sw.js.' : err.message.includes('CORS') ? 'CORS policy blocked.' : err.message;
                const guidance = 'Ensure /chatbot/sw.js exists at https://webxos.netlify.app/chatbot/sw.js.';
                logError('Service Worker registration failed', err, '/chatbot/sw.js', null, null, `${errorDetails} ${guidance}`);
                updateStatus('Error: Failed to register Service Worker.', true, `${errorDetails} Check Netlify deploy logs.`);
                isOffline = true;
            }
        }

        // Error logging to IndexedDB
        function logError(message, error, endpoint, response, requestDetails, contentPreview) {
            const stack = error && error.stack ? error.stack : 'No stack trace';
            const timestamp = new Date().toISOString();
            const responseDetails = response ? `Status: ${response.status || 'unknown'}, Response: ${JSON.stringify(response.data || response.statusText || 'No response')}` : 'No response';
            const logEntry = `[${timestamp}] ${message}\nEndpoint: ${endpoint}\nStack: ${stack}\nResponse: ${responseDetails}\nContent Preview: ${contentPreview || 'None'}`;
            console.error(logEntry);
            if (db) {
                const tx = db.transaction(['errors'], 'readwrite');
                tx.objectStore('errors').add({ timestamp, message: logEntry });
            }
            return logEntry;
        }

        // Update status
        function updateStatus(message, isError = false, details = '') {
            const status = document.getElementById('status');
            const timestamp = new Date().toLocaleTimeString();
            status.innerHTML = `<span class="${isError ? 'error' : 'success'}">${sanitizeInput(message)}${isError || details ? `<br><small>Details: ${sanitizeInput(details)} [${timestamp}]</small>` : ''}</span>`;
            status.classList.add('show');
            setTimeout(() => status.classList.remove('show'), 5000);
        }

        // Ping Agent for local authentication
        function pingAgent() {
            const mockResponse = {
                status: 200,
                data: JSON.stringify({ status: 'ok', timestamp: new Date().toISOString() }),
                contentType: 'application/json',
                rawText: JSON.stringify({ status: 'ok', timestamp: new Date().toISOString() })
            };
            console.log('Ping Agent: Using mock response for local authentication');
            return mockResponse;
        }

        // Validate JSON
        function isValidJSON(text) {
            if (!text || typeof text !== 'string' || !text.trim()) return false;
            if (text.startsWith('<!DOCTYPE html') || text.startsWith('<html')) return false;
            try {
                JSON.parse(text);
                return true;
            } catch (e) {
                return false;
            }
        }

        // Parse Markdown with flexible YAML for multiple agents
        function parseMarkdownAgent(mdContent) {
            const yamlMatch = mdContent.match(/^---\n([\s\S]*?)\n---/);
            if (!yamlMatch) {
                logError('Invalid YAML: No front matter found', null, 'parseMarkdownAgent', null, null, mdContent.slice(0, 100));
                return null;
            }
            const yamlContent = yamlMatch[1];
            const lines = yamlContent.split('\n').map(line => line.trim());
            let agents = [];
            let currentAgent = null;
            let errors = [];

            lines.forEach((line, index) => {
                if (!line || !line.includes(':')) return;
                let [key, value] = line.split(':').map(s => s.trim());
                if (!key || !value) {
                    errors.push(`Invalid key-value pair at line ${index + 1}: ${line}`);
                    return;
                }
                key = sanitizeInput(key.toLowerCase());
                value = sanitizeInput(value);

                if (key === 'agents') {
                    currentAgent = null; // Reset for new agents list
                    return;
                }
                if (key === '- name') {
                    currentAgent = { name: value, pattern: '', color: '' };
                    agents.push(currentAgent);
                } else if (currentAgent) {
                    currentAgent[key] = value; // Assign to current agent
                } else {
                    // Handle flat structure or single agent
                    if (['name', 'pattern', 'color'].includes(key)) {
                        if (!currentAgent) {
                            currentAgent = { name: '', pattern: '', color: '' };
                            agents.push(currentAgent);
                        }
                        currentAgent[key] = value;
                    } else {
                        if (!currentAgent) {
                            currentAgent = { name: '', pattern: '', color: '' };
                            agents.push(currentAgent);
                        }
                        currentAgent[key] = value; // Store extra fields
                    }
                }
            });

            // Validate all agents
            const validAgents = [];
            agents.forEach((agent, idx) => {
                if (!agent.name) errors.push(`Agent ${idx + 1}: Missing required field: name`);
                if (!agent.pattern) errors.push(`Agent ${idx + 1}: Missing required field: pattern`);
                if (!agent.color) errors.push(`Agent ${idx + 1}: Missing required field: color`);
                if (agent.name.toLowerCase().startsWith('wallet') || agent.pattern.toLowerCase().includes('wallet')) {
                    errors.push(`Agent ${idx + 1}: Invalid agent: name or pattern contains "wallet"`);
                }
                if (agent.name && agent.pattern && agent.color) {
                    validAgents.push(agent);
                }
            });

            if (errors.length > 0) {
                logError('Invalid agent format', null, 'parseMarkdownAgent', null, null, `Errors: ${errors.join('; ')}\nYAML: ${yamlContent.slice(0, 200)}`);
                return validAgents.length > 0 ? validAgents : null;
            }

            return validAgents.length > 0 ? validAgents : null;
        }

        // Load site index
        async function loadSiteIndex() {
            try {
                const response = await fetch('/site_index.json', { cache: 'no-cache' });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const text = await response.text();
                if (!isValidJSON(text)) {
                    logError('Invalid JSON in site_index.json', null, '/site_index.json', { status: response.status, data: text.slice(0, 500) });
                    updateStatus('Error: Invalid site_index.json.', true, 'Check server configuration.');
                    cachedContent.site_index = [
                        {
                            path: '/example',
                            source: 'Example Page',
                            text: { content: 'This is an example page for testing WebXOS search.', keywords: ['example', 'test', 'webxos'] }
                        }
                    ];
                    return;
                }
                cachedContent.site_index = JSON.parse(text);
                if ('caches' in window) {
                    const cache = await caches.open(CACHE_NAME);
                    await cache.put('/site_index.json', new Response(JSON.stringify(cachedContent.site_index)));
                }
                updateStatus(`Success: Indexed ${cachedContent.site_index.length} files.`, false);
            } catch (error) {
                logError('Failed to load site_index.json', error, '/site_index.json');
                updateStatus('Error: Failed to load site index.', true, 'Using fallback index.');
                cachedContent.site_index = [
                    {
                        path: '/example',
                        source: 'Example Page',
                        text: { content: 'This is an example page for testing WebXOS search.', keywords: ['example', 'test', 'webxos'] }
                    }
                ];
            }
        }

        // Show help menu
        function showHelp() {
            const messages = document.getElementById('messages');
            let customCommands = '';
            Object.keys(customAgents).forEach(agentName => {
                customCommands += `<p><b>/${sanitizeInput(agentName)}</b> - Activate custom ${sanitizeInput(agentName)} pattern.</p>`;
            });
            messages.innerHTML = `
                <p><b>Commands:</b></p>
                <p><b>/help</b> - Show this menu.</p>
                <p><b>/clear</b> - Clear chatbox and reset neural dots.</p>
                <p><b>/stats</b> - Show indexing stats.</p>
                <p><b>/version</b> - Show bot version.</p>
                <p><b>/troubleshoot</b> - Display debug information.</p>
                <p><b>/agent1</b> - Activate Agent 1 helix pattern.</p>
                <p><b>/agent2</b> - Activate Agent 2 cube pattern.</p>
                <p><b>/agent3</b> - Activate Agent 3 torus pattern.</p>
                <p><b>/agent4</b> - Activate Agent 4 star pattern.</p>
                ${customCommands}
                <p><b>/dna</b> - Display collaborative DNA-like agent network.</p>
                <p><b>/galaxy</b> - Display galaxy simulation.</p>
                <p><b>search [term]</b> - Search WebXOS content.</p>`;
            messages.scrollTop = messages.scrollHeight;
        }

        // Troubleshoot command
        function troubleshoot() {
            const messages = document.getElementById('messages');
            const indexedFiles = cachedContent.site_index?.length || 0;
            const totalKeywords = cachedContent.site_index?.reduce((sum, item) => sum + (item.text?.keywords?.length || 0), 0) || 0;
            const customAgentNames = Object.keys(customAgents);
            const neurotsStatus = typeof window.initNeurots === 'function' ? 'Loaded' : 'Not loaded';
            const serviceWorkerStatus = navigator.serviceWorker.controller ? 'Active' : 'Inactive';
            messages.innerHTML += `
                <p><b>Troubleshoot:</b></p>
                <p>Bot Version: ${BOT_VERSION}</p>
                <p>Indexed Files: ${indexedFiles}</p>
                <p>Total Keywords: ${totalKeywords}</p>
                <p>Custom Agents: ${customAgentNames.length > 0 ? customAgentNames.join(', ') : 'None'}</p>
                <p>Neurots.js: ${neurotsStatus}</p>
                <p>Service Worker: ${serviceWorkerStatus}</p>
                <p>Online Status: ${isOffline ? 'Offline' : 'Online'}</p>
                <p>Debug: Check console for detailed logs.</p>`;
            console.log('Troubleshoot Debug:', {
                version: BOT_VERSION,
                indexedFiles,
                totalKeywords,
                customAgents,
                neurotsStatus,
                serviceWorkerStatus,
                isOffline
            });
            updateStatus('Success: Troubleshoot info displayed.', false);
            messages.scrollTop = messages.scrollHeight;
        }

        // Authenticate using ping agent
        async function authenticate() {
            const messages = document.getElementById('messages');
            const loading = document.getElementById('loading');
            loading.style.display = 'block';
            const vialResponse = pingAgent();
            const parsedData = isValidJSON(vialResponse.data) ? JSON.parse(vialResponse.data) : {};
            
            if (vialResponse.status === 200 && isValidJSON(vialResponse.data) && parsedData.status === 'ok') {
                messages.innerHTML += `<p><b>System:</b> Local authentication verified via ping agent.</p>`;
                updateStatus('Success: Connected to chatbot server.', false);
            } else {
                const errorMsg = `Invalid ping agent response (Content: ${sanitizeInput(vialResponse.rawText.slice(0, 100))})`;
                const guidance = 'Check console for ping agent logs. Mock response used.';
                logError('Local authentication failed', new Error(errorMsg), 'pingAgent', vialResponse, null, vialResponse.rawText.slice(0, 500));
                messages.innerHTML += `<p class="error"><b>Error:</b> Failed to authenticate: ${sanitizeInput(errorMsg)}</p>`;
                updateStatus('Error: Local authentication failed.', true, guidance);
            }
            loading.style.display = 'none';
            messages.scrollTop = messages.scrollHeight;
        }

        // Import Markdown file
        function importFile() {
            const fileInput = document.getElementById('fileInput');
            fileInput.click();
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            const messages = document.getElementById('messages');
            if (!file || !file.name.endsWith('.md')) {
                updateStatus('Error: Invalid file.', true, 'Please select a .md file.');
                messages.innerHTML += `<p class="error"><b>Error:</b> Please select a .md file.</p>`;
                return;
            }
            const reader = new FileReader();
            reader.onload = async (e) => {
                const text = sanitizeInput(e.target.result);
                const agents = parseMarkdownAgent(text);
                if (!agents) {
                    updateStatus('Error: Invalid agent format.', true, 'Check console for specific YAML errors (name, pattern, color required).');
                    messages.innerHTML += `<p class="error"><b>Error:</b> Invalid agent format in .md file. Check console for details.</p>`;
                    return;
                }
                agents.forEach(agent => {
                    customAgents[agent.name] = agent;
                    window.customAgents[agent.name] = agent; // Expose to neurots.js
                    messages.innerHTML += `<p><b>System:</b> Imported custom agent: ${sanitizeInput(agent.name)}.</p>`;
                });
                updateStatus(`Success: Imported ${agents.length} agent(s).`, false);
                showHelp();
            };
            reader.readAsText(file);
        }

        // Search query
        async function searchQuery() {
            const query = sanitizeInput(document.getElementById('userInput').value.trim().toLowerCase());
            const messages = document.getElementById('messages');
            const loading = document.getElementById('loading');
            if (!query) {
                updateStatus('Error: Empty input.', true, 'Please enter a search term or /agent1-4.');
                return;
            }
            let colorClass = '';
            if (query.startsWith('/agent1')) colorClass = 'agent1-color';
            else if (query.startsWith('/agent2')) colorClass = 'agent2-color';
            else if (query.startsWith('/agent3')) colorClass = 'agent3-color';
            else if (query.startsWith('/agent4')) colorClass = 'agent4-color';
            else if (query.startsWith('/') && customAgents[query.slice(1)]) colorClass = 'custom-agent-color';
            messages.innerHTML += `<p class="${colorClass}"><b>You:</b> ${sanitizeInput(query)}</p>`;
            loading.style.display = 'block';

            try {
                if (query.startsWith('/')) {
                    const command = query.split(' ')[0];
                    if (['/agent1', '/agent2', '/agent3', '/agent4', '/dna', '/galaxy', '/troubleshoot'].includes(command) || customAgents[command.slice(1)]) {
                        const vialResponse = pingAgent();
                        const parsedData = isValidJSON(vialResponse.data) ? JSON.parse(vialResponse.data) : {};
                        if (vialResponse.status !== 200 || !isValidJSON(vialResponse.data) || parsedData.status !== 'ok') {
                            const errorMsg = `Local ping agent failed (Content: ${sanitizeInput(vialResponse.rawText.slice(0, 100))})`;
                            const guidance = 'Check console for ping agent logs. Mock response used.';
                            updateStatus('Error: Agent feature disabled.', true, `Requires local authentication. ${errorMsg} ${guidance}`);
                            messages.innerHTML += `<p class="error"><b>Error:</b> Agent feature requires local authentication: ${sanitizeInput(errorMsg)}</p>`;
                            setAgentsActive(false);
                            loading.style.display = 'none';
                            return;
                        }
                    }
                    switch (command) {
                        case '/help':
                            showHelp();
                            updateStatus('Success: Help menu displayed.', false);
                            setAgentsActive(false);
                            break;
                        case '/clear':
                            messages.innerHTML = '';
                            activeAgents = [];
                            setAgentsActive(false);
                            updateStatus('Success: Chatbox cleared.', false);
                            showHelp();
                            break;
                        case '/stats':
                            const indexedFiles = cachedContent.site_index?.length || 0;
                            const totalKeywords = cachedContent.site_index?.reduce((sum, item) => sum + (item.text?.keywords?.length || 0), 0) || 0;
                            messages.innerHTML += `<p><b>Stats:</b> Indexed ${indexedFiles} files with ${totalKeywords} keywords.</p>`;
                            updateStatus('Success: Indexing stats displayed.', false);
                            setAgentsActive(false);
                            break;
                        case '/version':
                            messages.innerHTML += `<p><b>Version:</b> WebXOS Searchbot v${BOT_VERSION}</p>`;
                            updateStatus('Success: Version displayed.', false);
                            setAgentsActive(false);
                            break;
                        case '/troubleshoot':
                            troubleshoot();
                            setAgentsActive(false);
                            break;
                        case '/agent1':
                        case '/agent2':
                        case '/agent3':
                        case '/agent4':
                            activeAgents = [command.slice(1)];
                            setAgentsActive(true, activeAgents, false, false);
                            messages.innerHTML += `<p class="${command.slice(1)}-color"><b>${command.slice(1).toUpperCase()}:</b> ${command.slice(1).toUpperCase()} pattern activated.</p>`;
                            updateStatus(`Success: ${command.slice(1).toUpperCase()} activated.`, false);
                            break;
                        case '/dna':
                            activeAgents = ['agent1', 'agent2', 'agent3', 'agent4', ...Object.keys(customAgents)];
                            setAgentsActive(true, activeAgents, true, false);
                            messages.innerHTML += `<p><b>System:</b> Collaborative DNA-like agent network activated.</p>`;
                            updateStatus('Success: DNA activated.', false);
                            break;
                        case '/galaxy':
                            activeAgents = [];
                            setAgentsActive(true, [], false, true);
                            messages.innerHTML += `<p><b>System:</b> Galaxy simulation activated.</p>`;
                            updateStatus('Success: Galaxy activated.', false);
                            break;
                        default:
                            if (customAgents[command.slice(1)]) {
                                activeAgents = [command.slice(1)];
                                setAgentsActive(true, activeAgents, false, false);
                                messages.innerHTML += `<p class="custom-agent-color"><b>${command.slice(1).toUpperCase()}:</b> Custom ${command.slice(1).toUpperCase()} pattern activated.</p>`;
                                const agent = customAgents[command.slice(1)];
                                if (agent.responses) {
                                    try {
                                        const responses = JSON.parse(agent.responses);
                                        messages.innerHTML += `<p class="custom-agent-color"><b>${command.slice(1).toUpperCase()}:</b> Pre-trained responses loaded: ${Object.keys(responses).length} patterns.</p>`;
                                    } catch (e) {
                                        messages.innerHTML += `<p class="error"><b>Error:</b> Failed to parse responses for ${command.slice(1)}.</p>`;
                                        logError(`Failed to parse responses for ${command.slice(1)}`, e, 'searchQuery');
                                    }
                                }
                                updateStatus(`Success: Custom ${command.slice(1).toUpperCase()} activated.`, false);
                            } else {
                                messages.innerHTML += `<p class="error"><b>Error:</b> Unknown command "${sanitizeInput(command)}". Type /help for commands.</p>`;
                                updateStatus('Error: Unknown command.', true);
                                setAgentsActive(false);
                            }
                    }
                } else {
                    const fuse = new Fuse(cachedContent.site_index || [], {
                        keys: ['text.content', 'text.keywords'],
                        threshold: 0.4,
                        includeMatches: true
                    });
                    const results = fuse.search(query);
                    if (results.length === 0) {
                        messages.innerHTML += `<p><b>Search Result:</b> No results found for "${sanitizeInput(query)}". Try a different query.</p>`;
                        updateStatus('Success: Search completed. No results found.', false);
                    } else {
                        messages.innerHTML += `<p><b>Search Results:</b> Found ${results.length} results.</p>`;
                        results.forEach(({ item, matches }) => {
                            matches.forEach(match => {
                                const snippet = sanitizeInput(match.value.slice(Math.max(0, match.indices[0][0] - 50), match.indices[0][1] + 50));
                                const url = `https://webxos.netlify.app${item.path}`;
                                messages.innerHTML += `<p><b>Result (<a href="${url}" target="_blank">${sanitizeInput(item.source)}):</b> ...${snippet}...</p>`;
                            });
                        });
                        updateStatus(`Success: Search completed. Found ${results.length} results.`, false);
                    }
                    // Check for custom agent responses
                    Object.keys(customAgents).forEach(agentName => {
                        const agent = customAgents[agentName];
                        if (agent.responses) {
                            try {
                                const responses = JSON.parse(agent.responses);
                                if (responses[query]) {
                                    messages.innerHTML += `<p class="custom-agent-color"><b>${agentName.toUpperCase()}:</b> ${sanitizeInput(responses[query])}</p>`;
                                } else {
                                    // Fuzzy match for partial query matches
                                    const queryWords = query.split(' ');
                                    let bestMatch = null;
                                    let bestScore = 0;
                                    Object.keys(responses).forEach(key => {
                                        const score = queryWords.reduce((sum, word) => sum + (key.includes(word) ? 1 : 0), 0);
                                        if (score > bestScore) {
                                            bestScore = score;
                                            bestMatch = key;
                                        }
                                    });
                                    if (bestMatch && bestScore > 0) {
                                        messages.innerHTML += `<p class="custom-agent-color"><b>${agentName.toUpperCase()}:</b> ${sanitizeInput(responses[bestMatch])}</p>`;
                                    }
                                }
                            } catch (e) {
                                logError(`Failed to parse responses for ${agentName}`, e, 'searchQuery');
                            }
                        }
                    });
                    setAgentsActive(false);
                }
            } catch (error) {
                logError('Search failed', error, 'searchQuery');
                messages.innerHTML += `<p class="error"><b>Error:</b> ${sanitizeInput(error.message)}</p>`;
                updateStatus('Error: Search failed.', true, sanitizeInput(error.message));
                setAgentsActive(false);
            } finally {
                loading.style.display = 'none';
                document.getElementById('userInput').value = '';
                messages.scrollTop = messages.scrollHeight;
            }
        }

        // Initialize app
        async function initializeApp() {
            updateStatus('Initializing WebXOS Searchbot...', false);
            window.addEventListener('online', () => {
                isOffline = false;
                updateStatus('Online: Using local ping agent.', false);
                loadSiteIndex();
            });
            window.addEventListener('offline', () => {
                isOffline = true;
                updateStatus('Offline: Using cached data and mock ping response.', true);
            });

            try {
                await loadScript('/chatbot/static/neurots.js');
                if (typeof window.initNeurots !== 'function') {
                    await loadScript('https://cdn.jsdelivr.net/gh/webxos/webxos@latest/chatbot/static/neurots.js');
                    if (typeof window.initNeurots !== 'function') {
                        throw new Error('initNeurots function not defined after loading neurots.js');
                    }
                }
                initNeurots();
                console.log('Neurots initialized successfully');
            } catch (error) {
                logError('Neurots initialization failed', error, '/chatbot/static/neurots.js');
                updateStatus('Error: Neural dots failed to initialize.', true, sanitizeInput(error.message));
            }

            showHelp();
            await registerServiceWorker();
            await loadSiteIndex();
        }

        // Event listeners
        window.addEventListener('load', initializeApp);
        document.getElementById('userInput').addEventListener('keydown', event => {
            if (event.key === 'Enter') {
                event.preventDefault();
                searchQuery();
            }
        });
        document.getElementById('searchButton').addEventListener('click', () => {
            console.log('Search button clicked');
            searchQuery();
        });
        document.getElementById('clearButton').addEventListener('click', () => {
            console.log('Clear button clicked');
            document.getElementById('messages').innerHTML = '';
            activeAgents = [];
            setAgentsActive(false);
            showHelp();
            updateStatus('Success: Chatbox cleared.', false);
        });
        document.getElementById('authButton').addEventListener('click', () => {
            console.log('Authenticate button clicked');
            authenticate();
        });
        document.getElementById('importButton').addEventListener('click', () => {
            console.log('Import button clicked');
            importFile();
        });
        document.getElementById('fileInput').addEventListener('change', handleFileSelect);
    </script>
</body>
</html>
