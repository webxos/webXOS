<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <meta name="description" content="WebXOS Searchbot 2025: Search innovative web apps, AI tools, games, and utilities across the WebXOS platform with neural dot visualization and Vial integration.">
    <meta name="keywords" content="webXOS, searchbot, web applications 2025, AI tools, web games, online utilities, digital solutions, webXOS AI, webXOS search, browser-based tools, innovative web apps, digital experience, web development, AI-powered search, online games, modular web tools, sustainable web solutions, carbon footprint tools, webXOS research, exoskeleton AI technology, green energy, web design, front end, sustainable software, AI, machine learning, eco-friendly tech, web interfaces, user experience, UX design, web technology, AI-driven search, browser-based applications, digital innovation, web utilities, sustainable design, green technology, front-end development, AI applications, web accessibility, interactive web, modern web design, eco-conscious software, AI research, digital transformation, web performance, sustainable digital tools, low-carbon tech, web app development, AI-enhanced tools, online platforms, futuristic web solutions, green computing, vial, quantum reasoning, agentic search">
    <meta name="robots" content="index, follow">
    <meta name="author" content="webXOS">
    <meta property="og:title" content="WebXOS Searchbot 2025 - Search Web Apps with Vial">
    <meta property="og:description" content="Explore WebXOS Searchbot 2025 with Vial integration for searching innovative web applications, AI tools, and games with neural dot visualization and quantum reasoning.">
    <meta property="og:url" content="https://webxos.netlify.app/chatbot/chatbot.html">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="webXOS">
    <meta property="og:locale" content="en_US">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@webxos">
    <meta name="twitter:creator" content="@webxos">
    <meta name="twitter:title" content="WebXOS Searchbot 2025 - Search Web Apps with Vial">
    <meta name="twitter:description" content="Discover WebXOS Searchbot 2025 with Vial integration for searching innovative web applications and games with neural dot visualization and quantum reasoning.">
    <link rel="canonical" href="https://webxos.netlify.app/chatbot/chatbot.html">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=OCR-A&display=swap">
    <link rel="stylesheet" href="/chatbot/static/style.css">
    <link rel="manifest" href="/manifest.json">
    <link rel="icon" href="/chatbot/static/icon.png">
    <title>WebXOS Searchbot 2025</title>
    <style>
        body {
            background: #000;
            color: #0f0;
            font-family: 'OCR-A', 'Courier New', monospace;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #neuralCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        .title {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5em;
            text-align: center;
            color: #0f0;
            text-shadow: 0 0 10px #0f0;
            margin: 20px 0;
        }
        .input-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        #chatbox {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 15px;
            box-shadow: 0 0 10px #0f0;
        }
        #messages {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 10px;
            background: #000;
            border: 1px solid #0f0;
        }
        #messages p {
            margin: 5px 0;
            word-wrap: break-word;
        }
        .input-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        #userInput {
            flex-grow: 1;
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px;
            font-family: 'OCR-A', 'Courier New', monospace;
            font-size: 1em;
        }
        #userInput:focus {
            outline: none;
            box-shadow: 0 0 5px #0f0;
        }
        button {
            background: #0f0;
            color: #000;
            border: none;
            padding: 10px 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1em;
            cursor: pointer;
            transition: background 0.3s;
        }
        button:hover {
            background: #00cc00;
            box-shadow: 0 0 5px #0f0;
        }
        .error-message {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #f00;
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
        .error-message.show {
            display: block;
        }
        .error-message .error {
            color: #f00;
        }
        .error-message .success {
            color: #0f0;
        }
        .error-text {
            color: #f00;
        }
        .loading-spinner {
            display: none;
            text-align: center;
            color: #0f0;
            font-size: 1.2em;
        }
        .loading-spinner::before {
            content: '⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏';
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { content: '⠋'; }
            10% { content: '⠙'; }
            20% { content: '⠹'; }
            30% { content: '⠸'; }
            40% { content: '⠼'; }
            50% { content: '⠴'; }
            60% { content: '⠦'; }
            70% { content: '⠧'; }
            80% { content: '⠇'; }
            90% { content: '⠏'; }
        }
        .vial1-color { color: #ff0; }
        .vial2-color { color: #0ff; }
        .vial3-color { color: #f0f; }
        .vial4-color { color: #f00; }
        footer {
            text-align: center;
            color: #0f0;
            margin-top: 20px;
            font-size: 0.9em;
        }
        @media (max-width: 600px) {
            .title { font-size: 1.5em; }
            .input-container { padding: 10px; }
            #chatbot { padding: 10px; }
            #userInput { font-size: 0.9em; }
            button { padding: 8px 15px; font-size: 0.9em; }
        }
    </style>
</head>
<body>
    <canvas id="neuralCanvas" style="pointer-events: none;"></canvas>
    <h1 class="title">WebXOS Searchbot with Vial</h1>
    <div class="input-container">
        <div id="status" class="error-message"></div>
        <div id="chatbox">
            <div id="messages"></div>
            <div class="input-group">
                <input type="text" id="userInput" placeholder="Search WebXOS or /vial1-4, /dna, /galaxy, /troubleshoot...">
                <button id="searchButton">Search</button>
                <button id="clearButton">Clear</button>
                <button id="authButton">Authenticate</button>
                <button id="importButton">Import</button>
            </div>
            <div id="loading" class="loading-spinner"></div>
            <input type="file" id="fileInput" accept=".md" style="display: none;">
        </div>
    </div>
    <footer>
        <div class="copyright">Copyright webXOS 2025</div>
    </footer>
    <script>
        const CACHE_NAME = 'webxos-searchbot-v25';
        const BOT_VERSION = '1.2.9';
        let cachedContent = { site_index: [] };
        let activeVials = [];
        let isAuthenticated = false;
        let authToken = null;
        let errorLog = [];
        let isInitializing = false;
        let isOffline = !navigator.onLine;
        const networkId = 'webxos';
        let authRetries = 0;
        let swRetries = 0;
        const MAX_RETRIES = 3;
        const VIAL_BACKEND = 'https://vial.webxos.netlify.app';
        const DEFAULT_SITE_INDEX = [];
        const SW_LOCAL_PATH = '/chatbot/sw.js';

        // IndexedDB for error logging
        let db;
        const dbRequest = indexedDB.open('WebXOSLogs', 1);
        dbRequest.onupgradeneeded = event => {
            db = event.target.result;
            db.createObjectStore('errors', { keyPath: 'timestamp' });
        };
        dbRequest.onsuccess = event => {
            db = event.target.result;
        };

        // Service Worker registration
        async function registerServiceWorker() {
            if (!('serviceWorker' in navigator)) {
                logError('Service Worker not supported', null, 'navigator.serviceWorker');
                displayError('Browser does not support Service Worker', 'Offline functionality limited.');
                return;
            }
            if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                logError('Service Worker requires HTTPS or localhost', null, 'registerServiceWorker');
                displayError('Service Worker requires secure context', 'Use HTTPS[](https://webxos.netlify.app) or localhost.');
                return;
            }

            async function attemptRegistration(path, retryCount) {
                try {
                    const registration = await navigator.serviceWorker.register(path, { scope: '/chatbot/' });
                    console.log('Service Worker registered:', registration.scope);
                    swRetries = 0;
                    updateStatus('Success: Service Worker registered.', false);
                    return registration;
                } catch (err) {
                    const errorDetails = err.message.includes('Failed to fetch') ? 'File not found or network issue.' :
                                        err.message.includes('CORS') ? 'CORS policy blocked request.' :
                                        err.message.includes('404') ? 'File not found (404).' : err.message;
                    const guidance = 'Ensure /chatbot/sw.js exists at https://webxos.netlify.app/chatbot/sw.js. Check Netlify deploy logs and Cloudflare cache settings.';
                    logError(`Service Worker registration failed: ${path}`, err, path, null, null, `${errorDetails} ${guidance}`);
                    displayError('Service Worker registration failed', `${errorDetails} Retrying...`);
                    if (retryCount < MAX_RETRIES) {
                        swRetries++;
                        await new Promise(resolve => setTimeout(resolve, Math.pow(2, retryCount) * 1000));
                        return attemptRegistration(path, retryCount + 1);
                    } else {
                        logError('Service Worker registration failed after retries', err, path, null, null, `${errorDetails} ${guidance} Run /troubleshoot for guidance.`);
                        displayError('Failed to register Service Worker', `${errorDetails} Ensure /chatbot/sw.js is accessible. Run /troubleshoot.`);
                        throw err;
                    }
                }
            }

            try {
                await attemptRegistration(SW_LOCAL_PATH, 0);
            } catch (err) {
                console.warn('Service Worker registration failed. Proceeding with limited offline support.');
                isOffline = true;
            }
        }

        // WebGL Neural Visualization
        function initNeuralCanvas() {
            const canvas = document.getElementById('neuralCanvas');
            const gl = canvas.getContext('webgl');
            if (!gl) {
                logError('WebGL not supported', null, 'initNeuralCanvas');
                displayError('WebGL not supported', 'Neural visualizations unavailable.');
                return;
            }
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const vsSource = `
                attribute vec2 a_position;
                void main() {
                    gl_Position = vec4(a_position, 0.0, 1.0);
                    gl_PointSize = 5.0;
                }
            `;
            const fsSource = `
                precision mediump float;
                uniform vec4 u_color;
                void main() {
                    gl_FragColor = u_color;
                }
            `;
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vsSource);
            gl.compileShader(vertexShader);
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fsSource);
            gl.compileShader(fragmentShader);
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            gl.useProgram(program);

            const positionBuffer = gl.createBuffer();
            const positions = new Float32Array(1000); // 500 particles
            for (let i = 0; i < 500; i++) {
                positions[i * 2] = Math.random() * 2 - 1;
                positions[i * 2 + 1] = Math.random() * 2 - 1;
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.DYNAMIC_DRAW);

            const positionLocation = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            const colorLocation = gl.getUniformLocation(program, 'u_color');
            let color = [0, 1, 0, 1]; // Default green

            function setAgentsActive(isActive, vials = [], isDNA = false, isGalaxy = false) {
                if (!isActive || isOffline) {
                    gl.clearColor(0, 0, 0, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    return;
                }
                const colorMap = {
                    'vial1': [1, 1, 0, 1],
                    'vial2': [0, 1, 1, 1],
                    'vial3': [1, 0, 1, 1],
                    'vial4': [1, 0, 0, 1]
                };
                color = isDNA ? [0, 1, 0, 1] : isGalaxy ? [1, 0, 1, 1] : vials.length ? colorMap[vials[0]] : [0, 1, 0, 1];
                gl.uniform4fv(colorLocation, color);
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.POINTS, 0, 500);
            }

            window.setAgentsActive = setAgentsActive;
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
                setAgentsActive(activeVials.length > 0, activeVials);
            });
        }

        // Error logging to IndexedDB
        function logError(message, error, endpoint, response, requestDetails, contentPreview) {
            const stack = error && error.stack ? error.stack : 'No stack trace';
            const timestamp = new Date().toISOString();
            const responseDetails = response ? `Status: ${response.status || 'unknown'}, Response: ${JSON.stringify(response.data || response.statusText || 'No response')}` : 'No response';
            const reqDetails = requestDetails ? `Request: ${JSON.stringify(requestDetails)}` : 'No request details';
            const content = contentPreview ? `Content Preview: ${contentPreview.slice(0, 500)}` : 'No content preview';
            const logEntry = `[${timestamp}] ${message}\nEndpoint: ${endpoint}\nStack: ${stack}\nResponse: ${responseDetails}\n${reqDetails}\n${content}`;
            console.error(logEntry);
            errorLog.push(logEntry);
            if (db) {
                const tx = db.transaction(['errors'], 'readwrite');
                tx.objectStore('errors').add({ timestamp, message: logEntry });
            }
            return logEntry;
        }

        // Display error
        function displayError(message, details) {
            const messages = document.getElementById('messages');
            messages.innerHTML += `<p class="error-text"><b>Error [${new Date().toLocaleTimeString()}]:</b> ${message}<br><small>${details}</small></p>`;
            messages.scrollTop = messages.scrollHeight;
            updateStatus(`Error: ${message}`, true, details);
        }

        // Update status
        function updateStatus(message, isError, details = '') {
            const status = document.getElementById('status');
            status.innerHTML = `<span class="${isError ? 'error' : 'success'}">${message}${details ? '<br><small>' + details + '</small>' : ''}</span>`;
            status.classList.add('show');
            setTimeout(() => status.classList.remove('show'), 3000);
        }

        // Test backend connectivity
        async function testBackend(endpoint) {
            try {
                const response = await fetch(endpoint, { method: 'GET', headers: { 'Content-Type': 'application/json' } });
                const contentType = response.headers.get('content-type') || 'unknown';
                const text = await response.text();
                return { status: response.status, data: text, contentType };
            } catch (error) {
                return { status: null, error: error.message, contentType: 'unknown', data: '' };
            }
        }

        // Validate JSON
        function isValidJSON(text) {
            if (!text || typeof text !== 'string' || !text.trim()) return false;
            if (text.startsWith('<!DOCTYPE html') || text.startsWith('<html')) return false;
            try {
                JSON.parse(text);
                return true;
            } catch (e) {
                return false;
            }
        }

        // Simple search implementation
        function searchIndex(query, index) {
            const results = [];
            index.forEach(item => {
                const score = (item.text?.content?.toLowerCase().includes(query) ? 0.1 : 0) +
                              (item.text?.keywords?.some(k => k.toLowerCase().includes(query)) ? 0.2 : 0);
                if (score > 0) results.push({ item, score });
            });
            return results.sort((a, b) => b.score - a.score);
        }

        // Initialize app
        async function initializeApp() {
            if (isInitializing) return;
            isInitializing = true;
            updateStatus('Initializing WebXOS Searchbot...', false);
            window.addEventListener('online', () => {
                isOffline = false;
                updateStatus('Online: Connecting to backend.', false);
            });
            window.addEventListener('offline', () => {
                isOffline = true;
                updateStatus('Offline: Using cached data.', true);
            });

            initNeuralCanvas();
            showHelp();

            try {
                await registerServiceWorker();
                await loadSiteIndex();
                await authenticate();
            } catch (error) {
                logError('Initialization error', error, 'initializeApp');
                displayError('Failed to initialize app', 'Run /troubleshoot for guidance.');
            } finally {
                isInitializing = false;
            }
        }

        // Load site index
        async function loadSiteIndex() {
            if (isOffline) {
                cachedContent.site_index = DEFAULT_SITE_INDEX;
                logError('Offline: Using default site_index', null, '/site_index.json');
                displayError('Offline: Using empty site index', 'Run /troubleshoot for guidance.');
                return;
            }
            try {
                const response = await fetch('/site_index.json', { cache: 'no-cache' });
                const contentType = response.headers.get('content-type') || 'unknown';
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const text = await response.text();
                if (!isValidJSON(text)) {
                    logError('Invalid JSON in site_index.json', null, '/site_index.json', { status: response.status, data: text.slice(0, 500) });
                    displayError('Invalid site_index.json', 'Check server configuration.');
                    cachedContent.site_index = DEFAULT_SITE_INDEX;
                    return;
                }
                cachedContent.site_index = JSON.parse(text);
                if ('caches' in window) {
                    const cache = await caches.open(CACHE_NAME);
                    await cache.put('/site_index.json', new Response(JSON.stringify(cachedContent.site_index)));
                }
                updateStatus(`Success: Indexed ${cachedContent.site_index.length} files.`, false);
            } catch (error) {
                logError('Failed to load site_index.json', error, '/site_index.json');
                displayError('Failed to load site index', 'Run /troubleshoot for guidance.');
                if ('caches' in window) {
                    const cache = await caches.open(CACHE_NAME);
                    const cachedResponse = await cache.match('/site_index.json');
                    if (cachedResponse) {
                        cachedContent.site_index = await cachedResponse.json();
                        updateStatus('Success: Using cached site index.', false);
                    } else {
                        cachedContent.site_index = DEFAULT_SITE_INDEX;
                    }
                }
            }
        }

        // Authenticate
        async function authenticate() {
            if (isAuthenticated) {
                updateStatus('Success: Already authenticated.', false);
                return true;
            }
            if (isOffline) {
                authToken = 'mock-token-' + Date.now();
                isAuthenticated = true;
                logError('Offline: Using mock authentication', null, '/chatbot/authenticate');
                displayError('Offline: Using mock authentication', 'Limited functionality (vial/dna/galaxy disabled).');
                return true;
            }
            try {
                const response = await fetch('/chatbot/authenticate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ network: networkId, session: 'chatbot_session_' + Date.now() })
                });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                authToken = data.token;
                isAuthenticated = true;
                updateStatus('Success: Authenticated with backend.', false);
                return true;
            } catch (error) {
                authRetries++;
                logError('Authentication error', error, '/chatbot/authenticate', { status: error.status, data: error.message });
                if (authRetries < MAX_RETRIES) {
                    await new Promise(resolve => setTimeout(resolve, Math.pow(2, authRetries) * 1000));
                    return authenticate();
                } else {
                    authToken = 'mock-token-' + Date.now();
                    isAuthenticated = true;
                    displayError('Authentication failed, using mock token', 'Limited functionality (vial/dna/galaxy disabled).');
                    return true;
                }
            }
        }

        // Troubleshoot
        async function troubleshoot() {
            const messages = document.getElementById('messages');
            messages.innerHTML += `<p class="error-text"><b>Troubleshooting [${new Date().toLocaleTimeString()}]:</b> Starting diagnostics...</p>`;
            let steps = [];

            steps.push(isOffline ? '1. Offline: Using cached data. Limited functionality available.' : '1. Online: Checking backend connectivity.');
            steps.push(isAuthenticated ? `2. Authenticated with token: ${authToken.slice(0, 8)}...` : '2. Not authenticated. Click "Authenticate" button or run /authenticate.');

            const chatbotResponse = await testBackend('/chatbot/ping');
            steps.push(isOffline ? '3. Offline: Cannot connect to /chatbot/. Using cached responses.' :
                      chatbotResponse.status === 200 ? '3. /chatbot/ backend connected successfully.' :
                      '3. /chatbot/ backend not connected. Ensure server.py is running on port 5001.');

            const vialResponse = await testBackend(`${VIAL_BACKEND}/ping`);
            steps.push(isOffline ? '4. Offline: Cannot connect to /vial/. Vial commands disabled.' :
                      vialResponse.status === 200 ? '4. /vial/ backend connected successfully.' :
                      '4. /vial/ backend not connected. Ensure vial_server.py is running.');

            const indexResponse = await testBackend('/site_index.json');
            steps.push(isOffline ? '5. Offline: Using default empty site_index.' :
                      indexResponse.status === 200 && isValidJSON(indexResponse.data) ? '5. /site_index.json loaded successfully with valid JSON.' :
                      `5. Failed to load /site_index.json. Status: ${indexResponse.status || 'unknown'}. Ensure file exists and server.py is running.`);

            steps.push(navigator.serviceWorker.controller ? `6. Service Worker active. Scope: ${navigator.serviceWorker.controller.scriptURL}` :
                      '6. Service Worker not active. Ensure /chatbot/sw.js exists at https://webxos.netlify.app/chatbot/sw.js. Verify MIME type (application/javascript).');

            messages.innerHTML += `<p class="error-text"><b>Troubleshooting Steps:</b><br>${steps.join('<br>')}</p>`;
            messages.innerHTML += `<p class="error-text"><b>Next Actions:</b><br>- Go online to restore full functionality.<br>- Verify /site_index.json exists and contains valid JSON.<br>- Ensure /chatbot/sw.js is accessible with correct MIME type.<br>- Check Netlify deploy logs and Cloudflare settings.</p>`;
            messages.scrollTop = messages.scrollHeight;
            updateStatus('Troubleshooting completed.', false);
        }

        // Show help
        function showHelp() {
            const messages = document.getElementById('messages');
            messages.innerHTML = [
                '<p><b>Commands:</b></p>',
                '<p><b>/help</b> - Show this menu.</p>',
                '<p><b>/clear</b> - Clear chatbox and reset neural dots.</p>',
                '<p><b>/stats</b> - Show indexing stats.</p>',
                '<p><b>/version</b> - Show bot version.</p>',
                '<p><b>/troubleshoot</b> - Diagnose connectivity and index issues.</p>',
                '<p><b>/vial1-4</b> - Activate Vial patterns (requires authentication).</p>',
                '<p><b>/dna</b> - Activate DNA-like reasoning (requires authentication).</p>',
                '<p><b>/galaxy</b> - Activate galaxy search (requires authentication).</p>',
                isOffline ? '<p class="error-text"><b>Note:</b> Offline mode active. Limited functionality.</p>' :
                authToken?.startsWith('mock-token-') ? '<p class="error-text"><b>Note:</b> Using mock authentication. Vial/dna/galaxy commands disabled.</p>' : ''
            ].join('');
            messages.scrollTop = messages.scrollHeight;
        }

        // Search query
        function searchQuery() {
            const query = document.getElementById('userInput').value.trim().toLowerCase();
            const messages = document.getElementById('messages');
            const loading = document.getElementById('loading');
            if (!query) {
                displayError('Empty input', 'Please enter a search term or command.');
                return;
            }
            messages.innerHTML += `<p><b>You:</b> ${query}</p>`;
            loading.style.display = 'block';

            if (query.startsWith('/')) {
                const command = query.split(' ')[0];
                switch (command) {
                    case '/help':
                        showHelp();
                        updateStatus('Success: Help menu displayed.', false);
                        break;
                    case '/clear':
                        messages.innerHTML = '';
                        activeVials = [];
                        window.setAgentsActive(false);
                        showHelp();
                        updateStatus('Success: Chatbox cleared.', false);
                        break;
                    case '/stats':
                        messages.innerHTML += `<p><b>Stats:</b> Indexed ${cachedContent.site_index.length} files.</p>`;
                        updateStatus('Success: Stats displayed.', false);
                        break;
                    case '/version':
                        messages.innerHTML += `<p><b>Version:</b> WebXOS Searchbot v${BOT_VERSION}</p>`;
                        updateStatus('Success: Version displayed.', false);
                        break;
                    case '/troubleshoot':
                        troubleshoot();
                        break;
                    case '/vial1':
                    case '/vial2':
                    case '/vial3':
                    case '/vial4':
                    case '/dna':
                    case '/galaxy':
                        displayError('Feature disabled', 'Vial/DNA/Galaxy commands require backend authentication.');
                        break;
                    default:
                        displayError('Unknown command', `Type /help for commands.`);
                        updateStatus('Error: Unknown command.', true);
                }
                window.setAgentsActive(false);
                loading.style.display = 'none';
                document.getElementById('userInput').value = '';
                messages.scrollTop = messages.scrollHeight;
                return;
            }

            const results = searchIndex(query, cachedContent.site_index);
            if (results.length === 0) {
                messages.innerHTML += `<p><b>Search Result:</b> No results found for "${query}".</p>`;
                updateStatus('Success: Search completed. No results.', false);
            } else {
                messages.innerHTML += `<p><b>Search Results:</b> Found ${results.length} results.</p>`;
                results.forEach(result => {
                    const url = 'https://webxos.netlify.app' + result.item.path;
                    messages.innerHTML += `<p><b>Result (<a href="${url}" target="_blank">${result.item.source}</a>):</b> ${result.item.text?.content?.slice(0, 100)}...</p>`;
                });
                updateStatus(`Success: Found ${results.length} results.`, false);
            }
            window.setAgentsActive(false);
            loading.style.display = 'none';
            document.getElementById('userInput').value = '';
            messages.scrollTop = messages.scrollHeight;
        }

        // Event listeners
        window.addEventListener('load', initializeApp);
        document.getElementById('userInput').addEventListener('keydown', event => {
            if (event.key === 'Enter') {
                event.preventDefault();
                searchQuery();
            }
        });
        document.getElementById('searchButton').addEventListener('click', searchQuery);
        document.getElementById('clearButton').addEventListener('click', () => {
            document.getElementById('messages').innerHTML = '';
            activeVials = [];
            window.setAgentsActive(false);
            showHelp();
            updateStatus('Success: Chatbox cleared.', false);
        });
        document.getElementById('authButton').addEventListener('click', authenticate);
        document.getElementById('importButton').addEventListener('click', () => {
            displayError('Import disabled', 'File import requires backend authentication.');
        });
    </script>
</body>
</html>
