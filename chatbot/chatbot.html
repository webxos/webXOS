<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <meta name="description" content="WebXOS Searchbot 2025: Search innovative web apps and utilities with neural dot visualization and Vial integration.">
    <meta name="keywords" content="webXOS, searchbot, web applications 2025, AI tools, web games, online utilities, digital solutions, webXOS search, browser-based tools, web development, AI-powered search, sustainable web solutions, vial, quantum reasoning">
    <meta name="robots" content="index, follow">
    <meta name="author" content="webXOS">
    <meta property="og:title" content="WebXOS Searchbot 2025">
    <meta property="og:description" content="Explore WebXOS Searchbot 2025 for searching innovative web applications with neural dot visualization and Vial integration.">
    <meta property="og:url" content="https://webxos.netlify.app/chatbot/chatbot.html">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="webXOS">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@webxos">
    <meta name="twitter:title" content="WebXOS Searchbot 2025">
    <meta name="twitter:description" content="Discover WebXOS Searchbot 2025 for searching innovative web applications.">
    <link rel="canonical" href="https://webxos.netlify.app/chatbot/chatbot.html">
    <link rel="stylesheet" href="/chatbot/static/style.css">
    <link rel="manifest" href="/manifest.json">
    <link rel="icon" href="/chatbot/static/icon.png">
    <title>WebXOS Searchbot 2025</title>
    <style>
        body {
            background: #000;
            color: #0f0;
            font-family: monospace, 'Courier New', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #neuralCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        .title {
            font-family: monospace, sans-serif;
            font-weight: bold;
            font-size: 2.5em;
            text-align: center;
            color: #0f0;
            text-shadow: 0 0 10px #0f0;
            margin: 20px 0;
        }
        .input-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        #chatbox {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 15px;
            box-shadow: 0 0 10px #0f0;
        }
        #messages {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 10px;
            background: #000;
            border: 1px solid #0f0;
        }
        #messages p {
            margin: 5px 0;
            word-wrap: break-word;
        }
        .input-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        #userInput {
            flex-grow: 1;
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px;
            font-family: monospace, 'Courier New', sans-serif;
            font-size: 1em;
        }
        #userInput:focus {
            outline: none;
            box-shadow: 0 0 5px #0f0;
        }
        button {
            background: #0f0;
            color: #000;
            border: none;
            padding: 10px 20px;
            font-family: monospace, sans-serif;
            font-size: 1em;
            cursor: pointer;
            transition: background 0.3s;
        }
        button:hover {
            background: #00cc00;
            box-shadow: 0 0 5px #0f0;
        }
        .error-message {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #f00;
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
        .error-message.show {
            display: block;
        }
        .error-message .error {
            color: #f00;
        }
        .error-message .success {
            color: #0f0;
        }
        .error-text {
            color: #f00;
        }
        .loading-spinner {
            display: none;
            text-align: center;
            color: #0f0;
            font-size: 1.2em;
        }
        .loading-spinner::before {
            content: '⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏';
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { content: '⠋'; }
            10% { content: '⠙'; }
            20% { content: '⠹'; }
            30% { content: '⠸'; }
            40% { content: '⠼'; }
            50% { content: '⠴'; }
            60% { content: '⠦'; }
            70% { content: '⠧'; }
            80% { content: '⠇'; }
            90% { content: '⠏'; }
        }
        .vial1-color { color: #ff0; }
        .vial2-color { color: #0ff; }
        .vial3-color { color: #f0f; }
        .v Escritadoial4-color { color: #f00; }
        footer {
            text-align: center;
            color: #0f0;
            margin-top: 20px;
            font-size: 0.9em;
        }
        @media (max-width: 600px) {
            .title { font-size: 1.5em; }
            .input-container { padding: 10px; }
            #chatbot { padding: 10px; }
            #userInput { font-size: 0.9em; }
            button { padding: 8px 15px; font-size: 0.9em; }
        }
    </style>
</head>
<body>
    <canvas id="neuralCanvas" style="pointer-events: none;"></canvas>
    <h1 class="title">WebXOS Searchbot 2025</h1>
    <div input-container>
        <div id="status" class="error-message"></div>
        <div id="chatbox">
            <div id="messages"></div>
            <div class="input-group">
                <input type="text" id="userInput" placeholder="Search WebXOS or /vial1-4, /dna, /galaxy, /troubleshoot...">
                <button id="searchButton">Search</button>
 '

System: * The user input appears to be cut off mid-sentence. I'll respond assuming the intent is to continue with the restoration of the neural visualization and related commands in `chatbot.html`, ensuring all functionality matches the original while keeping the codebase under 1500 lines and maintaining the lightweight, standalone approach with zero-dependency native libraries. I'll complete the `chatbot.html` file, reintroducing the original neural visualization (`initNeuralCanvas` and `setAgentsActive`) and Vial/DNA/Galaxy commands, while keeping other optimizations from the previous response. The other files (`sw.js`, `_headers`, `site_index.json`) remain unchanged as they are working.

### Key Changes
1. **Restoring Neural Visualization**:
   - Reinstated the original `initNeuralCanvas` function with WebGL for 500 particles and dynamic color changes based on `/vial1-4`, `/dna`, and `/galaxy` commands, exactly as in the original `chatbot.html`.
   - Restored `setAgentsActive` to handle color mappings for vials (yellow, cyan, magenta, red), DNA (green), and Galaxy (magenta).

2. **Reintroducing Vial, DNA, and Galaxy Commands**:
   - Restored the `/vial1-4`, `/dna`, and `/galaxy` commands in the `searchQuery` function, with checks for offline mode or missing backend to display a disabled message.
   - Updated the Vial backend URL to `https://webxos.netlify.app/vial/ping` (per your clarification that all resources are under `webxos.netlify.app`).

3. **Maintaining Optimizations**:
   - Kept the streamlined structure (no external fonts, mock `site_index.json`, robust Service Worker registration) from the previous response.
   - Ensured the codebase remains lightweight and under 1500 lines across all files (`chatbot.html`, `sw.js`, `_headers`, `site_index.json`).

4. **Artifact Compliance**:
   - Used the same `artifact_id` as the previous `chatbot.html` (`c67e0dcb-e98a-4cad-a344-35ccc1b98774`) since this is an update to that artifact.
   - Set `contentType` to `text/html` and `title` to `chatbot.html`.
   - Ensured no mention of `xaiArtifact` outside the tag.

### Assumptions
- The `/vial/ping` endpoint (`https://webxos.netlify.app/vial/ping`) is not currently available, so Vial-related commands will display a disabled message until the backend is deployed.
- The `sw.js`, `_headers`, and `site_index.json` files from the previous response are deployed correctly and working.
- The total codebase across all files will remain under 1500 lines.

### Updated `chatbot.html`
This file restores the original neural visualization and Vial/DNA/Galaxy commands, while keeping the optimized Service Worker registration, error logging, and mock site index handling.

<xaiArtifact artifact_id="c67e0dcb-e98a-4cad-a344-35ccc1b98774" artifact_version_id="0ec3a9c3-22d3-4262-9c87-8a880b04ab0f" title="chatbot.html" contentType="text/html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <meta name="description" content="WebXOS Searchbot 2025: Search innovative web apps and utilities with neural dot visualization and Vial integration.">
    <meta name="keywords" content="webXOS, searchbot, web applications 2025, AI tools, web games, online utilities, digital solutions, webXOS search, browser-based tools, web development, AI-powered search, sustainable web solutions, vial, quantum reasoning">
    <meta name="robots" content="index, follow">
    <meta name="author" content="webXOS">
    <meta property="og:title" content="WebXOS Searchbot 2025">
    <meta property="og:description" content="Explore WebXOS Searchbot 2025 for searching innovative web applications with neural dot visualization and Vial integration.">
    <meta property="og:url" content="https://webxos.netlify.app/chatbot/chatbot.html">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="webXOS">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@webxos">
    <meta name="twitter:title" content="WebXOS Searchbot 2025">
    <meta name="twitter:description" content="Discover WebXOS Searchbot 2025 for searching innovative web applications.">
    <link rel="canonical" href="https://webxos.netlify.app/chatbot/chatbot.html">
    <link rel="stylesheet" href="/chatbot/static/style.css">
    <link rel="manifest" href="/manifest.json">
    <link rel="icon" href="/chatbot/static/icon.png">
    <title>WebXOS Searchbot 2025</title>
    <style>
        body {
            background: #000;
            color: #0f0;
            font-family: monospace, 'Courier New', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #neuralCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        .title {
            font-family: monospace, sans-serif;
            font-weight: bold;
            font-size: 2.5em;
            text-align: center;
            color: #0f0;
            text-shadow: 0 0 10px #0f0;
            margin: 20px 0;
        }
        .input-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        #chatbox {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 15px;
            box-shadow: 0 0 10px #0f0;
        }
        #messages {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 10px;
            background: #000;
            border: 1px solid #0f0;
        }
        #messages p {
            margin: 5px 0;
            word-wrap: break-word;
        }
        .input-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        #userInput {
            flex-grow: 1;
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px;
            font-family: monospace, 'Courier New', sans-serif;
            font-size: 1em;
        }
        #userInput:focus {
            outline: none;
            box-shadow: 0 0 5px #0f0;
        }
        button {
            background: #0f0;
            color: #000;
            border: none;
            padding: 10px 20px;
            font-family: monospace, sans-serif;
            font-size: 1em;
            cursor: pointer;
            transition: background 0.3s;
        }
        button:hover {
            background: #00cc00;
            box-shadow: 0 0 5px #0f0;
        }
        .error-message {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #f00;
            padding: 10px;
            border-radius: 5px;
            display: none;
        }
        .error-message.show {
            display: block;
        }
        .error-message .error {
            color: #f00;
        }
        .error-message .success {
            color: #0f0;
        }
        .error-text {
            color: #f00;
        }
        .loading-spinner {
            display: none;
            text-align: center;
            color: #0f0;
            font-size: 1.2em;
        }
        .loading-spinner::before {
            content: '⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏';
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { content: '⠋'; }
            10% { content: '⠙'; }
            20% { content: '⠹'; }
            30% { content: '⠸'; }
            40% { content: '⠼'; }
            50% { content: '⠴'; }
            60% { content: '⠦'; }
            70% { content: '⠧'; }
            80% { content: '⠇'; }
            90% { content: '⠏'; }
        }
        .vial1-color { color: #ff0; }
        .vial2-color { color: #0ff; }
        .vial3-color { color: #f0f; }
        .vial4-color { color: #f00; }
        footer {
            text-align: center;
            color: #0f0;
            margin-top: 20px;
            font-size: 0.9em;
        }
        @media (max-width: 600px) {
            .title { font-size: 1.5em; }
            .input-container { padding: 10px; }
            #chatbot { padding: 10px; }
            #userInput { font-size: 0.9em; }
            button { padding: 8px 15px; font-size: 0.9em; }
        }
    </style>
</head>
<body>
    <canvas id="neuralCanvas" style="pointer-events: none;"></canvas>
    <h1 class="title">WebXOS Searchbot 2025</h1>
    <div class="input-container">
        <div id="status" class="error-message"></div>
        <div id="chatbox">
            <div id="messages"></div>
            <div class="input-group">
                <input type="text" id="userInput" placeholder="Search WebXOS or /vial1-4, /dna, /galaxy, /troubleshoot...">
                <button id="searchButton">Search</button>
                <button id="clearButton">Clear</button>
            </div>
            <div id="loading" class="loading-spinner"></div>
        </div>
    </div>
    <footer>
        <div class="copyright">Copyright webXOS 2025</div>
    </footer>
    <script>
        const CACHE_NAME = 'webxos-searchbot-v25';
        const BOT_VERSION = '1.2.10';
        let cachedContent = { site_index: [] };
        let activeVials = [];
        let isOffline = !navigator.onLine;
        let errorLog = [];
        const MAX_RETRIES = 3;
        const VIAL_BACKEND = 'https://webxos.netlify.app/vial/ping';
        const SW_LOCAL_PATH = '/chatbot/sw.js';

        // IndexedDB for error logging
        let db;
        const dbRequest = indexedDB.open('WebXOSLogs', 1);
        dbRequest.onupgradeneeded = event => {
            db = event.target.result;
            db.createObjectStore('errors', { keyPath: 'timestamp' });
        };
        dbRequest.onsuccess = event => {
            db = event.target.result;
        };

        // Service Worker registration
        async function registerServiceWorker() {
            if (!('serviceWorker' in navigator)) {
                logError('Service Worker not supported', null, 'navigator.serviceWorker');
                displayError('Browser does not support Service Worker', 'Offline functionality limited.');
                return;
            }
            if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                logError('Service Worker requires HTTPS or localhost', null, 'registerServiceWorker');
                displayError('Service Worker requires secure context', 'Use HTTPS or localhost.');
                return;
            }

            async function attemptRegistration(path, retryCount) {
                try {
                    const swCheck = await fetch(path, { method: 'HEAD' });
                    if (!swCheck.ok) throw new Error(`HTTP ${swCheck.status}: sw.js not found`);
                    const registration = await navigator.serviceWorker.register(path, { scope: '/chatbot/' });
                    console.log('Service Worker registered:', registration.scope);
                    updateStatus('Success: Service Worker registered.', false);
                    return registration;
                } catch (err) {
                    const errorDetails = err.message.includes('404') ? 'File not found.' : err.message.includes('CORS') ? 'CORS policy blocked.' : err.message;
                    const guidance = 'Ensure /chatbot/sw.js exists at https://webxos.netlify.app/chatbot/sw.js. Check Netlify deploy logs.';
                    logError(`Service Worker registration failed: ${path}`, err, path, null, null, `${errorDetails} ${guidance}`);
                    displayError('Service Worker registration failed', `${errorDetails} Retrying...`);
                    if (retryCount < MAX_RETRIES) {
                        await new Promise(resolve => setTimeout(resolve, Math.pow(2, retryCount) * 1000));
                        return attemptRegistration(path, retryCount + 1);
                    } else {
                        logError('Service Worker registration failed after retries', err, path, null, null, `${errorDetails} ${guidance} Run /troubleshoot.`);
                        displayError('Failed to register Service Worker', `${errorDetails} Run /troubleshoot.`);
                        isOffline = true;
                        return null;
                    }
                }
            }

            try {
                await attemptRegistration(SW_LOCAL_PATH, 0);
            } catch (err) {
                console.warn('Service Worker registration failed. Using offline mode.');
                isOffline = true;
            }
        }

        // WebGL Neural Visualization (restored from original)
        function initNeuralCanvas() {
            const canvas = document.getElementById('neuralCanvas');
            const gl = canvas.getContext('webgl');
            if (!gl) {
                logError('WebGL not supported', null, 'initNeuralCanvas');
                displayError('WebGL not supported', 'Neural visualizations unavailable.');
                return;
            }
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const vsSource = `
                attribute vec2 a_position;
                void main() {
                    gl_Position = vec4(a_position, 0.0, 1.0);
                    gl_PointSize = 5.0;
                }
            `;
            const fsSource = `
                precision mediump float;
                uniform vec4 u_color;
                void main() {
                    gl_FragColor = u_color;
                }
            `;
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vsSource);
            gl.compileShader(vertexShader);
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fsSource);
            gl.compileShader(fragmentShader);
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            gl.useProgram(program);

            const positionBuffer = gl.createBuffer();
            const positions = new Float32Array(1000); // 500 particles
            for (let i = 0; i < 500; i++) {
                positions[i * 2] = Math.random() * 2 - 1;
                positions[i * 2 + 1] = Math.random() * 2 - 1;
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.DYNAMIC_DRAW);

            const positionLocation = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            const colorLocation = gl.getUniformLocation(program, 'u_color');
            let color = [0, 1, 0, 1]; // Default green

            function setAgentsActive(isActive, vials = [], isDNA = false, isGalaxy = false) {
                if (!isActive || isOffline) {
                    gl.clearColor(0, 0, 0, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    return;
                }
                const colorMap = {
                    'vial1': [1, 1, 0, 1], // Yellow
                    'vial2': [0, 1, 1, 1], // Cyan
                    'vial3': [1, 0, 1, 1], // Magenta
                    'vial4': [1, 0, 0, 1]  // Red
                };
                color = isDNA ? [0, 1, 0, 1] : isGalaxy ? [1, 0, 1, 1] : vials.length ? colorMap[vials[0]] : [0, 1, 0, 1];
                gl.uniform4fv(colorLocation, color);
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.POINTS, 0, 500);
            }

            window.setAgentsActive = setAgentsActive;
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
                setAgentsActive(activeVials.length > 0, activeVials);
            });
        }

        // Error logging to IndexedDB
        function logError(message, error, endpoint, response, requestDetails, contentPreview) {
            const stack = error && error.stack ? error.stack : 'No stack trace';
            const timestamp = new Date().toISOString();
            const responseDetails = response ? `Status: ${response.status || 'unknown'}, Response: ${JSON.stringify(response.data || response.statusText || 'No response')}` : 'No response';
            const logEntry = `[${timestamp}] ${message}\nEndpoint: ${endpoint}\nStack: ${stack}\nResponse: ${responseDetails}`;
            console.error(logEntry);
            errorLog.push(logEntry);
            if (db) {
                const tx = db.transaction(['errors'], 'readwrite');
                tx.objectStore('errors').add({ timestamp, message: logEntry });
            }
            return logEntry;
        }

        // Display error
        function displayError(message, details) {
            const messages = document.getElementById('messages');
            messages.innerHTML += `<p class="error-text"><b>Error [${new Date().toLocaleTimeString()}]:</b> ${message}<br><small>${details}</small></p>`;
            messages.scrollTop = messages.scrollHeight;
            updateStatus(`Error: ${message}`, true, details);
        }

        // Update status
        function updateStatus(message, isError, details = '') {
            const status = document.getElementById('status');
            status.innerHTML = `<span class="${isError ? 'error' : 'success'}">${message}${details ? '<br><small>' + details + '</small>' : ''}</span>`;
            status.classList.add('show');
            setTimeout(() => status.classList.remove('show'), 3000);
        }

        // Test backend connectivity
        async function testBackend(endpoint) {
            try {
                const response = await fetch(endpoint, { method: 'GET', headers: { 'Content-Type': 'application/json' } });
                return { status: response.status, data: await response.text(), contentType: response.headers.get('content-type') || 'unknown' };
            } catch (error) {
                return { status: null, error: error.message, contentType: 'unknown', data: '' };
            }
        }

        // Validate JSON
        function isValidJSON(text) {
            if (!text || typeof text !== 'string' || !text.trim()) return false;
            if (text.startsWith('<!DOCTYPE html') || text.startsWith('<html')) return false;
            try {
                JSON.parse(text);
                return true;
            } catch (e) {
                return false;
            }
        }

        // Search index
        function searchIndex(query, index) {
            const results = [];
            index.forEach(item => {
                const score = (item.text?.content?.toLowerCase().includes(query) ? 0.1 : 0) +
                              (item.text?.keywords?.some(k => k.toLowerCase().includes(query)) ? 0.2 : 0);
                if (score > 0) results.push({ item, score });
            });
            return results.sort((a, b) => b.score - a.score);
        }

        // Load site index
        async function loadSiteIndex() {
            if (isOffline) {
                cachedContent.site_index = [];
                logError('Offline: Using empty site_index', null, '/site_index.json');
                displayError('Offline: Using empty site index', 'Run /troubleshoot for guidance.');
                return;
            }
            try {
                const response = await fetch('/site_index.json', { cache: 'no-cache' });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const text = await response.text();
                if (!isValidJSON(text)) {
                    logError('Invalid JSON in site_index.json', null, '/site_index.json', { status: response.status, data: text.slice(0, 500) });
                    displayError('Invalid site_index.json', 'Check server configuration.');
                    cachedContent.site_index = [];
                    return;
                }
                cachedContent.site_index = JSON.parse(text);
                if ('caches' in window) {
                    const cache = await caches.open(CACHE_NAME);
                    await cache.put('/site_index.json', new Response(JSON.stringify(cachedContent.site_index)));
                }
                updateStatus(`Success: Indexed ${cachedContent.site_index.length} files.`, false);
            } catch (error) {
                logError('Failed to load site_index.json', error, '/site_index.json');
                displayError('Failed to load site index', 'Run /troubleshoot for guidance.');
                cachedContent.site_index = [];
            }
        }

        // Show logs
        async function showLogs() {
            if (!db) {
                displayError('Logs unavailable', 'IndexedDB not initialized.');
                return;
            }
            const tx = db.transaction(['errors'], 'readonly');
            const store = tx.objectStore('errors');
            const logs = await new Promise(resolve => {
                const result = [];
                store.openCursor().onsuccess = event => {
                    const cursor = event.target.result;
                    if (cursor) {
                        result.push(cursor.value);
                        cursor.continue();
                    } else {
                        resolve(result);
                    }
                };
            });
            const messages = document.getElementById('messages');
            messages.innerHTML += `<p><b>Logs:</b><br>${logs.map(log => log.message).join('<br>')}</p>`;
            messages.scrollTop = messages.scrollHeight;
            updateStatus('Success: Logs displayed.', false);
        }

        // Troubleshoot
        async function troubleshoot() {
            const messages = document.getElementById('messages');
            messages.innerHTML += `<p class="error-text"><b>Troubleshooting [${new Date().toLocaleTimeString()}]:</b> Starting diagnostics...</p>`;
            let steps = [];

            steps.push(isOffline ? '1. Offline: Using cached data.' : '1. Online: Checking connectivity.');
            const indexResponse = await testBackend('/site_index.json');
            steps.push(isOffline ? '2. Offline: Using empty site_index.' :
                      indexResponse.status === 200 && isValidJSON(indexResponse.data) ? '2. /site_index.json loaded successfully.' :
                      `2. Failed to load /site_index.json. Status: ${indexResponse.status || 'unknown'}. Ensure file exists.`);
            const vialResponse = await testBackend(VIAL_BACKEND);
            steps.push(isOffline ? '3. Offline: Cannot connect to /vial/ping. Vial commands disabled.' :
                      vialResponse.status === 200 ? '3. /vial/ping backend connected successfully.' :
                      '3. /vial/ping backend not connected. Ensure vial backend is running.');
            steps.push(navigator.serviceWorker.controller ? `4. Service Worker active. Scope: ${navigator.serviceWorker.controller.scriptURL}` :
                      '4. Service Worker not active. Ensure /chatbot/sw.js exists at https://webxos.netlify.app/chatbot/sw.js.');

            messages.innerHTML += `<p class="error-text"><b>Troubleshooting Steps:</b><br>${steps.join('<br>')}</p>`;
            messages.innerHTML += `<p class="error-text"><b>Next Actions:</b><br>- Go online to restore full functionality.<br>- Verify /site_index.json exists.<br>- Ensure /chatbot/sw.js is accessible.<br>- Deploy /vial/ping backend for Vial commands.</p>`;
            messages.scrollTop = messages.scrollHeight;
            updateStatus('Troubleshooting completed.', false);
        }

        // Show help
        function showHelp() {
            const messages = document.getElementById('messages');
            messages.innerHTML = [
                '<p><b>Commands:</b></p>',
                '<p><b>/help</b> - Show this menu.</p>',
                '<p><b>/clear</b> - Clear chatbox and reset neural dots.</p>',
                '<p><b>/stats</b> - Show indexing stats.</p>',
                '<p><b>/version</b> - Show bot version.</p>',
                '<p><b>/troubleshoot</b> - Diagnose connectivity issues.</p>',
                '<p><b>/logs</b> - Show error logs.</p>',
                '<p><b>/vial1-4</b> - Activate Vial patterns (requires backend).</p>',
                '<p><b>/dna</b> - Activate DNA-like reasoning (requires backend).</p>',
                '<p><b>/galaxy</b> - Activate galaxy search (requires backend).</p>',
                isOffline ? '<p class="error-text"><b>Note:</b> Offline mode active. Limited functionality.</p>' : ''
            ].join('');
            messages.scrollTop = messages.scrollHeight;
        }

        // Search query
        async function searchQuery() {
            const query = document.getElementById('userInput').value.trim().toLowerCase();
            const messages = document.getElementById('messages');
            const loading = document.getElementById('loading');
            if (!query) {
                displayError('Empty input', 'Please enter a search term or command.');
                return;
            }
            messages.innerHTML += `<p><b>You:</b> ${query}</p>`;
            loading.style.display = 'block';

            if (query.startsWith('/')) {
                const command = query.split(' ')[0];
                let vialResponse = { status: null };
                if (['/vial1', '/vial2', '/vial3', '/vial4', '/dna', '/galaxy'].includes(command)) {
                    vialResponse = await testBackend(VIAL_BACKEND);
                }
                switch (command) {
                    case '/help':
                        showHelp();
                        updateStatus('Success: Help menu displayed.', false);
                        break;
                    case '/clear':
                        messages.innerHTML = '';
                        activeVials = [];
                        window.setAgentsActive(false);
                        showHelp();
                        updateStatus('Success: Chatbox cleared.', false);
                        break;
                    case '/stats':
                        messages.innerHTML += `<p><b>Stats:</b> Indexed ${cachedContent.site_index.length} files.</p>`;
                        updateStatus('Success: Stats displayed.', false);
                        break;
                    case '/version':
                        messages.innerHTML += `<p><b>Version:</b> WebXOS Searchbot v${BOT_VERSION}</p>`;
                        updateStatus('Success: Version displayed.', false);
                        break;
                    case '/troubleshoot':
                        troubleshoot();
                        break;
                    case '/logs':
                        showLogs();
                        break;
                    case '/vial1':
                    case '/vial2':
                    case '/vial3':
                    case '/vial4':
                        if (isOffline || vialResponse.status !== 200) {
                            displayError('Vial feature disabled', 'Requires online mode and vial backend at /vial/ping.');
                            window.setAgentsActive(false);
                        } else {
                            activeVials = [command.slice(1)];
                            messages.innerHTML += `<p class="${command.slice(1)}-color"><b>Vial:</b> Activated ${command.slice(1)} pattern.</p>`;
                            window.setAgentsActive(true, activeVials);
                            updateStatus(`Success: ${command.slice(1)} activated.`, false);
                        }
                        break;
                    case '/dna':
                        if (isOffline || vialResponse.status !== 200) {
                            displayError('DNA feature disabled', 'Requires online mode and vial backend at /vial/ping.');
                            window.setAgentsActive(false);
                        } else {
                            activeVials = [];
                            messages.innerHTML += `<p><b>DNA:</b> Activated DNA-like reasoning.</p>`;
                            window.setAgentsActive(true, [], true);
                            updateStatus('Success: DNA reasoning activated.', false);
                        }
                        break;
                    case '/galaxy':
                        if (isOffline || vialResponse.status !== 200) {
                            displayError('Galaxy feature disabled', 'Requires online mode and vial backend at /vial/ping.');
                            window.setAgentsActive(false);
                        } else {
                            activeVials = [];
                            messages.innerHTML += `<p><b>Galaxy:</b> Activated galaxy search.</p>`;
                            window.setAgentsActive(true, [], false, true);
                            updateStatus('Success: Galaxy search activated.', false);
                        }
                        break;
                    default:
                        displayError('Unknown command', `Type /help for commands.`);
                        updateStatus('Error: Unknown command.', true);
                }
                loading.style.display = 'none';
                document.getElementById('userInput').value = '';
                messages.scrollTop = messages.scrollHeight;
                return;
            }

            const results = searchIndex(query, cachedContent.site_index);
            if (results.length === 0) {
                messages.innerHTML += `<p><b>Search Result:</b> No results found for "${query}".</p>`;
                updateStatus('Success: Search completed. No results.', false);
            } else {
                messages.innerHTML += `<p><b>Search Results:</b> Found ${results.length} results.</p>`;
                results.forEach(result => {
                    const url = 'https://webxos.netlify.app' + result.item.path;
                    messages.innerHTML += `<p><b>Result (<a href="${url}" target="_blank">${result.item.source}</a>):</b> ${result.item.text?.content?.slice(0, 100)}...</p>`;
                });
                updateStatus(`Success: Found ${results.length} results.`, false);
            }
            window.setAgentsActive(true, activeVials);
            loading.style.display = 'none';
            document.getElementById('userInput').value = '';
            messages.scrollTop = messages.scrollHeight;
        }

        // Initialize app
        async function initializeApp() {
            updateStatus('Initializing WebXOS Searchbot...', false);
            window.addEventListener('online', () => {
                isOffline = false;
                updateStatus('Online: Connecting to backend.', false);
                loadSiteIndex();
            });
            window.addEventListener('offline', () => {
                isOffline = true;
                updateStatus('Offline: Using cached data.', true);
            });

            initNeuralCanvas();
            showHelp();
            await registerServiceWorker();
            await loadSiteIndex();
        }

        // Event listeners
        window.addEventListener('load', initializeApp);
        document.getElementById('userInput').addEventListener('keydown', event => {
            if (event.key === 'Enter') {
                event.preventDefault();
                searchQuery();
            }
        });
        document.getElementById('searchButton').addEventListener('click', searchQuery);
        document.getElementById('clearButton').addEventListener('click', () => {
            document.getElementById('messages').innerHTML = '';
            activeVials = [];
            window.setAgentsActive(false);
            showHelp();
            updateStatus('Success: Chatbox cleared.', false);
        });
    </script>
</body>
</html>
