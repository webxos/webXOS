<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BCI GRID TRAINING: webXOS 2025</title>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- JSZip for exports -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- FileSaver for downloads -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: monospace;
            color: #0f0;
            cursor: none;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* Crosshair */
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 100;
        }
        
        .crosshair-dot {
            position: absolute;
            width: 3px;
            height: 3px;
            background: #0f0;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .crosshair-line {
            position: absolute;
            background: #0f0;
        }
        
        .crosshair-line.horizontal {
            width: 6px;
            height: 1px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .crosshair-line.horizontal.left {
            left: calc(50% - 10px);
        }
        
        .crosshair-line.horizontal.right {
            right: calc(50% - 10px);
        }
        
        .crosshair-line.vertical {
            width: 1px;
            height: 6px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .crosshair-line.vertical.top {
            top: calc(50% - 10px);
        }
        
        .crosshair-line.vertical.bottom {
            bottom: calc(50% - 10px);
        }
        
        /* HUD Elements */
        .hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }
        
        .hud-top {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
        }
        
        .xp-bar-container {
            width: 200px;
            height: 12px;
            background: #001100;
            border: 1px solid #ff0;
            overflow: hidden;
        }
        
        .xp-bar {
            height: 100%;
            width: 0%;
            background: #ff0;
            transition: width 0.3s;
        }
        
        .level-display {
            color: #ff0;
            font-size: 14px;
            margin-top: 2px;
        }
        
        .enemy-counter {
            color: #f00;
            font-size: 18px;
            text-align: right;
        }
        
        .score-display {
            color: #0f0;
            font-size: 16px;
        }
        
        .hud-bottom {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
        }
        
        .weapon-info {
            color: #0f0;
            font-size: 12px;
        }
        
        .bci-data {
            background: rgba(0, 20, 0, 0.8);
            border: 1px solid #0ff;
            padding: 8px;
            font-size: 10px;
            color: #0ff;
            width: 180px;
        }
        
        .bci-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2px;
        }
        
        /* Menu */
        .menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .menu-title {
            font-size: 32px;
            color: #0f0;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #0f0;
        }
        
        .menu-subtitle {
            color: #0ff;
            font-size: 14px;
            margin-bottom: 20px;
            text-align: center;
            max-width: 500px;
            line-height: 1.4;
        }
        
        .menu-btn {
            padding: 10px 20px;
            background: #001100;
            border: 2px solid #0f0;
            color: #0f0;
            font-size: 14px;
            cursor: pointer;
            margin: 5px;
            min-width: 200px;
            transition: all 0.2s;
        }
        
        .menu-btn:hover {
            background: #0f0;
            color: #000;
            border-color: #0ff;
            transform: scale(1.05);
        }
        
        .menu-stats {
            margin-top: 20px;
            color: #0a0;
            font-size: 11px;
            text-align: center;
        }
        
        /* Export Modal */
        .export-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 30, 0, 0.95);
            border: 2px solid #0ff;
            padding: 20px;
            z-index: 2000;
            display: none;
            min-width: 400px;
        }
        
        .export-title {
            color: #0ff;
            font-size: 18px;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .export-content {
            color: #0f0;
            font-size: 12px;
            margin-bottom: 10px;
        }
        
        .export-stats {
            background: rgba(0, 40, 0, 0.8);
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #0f0;
        }
        
        .export-btn {
            padding: 8px 16px;
            background: #000;
            border: 1px solid #0ff;
            color: #0ff;
            cursor: pointer;
            margin: 3px;
            transition: all 0.2s;
        }
        
        .export-btn:hover {
            background: #0ff;
            color: #000;
        }
        
        /* Hit Marker */
        .hit-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            border: 2px solid #f00;
            border-radius: 50%;
            animation: hitPulse 0.2s;
            display: none;
            pointer-events: none;
            z-index: 80;
        }
        
        @keyframes hitPulse {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
        }
        
        /* BCI Status */
        .bci-status {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 20, 0, 0.8);
            border: 1px solid #0ff;
            padding: 6px;
            font-size: 9px;
            color: #0ff;
        }
        
        /* Loading Screen */
        .loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 3000;
        }
        
        .loading-text {
            color: #0f0;
            font-size: 16px;
            margin-top: 10px;
        }
        
        /* Movement Data Panel */
        .movement-panel {
            position: absolute;
            top: 100px;
            left: 10px;
            background: rgba(0, 20, 0, 0.8);
            border: 1px solid #0f0;
            padding: 8px;
            font-size: 10px;
            color: #0f0;
            width: 150px;
        }
        
        .data-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 3px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Loading Screen -->
        <div class="loading" id="loadingScreen">
            <div class="loading-text">INITIALIZING BCI GRID TRAINING...</div>
        </div>
        
        <!-- Menu -->
        <div class="menu" id="mainMenu">
            <div class="menu-title">webXOS GYM-1</div>
            <div class="menu-subtitle">
                SINGLE-ENEMY MOVEMENT INTENT BCI GRID TRAINING DATASET GENERATOR<br>
                • WASD Movement • 1 Enemy at a Time • Grid Environment • Intent & Telemetry Data •
            </div>
            <button class="menu-btn" id="startBtn">START TRAINING</button>
            <button class="menu-btn" id="exportBtn">EXPORT DATASET</button>
            <button class="menu-btn" id="statsBtn">VIEW STATS</button>
            <div class="menu-stats">
                <div>BCI Samples: <span id="menuSamples">0</span></div>
                <div>Level: <span id="menuLevel">1</span> • XP: <span id="menuXP">0</span></div>
                <div>Enemies Destroyed: <span id="menuKills">0</span> • Accuracy: <span id="menuAccuracy">0%</span></div>
            </div>
        </div>
        
        <!-- Game Canvas -->
        <canvas id="gameCanvas"></canvas>
        
        <!-- HUD -->
        <div class="hud" id="hud" style="display: none;">
            <div class="hud-top">
                <div>
                    <div class="xp-bar-container">
                        <div class="xp-bar" id="xpBar"></div>
                    </div>
                    <div class="level-display">LEVEL <span id="levelText">1</span></div>
                </div>
                <div class="enemy-counter" id="enemyCounter">ENEMY: ACTIVE</div>
                <div class="score-display">SCORE: <span id="scoreText">0</span></div>
            </div>
            
            <div class="hud-bottom">
                <div class="weapon-info">NEURAL RIFLE [WASD MOVEMENT]</div>
                <div class="bci-data">
                    <div class="bci-row">
                        <span>NEURAL SAMPLES:</span>
                        <span id="bciSamples">0</span>
                    </div>
                    <div class="bci-row">
                        <span>SAMPLE RATE:</span>
                        <span id="dataRate">0 Hz</span>
                    </div>
                    <div class="bci-row">
                        <span>MOVEMENT DATA:</span>
                        <span id="movementData">0 samples</span>
                    </div>
                    <div class="bci-row">
                        <span>INTENT ACCURACY:</span>
                        <span id="intentQuality">0%</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Crosshair -->
        <div class="crosshair" id="crosshair">
            <div class="crosshair-dot"></div>
            <div class="crosshair-line horizontal left"></div>
            <div class="crosshair-line horizontal right"></div>
            <div class="crosshair-line vertical top"></div>
            <div class="crosshair-line vertical bottom"></div>
        </div>
        
        <!-- Hit Marker -->
        <div class="hit-marker" id="hitMarker"></div>
        
        <!-- Movement Data Panel -->
        <div class="movement-panel" id="movementPanel" style="display: none;">
            <div class="data-row">
                <span>POSITION:</span>
                <span id="playerPosition">0,0,0</span>
            </div>
            <div class="data-row">
                <span>VELOCITY:</span>
                <span id="playerVelocity">0</span>
            </div>
            <div class="data-row">
                <span>MOVEMENT INTENT:</span>
                <span id="movementIntent">NONE</span>
            </div>
            <div class="data-row">
                <span>DISTANCE TRAVELED:</span>
                <span id="distanceTraveled">0m</span>
            </div>
        </div>
        
        <!-- BCI Status -->
        <div class="bci-status" id="bciStatus">
            BCI: ACTIVE • <span id="sessionTime">00:00</span>
        </div>
        
        <!-- Export Modal -->
        <div class="export-modal" id="exportModal">
            <div class="export-title">BCI DATASET EXPORT</div>
            <div class="export-content">
                Export your movement intent data for ML training.
                Includes neural signals, WASD inputs, and movement telemetry.
            </div>
            <div class="export-stats" id="exportStats">
                <!-- Stats will be populated here -->
            </div>
            <div style="text-align: center;">
                <button class="export-btn" onclick="exportDataset('hf')">HUGGINGFACE FORMAT</button>
                <button class="export-btn" onclick="exportDataset('json')">JSONL FORMAT</button>
                <button class="export-btn" onclick="hideExportModal()">CANCEL</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            // Environment Settings
            GRID_SIZE: 50,
            GRID_DIVISIONS: 50,
            GRID_COLOR: 0x00aa00,
            
            // Player Settings
            PLAYER_HEIGHT: 1.7,
            MOVEMENT_SPEED: 10,
            MOUSE_SENSITIVITY: 0.002,
            
            // Enemy Settings
            ENEMY_SPAWN_DISTANCE_MIN: 15,
            ENEMY_SPAWN_DISTANCE_MAX: 30,
            ENEMY_RESPAWN_DELAY: 500,
            
            // Weapon Settings
            FIRE_RATE: 0.1,
            BULLET_SPEED: 300,
            BULLET_LIFETIME: 1,
            
            // XP System
            XP_PER_ENEMY: 100,
            XP_PER_DATA_SAMPLE: 0.02,
            XP_LEVEL_MULTIPLIER: 1.25,
            
            // BCI Data Collection
            SAMPLING_RATE: 120,
            NEURAL_SIMULATION_RATE: 100,
            
            // Dataset Settings
            TRAIN_TEST_SPLIT: 0.8
        };
        
        // ============================================
        // GAME STATE
        // ============================================
        let scene, camera, renderer;
        let player, enemy = null;
        let bullets = [];
        let grid = null;
        let raycaster = new THREE.Raycaster();
        
        // Game State
        let gameState = 'MENU';
        let level = 1;
        let xp = 0;
        let xpToNextLevel = 1000;
        let score = 0;
        let enemiesDestroyed = 0;
        let shotsFired = 0;
        let shotsHit = 0;
        let currentStreak = 0;
        let maxStreak = 0;
        let reactionTimes = [];
        
        // Movement Tracking
        let movementData = [];
        let totalDistanceTraveled = 0;
        let lastPosition = new THREE.Vector3(0, 0, 0);
        let velocity = 0;
        
        // Weapon State
        let canFire = true;
        let lastFireTime = 0;
        
        // Input State
        const keys = {};
        const mouse = { 
            x: 0, 
            y: 0, 
            dx: 0, 
            dy: 0,
            buttons: { left: false }
        };
        
        // BCI Data Collection
        let bciSession = {
            startTime: null,
            neuralData: [],
            movementIntentData: [],
            gameEvents: [],
            telemetry: [],
            samplesCollected: 0,
            bandwidth: 0,
            intentAccuracy: 0
        };
        
        // Performance Tracking
        let frameCount = 0;
        let lastFpsUpdate = 0;
        let sessionTimer = null;
        let neuralCollectionInterval = null;
        let movementCollectionInterval = null;
        
        // Metrics
        let totalEnemyTime = 0;
        let avgReactionTime = 0;
        
        // ============================================
        // INITIALIZATION
        // ============================================
        
        function init() {
            console.log("Initializing BCI Grid Training");
            
            setTimeout(() => {
                document.getElementById('loadingScreen').style.display = 'none';
                document.getElementById('mainMenu').style.display = 'flex';
                loadGameStats();
            }, 800);
            
            initThreeJS();
            setupEventListeners();
            animate();
            
            console.log("Game initialized successfully!");
        }
        
        function initThreeJS() {
            try {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000000);
                
                camera = new THREE.PerspectiveCamera(
                    90,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                
                renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('gameCanvas'),
                    antialias: false,
                    powerPreference: "high-performance"
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.2));
                
                // Create grid environment
                createGridEnvironment();
                
                // Create player
                createPlayer();
                
                // Add lighting
                const ambientLight = new THREE.AmbientLight(0x333333);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(10, 20, 10);
                scene.add(directionalLight);
                
                console.log("Three.js initialized successfully!");
            } catch (error) {
                console.error("Error initializing Three.js:", error);
                alert("Failed to initialize graphics.");
            }
        }
        
        function createGridEnvironment() {
            // Create ground plane
            const groundGeometry = new THREE.PlaneGeometry(CONFIG.GRID_SIZE, CONFIG.GRID_SIZE);
            const groundMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x001100,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0.01;
            scene.add(ground);
            
            // Create grid helper
            grid = new THREE.GridHelper(
                CONFIG.GRID_SIZE, 
                CONFIG.GRID_DIVISIONS, 
                CONFIG.GRID_COLOR, 
                0x003300
            );
            grid.position.y = 0.02;
            scene.add(grid);
            
            // Create boundary markers
            const halfSize = CONFIG.GRID_SIZE / 2;
            const markerGeometry = new THREE.BoxGeometry(1, 5, 1);
            const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
            
            const positions = [
                [halfSize, 2.5, halfSize],
                [-halfSize, 2.5, halfSize],
                [halfSize, 2.5, -halfSize],
                [-halfSize, 2.5, -halfSize]
            ];
            
            positions.forEach(pos => {
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.set(pos[0], pos[1], pos[2]);
                scene.add(marker);
            });
        }
        
        function createPlayer() {
            // Create player container
            player = new THREE.Object3D();
            player.position.set(0, CONFIG.PLAYER_HEIGHT, 0);
            
            // Add camera to player
            camera.position.set(0, 0, 0);
            player.add(camera);
            
            scene.add(player);
            
            lastPosition.copy(player.position);
        }
        
        // ============================================
        // GAMEPLAY FUNCTIONS - SINGLE ENEMY SYSTEM
        // ============================================
        
        function startGame() {
            console.log("Starting training session...");
            
            // Reset game state
            level = 1;
            xp = 0;
            xpToNextLevel = 1000;
            score = 0;
            enemiesDestroyed = 0;
            shotsFired = 0;
            shotsHit = 0;
            currentStreak = 0;
            maxStreak = 0;
            reactionTimes = [];
            totalEnemyTime = 0;
            avgReactionTime = 0;
            totalDistanceTraveled = 0;
            movementData = [];
            
            // Clear existing objects
            if (enemy && enemy.parent) scene.remove(enemy);
            enemy = null;
            
            bullets.forEach(bullet => {
                if (bullet && bullet.parent) scene.remove(bullet);
            });
            bullets = [];
            
            // Reset player position
            player.position.set(0, CONFIG.PLAYER_HEIGHT, 0);
            player.rotation.set(0, 0, 0);
            camera.rotation.set(0, 0, 0);
            lastPosition.copy(player.position);
            
            // Initialize BCI session
            bciSession = {
                startTime: Date.now(),
                neuralData: [],
                movementIntentData: [],
                gameEvents: [],
                telemetry: [],
                samplesCollected: 0,
                bandwidth: 0,
                intentAccuracy: 0
            };
            
            // Show HUD
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('crosshair').style.display = 'block';
            document.getElementById('movementPanel').style.display = 'block';
            
            // Start data collection
            startBCIDataCollection();
            startSessionTimer();
            
            // Spawn first enemy
            spawnEnemy();
            
            // Request pointer lock
            document.body.requestPointerLock();
            
            gameState = 'PLAYING';
            
            recordBCIEvent('game_start', {
                level: level,
                timestamp: Date.now(),
                position: player.position.toArray()
            });
            
            console.log("Game started successfully!");
            updateHUD();
            updateMovementPanel();
        }
        
        function spawnEnemy() {
            if (enemy && enemy.parent) scene.remove(enemy);
            
            // Calculate random position within grid bounds
            const halfSize = CONFIG.GRID_SIZE / 2 - 5;
            const distance = CONFIG.ENEMY_SPAWN_DISTANCE_MIN + 
                           Math.random() * (CONFIG.ENEMY_SPAWN_DISTANCE_MAX - CONFIG.ENEMY_SPAWN_DISTANCE_MIN);
            
            const angle = Math.random() * Math.PI * 2;
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;
            const y = 1.5;
            
            // Ensure enemy stays within grid
            const clampedX = THREE.MathUtils.clamp(x, -halfSize, halfSize);
            const clampedZ = THREE.MathUtils.clamp(z, -halfSize, halfSize);
            
            // Create enemy cube
            const geometry = new THREE.BoxGeometry(2, 2, 2);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xff0000,
                transparent: true,
                opacity: 0.95
            });
            
            enemy = new THREE.Mesh(geometry, material);
            enemy.position.set(clampedX, y, clampedZ);
            
            enemy.userData = {
                id: 'enemy_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                spawnTime: Date.now(),
                position: [clampedX, y, clampedZ],
                isAlive: true
            };
            
            scene.add(enemy);
            
            updateEnemyCounter();
            
            recordBCIEvent('enemy_spawn', {
                enemyId: enemy.userData.id,
                position: enemy.position.toArray(),
                distance: player.position.distanceTo(enemy.position),
                timestamp: Date.now()
            });
        }
        
        function fire() {
            if (!canFire || gameState !== 'PLAYING' || !camera || !enemy) return;
            
            const currentTime = Date.now();
            if (currentTime - lastFireTime < CONFIG.FIRE_RATE * 1000) return;
            
            lastFireTime = currentTime;
            shotsFired++;
            canFire = false;
            
            // Get camera position and direction
            const worldPosition = new THREE.Vector3();
            camera.getWorldPosition(worldPosition);
            
            const direction = new THREE.Vector3(0, 0, -1);
            camera.getWorldDirection(direction);
            
            // Create bullet
            const bulletGeometry = new THREE.SphereGeometry(0.2, 6, 6);
            const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            
            bullet.position.copy(worldPosition);
            bullet.position.add(direction.clone().multiplyScalar(1));
            
            bullet.userData = {
                direction: direction,
                speed: CONFIG.BULLET_SPEED,
                spawnTime: currentTime,
                firedAt: worldPosition.clone()
            };
            
            scene.add(bullet);
            bullets.push(bullet);
            
            // Record shot event
            recordBCIEvent('shot_fired', {
                timestamp: currentTime,
                position: worldPosition.toArray(),
                direction: direction.toArray(),
                currentStreak: currentStreak,
                playerPosition: player.position.toArray()
            });
            
            // Cooldown
            setTimeout(() => {
                canFire = true;
            }, CONFIG.FIRE_RATE * 1000);
            
            updateHUD();
        }
        
        function updateBullets(delta) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                if (!bullet || !bullet.parent) continue;
                
                // Move bullet
                const moveDistance = bullet.userData.speed * delta;
                bullet.position.add(bullet.userData.direction.clone().multiplyScalar(moveDistance));
                
                // Check lifetime
                if (Date.now() - bullet.userData.spawnTime > CONFIG.BULLET_LIFETIME * 1000) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                    continue;
                }
                
                // Check collision with enemy
                if (enemy && enemy.userData.isAlive) {
                    // Simple distance-based collision
                    const distance = bullet.position.distanceTo(enemy.position);
                    const enemyRadius = 1.5; // Approximate radius of 2x2x2 cube
                    
                    if (distance < enemyRadius) {
                        destroyEnemy(enemy, bullet);
                        scene.remove(bullet);
                        bullets.splice(i, 1);
                        break;
                    }
                }
            }
        }
        
        function destroyEnemy(target, bullet) {
            if (!target || !target.userData.isAlive) return;
            
            target.userData.isAlive = false;
            shotsHit++;
            currentStreak++;
            if (currentStreak > maxStreak) maxStreak = currentStreak;
            
            // Calculate reaction time
            const reactionTime = Date.now() - target.userData.spawnTime;
            reactionTimes.push(reactionTime);
            totalEnemyTime += reactionTime;
            avgReactionTime = reactionTimes.length > 0 ? 
                totalEnemyTime / reactionTimes.length : 0;
            
            // Calculate XP
            let xpGained = CONFIG.XP_PER_ENEMY;
            
            // Distance-based bonus
            const distance = bullet.userData.firedAt.distanceTo(target.position);
            if (distance > 20) {
                xpGained += 25; // Long-range bonus
            }
            
            // Streak bonus
            xpGained += currentStreak * 5;
            
            // BCI data bonus
            xpGained += Math.floor(bciSession.samplesCollected * CONFIG.XP_PER_DATA_SAMPLE);
            
            // Add XP and score
            addXP(xpGained);
            score += xpGained;
            enemiesDestroyed++;
            
            // Visual feedback
            showHitMarker('#f00');
            
            // Record destruction event
            recordBCIEvent('enemy_destroyed', {
                timestamp: Date.now(),
                enemyId: target.userData.id,
                position: target.position.toArray(),
                distance: distance,
                reactionTime: reactionTime,
                xpGained: xpGained,
                streak: currentStreak,
                currentLevel: level,
                playerPosition: player.position.toArray(),
                movementDataSamples: movementData.length
            });
            
            // Remove enemy
            if (target && target.parent) {
                scene.remove(target);
            }
            enemy = null;
            
            // Update enemy counter
            updateEnemyCounter();
            
            // Respawn enemy after delay
            setTimeout(() => {
                if (gameState === 'PLAYING') {
                    spawnEnemy();
                }
            }, CONFIG.ENEMY_RESPAWN_DELAY);
            
            updateHUD();
        }
        
        function updatePlayer(delta) {
            if (!player || gameState !== 'PLAYING') return;
            
            // Movement vector
            const move = new THREE.Vector3();
            
            if (keys['KeyW']) move.z = -1;
            if (keys['KeyS']) move.z = 1;
            if (keys['KeyA']) move.x = -1;
            if (keys['KeyD']) move.x = 1;
            
            if (move.length() > 0) {
                move.normalize();
                move.applyQuaternion(player.quaternion);
                move.multiplyScalar(CONFIG.MOVEMENT_SPEED * delta);
                
                // Update position
                player.position.add(move);
                
                // Calculate distance traveled
                const distance = player.position.distanceTo(lastPosition);
                totalDistanceTraveled += distance;
                lastPosition.copy(player.position);
                
                // Calculate velocity
                velocity = distance / delta;
                
                // Record movement intent
                recordMovementIntent(move);
                
                // Update movement panel
                updateMovementPanel();
            }
            
            // Keep player within grid bounds
            const halfSize = CONFIG.GRID_SIZE / 2 - 2;
            player.position.x = THREE.MathUtils.clamp(player.position.x, -halfSize, halfSize);
            player.position.z = THREE.MathUtils.clamp(player.position.z, -halfSize, halfSize);
            player.position.y = CONFIG.PLAYER_HEIGHT; // Keep at constant height
        }
        
        function recordMovementIntent(move) {
            const intentSample = {
                timestamp: Date.now(),
                session_time: Date.now() - bciSession.startTime,
                keys: {
                    W: keys['KeyW'] || false,
                    A: keys['KeyA'] || false,
                    S: keys['KeyS'] || false,
                    D: keys['KeyD'] || false
                },
                movement_vector: [move.x, move.y, move.z],
                player_position: player.position.toArray(),
                velocity: velocity,
                distance_traveled: totalDistanceTraveled
            };
            
            bciSession.movementIntentData.push(intentSample);
        }
        
        function addXP(amount) {
            xp += amount;
            
            while (xp >= xpToNextLevel) {
                xp -= xpToNextLevel;
                level++;
                xpToNextLevel = Math.floor(xpToNextLevel * CONFIG.XP_LEVEL_MULTIPLIER);
                
                recordBCIEvent('level_up', {
                    level: level,
                    timestamp: Date.now(),
                    xpToNext: xpToNextLevel,
                    totalXP: xp,
                    dataSamplesCollected: bciSession.samplesCollected,
                    avgReactionTime: avgReactionTime,
                    enemiesDestroyed: enemiesDestroyed,
                    movementDataSamples: movementData.length
                });
                
                addXP(Math.floor(level * 50));
            }
            
            updateHUD();
        }
        
        // ============================================
        // BCI DATA COLLECTION
        // ============================================
        
        function startBCIDataCollection() {
            stopBCIDataCollection();
            
            neuralCollectionInterval = setInterval(() => {
                collectNeuralData();
            }, 10); // 100Hz
            
            movementCollectionInterval = setInterval(() => {
                collectMovementTelemetry();
            }, 16); // ~60Hz
            
            setInterval(() => {
                updateBCIMetrics();
            }, 1000);
            
            console.log("BCI data collection started");
        }
        
        function stopBCIDataCollection() {
            if (neuralCollectionInterval) clearInterval(neuralCollectionInterval);
            if (movementCollectionInterval) clearInterval(movementCollectionInterval);
        }
        
        function collectNeuralData() {
            const neuralSample = {
                timestamp: Date.now(),
                session_time: Date.now() - bciSession.startTime,
                channels: {},
                game_context: {},
                movement_intent: {
                    W: keys['KeyW'] || false,
                    A: keys['KeyA'] || false,
                    S: keys['KeyS'] || false,
                    D: keys['KeyD'] || false
                },
                fire_intent: mouse.buttons.left ? 1 : 0
            };
            
            // Simulate 12 neural channels
            for (let i = 0; i < 12; i++) {
                let signal = 0;
                
                // Different channels respond to different inputs
                if (i < 3) { // Movement intent channels
                    const movementActive = keys['KeyW'] || keys['KeyA'] || keys['KeyS'] || keys['KeyD'];
                    signal = movementActive ? 
                             Math.sin(Date.now() / 100 * i) * 0.8 : 
                             Math.random() * 0.1;
                }
                else if (i < 6) { // Aiming channels
                    signal = Math.abs(mouse.dx) > 0 || Math.abs(mouse.dy) > 0 ?
                             Math.cos(Date.now() / 150 * i) * 0.7 :
                             Math.random() * 0.1;
                }
                else if (i < 9) { // Decision making
                    signal = enemy ? 
                             Math.sin(Date.now() / 200 * i) * 0.5 :
                             Math.random() * 0.1;
                }
                else { // Attention/focus
                    signal = currentStreak > 3 ? 
                             Math.cos(Date.now() / 250 * i) * 0.3 :
                             Math.random() * 0.1;
                }
                
                signal += (Math.random() - 0.5) * 0.15;
                neuralSample.channels[`channel_${i}`] = parseFloat(signal.toFixed(6));
            }
            
            neuralSample.game_context = {
                enemy_active: enemy ? 1 : 0,
                current_streak: currentStreak,
                level: level,
                accuracy: shotsFired > 0 ? parseFloat((shotsHit / shotsFired).toFixed(4)) : 0,
                mouse_activity: parseFloat((Math.abs(mouse.dx) + Math.abs(mouse.dy)).toFixed(4)),
                player_position: player.position.toArray()
            };
            
            bciSession.neuralData.push(neuralSample);
            bciSession.samplesCollected++;
        }
        
        function collectMovementTelemetry() {
            const telemetrySample = {
                timestamp: Date.now(),
                session_time: Date.now() - bciSession.startTime,
                player_state: {
                    position: player.position.toArray(),
                    rotation: player.rotation.toArray(),
                    velocity: parseFloat(velocity.toFixed(4)),
                    distance_traveled: parseFloat(totalDistanceTraveled.toFixed(4))
                },
                game_state: {
                    level: level,
                    xp: xp,
                    xp_to_next: xpToNextLevel,
                    score: score,
                    enemies_destroyed: enemiesDestroyed,
                    current_streak: currentStreak
                },
                input_state: {
                    keys_pressed: Object.keys(keys).filter(k => keys[k]),
                    mouse_click: mouse.buttons.left ? 1 : 0,
                    mouse_movement: [mouse.dx, mouse.dy]
                }
            };
            
            bciSession.telemetry.push(telemetrySample);
        }
        
        function recordBCIEvent(type, data) {
            const event = {
                type: type,
                timestamp: Date.now(),
                session_time: Date.now() - bciSession.startTime,
                ...data
            };
            
            bciSession.gameEvents.push(event);
        }
        
        function updateBCIMetrics() {
            // Calculate bandwidth
            const recentSamples = bciSession.neuralData.filter(s => 
                Date.now() - s.timestamp < 1000
            ).length;
            
            bciSession.bandwidth = recentSamples;
            
            // Calculate intent accuracy
            const successfulShots = bciSession.gameEvents.filter(e => 
                e.type === 'enemy_destroyed'
            ).length;
            
            const totalShots = bciSession.gameEvents.filter(e => 
                e.type === 'shot_fired'
            ).length;
            
            bciSession.intentAccuracy = totalShots > 0 ? 
                (successfulShots / totalShots) * 100 : 0;
            
            // Update HUD
            document.getElementById('dataRate').textContent = 
                `${bciSession.bandwidth} Hz`;
            document.getElementById('bciSamples').textContent = 
                bciSession.samplesCollected.toLocaleString();
            document.getElementById('intentQuality').textContent = 
                `${bciSession.intentAccuracy.toFixed(1)}%`;
            document.getElementById('movementData').textContent = 
                `${bciSession.movementIntentData.length.toLocaleString()}`;
                
            const accuracy = shotsFired > 0 ? ((shotsHit / shotsFired) * 100).toFixed(1) : 0;
            document.getElementById('accuracyDisplay').textContent = 
                `${accuracy}%`;
        }
        
        // ============================================
        // UI FUNCTIONS
        // ============================================
        
        function updateHUD() {
            const xpPercent = (xp / xpToNextLevel) * 100;
            document.getElementById('xpBar').style.width = `${Math.min(100, xpPercent)}%`;
            
            document.getElementById('levelText').textContent = level;
            document.getElementById('scoreText').textContent = score.toLocaleString();
        }
        
        function updateEnemyCounter() {
            const enemyActive = enemy && enemy.userData.isAlive;
            document.getElementById('enemyCounter').textContent = 
                enemyActive ? 'ENEMY: ACTIVE' : 'ENEMY: SPAWNING';
            document.getElementById('enemyCounter').style.color = enemyActive ? '#f00' : '#ff8800';
        }
        
        function updateMovementPanel() {
            document.getElementById('playerPosition').textContent = 
                `${player.position.x.toFixed(1)}, ${player.position.z.toFixed(1)}`;
            document.getElementById('playerVelocity').textContent = 
                `${velocity.toFixed(1)}`;
            
            // Determine movement intent
            let intent = 'NONE';
            if (keys['KeyW'] && keys['KeyA']) intent = 'W+A';
            else if (keys['KeyW'] && keys['KeyD']) intent = 'W+D';
            else if (keys['KeyS'] && keys['KeyA']) intent = 'S+A';
            else if (keys['KeyS'] && keys['KeyD']) intent = 'S+D';
            else if (keys['KeyW']) intent = 'W';
            else if (keys['KeyA']) intent = 'A';
            else if (keys['KeyS']) intent = 'S';
            else if (keys['KeyD']) intent = 'D';
            
            document.getElementById('movementIntent').textContent = intent;
            document.getElementById('distanceTraveled').textContent = 
                `${totalDistanceTraveled.toFixed(1)}m`;
        }
        
        function showHitMarker(color) {
            const marker = document.getElementById('hitMarker');
            marker.style.borderColor = color;
            marker.style.display = 'block';
            
            setTimeout(() => {
                marker.style.display = 'none';
            }, 200);
        }
        
        function startSessionTimer() {
            clearInterval(sessionTimer);
            sessionTimer = setInterval(() => {
                const elapsed = Date.now() - bciSession.startTime;
                const minutes = Math.floor(elapsed / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                document.getElementById('sessionTime').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }
        
        function showExportModal() {
            const statsDiv = document.getElementById('exportStats');
            const accuracy = shotsFired > 0 ? ((shotsHit / shotsFired) * 100).toFixed(1) : 0;
            const totalXP = xp + (level - 1) * 1000;
            const avgReaction = avgReactionTime.toFixed(1);
            
            const stats = `
                <div><strong>Session Duration:</strong> ${formatTime(Date.now() - bciSession.startTime)}</div>
                <div><strong>Neural Samples:</strong> ${bciSession.neuralData.length.toLocaleString()}</div>
                <div><strong>Movement Intent Samples:</strong> ${bciSession.movementIntentData.length.toLocaleString()}</div>
                <div><strong>Telemetry Samples:</strong> ${bciSession.telemetry.length.toLocaleString()}</div>
                <div><strong>Accuracy:</strong> ${accuracy}%</div>
                <div><strong>Avg Reaction Time:</strong> ${avgReaction}ms</div>
                <div><strong>Level Reached:</strong> ${level}</div>
                <div><strong>Distance Traveled:</strong> ${totalDistanceTraveled.toFixed(1)}m</div>
                <div><strong>Dataset Size:</strong> ~${Math.round((bciSession.neuralData.length * 0.18) / 1024)}KB</div>
            `;
            
            statsDiv.innerHTML = stats;
            document.getElementById('exportModal').style.display = 'block';
            gameState = 'PAUSED';
        }
        
        function hideExportModal() {
            document.getElementById('exportModal').style.display = 'none';
            if (gameState === 'PAUSED') {
                gameState = 'PLAYING';
                document.body.requestPointerLock();
            }
        }
        
        function formatTime(ms) {
            const seconds = Math.floor(ms / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            
            if (hours > 0) {
                return `${hours}h ${minutes % 60}m`;
            } else if (minutes > 0) {
                return `${minutes}m ${seconds % 60}s`;
            } else {
                return `${seconds}s`;
            }
        }
        
        function loadGameStats() {
            try {
                const savedStats = JSON.parse(localStorage.getItem('bciGridStats') || '{}');
                
                document.getElementById('menuSamples').textContent = 
                    (savedStats.totalSamples || 0).toLocaleString();
                document.getElementById('menuLevel').textContent = savedStats.highestLevel || 1;
                document.getElementById('menuXP').textContent = (savedStats.totalXP || 0).toLocaleString();
                document.getElementById('menuKills').textContent = savedStats.totalKills || 0;
                document.getElementById('menuAccuracy').textContent = 
                    savedStats.bestAccuracy ? `${savedStats.bestAccuracy.toFixed(1)}%` : '0%';
            } catch (e) {
                console.error("Error loading game stats:", e);
            }
        }
        
        function saveGameStats() {
            try {
                const accuracy = shotsFired > 0 ? (shotsHit / shotsFired) * 100 : 0;
                const savedStats = JSON.parse(localStorage.getItem('bciGridStats') || '{}');
                
                const stats = {
                    totalSamples: (savedStats.totalSamples || 0) + bciSession.samplesCollected,
                    highestLevel: Math.max(level, savedStats.highestLevel || 0),
                    totalXP: (savedStats.totalXP || 0) + xp,
                    totalKills: (savedStats.totalKills || 0) + enemiesDestroyed,
                    bestAccuracy: Math.max(accuracy, savedStats.bestAccuracy || 0),
                    bestReaction: avgReactionTime > 0 ? Math.min(avgReactionTime, savedStats.bestReaction || Infinity) : (savedStats.bestReaction || Infinity),
                    totalDistance: (savedStats.totalDistance || 0) + totalDistanceTraveled,
                    lastExport: new Date().toISOString()
                };
                
                localStorage.setItem('bciGridStats', JSON.stringify(stats));
            } catch (e) {
                console.error("Error saving game stats:", e);
            }
        }
        
        // ============================================
        // DATASET EXPORT - WITH MOVEMENT INTENT DATA
        // ============================================
        
        async function exportDataset(format) {
            try {
                const sessionId = `bcigrid_${Date.now()}`;
                const sessionDuration = Date.now() - bciSession.startTime;
                const accuracy = shotsFired > 0 ? parseFloat(((shotsHit / shotsFired) * 100).toFixed(2)) : 0;
                
                // Calculate metrics
                const metrics = {
                    accuracy: accuracy,
                    avg_reaction_time: parseFloat(avgReactionTime.toFixed(2)),
                    level_reached: level,
                    enemies_destroyed: enemiesDestroyed,
                    total_shots: shotsFired,
                    total_hits: shotsHit,
                    max_streak: maxStreak,
                    total_xp: xp,
                    distance_traveled: parseFloat(totalDistanceTraveled.toFixed(2)),
                    movement_intent_samples: bciSession.movementIntentData.length,
                    session_duration: sessionDuration,
                    data_samples: bciSession.samplesCollected,
                    data_rate: bciSession.bandwidth
                };
                
                // Create metadata
                const metadata = {
                    dataset_info: {
                        name: "BCI_Grid_Movement_Dataset",
                        description: "BCI dataset with WASD movement intent data from single-enemy grid training environment. Includes neural signals, movement vectors, and game telemetry for ML training.",
                        version: "1.0.0",
                        created: new Date().toISOString(),
                        license: "MIT",
                        citation: `@misc{bcigrid_${new Date().getFullYear()},
  title={BCI Grid Movement Intent Dataset},
  author={BCI Research},
  year=${new Date().getFullYear()},
  note={Movement intent data from grid training environment}
}`,
                        tags: [
                            "bci", "movement-intent", "neural-signals", 
                            "fps-telemetry", "grid-environment", "brain-computer-interface",
                            "wasd-movement", "intent-prediction"
                        ],
                        task: "Train ML models for movement intent prediction from neural signals in 3D environments",
                        target_use_cases: [
                            "Movement intent prediction from neural signals",
                            "Correlation analysis between WASD inputs and neural patterns",
                            "Reinforcement learning for BCI navigation",
                            "3D environment interaction analysis"
                        ]
                    },
                    
                    session_info: {
                        session_id: sessionId,
                        duration_ms: sessionDuration,
                        start_time: new Date(bciSession.startTime).toISOString(),
                        end_time: new Date().toISOString(),
                        grid_size: CONFIG.GRID_SIZE
                    },
                    
                    metrics: metrics,
                    
                    data_structure: {
                        neural_data: {
                            description: "12-channel simulated neural signals with movement intent labels",
                            sample_rate: 100,
                            features: ["timestamp", "session_time", "channels", "game_context", "movement_intent", "fire_intent"]
                        },
                        movement_intent_data: {
                            description: "Detailed WASD movement intent data with vectors",
                            sample_rate: 60,
                            features: ["timestamp", "session_time", "keys", "movement_vector", "player_position", "velocity", "distance_traveled"]
                        },
                        telemetry: {
                            description: "Game state and player telemetry",
                            sample_rate: 60,
                            features: ["timestamp", "session_time", "player_state", "game_state", "input_state"]
                        },
                        game_events: {
                            description: "Discrete game events",
                            event_types: ["game_start", "enemy_spawn", "shot_fired", "enemy_destroyed", "level_up"]
                        }
                    }
                };
                
                // Create ZIP
                const zip = new JSZip();
                
                if (format === 'hf') {
                    // HuggingFace format with train/test splits
                    await exportHuggingFaceFormat(zip, sessionId, metadata);
                } else {
                    // JSONL format
                    await exportJSONLFormat(zip, sessionId, metadata);
                }
                
                // Add metadata
                zip.file("metadata.json", JSON.stringify(metadata, null, 2));
                
                // Add dataset card
                const datasetCard = `# BCI Grid Movement Intent Dataset

## Description
BCI dataset with WASD movement intent data from single-enemy grid training environment. 
Includes neural signals, movement vectors, and game telemetry for ML training on movement intent prediction.

## Session Information
- **Session ID**: ${sessionId}
- **Duration**: ${formatTime(sessionDuration)}
- **Level Reached**: ${level}
- **Accuracy**: ${accuracy}%
- **Avg Reaction Time**: ${avgReactionTime.toFixed(1)}ms
- **Distance Traveled**: ${totalDistanceTraveled.toFixed(1)}m
- **Movement Intent Samples**: ${bciSession.movementIntentData.length.toLocaleString()}
- **Neural Samples**: ${bciSession.neuralData.length.toLocaleString()}

## Environment
- **Grid Size**: ${CONFIG.GRID_SIZE}x${CONFIG.GRID_SIZE} units
- **Single Enemy System**: One enemy at a time, respawns after destruction
- **WASD Movement**: Full 3D movement with intent tracking
- **Fixed Player Height**: ${CONFIG.PLAYER_HEIGHT} units

## Data Structure
### 1. Neural Data (100Hz)
- 12-channel simulated neural signals
- Movement intent labels (W/A/S/D keys pressed)
- Fire intent labels (mouse click)
- Game context (enemy status, streak, accuracy, position)

### 2. Movement Intent Data (~60Hz)
- Raw WASD key states
- Movement vectors (direction and magnitude)
- Player position coordinates
- Velocity and distance traveled

### 3. Telemetry (60Hz)
- Player state (position, rotation, velocity)
- Game state (level, XP, score, streak)
- Input state (keys pressed, mouse activity)

### 4. Game Events
- Timestamped events with full context
- Enemy spawn/destroy events with reaction times
- Level-up events with performance metrics

## Intended Use
- Train ML models for movement intent prediction from neural signals
- Analyze correlations between WASD inputs and neural patterns
- Research reinforcement learning for BCI navigation
- Study 3D environment interaction in BCI systems

## Tags
bci, movement-intent, neural-signals, fps-telemetry, grid-environment, brain-computer-interface, wasd-movement, intent-prediction

## Citation
\`\`\`bibtex
@misc{bcigrid_${new Date().getFullYear()},
  title={BCI Grid Movement Intent Dataset},
  author={BCI Research},
  year=${new Date().getFullYear()},
  note={Movement intent data from grid training environment}
}
\`\`\`

## License
MIT
`;
                
                zip.file("README.md", datasetCard);
                
                // Generate and download
                const content = await zip.generateAsync({ 
                    type: "blob",
                    compression: "DEFLATE"
                });
                
                saveAs(content, `${sessionId}.zip`);
                
                // Save stats and award XP
                saveGameStats();
                const exportXP = Math.floor(bciSession.samplesCollected / 100) * 30;
                addXP(exportXP);
                
                alert(`✅ DATASET EXPORTED!\n\n📁 File: ${sessionId}.zip\n📊 Format: ${format === 'hf' ? 'HuggingFace' : 'JSONL'}\n📈 Movement Samples: ${bciSession.movementIntentData.length.toLocaleString()}\n🎮 +${exportXP} XP\n\n🚀 Ready for movement intent research!`);
                
                hideExportModal();
                
            } catch (error) {
                console.error("Error exporting dataset:", error);
                alert("Error exporting dataset. Please try again.");
            }
        }
        
        async function exportHuggingFaceFormat(zip, sessionId, metadata) {
            // Split data into train/test (80/20)
            
            // Neural data split
            const neuralSplitIndex = Math.floor(bciSession.neuralData.length * CONFIG.TRAIN_TEST_SPLIT);
            const trainNeural = bciSession.neuralData.slice(0, neuralSplitIndex);
            const testNeural = bciSession.neuralData.slice(neuralSplitIndex);
            
            // Movement intent data split
            const movementSplitIndex = Math.floor(bciSession.movementIntentData.length * CONFIG.TRAIN_TEST_SPLIT);
            const trainMovement = bciSession.movementIntentData.slice(0, movementSplitIndex);
            const testMovement = bciSession.movementIntentData.slice(movementSplitIndex);
            
            // Telemetry split
            const telemetrySplitIndex = Math.floor(bciSession.telemetry.length * CONFIG.TRAIN_TEST_SPLIT);
            const trainTelemetry = bciSession.telemetry.slice(0, telemetrySplitIndex);
            const testTelemetry = bciSession.telemetry.slice(telemetrySplitIndex);
            
            // Events split
            const eventsSplitIndex = Math.floor(bciSession.gameEvents.length * CONFIG.TRAIN_TEST_SPLIT);
            const trainEvents = bciSession.gameEvents.slice(0, eventsSplitIndex);
            const testEvents = bciSession.gameEvents.slice(eventsSplitIndex);
            
            // Create train folder
            const trainFolder = zip.folder("train");
            
            // Train data
            let trainNeuralJSONL = "";
            trainNeural.forEach(sample => {
                trainNeuralJSONL += JSON.stringify(sample) + "\n";
            });
            trainFolder.file("neural_data.jsonl", trainNeuralJSONL);
            
            let trainMovementJSONL = "";
            trainMovement.forEach(sample => {
                trainMovementJSONL += JSON.stringify(sample) + "\n";
            });
            trainFolder.file("movement_intent.jsonl", trainMovementJSONL);
            
            let trainTelemetryJSONL = "";
            trainTelemetry.forEach(sample => {
                trainTelemetryJSONL += JSON.stringify(sample) + "\n";
            });
            trainFolder.file("telemetry.jsonl", trainTelemetryJSONL);
            
            let trainEventsJSONL = "";
            trainEvents.forEach(event => {
                trainEventsJSONL += JSON.stringify(event) + "\n";
            });
            trainFolder.file("events.jsonl", trainEventsJSONL);
            
            // Create test folder
            const testFolder = zip.folder("test");
            
            // Test data
            let testNeuralJSONL = "";
            testNeural.forEach(sample => {
                testNeuralJSONL += JSON.stringify(sample) + "\n";
            });
            testFolder.file("neural_data.jsonl", testNeuralJSONL);
            
            let testMovementJSONL = "";
            testMovement.forEach(sample => {
                testMovementJSONL += JSON.stringify(sample) + "\n";
            });
            testFolder.file("movement_intent.jsonl", testMovementJSONL);
            
            let testTelemetryJSONL = "";
            testTelemetry.forEach(sample => {
                testTelemetryJSONL += JSON.stringify(sample) + "\n";
            });
            testFolder.file("telemetry.jsonl", testTelemetryJSONL);
            
            let testEventsJSONL = "";
            testEvents.forEach(event => {
                testEventsJSONL += JSON.stringify(event) + "\n";
            });
            testFolder.file("events.jsonl", testEventsJSONL);
            
            // Add split info to metadata
            metadata.data_splits = {
                train_test_ratio: CONFIG.TRAIN_TEST_SPLIT,
                neural_data: {
                    train: trainNeural.length,
                    test: testNeural.length
                },
                movement_intent: {
                    train: trainMovement.length,
                    test: testMovement.length
                },
                telemetry: {
                    train: trainTelemetry.length,
                    test: testTelemetry.length
                },
                game_events: {
                    train: trainEvents.length,
                    test: testEvents.length
                }
            };
        }
        
        async function exportJSONLFormat(zip, sessionId, metadata) {
            // Export everything in JSONL format
            let neuralJSONL = "";
            bciSession.neuralData.forEach(sample => {
                neuralJSONL += JSON.stringify(sample) + "\n";
            });
            zip.file("neural_data.jsonl", neuralJSONL);
            
            let movementJSONL = "";
            bciSession.movementIntentData.forEach(sample => {
                movementJSONL += JSON.stringify(sample) + "\n";
            });
            zip.file("movement_intent.jsonl", movementJSONL);
            
            let telemetryJSONL = "";
            bciSession.telemetry.forEach(sample => {
                telemetryJSONL += JSON.stringify(sample) + "\n";
            });
            zip.file("telemetry.jsonl", telemetryJSONL);
            
            let eventsJSONL = "";
            bciSession.gameEvents.forEach(event => {
                eventsJSONL += JSON.stringify(event) + "\n";
            });
            zip.file("events.jsonl", eventsJSONL);
        }
        
        // ============================================
        // INPUT HANDLING
        // ============================================
        
        function setupEventListeners() {
            // Menu buttons
            document.getElementById('startBtn').addEventListener('click', startGame);
            
            document.getElementById('exportBtn').addEventListener('click', () => {
                if (bciSession.samplesCollected > 0) {
                    showExportModal();
                } else {
                    alert("Play the game first to collect BCI data!");
                }
            });
            
            document.getElementById('statsBtn').addEventListener('click', () => {
                const accuracy = shotsFired > 0 ? ((shotsHit / shotsFired) * 100).toFixed(1) : 0;
                const stats = `📊 TRAINING STATS\n\n` +
                             `🎮 Level: ${level}\n` +
                             `⭐ XP: ${xp.toLocaleString()}\n` +
                             `🎯 Accuracy: ${accuracy}%\n` +
                             `💀 Enemies Destroyed: ${enemiesDestroyed}\n` +
                             `🔥 Current Streak: ${currentStreak}\n` +
                             `⚡ Avg Reaction: ${avgReactionTime.toFixed(0)}ms\n` +
                             `🏃 Distance Traveled: ${totalDistanceTraveled.toFixed(1)}m\n` +
                             `🧠 BCI Samples: ${bciSession.samplesCollected.toLocaleString()}\n` +
                             `🎮 Movement Samples: ${bciSession.movementIntentData.length.toLocaleString()}`;
                alert(stats);
            });
            
            // Keyboard input
            document.addEventListener('keydown', (e) => {
                keys[e.code] = true;
                
                if (e.code === 'Escape') {
                    if (gameState === 'PLAYING') {
                        gameState = 'MENU';
                        document.getElementById('mainMenu').style.display = 'flex';
                        document.getElementById('hud').style.display = 'none';
                        document.getElementById('crosshair').style.display = 'none';
                        document.getElementById('movementPanel').style.display = 'none';
                        document.exitPointerLock();
                        
                        stopBCIDataCollection();
                        saveGameStats();
                        loadGameStats();
                    }
                }
                
                // Prevent default for game keys
                if (['KeyW', 'KeyA', 'KeyS', 'KeyD', 'Space'].includes(e.code)) {
                    e.preventDefault();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
            });
            
            // Mouse input
            document.addEventListener('mousedown', (e) => {
                e.preventDefault();
                
                if (e.button === 0) {
                    mouse.buttons.left = true;
                    if (gameState === 'PLAYING') {
                        fire();
                    }
                }
            });
            
            document.addEventListener('mouseup', (e) => {
                if (e.button === 0) mouse.buttons.left = false;
            });
            
            // Mouse movement
            document.addEventListener('mousemove', (e) => {
                if (document.pointerLockElement === document.body && gameState === 'PLAYING') {
                    mouse.dx = e.movementX;
                    mouse.dy = e.movementY;
                    
                    if (player) {
                        player.rotation.y -= mouse.dx * CONFIG.MOUSE_SENSITIVITY;
                    }
                    if (camera) {
                        camera.rotation.x -= mouse.dy * CONFIG.MOUSE_SENSITIVITY;
                        camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                    }
                }
            });
            
            // Pointer lock
            document.addEventListener('click', () => {
                if (gameState === 'PLAYING' && !document.pointerLockElement) {
                    document.body.requestPointerLock();
                }
            });
            
            // Prevent context menu
            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                return false;
            });
            
            // Window resize
            window.addEventListener('resize', () => {
                if (camera && renderer) {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
            });
        }
        
        // ============================================
        // GAME LOOP
        // ============================================
        
        let lastTime = 0;
        function animate(currentTime = 0) {
            requestAnimationFrame(animate);
            
            const delta = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;
            
            frameCount++;
            if (currentTime - lastFpsUpdate >= 1000) {
                const fps = frameCount;
                frameCount = 0;
                lastFpsUpdate = currentTime;
            }
            
            if (gameState === 'PLAYING') {
                // Update player movement
                updatePlayer(delta);
                
                // Update bullets
                updateBullets(delta);
            }
            
            // Render scene
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }
        
        // ============================================
        // START GAME
        // ============================================
        
        window.addEventListener('load', init);
    </script>
</body>
</html>
