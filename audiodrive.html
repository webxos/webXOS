<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>webXOS AUDIODRIVE v1.0</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.2;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        /* Loading */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .ascii {
            white-space: pre;
            font-size: 8px;
            line-height: 1;
            color: #0f0;
            text-align: center;
        }
        
        /* Header */
        #header {
            padding: 5px;
            border-bottom: 1px solid #0f0;
            text-align: center;
            background: #000;
            z-index: 1;
            flex-shrink: 0;
        }
        
        #header .ascii {
            font-size: 6px;
            margin-bottom: 2px;
        }
        
        /* Main Container - FIXED FLEXBOX LAYOUT */
        .main-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        
        /* Terminal Container - FIXED SCROLLING */
        .terminal-container {
            flex: 1;
            min-height: 0; /* CRITICAL FIX: Allows shrinking for scrolling */
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        #terminal {
            flex: 1;
            min-height: 0; /* CRITICAL FIX: Override default min-height: auto */
            overflow-y: auto;
            padding: 10px;
            padding-bottom: 0;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        #output {
            min-height: 0; /* CRITICAL FIX: Allows content to overflow */
            display: flex;
            flex-direction: column;
            flex: 1;
        }
        
        /* Terminal Content Container */
        .terminal-content {
            min-height: 0;
            display: flex;
            flex-direction: column;
            flex: 1;
        }
        
        .line {
            margin-bottom: 2px;
            word-wrap: break-word;
            word-break: break-all;
            flex-shrink: 0;
        }
        
        .input-line {
            color: #0f0;
        }
        
        .output-line {
            color: #0a0;
        }
        
        .error {
            color: #f00;
        }
        
        /* Audio File Entry */
        .audio-entry {
            margin: 5px 0;
            padding: 3px;
            background: #000;
            border-left: 2px solid #0f0;
            word-break: break-word;
            flex-shrink: 0;
        }
        
        .audio-controls {
            display: inline-block;
            margin-left: 10px;
            margin-top: 2px;
        }
        
        .audio-controls button {
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 2px 5px;
            margin: 0 2px;
            cursor: pointer;
            font-size: 11px;
        }
        
        .audio-controls button:hover {
            background: #0f0;
            color: #000;
        }
        
        /* Bottom Bar */
        #bottom-bar {
            padding: 5px;
            background: #000;
            border-top: 1px solid #0f0;
            display: flex;
            gap: 5px;
            flex-shrink: 0;
            z-index: 10;
        }
        
        #command-input {
            flex: 1;
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 5px;
            font-family: 'Courier New', monospace;
        }
        
        #bottom-bar button {
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 5px 10px;
            cursor: pointer;
        }
        
        #bottom-bar button:hover {
            background: #0f0;
            color: #000;
        }
        
        /* Player Popup */
        #player-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            background: #000;
            border: 2px solid #0f0;
            padding: 15px;
            display: none;
            z-index: 1000;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }
        
        .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            border-bottom: 1px solid #0f0;
            padding-bottom: 5px;
        }
        
        .player-title {
            color: #0f0;
            font-weight: bold;
        }
        
        .close-btn {
            background: #000;
            border: 1px solid #f00;
            color: #f00;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            line-height: 1;
        }
        
        .close-btn:hover {
            background: #f00;
            color: #000;
        }
        
        .player-info {
            margin-bottom: 15px;
            min-height: 20px;
            color: #0a0;
            font-size: 12px;
            word-wrap: break-word;
        }
        
        .player-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            justify-content: center;
        }
        
        .player-controls button {
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 5px 15px;
            cursor: pointer;
            min-width: 70px;
        }
        
        .player-controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .player-controls button:hover:not(:disabled) {
            background: #0f0;
            color: #000;
        }
        
        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        #volume-slider {
            flex: 1;
            height: 5px;
            background: #000;
            border: 1px solid #0f0;
            outline: none;
        }
        
        .player-time {
            text-align: center;
            font-size: 11px;
            color: #0a0;
            margin-top: 5px;
        }
        
        /* Help Menu */
        #help-menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000;
            border: 1px solid #0f0;
            padding: 20px;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
            z-index: 1001;
            min-width: 400px;
        }
        
        .help-section {
            margin-bottom: 15px;
        }
        
        .help-title {
            color: #0f0;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .help-command {
            color: #0a0;
            margin: 2px 0;
            font-size: 12px;
        }
        
        /* Progress bar */
        .progress-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: #000;
            border-bottom: 1px solid #0a0;
            margin: 2px 0;
            display: none;
            z-index: 1000;
        }
        
        .progress-bar {
            height: 100%;
            background: #0f0;
            width: 0%;
            transition: width 0.3s;
        }
        
        /* Typewriter cursor */
        .typewriter-cursor {
            display: inline-block;
            width: 7px;
            height: 16px;
            background: #0f0;
            animation: blink 1s infinite;
            vertical-align: middle;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }
        
        /* Status indicators */
        .status-processing {
            color: #0a0;
            animation: pulse 1s infinite;
        }
        
        .status-done {
            color: #0f0;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        /* Command prompt */
        .prompt {
            color: #0f0;
            margin-right: 5px;
        }
        
        /* Overlay for popup */
        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            z-index: 999;
        }
        
        /* List command styling */
        .list-header {
            margin-bottom: 5px;
            color: #0f0;
            font-weight: bold;
            flex-shrink: 0;
        }
        
        .list-entry {
            margin: 3px 0;
            padding-left: 10px;
            word-break: break-word;
            flex-shrink: 0;
        }
        
        /* Scrollbar styling */
        #terminal::-webkit-scrollbar {
            width: 8px;
        }
        
        #terminal::-webkit-scrollbar-track {
            background: #000;
        }
        
        #terminal::-webkit-scrollbar-thumb {
            background: #0f0;
            border: 1px solid #000;
        }
        
        #terminal::-webkit-scrollbar-thumb:hover {
            background: #0a0;
        }
        
        /* Fixed spacer for bottom bar */
        .bottom-spacer {
            height: 50px; /* Matches bottom bar height */
            width: 100%;
            flex-shrink: 0;
            visibility: hidden;
        }
        
        /* Content wrapper for proper scrolling */
        .content-wrapper {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
            overflow: visible;
        }
        
        /* Queue status */
        .queue-status {
            color: #0a0;
            font-style: italic;
            font-size: 12px;
            margin-top: 5px;
            flex-shrink: 0;
        }
        
        /* Scrollable content area */
        .scrollable-content {
            flex: 1;
            min-height: 0;
            overflow: visible;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading">
        <div class="ascii">
                          __  __                  __            __                      
                          |  \|  \                |  \          |  \                     
  ______   __    __   ____| $$ \$$  ______    ____| $$  ______   \$$ __     __   ______  
 |      \ |  \  |  \ /      $$|  \ /      \  /      $$ /      \ |  \|  \   /  \ /      \ 
  \$$$$$$\| $$  | $$|  $$$$$$$| $$|  $$$$$$\|  $$$$$$$|  $$$$$$\| $$ \$$\ /  $$|  $$$$$$\
 /      $$| $$  | $$| $$  | $$| $$| $$  | $$| $$  | $$| $$   \$$| $$  \$$\  $$ | $$    $$
|  $$$$$$$| $$__/ $$| $$__| $$| $$| $$__/ $$| $$__| $$| $$      | $$   \$$ $$  | $$$$$$$$
 \$$    $$ \$$    $$ \$$    $$| $$ \$$    $$ \$$    $$| $$      | $$    \$$$    \$$     \
  \$$$$$$$  \$$$$$$   \$$$$$$$ \$$  \$$$$$$   \$$$$$$$ \$$       \$$     \$      \$$$$$$$
                                                                                         
                                                                                         
                                                                                         
        </div>
    </div>

    <!-- Popup Overlay -->
    <div id="popup-overlay" class="popup-overlay"></div>

    <!-- Main Container -->
    <div class="main-container" style="display:none;">
        <div id="header">
            <div class="ascii">
                          __  __                  __            __                      
                          |  \|  \                |  \          |  \                     
  ______   __    __   ____| $$ \$$  ______    ____| $$  ______   \$$ __     __   ______  
 |      \ |  \  |  \ /      $$|  \ /      \  /      $$ /      \ |  \|  \   /  \ /      \ 
  \$$$$$$\| $$  | $$|  $$$$$$$| $$|  $$$$$$\|  $$$$$$$|  $$$$$$\| $$ \$$\ /  $$|  $$$$$$\
 /      $$| $$  | $$| $$  | $$| $$| $$  | $$| $$  | $$| $$   \$$| $$  \$$\  $$ | $$    $$
|  $$$$$$$| $$__/ $$| $$__| $$| $$| $$__/ $$| $$__| $$| $$      | $$   \$$ $$  | $$$$$$$$
 \$$    $$ \$$    $$ \$$    $$| $$ \$$    $$ \$$    $$| $$      | $$    \$$$    \$$     \
  \$$$$$$$  \$$$$$$   \$$$$$$$ \$$  \$$$$$$   \$$$$$$$ \$$       \$$     \$      \$$$$$$$
                                                                                         
                                                                                         
                                                                                         
            </div>
            <div>AUDIODRIVE | 56K MODEM WAV | audiodrive by webxos 2025</div>
        </div>
        
        <!-- Terminal Container -->
        <div class="terminal-container">
            <!-- Terminal Output -->
            <div id="terminal">
                <div id="output">
                    <div class="content-wrapper" id="content-wrapper">
                        <!-- Content will be added here -->
                    </div>
                </div>
                <!-- Spacer to prevent content hiding behind bottom bar -->
                <div class="bottom-spacer"></div>
            </div>
        </div>

        <!-- Bottom Bar -->
        <div id="bottom-bar">
            <input type="text" id="command-input" placeholder="Type /help or enter text" autocomplete="off">
            <button id="send-btn">SEND</button>
            <button id="import-btn">IMPORT</button>
            <button id="export-btn">EXPORT ALL</button>
        </div>
    </div>

    <!-- Player Popup -->
    <div id="player-popup">
        <div class="player-header">
            <div class="player-title">ðŸŽµ MODEM PLAYER</div>
            <button class="close-btn" id="close-player-btn">âœ•</button>
        </div>
        <div class="player-info" id="player-info">No audio loaded</div>
        <div class="player-controls">
            <button id="play-btn">PLAY</button>
            <button id="pause-btn" disabled>PAUSE</button>
            <button id="stop-btn" disabled>STOP</button>
        </div>
        <div class="volume-control">
            <span>VOL:</span>
            <input type="range" id="volume-slider" min="0" max="100" value="70">
        </div>
        <div class="player-time" id="player-time">--:-- / --:--</div>
    </div>

    <!-- Help Menu -->
    <div id="help-menu">
        <div class="help-section">
            <div class="help-title">BASIC COMMANDS</div>
            <div class="help-command">/help - Show this menu</div>
            <div class="help-command">/guide - Quick start guide</div>
            <div class="help-command">/clear - Clear terminal</div>
        </div>
        
        <div class="help-section">
            <div class="help-title">AUDIO COMMANDS</div>
            <div class="help-command">[any text] - Auto-encode to 56K WAV</div>
            <div class="help-command">/import - Upload .wav file</div>
            <div class="help-command">/export - Export all as single .wav</div>
            <div class="help-command">/list - Show all audio files</div>
        </div>
        
        <div class="help-section">
            <div class="help-title">QUICK GUIDE</div>
            <div class="help-command">1. Type text to auto-encode to 56K modem WAV</div>
            <div class="help-command">2. Each file gets Play/Delete/Export buttons</div>
            <div class="help-command">3. Click Play to hear authentic modem sounds</div>
            <div class="help-command">4. Use Import for .wav files</div>
            <div class="help-command">5. Export All creates combined .wav</div>
        </div>
        
        <div style="text-align:center; margin-top:15px;">
            <button onclick="closeHelp()" style="background:#000; border:1px solid #0f0; color:#0f0; padding:3px 10px; cursor:pointer;">CLOSE</button>
        </div>
    </div>

    <!-- Hidden file input -->
    <input type="file" id="file-input" accept=".wav" style="display:none;">

    <!-- Progress container -->
    <div id="progress-container" class="progress-container">
        <div id="progress-bar" class="progress-bar"></div>
    </div>

    <script>
        // ==================== GLOBAL STATE ====================
        const terminal = {
            audioFiles: [],
            currentAudio: null,
            audioContext: null,
            currentSource: null,
            isPlaying: false,
            volume: 0.7,
            db: null,
            isTyping: false,
            playStartTime: 0,
            playDuration: 0,
            updateInterval: null,
            processingQueue: [],
            isProcessingQueue: false,
            autoScroll: true,
            userScrolledUp: false,
            lastScrollPosition: 0,
            scrollThreshold: 50,
            scrollDebounceTimer: null
        };

        // ==================== INITIALIZATION ====================
        async function init() {
            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
                document.querySelector('.main-container').style.display = 'flex';
                typewriterLog('AUDIODRIVE 56K Modem Transcoder ready.');
                setTimeout(() => typewriterLog('Type /help for commands.'), 500);
                initializeTerminal();
            }, 2000);

            // Initialize IndexedDB
            await initDB();
            
            // Load saved data
            await loadAudioFiles();
            
            // Setup event listeners
            setupEvents();
            
            // Focus input
            document.getElementById('command-input').focus();
            
            // Setup ESC key listener for closing popups
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closePlayer();
                    closeHelp();
                }
            });
        }
        
        function initializeTerminal() {
            const terminalEl = document.getElementById('terminal');
            const output = document.getElementById('output');
            
            // Set up scroll tracking with debounce
            terminalEl.addEventListener('scroll', () => {
                clearTimeout(terminal.scrollDebounceTimer);
                
                terminal.scrollDebounceTimer = setTimeout(() => {
                    const scrollBottom = terminalEl.scrollHeight - terminalEl.scrollTop - terminalEl.clientHeight;
                    terminal.lastScrollPosition = terminalEl.scrollTop;
                    
                    // If user scrolls up more than threshold from bottom, disable auto-scroll
                    if (scrollBottom > terminal.scrollThreshold) {
                        terminal.userScrolledUp = true;
                        terminal.autoScroll = false;
                    } else {
                        terminal.userScrolledUp = false;
                        terminal.autoScroll = true;
                    }
                }, 100);
            });
            
            // Initial scroll to bottom
            setTimeout(() => {
                scrollToBottom();
                terminal.autoScroll = true;
            }, 100);
        }

        // ==================== INDEXEDDB ====================
        async function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('AudioDrive56K', 5);
                
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('audioFiles')) {
                        const store = db.createObjectStore('audioFiles', { keyPath: 'id' });
                        store.createIndex('timestamp', 'timestamp');
                    }
                };
                
                request.onsuccess = (e) => {
                    terminal.db = e.target.result;
                    resolve();
                };
                
                request.onerror = (e) => {
                    console.error('Database error:', e);
                    reject();
                };
            });
        }

        async function saveAudioFile(file) {
            return new Promise((resolve, reject) => {
                const tx = terminal.db.transaction(['audioFiles'], 'readwrite');
                const store = tx.objectStore('audioFiles');
                
                const fileData = {
                    id: file.id,
                    text: file.text,
                    filename: file.filename,
                    timestamp: file.timestamp,
                    duration: file.duration,
                    imported: file.imported || false,
                    audioData: file.audioData || null,
                    sampleRate: file.sampleRate || 44100
                };
                
                const request = store.put(fileData);
                
                request.onsuccess = () => {
                    terminal.audioFiles.push(file);
                    resolve();
                };
                
                request.onerror = (e) => {
                    console.error('Save error:', e);
                    reject();
                };
            });
        }

        async function loadAudioFiles() {
            return new Promise((resolve, reject) => {
                const tx = terminal.db.transaction(['audioFiles'], 'readonly');
                const store = tx.objectStore('audioFiles');
                const request = store.getAll();
                
                request.onsuccess = (e) => {
                    const files = e.target.result || [];
                    
                    files.forEach(file => {
                        const audioFile = {
                            id: file.id,
                            text: file.text,
                            filename: file.filename,
                            timestamp: file.timestamp,
                            duration: file.duration,
                            imported: file.imported || false,
                            audioData: file.audioData || null,
                            sampleRate: file.sampleRate || 44100,
                            readyForExport: true
                        };
                        
                        terminal.audioFiles.push(audioFile);
                        displayAudioFile(audioFile);
                    });
                    
                    if (files.length > 0) {
                        typewriterLog(`Loaded ${files.length} audio files from storage`);
                    }
                    resolve();
                };
                
                request.onerror = (e) => {
                    console.error('Load error:', e);
                    reject();
                };
            });
        }

        async function deleteAudioFile(id) {
            const index = terminal.audioFiles.findIndex(f => f.id === id);
            if (index !== -1) {
                terminal.audioFiles.splice(index, 1);
            }
            
            return new Promise((resolve, reject) => {
                const tx = terminal.db.transaction(['audioFiles'], 'readwrite');
                const store = tx.objectStore('audioFiles');
                
                const request = store.delete(id);
                
                request.onsuccess = () => resolve();
                request.onerror = () => reject();
            });
        }

        async function clearStorage() {
            return new Promise((resolve, reject) => {
                const tx = terminal.db.transaction(['audioFiles'], 'readwrite');
                const store = tx.objectStore('audioFiles');
                
                const request = store.clear();
                
                request.onsuccess = () => {
                    terminal.audioFiles = [];
                    resolve();
                };
                
                request.onerror = () => reject();
            });
        }

        // ==================== PROCESSING QUEUE ====================
        async function processQueue() {
            if (terminal.isProcessingQueue || terminal.processingQueue.length === 0) {
                return;
            }
            
            terminal.isProcessingQueue = true;
            
            while (terminal.processingQueue.length > 0) {
                const text = terminal.processingQueue.shift();
                await processText(text);
                
                // Show queue status
                if (terminal.processingQueue.length > 0) {
                    const output = document.getElementById('content-wrapper');
                    const statusDiv = document.createElement('div');
                    statusDiv.className = 'queue-status';
                    statusDiv.textContent = `Queue: ${terminal.processingQueue.length} item(s) remaining...`;
                    output.appendChild(statusDiv);
                    
                    // Auto-scroll if enabled
                    if (terminal.autoScroll) {
                        scrollToBottom();
                    }
                    
                    // Remove status after 2 seconds
                    setTimeout(() => {
                        if (statusDiv.parentNode) {
                            statusDiv.remove();
                        }
                    }, 2000);
                }
                
                // Small delay between processing items
                await sleep(500);
            }
            
            terminal.isProcessingQueue = false;
        }

        async function processText(text) {
            try {
                if (!terminal.audioContext) {
                    terminal.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                showProgress();
                
                updateProgress(25);
                await sleep(300);
                
                const audioBuffer = generateModemAudio(text, terminal.audioContext.sampleRate);
                
                updateProgress(75);
                await sleep(300);
                
                // Convert audio buffer to array for storage
                const audioData = Array.from(audioBuffer.getChannelData(0));
                
                const audioFile = {
                    id: Date.now() + Math.random(),
                    text: text,
                    buffer: audioBuffer,
                    timestamp: Date.now(),
                    duration: audioBuffer.duration.toFixed(2),
                    audioData: audioData,
                    sampleRate: terminal.audioContext.sampleRate,
                    readyForExport: true
                };
                
                // Save to IndexedDB
                await saveAudioFile(audioFile);
                
                updateProgress(100);
                await sleep(200);
                
                hideProgress();
                
                displayAudioFile(audioFile);
                
                typewriterLog(`âœ“ Created 56K modem WAV (${audioFile.duration}s)`);
                
            } catch (error) {
                console.error('Encoding error:', error);
                log(`Encoding failed: ${error.message}`, 'error');
                hideProgress();
            }
        }

        // ==================== AUDIO ENCODING ====================
        function encodeText(text) {
            if (!text.trim()) {
                log('No text to encode', 'error');
                return;
            }
            
            // Add to processing queue
            terminal.processingQueue.push(text);
            
            // Show queue status
            if (terminal.processingQueue.length === 1) {
                typewriterLog(`Encoding "${text.substring(0, 50)}${text.length > 50 ? '...' : ''}" to 56K modem audio...`);
            } else {
                typewriterLog(`Added "${text.substring(0, 50)}${text.length > 50 ? '...' : ''}" to processing queue (position: ${terminal.processingQueue.length})`);
            }
            
            // Start processing queue if not already running
            if (!terminal.isProcessingQueue) {
                setTimeout(() => processQueue(), 100);
            }
        }

        function generateModemAudio(text, sampleRate) {
            const MARK_FREQ = 1200;    // Binary 1
            const SPACE_FREQ = 2400;   // Binary 0
            const ANSWER_FREQ = 2100;  // Answer tone
            const CARRIER_FREQ = 1800; // Carrier
            
            const BAUD_RATE = 2400;
            const BIT_DURATION = sampleRate / BAUD_RATE;
            
            const encoder = new TextEncoder();
            const bytes = encoder.encode(text);
            
            // Handshake: 1s answer + 0.5s carrier
            const handshakeSamples = sampleRate * 1.5;
            const dataSamples = bytes.length * 10 * BIT_DURATION;
            const totalSamples = Math.ceil(handshakeSamples + dataSamples + sampleRate * 0.5);
            
            const audioBuffer = terminal.audioContext.createBuffer(1, totalSamples, sampleRate);
            const data = audioBuffer.getChannelData(0);
            
            let sampleIndex = 0;
            
            // Handshake sequence
            for (let i = 0; i < sampleRate; i++) {
                const t = i / sampleRate;
                data[sampleIndex++] = 0.8 * Math.sin(2 * Math.PI * ANSWER_FREQ * t);
            }
            
            for (let i = 0; i < 0.5 * sampleRate; i++) {
                const t = (i + sampleRate) / sampleRate;
                data[sampleIndex++] = 0.6 * Math.sin(2 * Math.PI * CARRIER_FREQ * t);
            }
            
            // Data transmission
            for (let byte of bytes) {
                // Start bit (0)
                for (let i = 0; i < BIT_DURATION; i++) {
                    const t = sampleIndex / sampleRate;
                    data[sampleIndex++] = 0.7 * Math.sin(2 * Math.PI * SPACE_FREQ * t);
                }
                
                // 8 data bits
                for (let bit = 0; bit < 8; bit++) {
                    const value = (byte >> bit) & 1;
                    const freq = value ? MARK_FREQ : SPACE_FREQ;
                    
                    for (let i = 0; i < BIT_DURATION; i++) {
                        const t = sampleIndex / sampleRate;
                        data[sampleIndex++] = 0.7 * Math.sin(2 * Math.PI * freq * t);
                    }
                }
                
                // Stop bit (1)
                for (let i = 0; i < BIT_DURATION; i++) {
                    const t = sampleIndex / sampleRate;
                    data[sampleIndex++] = 0.7 * Math.sin(2 * Math.PI * MARK_FREQ * t);
                }
                
                // Small pause
                for (let i = 0; i < BIT_DURATION * 0.5 && sampleIndex < totalSamples; i++) {
                    data[sampleIndex++] = 0;
                }
            }
            
            // End sequence
            for (let i = 0; i < 0.5 * sampleRate && sampleIndex < totalSamples; i++) {
                const t = i / sampleRate;
                const freq = 400 + (200 * Math.sin(Math.PI * t));
                data[sampleIndex++] = 0.5 * Math.sin(2 * Math.PI * freq * t);
            }
            
            // Fill remaining with silence
            while (sampleIndex < totalSamples) {
                data[sampleIndex++] = 0;
            }
            
            return audioBuffer;
        }

        function recreateAudioBuffer(audioFile) {
            if (!terminal.audioContext) {
                terminal.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            const audioBuffer = terminal.audioContext.createBuffer(1, audioFile.audioData.length, audioFile.sampleRate);
            const channelData = audioBuffer.getChannelData(0);
            
            // Copy the audio data
            for (let i = 0; i < audioFile.audioData.length; i++) {
                channelData[i] = audioFile.audioData[i];
            }
            
            audioFile.buffer = audioBuffer;
            audioFile.readyForExport = true;
            
            return audioBuffer;
        }

        // ==================== EXPORT FUNCTIONS ====================
        async function exportAllFiles() {
            if (terminal.audioFiles.length === 0) {
                log('No audio files to export', 'error');
                return;
            }
            
            showProgress();
            typewriterLog(`Exporting ${terminal.audioFiles.length} files as combined WAV...`);
            
            setTimeout(async () => {
                try {
                    if (!terminal.audioContext) {
                        terminal.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    updateProgress(10);
                    
                    // Ensure all buffers are available
                    const exportableFiles = [];
                    for (const file of terminal.audioFiles) {
                        if (file.readyForExport) {
                            if (!file.buffer && file.audioData) {
                                recreateAudioBuffer(file);
                            }
                            exportableFiles.push(file);
                        }
                    }
                    
                    if (exportableFiles.length === 0) {
                        hideProgress();
                        log('No exportable files found', 'error');
                        return;
                    }
                    
                    updateProgress(40);
                    
                    // Combine all buffers
                    const combinedBuffer = combineAudioBuffers(exportableFiles);
                    
                    updateProgress(80);
                    await sleep(300);
                    
                    // Create filename with timestamp
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/[:T]/g, '-');
                    const filename = `audiodrive-combined-${timestamp}.wav`;
                    
                    // Export the combined file
                    downloadWav(combinedBuffer, filename);
                    
                    updateProgress(100);
                    await sleep(200);
                    
                    hideProgress();
                    
                    typewriterLog(`âœ“ Exported ${exportableFiles.length} files as: ${filename}`);
                    
                } catch (error) {
                    console.error('Export error:', error);
                    log(`Export failed: ${error.message}`, 'error');
                    hideProgress();
                }
            }, 300);
        }

        function exportSingleFile(audioFile) {
            if (!audioFile.readyForExport) {
                log('File not ready for export', 'error');
                return;
            }
            
            showProgress();
            typewriterLog(`Exporting single file...`);
            
            setTimeout(async () => {
                try {
                    if (!audioFile.buffer && audioFile.audioData) {
                        recreateAudioBuffer(audioFile);
                    }
                    
                    if (!audioFile.buffer) {
                        throw new Error('Audio buffer not available');
                    }
                    
                    updateProgress(50);
                    await sleep(300);
                    
                    const text = audioFile.text ? audioFile.text.substring(0, 20).replace(/[^a-z0-9]/gi, '-') : 'audio';
                    const timestamp = new Date().toISOString().slice(0, 10);
                    const filename = `audiodrive-${text}-${timestamp}.wav`;
                    
                    downloadWav(audioFile.buffer, filename);
                    
                    updateProgress(100);
                    await sleep(200);
                    
                    hideProgress();
                    
                    typewriterLog(`âœ“ Exported: ${filename}`);
                    
                } catch (error) {
                    console.error('Single export error:', error);
                    log(`Export failed: ${error.message}`, 'error');
                    hideProgress();
                }
            }, 100);
        }

        function combineAudioBuffers(files) {
            const sampleRate = terminal.audioContext.sampleRate;
            const gapDuration = 0.5; // 0.5 seconds between files
            const gapSamples = Math.floor(gapDuration * sampleRate);
            
            // Calculate total length
            let totalSamples = 0;
            for (const file of files) {
                if (file.buffer) {
                    totalSamples += file.buffer.length + gapSamples;
                }
            }
            
            // Remove last gap
            if (files.length > 0) {
                totalSamples -= gapSamples;
            }
            
            // Create combined buffer
            const combinedBuffer = terminal.audioContext.createBuffer(1, totalSamples, sampleRate);
            const combinedData = combinedBuffer.getChannelData(0);
            
            let offset = 0;
            for (const file of files) {
                if (file.buffer) {
                    const fileData = file.buffer.getChannelData(0);
                    combinedData.set(fileData, offset);
                    offset += file.buffer.length;
                    
                    // Add gap (except after last file)
                    if (offset < totalSamples) {
                        for (let i = 0; i < gapSamples && offset + i < totalSamples; i++) {
                            combinedData[offset + i] = 0;
                        }
                        offset += gapSamples;
                    }
                }
            }
            
            return combinedBuffer;
        }

        function downloadWav(audioBuffer, filename) {
            try {
                const wavData = audioBufferToWav(audioBuffer);
                const blob = new Blob([wavData], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
            } catch (error) {
                console.error('Download error:', error);
                log('Download failed: Could not create WAV file', 'error');
            }
        }

        function audioBufferToWav(audioBuffer) {
            const numChannels = audioBuffer.numberOfChannels;
            const sampleRate = audioBuffer.sampleRate;
            const format = 1; // PCM
            const bitDepth = 16;
            
            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;
            const dataSize = audioBuffer.length * numChannels * bytesPerSample;
            
            const arrayBuffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(arrayBuffer);
            
            // WAV header
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, format, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * blockAlign, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);
            
            // Write PCM samples
            let offset = 44;
            for (let i = 0; i < audioBuffer.length; i++) {
                for (let channel = 0; channel < numChannels; channel++) {
                    const sample = Math.max(-1, Math.min(1, audioBuffer.getChannelData(channel)[i]));
                    view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                    offset += 2;
                }
            }
            
            return arrayBuffer;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // ==================== IMPORT FUNCTION ====================
        async function importWav(file) {
            if (!file.name.toLowerCase().endsWith('.wav')) {
                log('Only .wav files supported', 'error');
                return;
            }
            
            showProgress();
            typewriterLog(`Importing: ${file.name}...`);
            
            try {
                const arrayBuffer = await file.arrayBuffer();
                
                if (!terminal.audioContext) {
                    terminal.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                updateProgress(30);
                
                const audioBuffer = await terminal.audioContext.decodeAudioData(arrayBuffer);
                
                updateProgress(70);
                
                // Convert to array for storage
                const audioData = Array.from(audioBuffer.getChannelData(0));
                
                const audioFile = {
                    id: Date.now(),
                    filename: file.name,
                    buffer: audioBuffer,
                    timestamp: Date.now(),
                    duration: audioBuffer.duration.toFixed(2),
                    imported: true,
                    audioData: audioData,
                    sampleRate: audioBuffer.sampleRate,
                    readyForExport: true
                };
                
                // Save to IndexedDB
                await saveAudioFile(audioFile);
                
                updateProgress(100);
                await sleep(200);
                
                hideProgress();
                
                displayAudioFile(audioFile);
                
                setTimeout(() => {
                    typewriterLog(`âœ“ Imported ${file.name} (${audioFile.duration}s)`);
                    typewriterLog('File is ready for export.');
                }, 300);
                
            } catch (e) {
                console.error('Import error:', e);
                log('Import failed: ' + e.message, 'error');
                hideProgress();
            }
        }

        // ==================== PLAYER FUNCTIONS ====================
        async function playAudio(audioFile) {
            if (!audioFile.buffer) {
                if (audioFile.audioData) {
                    recreateAudioBuffer(audioFile);
                } else {
                    log('Audio buffer not available', 'error');
                    return;
                }
            }
            
            // Ensure audio context is ready
            if (!terminal.audioContext) {
                terminal.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            if (terminal.audioContext.state === 'suspended') {
                await terminal.audioContext.resume();
            }
            
            // Stop any currently playing audio
            if (terminal.currentSource) {
                try {
                    terminal.currentSource.stop();
                } catch (e) {
                    // Ignore if already stopped
                }
                terminal.currentSource = null;
                clearInterval(terminal.updateInterval);
            }
            
            terminal.currentAudio = audioFile;
            terminal.currentSource = terminal.audioContext.createBufferSource();
            terminal.currentSource.buffer = audioFile.buffer;
            
            const gainNode = terminal.audioContext.createGain();
            gainNode.gain.value = terminal.volume;
            
            terminal.currentSource.connect(gainNode);
            gainNode.connect(terminal.audioContext.destination);
            
            terminal.currentSource.start();
            terminal.isPlaying = true;
            terminal.playStartTime = terminal.audioContext.currentTime;
            terminal.playDuration = parseFloat(audioFile.duration);
            
            // Show player
            showPlayer();
            
            const info = audioFile.text ? 
                audioFile.text.substring(0, 30) + (audioFile.text.length > 30 ? '...' : '') : 
                audioFile.filename || 'Modem Audio';
            document.getElementById('player-info').textContent = info;
            
            updatePlayerButtons();
            
            // Start time update interval
            updatePlayerTime();
            terminal.updateInterval = setInterval(updatePlayerTime, 1000);
            
            terminal.currentSource.onended = () => {
                terminal.isPlaying = false;
                terminal.currentSource = null;
                clearInterval(terminal.updateInterval);
                updatePlayerButtons();
                document.getElementById('player-time').textContent = formatTime(terminal.playDuration) + ' / ' + formatTime(terminal.playDuration);
            };
            
            typewriterLog(`Playing 56K modem audio (${audioFile.duration}s)`);
        }

        function updatePlayerTime() {
            if (terminal.isPlaying && terminal.audioContext) {
                const currentTime = terminal.audioContext.currentTime - terminal.playStartTime;
                const timeElement = document.getElementById('player-time');
                timeElement.textContent = formatTime(currentTime) + ' / ' + formatTime(terminal.playDuration);
            }
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function pauseAudio() {
            if (!terminal.audioContext || !terminal.isPlaying) return;
            
            terminal.audioContext.suspend().then(() => {
                terminal.isPlaying = false;
                clearInterval(terminal.updateInterval);
                updatePlayerButtons();
            });
        }

        function resumeAudio() {
            if (!terminal.audioContext || terminal.isPlaying) return;
            
            terminal.audioContext.resume().then(() => {
                terminal.isPlaying = true;
                terminal.playStartTime = terminal.audioContext.currentTime;
                updatePlayerButtons();
                updatePlayerTime();
                terminal.updateInterval = setInterval(updatePlayerTime, 1000);
            });
        }

        function stopAudio() {
            if (terminal.currentSource) {
                try {
                    terminal.currentSource.stop();
                } catch(e) {
                    // Ignore if already stopped
                }
                terminal.currentSource = null;
            }
            terminal.isPlaying = false;
            clearInterval(terminal.updateInterval);
            
            if (terminal.audioContext && terminal.audioContext.state === 'suspended') {
                terminal.audioContext.resume();
            }
            
            updatePlayerButtons();
        }

        function updatePlayerButtons() {
            const playBtn = document.getElementById('play-btn');
            const pauseBtn = document.getElementById('pause-btn');
            const stopBtn = document.getElementById('stop-btn');
            
            if (terminal.currentAudio) {
                playBtn.textContent = terminal.isPlaying ? 'RESUME' : 'PLAY';
                playBtn.disabled = terminal.isPlaying;
                pauseBtn.disabled = !terminal.isPlaying;
                stopBtn.disabled = !terminal.currentSource;
            }
        }

        function showPlayer() {
            const player = document.getElementById('player-popup');
            const overlay = document.getElementById('popup-overlay');
            player.style.display = 'block';
            overlay.style.display = 'block';
        }

        function closePlayer() {
            const player = document.getElementById('player-popup');
            const overlay = document.getElementById('popup-overlay');
            player.style.display = 'none';
            overlay.style.display = 'none';
            
            // Stop audio if playing
            if (terminal.isPlaying) {
                stopAudio();
            }
        }

        // ==================== UTILITY FUNCTIONS ====================
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function showProgress() {
            const progress = document.getElementById('progress-container');
            progress.style.display = 'block';
        }

        function updateProgress(percent) {
            const progressBar = document.getElementById('progress-bar');
            progressBar.style.width = percent + '%';
        }

        function hideProgress() {
            const progress = document.getElementById('progress-container');
            progress.style.display = 'none';
            updateProgress(0);
        }

        // ==================== SCROLLING FUNCTIONS ====================
        function scrollToBottom() {
            const terminalEl = document.getElementById('terminal');
            setTimeout(() => {
                terminalEl.scrollTop = terminalEl.scrollHeight;
                terminal.autoScroll = true;
                terminal.userScrolledUp = false;
            }, 10);
        }
        
        function smartScrollToBottom() {
            if (terminal.autoScroll && !terminal.userScrolledUp) {
                scrollToBottom();
            }
        }

        // ==================== TYPEWRITER EFFECT ====================
        function typewriterLog(message, type = 'output') {
            const output = document.getElementById('content-wrapper');
            const div = document.createElement('div');
            div.className = `line ${type}-line`;
            output.appendChild(div);
            
            terminal.isTyping = true;
            let i = 0;
            
            function typeChar() {
                if (i < message.length) {
                    div.innerHTML = message.substring(0, i + 1);
                    i++;
                    setTimeout(typeChar, 5);
                } else {
                    terminal.isTyping = false;
                    smartScrollToBottom();
                }
            }
            
            typeChar();
        }

        function log(message, type = 'output') {
            const output = document.getElementById('content-wrapper');
            const div = document.createElement('div');
            div.className = `line ${type}-line`;
            
            if (type === 'input') {
                div.innerHTML = `<span class="prompt">$</span> ${message}`;
            } else {
                div.textContent = message;
            }
            
            output.appendChild(div);
            smartScrollToBottom();
        }

        // ==================== UI FUNCTIONS ====================
        function setupEvents() {
            const input = document.getElementById('command-input');
            const sendBtn = document.getElementById('send-btn');
            const importBtn = document.getElementById('import-btn');
            const exportBtn = document.getElementById('export-btn');
            const fileInput = document.getElementById('file-input');
            
            // Send on Enter or button click
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') processCommand();
            });
            
            sendBtn.addEventListener('click', processCommand);
            
            // Import button
            importBtn.addEventListener('click', () => fileInput.click());
            
            // Export button - Export all files
            exportBtn.addEventListener('click', () => {
                if (terminal.isTyping || terminal.isProcessingQueue) return;
                exportAllFiles();
            });
            
            // File input
            fileInput.addEventListener('change', (e) => {
                if (e.target.files[0]) importWav(e.target.files[0]);
                fileInput.value = '';
            });
            
            // Player controls
            document.getElementById('play-btn').addEventListener('click', () => {
                if (terminal.currentAudio) {
                    if (terminal.isPlaying) {
                        resumeAudio();
                    } else {
                        playAudio(terminal.currentAudio);
                    }
                }
            });
            
            document.getElementById('pause-btn').addEventListener('click', pauseAudio);
            document.getElementById('stop-btn').addEventListener('click', stopAudio);
            
            // Close player button
            document.getElementById('close-player-btn').addEventListener('click', closePlayer);
            
            // Close player when clicking overlay
            document.getElementById('popup-overlay').addEventListener('click', closePlayer);
            
            // Volume slider
            document.getElementById('volume-slider').addEventListener('input', (e) => {
                terminal.volume = e.target.value / 100;
            });
            
            // Focus input on click
            document.addEventListener('click', (e) => {
                if (!e.target.closest('#player-popup') && !e.target.closest('#help-menu')) {
                    input.focus();
                }
            });
            
            // When user focuses input, check if they're near bottom and reset auto-scroll
            input.addEventListener('focus', () => {
                const terminalEl = document.getElementById('terminal');
                const scrollBottom = terminalEl.scrollHeight - terminalEl.scrollTop - terminalEl.clientHeight;
                
                if (scrollBottom <= terminal.scrollThreshold) {
                    terminal.userScrolledUp = false;
                    terminal.autoScroll = true;
                }
            });
            
            // Initial scroll to bottom
            setTimeout(() => {
                scrollToBottom();
                terminal.autoScroll = true;
            }, 300);
        }

        function processCommand() {
            if (terminal.isTyping) return;
            
            const input = document.getElementById('command-input');
            const cmd = input.value.trim();
            
            if (!cmd) return;
            
            // Show user input immediately
            log(cmd, 'input');
            
            // Process command with delay
            setTimeout(() => {
                if (cmd.startsWith('/')) {
                    const parts = cmd.split(' ');
                    const command = parts[0].toLowerCase();
                    const args = parts.slice(1).join(' ');
                    
                    switch(command) {
                        case '/help':
                            showHelp();
                            break;
                        case '/clear':
                            clearTerminal();
                            break;
                        case '/import':
                            document.getElementById('file-input').click();
                            break;
                        case '/export':
                            exportAllFiles();
                            break;
                        case '/list':
                            listAudioFiles();
                            break;
                        case '/play':
                            if (args) {
                                const id = parseInt(args);
                                const audioFile = terminal.audioFiles.find(f => f.id === id);
                                if (audioFile) {
                                    playAudio(audioFile);
                                } else {
                                    log(`Audio file ${id} not found`, 'error');
                                }
                            } else {
                                log('Usage: /play [id]', 'error');
                            }
                            break;
                        default:
                            typewriterLog(`Unknown command: ${command}`, 'error');
                    }
                } else {
                    // Auto-encode text
                    encodeText(cmd);
                }
            }, 300);
            
            // Clear input
            input.value = '';
            input.focus();
        }

        function displayAudioFile(audioFile) {
            const output = document.getElementById('content-wrapper');
            const div = document.createElement('div');
            div.className = 'audio-entry';
            div.id = `audio-${audioFile.id}`;
            
            const text = audioFile.text ? 
                audioFile.text.substring(0, 50) + (audioFile.text.length > 50 ? '...' : '') : 
                audioFile.filename;
            const type = audioFile.imported ? '[IMPORT]' : '[56K]';
            
            div.innerHTML = `
                ${type} ${text} (${audioFile.duration}s)
                <div class="audio-controls">
                    <button onclick="playAudioById(${audioFile.id})">PLAY</button>
                    <button onclick="deleteAudioById(${audioFile.id})">DELETE</button>
                    <button onclick="exportSingleById(${audioFile.id})">EXPORT</button>
                </div>
            `;
            
            output.appendChild(div);
            smartScrollToBottom();
        }

        async function playAudioById(id) {
            const audioFile = terminal.audioFiles.find(f => f.id === id);
            if (audioFile) {
                await playAudio(audioFile);
            }
        }

        function deleteAudioById(id) {
            if (confirm('Delete this audio file?')) {
                deleteAudioFile(id).then(() => {
                    const element = document.getElementById(`audio-${id}`);
                    if (element) element.remove();
                    
                    const index = terminal.audioFiles.findIndex(f => f.id === id);
                    if (index !== -1) terminal.audioFiles.splice(index, 1);
                    
                    typewriterLog('Audio file deleted');
                }).catch(() => {
                    log('Delete failed', 'error');
                });
            }
        }

        function exportSingleById(id) {
            const audioFile = terminal.audioFiles.find(f => f.id === id);
            if (audioFile) {
                exportSingleFile(audioFile);
            }
        }

        function listAudioFiles() {
            if (terminal.audioFiles.length === 0) {
                log('No audio files');
                return;
            }
            
            const output = document.getElementById('content-wrapper');
            const headerDiv = document.createElement('div');
            headerDiv.className = 'list-header';
            headerDiv.textContent = `Audio files (${terminal.audioFiles.length}):`;
            output.appendChild(headerDiv);
            
            // Small delay to ensure DOM is updated
            setTimeout(() => {
                terminal.audioFiles.forEach(file => {
                    const listDiv = document.createElement('div');
                    listDiv.className = 'list-entry audio-entry';
                    
                    const text = file.text ? 
                        (file.text.substring(0, 40) + (file.text.length > 40 ? '...' : '')) : 
                        file.filename;
                    const type = file.imported ? '[IMPORT]' : '[56K]';
                    
                    listDiv.innerHTML = `
                        ${type} ${text} (${file.duration}s)
                        <div class="audio-controls">
                            <button onclick="playAudioById(${file.id})">PLAY</button>
                            <button onclick="deleteAudioById(${file.id})">DELETE</button>
                            <button onclick="exportSingleById(${file.id})">EXPORT</button>
                        </div>
                    `;
                    
                    output.appendChild(listDiv);
                });
                smartScrollToBottom();
            }, 50);
        }

        function clearTerminal() {
            if (confirm('Clear terminal and delete all audio files?')) {
                clearStorage().then(() => {
                    document.getElementById('content-wrapper').innerHTML = '';
                    terminal.audioFiles = [];
                    terminal.processingQueue = [];
                    terminal.isProcessingQueue = false;
                    terminal.autoScroll = true;
                    terminal.userScrolledUp = false;
                    typewriterLog('Terminal cleared');
                    setTimeout(() => {
                        typewriterLog('AUDIODRIVE 56K ready');
                    }, 300);
                }).catch(() => {
                    log('Clear failed', 'error');
                });
            }
        }

        function showHelp() {
            document.getElementById('help-menu').style.display = 'block';
            document.getElementById('popup-overlay').style.display = 'block';
        }

        function closeHelp() {
            document.getElementById('help-menu').style.display = 'none';
            document.getElementById('popup-overlay').style.display = 'none';
        }

        // ==================== INITIALIZE ====================
        window.addEventListener('load', init);
        
        // Make functions globally available
        window.playAudioById = playAudioById;
        window.deleteAudioById = deleteAudioById;
        window.exportSingleById = exportSingleById;
        window.closeHelp = closeHelp;
        window.closePlayer = closePlayer;
    </script>
</body>
</html>
