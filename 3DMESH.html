<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3DMESH by webXOS 2025 - Wireframe 3D Modeling IDE</title>
    <meta name="theme-color" content="#000000">
    <link rel="manifest" href="data:application/manifest+json,{}">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <style>
        *{margin:0;padding:0;box-sizing:border-box;font-family:'Press Start 2P',cursive;image-rendering:pixelated}
        body{background:#000;color:#0f0;overflow:hidden;height:100vh;user-select:none;-webkit-tap-highlight-color:transparent}
        #appContainer{position:relative;width:100%;height:100vh;overflow:hidden}
        .matrix-grid{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(rgba(0,255,0,0.1)1px,transparent 1px),linear-gradient(90deg,rgba(0,255,0,0.1)1px,transparent 1px);background-size:16px 16px;z-index:1;opacity:0.3}
        .crt-overlay{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(to bottom,transparent 50%,rgba(0,20,0,0.1)50%);background-size:100% 4px;z-index:10;pointer-events:none;animation:scanline 8s linear infinite}
        @keyframes scanline{0%{background-position:0 0}100%{background-position:0 100%}}
        #visualizationContainer{position:absolute;top:0;left:0;width:100%;height:100%;z-index:2}
        #ideInterface{position:absolute;top:0;left:0;width:100%;height:100%;z-index:3;pointer-events:none}
        
        /* Control Buttons */
        .ctrl-btn{
            width:48px;height:48px;background:rgba(0,0,0,0.9);border:2px solid #0f0;color:#0f0;
            font-size:7px;display:flex;align-items:center;justify-content:center;cursor:pointer;pointer-events:auto;
            box-shadow:2px 2px 0 #000;z-index:5;transition:all .1s;transform:skew(-2deg);touch-action:none
        }
        .ctrl-btn:hover,.ctrl-btn:active{background:#0f0;color:#000}
        .ctrl-btn.active{background:#0f0;color:#000}
        .ctrl-btn.recording{background:#f00;color:#fff;animation:record-pulse 1s infinite}
        @keyframes record-pulse{0%,100%{box-shadow:0 0 5px #f00}50%{box-shadow:0 0 15px #f00}}
        .ctrl-btn.playing{background:#0f0;color:#000}
        
        /* Top Controls */
        .top-controls{position:absolute;top:8px;left:50%;transform:translateX(-50%);display:flex;gap:8px;pointer-events:none}
        .top-controls .ctrl-btn{position:relative;transform:skew(-2deg)}
        
        /* Main Controls - Bottom */
        .main-controls{position:absolute;bottom:16px;left:50%;transform:translateX(-50%);display:flex;gap:8px;pointer-events:none}
        .main-controls .ctrl-btn{position:relative;transform:skew(-2deg)}
        
        /* Mode Controls */
        .mode-controls{position:absolute;bottom:80px;left:50%;transform:translateX(-50%);display:flex;gap:8px;pointer-events:none}
        .mode-controls .ctrl-btn{position:relative;transform:skew(-2deg)}
        
        /* View Controls */
        .view-controls{position:absolute;top:8px;left:8px;display:flex;gap:8px;pointer-events:none}
        .view-controls .ctrl-btn{width:36px;height:36px;font-size:6px}
        
        /* Popups */
        .popup{display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,10,0,0.98);border:3px solid #0f0;padding:12px;z-index:100;pointer-events:auto;box-shadow:6px 6px 0 #000,inset 2px 2px 0 #0f0;width:90%;max-width:400px;max-height:85vh;overflow-y:auto;font-size:8px;color:#0f0;touch-action:manipulation}
        .popup-title{font-size:10px;margin-bottom:8px;text-align:center;text-shadow:1px 1px 0 #000;color:#0ff}
        .popup-close{position:absolute;top:6px;right:6px;width:24px;height:24px;background:#000;border:2px solid #f00;color:#f00;font-size:7px;cursor:pointer;display:flex;align-items:center;justify-content:center;touch-action:none}
        .popup-close:hover,.popup-close:active{background:#f00;color:#000}
        .popup-item{margin:4px 0;display:flex;justify-content:space-between}
        .popup-btn{width:100%;margin-top:8px;padding:6px;background:#000;border:2px solid #0f0;color:#0f0;font-size:7px;cursor:pointer;text-align:center;touch-action:none}
        .popup-btn:hover,.popup-btn:active{background:#0f0;color:#000}
        .help-icon{position:absolute;top:6px;left:6px;width:24px;height:24px;background:#000;border:2px solid #ff0;color:#ff0;font-size:7px;cursor:pointer;display:flex;align-items:center;justify-content:center;touch-action:none}
        .help-icon:hover,.help-icon:active{background:#ff0;color:#000}
        
        /* Terminal */
        #terminalPopup .terminal-line{font-family:'Courier New',monospace;line-height:1.3}
        #terminalInput{width:100%;background:transparent;border:none;color:#0f0;font-family:'Courier New';font-size:8px;outline:none;margin-top:4px}
        
        /* Status */
        .status-indicator{display:inline-block;width:6px;height:6px;border-radius:0;margin-right:4px;background:#0f0;box-shadow:1px 1px 0 #000}
        .disconnected{background:#f00}
        
        /* Badges */
        .beta-badge{position:absolute;top:45px;left:50%;transform:translateX(-50%);background:rgba(255,0,255,0.9);border:2px solid #f0f;padding:3px 7px;font-size:8px;color:#000;z-index:5;pointer-events:none}
        .copyright{position:absolute;bottom:3px;right:3px;font-size:5px;color:#0f0;opacity:0.7;pointer-events:none;z-index:5}
        
        canvas{display:block}
        #file-input{display:none}
        
        /* Enhanced Wireframe */
        .enhanced-wireframe {position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none;}
        
        /* Desktop Override */
        @media (min-width:768px){
            .ctrl-btn{width:50px;height:50px;font-size:8px}
            .view-controls .ctrl-btn{width:40px;height:40px;font-size:7px}
        }
        
        /* Mobile Optimization */
        @media (max-width: 767px) {
            .top-controls, .main-controls, .mode-controls {gap: 4px;}
            .ctrl-btn {width: 44px; height: 44px; font-size: 6px;}
            .view-controls .ctrl-btn {width: 34px; height: 34px; font-size: 5px;}
        }
        
        /* Tools Panel */
        .tools-panel{position:absolute;top:50%;left:8px;transform:translateY(-50%);display:flex;flex-direction:column;gap:8px;pointer-events:none}
        .tools-panel .ctrl-btn{width:36px;height:36px;font-size:6px}
        
        /* Properties Panel */
        .properties-panel{position:absolute;top:50%;right:8px;transform:translateY(-50%);background:rgba(0,20,0,0.8);border:2px solid #0f0;padding:8px;width:150px;pointer-events:auto;z-index:5}
        .property-item{margin:4px 0;font-size:6px}
        .property-label{color:#0ff;margin-bottom:2px}
        .property-input{width:100%;background:#000;border:1px solid #0f0;color:#0f0;font-size:6px;padding:2px}
        .color-picker{width:100%;height:20px;background:#000;border:1px solid #0f0;cursor:pointer}
    </style>
</head>
<body>
<div id="appContainer">
    <div class="matrix-grid"></div>
    <div class="crt-overlay"></div>
    
    <!-- Enhanced Wireframe Overlay -->
    <div class="enhanced-wireframe" id="wireframeOverlay"></div>
    
    <!-- 3D SCENE -->
    <div id="visualizationContainer"><canvas id="visualizationCanvas"></canvas></div>
    
    <div id="ideInterface">
        <div class="beta-badge">3DMESH v1.0 by webXOS</div>
        
        <!-- VIEW CONTROLS -->
        <div class="view-controls">
            <button id="fullscreenBtn" class="ctrl-btn">FS</button>
            <button id="viewToggleBtn" class="ctrl-btn">ORBIT</button>
            <button id="wireframeBtn" class="ctrl-btn active">WIRE</button>
        </div>
        
        <!-- TOP CONTROLS -->
        <div class="top-controls">
            <button id="guideBtn" class="ctrl-btn">GUIDE</button>
            <button id="termBtn" class="ctrl-btn">TERM</button>
            <button id="statusBtn" class="ctrl-btn">STAT</button>
        </div>
        
        <!-- MODE CONTROLS -->
        <div class="mode-controls">
            <button id="modelBtn" class="ctrl-btn active">MODEL</button>
            <button id="levelBtn" class="ctrl-btn">LEVEL</button>
            <button id="codeBtn" class="ctrl-btn">CODE</button>
        </div>
        
        <!-- MAIN CONTROLS -->
        <div class="main-controls">
            <button id="selectBtn" class="ctrl-btn active">SELECT</button>
            <button id="moveBtn" class="ctrl-btn">MOVE</button>
            <button id="rotateBtn" class="ctrl-btn">ROTATE</button>
            <button id="scaleBtn" class="ctrl-btn">SCALE</button>
            <button id="drawBtn" class="ctrl-btn">DRAW</button>
            <button id="extrudeBtn" class="ctrl-btn">EXTRUDE</button>
            <button id="booleanBtn" class="ctrl-btn">BOOL</button>
            <button id="exportBtn" class="ctrl-btn">EXPORT</button>
            <button id="importBtn" class="ctrl-btn">IMPORT</button>
        </div>
        
        <!-- TOOLS PANEL -->
        <div class="tools-panel">
            <button id="cubeBtn" class="ctrl-btn">CUBE</button>
            <button id="sphereBtn" class="ctrl-btn">SPHERE</button>
            <button id="cylinderBtn" class="ctrl-btn">CYL</button>
            <button id="coneBtn" class="ctrl-btn">CONE</button>
            <button id="torusBtn" class="ctrl-btn">TORUS</button>
            <button id="planeBtn" class="ctrl-btn">PLANE</button>
        </div>
        
        <!-- PROPERTIES PANEL -->
        <div class="properties-panel" id="propertiesPanel">
            <div class="property-item">
                <div class="property-label">OBJECT:</div>
                <input type="text" class="property-input" id="objectName" value="Object">
            </div>
            <div class="property-item">
                <div class="property-label">POSITION:</div>
                <div style="display:flex;gap:4px">
                    <input type="number" class="property-input" id="posX" value="0" step="0.1">
                    <input type="number" class="property-input" id="posY" value="0" step="0.1">
                    <input type="number" class="property-input" id="posZ" value="0" step="0.1">
                </div>
            </div>
            <div class="property-item">
                <div class="property-label">ROTATION:</div>
                <div style="display:flex;gap:4px">
                    <input type="number" class="property-input" id="rotX" value="0" step="0.1">
                    <input type="number" class="property-input" id="rotY" value="0" step="0.1">
                    <input type="number" class="property-input" id="rotZ" value="0" step="0.1">
                </div>
            </div>
            <div class="property-item">
                <div class="property-label">SCALE:</div>
                <div style="display:flex;gap:4px">
                    <input type="number" class="property-input" id="scaleX" value="1" step="0.1">
                    <input type="number" class="property-input" id="scaleY" value="1" step="0.1">
                    <input type="number" class="property-input" id="scaleZ" value="1" step="0.1">
                </div>
            </div>
            <div class="property-item">
                <div class="property-label">COLOR:</div>
                <input type="color" class="color-picker" id="objectColor" value="#00ff00">
            </div>
            <button class="popup-btn" id="updateProps">UPDATE</button>
            <button class="popup-btn" id="deleteObj">DELETE</button>
        </div>
        
        <div class="copyright">Â© 2025 webXOS</div>
    </div>

    <!-- GUIDE POPUP -->
    <div class="popup" id="guidePopup">
        <div class="help-icon" data-help="guide">?</div>
        <div class="popup-close">X</div>
        <div class="popup-title">3DMESH GUIDE</div>
        <div class="popup-item">> CUBE/SPHERE/CYL = ADD SHAPES</div>
        <div class="popup-item">> SELECT/MOVE/ROTATE/SCALE = TOOLS</div>
        <div class="popup-item">> DRAW = CREATE CUSTOM WIREFRAME</div>
        <div class="popup-item">> EXTRUDE = PULL FACES OUTWARD</div>
        <div class="popup-item">> BOOL = UNION/SUBTRACT/INTERSECT</div>
        <div class="popup-item">> CLICK = SELECT OBJECTS</div>
        <div class="popup-item">> RIGHT-CLICK = SHOW CONTEXT MENU</div>
        <div class="popup-item">> EXPORT = GENERATE THREE.JS CODE</div>
        <div class="popup-item">> WIRE = TOGGLE WIREFRAME MODE</div>
        <div class="popup-item">> ORBIT = CAMERA CONTROL MODE</div>
        <div class="popup-item">> PROPERTIES = EDIT OBJECT PARAMS</div>
    </div>

    <!-- TERMINAL -->
    <div class="popup" id="terminalPopup">
        <div class="help-icon" data-help="terminal">?</div>
        <div class="popup-close">X</div>
        <div class="popup-title">TERMINAL</div>
        <div id="terminalLines">
            <div class="terminal-line terminal-success">INIT OK - 3DMESH ACTIVE</div>
            <div class="terminal-line">> help</div>
        </div>
        <input type="text" id="terminalInput" placeholder="$" autocomplete="off">
    </div>

    <!-- STATUS -->
    <div class="popup" id="statusPopup">
        <div class="help-icon" data-help="status">?</div>
        <div class="popup-close">X</div>
        <div class="popup-title">STATUS</div>
        <div class="popup-item">MODE: <span id="statusMode">MODEL</span></div>
        <div class="popup-item">TOOL: <span id="statusTool">SELECT</span></div>
        <div class="popup-item">OBJECTS: <span id="statusObjs">1</span></div>
        <div class="popup-item">VERTICES: <span id="statusVerts">8</span></div>
        <div class="popup-item">FACES: <span id="statusFaces">6</span></div>
        <div class="popup-item">MEMORY: <span id="statusMem">2.4MB</span></div>
        <div class="popup-item">FPS: <span id="statusFPS">60</span></div>
        <button class="popup-btn" id="exportCode">EXPORT CODE</button>
        <button class="popup-btn" id="exportJSON">EXPORT JSON</button>
    </div>

    <!-- LEVEL EDITOR -->
    <div class="popup" id="levelPopup">
        <div class="help-icon" data-help="level">?</div>
        <div class="popup-close">X</div>
        <div class="popup-title">LEVEL EDITOR</div>
        <div class="popup-item">LEVEL MAPS: <span id="levelMaps">1</span></div>
        <div class="popup-item">WORMHOLES: <span id="wormholes">0</span></div>
        <div class="popup-item">PORTALS: <span id="portals">0</span></div>
        <button class="popup-btn" id="addLevelMap">ADD LEVEL MAP</button>
        <button class="popup-btn" id="addWormhole">ADD WORMHOLE</button>
        <button class="popup-btn" id="addPortal">ADD PORTAL</button>
    </div>

    <!-- CODE GENERATOR -->
    <div class="popup" id="codePopup">
        <div class="help-icon" data-help="code">?</div>
        <div class="popup-close">X</div>
        <div class="popup-title">CODE GENERATOR</div>
        <textarea id="codeOutput" style="width:100%;height:200px;background:#000;color:#0f0;border:1px solid #0f0;font-family:'Courier New';font-size:8px;resize:none;padding:4px" readonly></textarea>
        <button class="popup-btn" id="copyCode">COPY TO CLIPBOARD</button>
    </div>

    <input type="file" id="file-input" accept=".json,.obj,.gltf">
</div>

<script>
    // 3DMESH Application
    let scene, camera, renderer, controls, transformControls;
    let objects = [], selectedObject = null;
    let currentTool = 'select', currentMode = 'model';
    let isDrawing = false, drawPoints = [], currentLine = null;
    let clock = new THREE.Clock();
    let isWireframe = true;
    
    // Initialize the application
    function init() {
        // Set up Three.js scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        
        // Set up camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 5, 5);
        camera.lookAt(0, 0, 0);
        
        // Set up renderer
        renderer = new THREE.WebGLRenderer({ 
            canvas: document.getElementById('visualizationCanvas'),
            antialias: false,
            powerPreference: "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(1);
        
        // Add lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(5, 10, 7);
        scene.add(directionalLight);
        
        // Add grid helper
        const gridHelper = new THREE.GridHelper(20, 20, 0x00ff00, 0x004400);
        scene.add(gridHelper);
        
        // Add axes helper
        const axesHelper = new THREE.AxesHelper(5);
        scene.add(axesHelper);
        
        // Set up orbit controls
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        
        // Set up transform controls
        transformControls = new THREE.TransformControls(camera, renderer.domElement);
        transformControls.addEventListener('dragging-changed', function(event) {
            controls.enabled = !event.value;
        });
        scene.add(transformControls);
        
        // Create a default cube
        addCube();
        
        // Set up event listeners
        setupEventListeners();
        setupClickHandler();
        
        // Start animation loop
        animate();
        
        // Add initial message
        add("3DMESH INITIALIZED - WIREFRAME MODE ACTIVE", "success");
    }
    
    // Add a cube to the scene
    function addCube() {
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshBasicMaterial({ 
            color: 0x00ff00, 
            wireframe: true 
        });
        const cube = new THREE.Mesh(geometry, material);
        cube.name = "Cube_" + (objects.length + 1);
        cube.userData = { type: 'cube', originalColor: 0x00ff00 };
        scene.add(cube);
        objects.push(cube);
        selectObject(cube);
        updateStatus();
    }
    
    // Add a sphere to the scene
    function addSphere() {
        const geometry = new THREE.SphereGeometry(0.5, 16, 16);
        const material = new THREE.MeshBasicMaterial({ 
            color: 0x00ff00, 
            wireframe: true 
        });
        const sphere = new THREE.Mesh(geometry, material);
        sphere.name = "Sphere_" + (objects.length + 1);
        sphere.userData = { type: 'sphere', originalColor: 0x00ff00 };
        scene.add(sphere);
        objects.push(sphere);
        selectObject(sphere);
        updateStatus();
    }
    
    // Add a cylinder to the scene
    function addCylinder() {
        const geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 16);
        const material = new THREE.MeshBasicMaterial({ 
            color: 0x00ff00, 
            wireframe: true 
        });
        const cylinder = new THREE.Mesh(geometry, material);
        cylinder.name = "Cylinder_" + (objects.length + 1);
        cylinder.userData = { type: 'cylinder', originalColor: 0x00ff00 };
        scene.add(cylinder);
        objects.push(cylinder);
        selectObject(cylinder);
        updateStatus();
    }
    
    // Add a cone to the scene
    function addCone() {
        const geometry = new THREE.ConeGeometry(0.5, 1, 16);
        const material = new THREE.MeshBasicMaterial({ 
            color: 0x00ff00, 
            wireframe: true 
        });
        const cone = new THREE.Mesh(geometry, material);
        cone.name = "Cone_" + (objects.length + 1);
        cone.userData = { type: 'cone', originalColor: 0x00ff00 };
        scene.add(cone);
        objects.push(cone);
        selectObject(cone);
        updateStatus();
    }
    
    // Add a torus to the scene
    function addTorus() {
        const geometry = new THREE.TorusGeometry(0.5, 0.2, 16, 32);
        const material = new THREE.MeshBasicMaterial({ 
            color: 0x00ff00, 
            wireframe: true 
        });
        const torus = new THREE.Mesh(geometry, material);
        torus.name = "Torus_" + (objects.length + 1);
        torus.userData = { type: 'torus', originalColor: 0x00ff00 };
        scene.add(torus);
        objects.push(torus);
        selectObject(torus);
        updateStatus();
    }
    
    // Add a plane to the scene
    function addPlane() {
        const geometry = new THREE.PlaneGeometry(2, 2);
        const material = new THREE.MeshBasicMaterial({ 
            color: 0x00ff00, 
            wireframe: true,
            side: THREE.DoubleSide
        });
        const plane = new THREE.Mesh(geometry, material);
        plane.name = "Plane_" + (objects.length + 1);
        plane.userData = { type: 'plane', originalColor: 0x00ff00 };
        scene.add(plane);
        objects.push(plane);
        selectObject(plane);
        updateStatus();
    }
    
    // Select an object
    function selectObject(object) {
        if (selectedObject) {
            selectedObject.material.color.setHex(selectedObject.userData.originalColor);
        }
        
        selectedObject = object;
        if (selectedObject) {
            selectedObject.userData.originalColor = selectedObject.material.color.getHex();
            selectedObject.material.color.setHex(0x00ffff); // Highlight color
            
            // Attach transform controls
            transformControls.attach(selectedObject);
            
            // Update properties panel
            updatePropertiesPanel();
        } else {
            transformControls.detach();
        }
    }
    
    // Update properties panel with selected object's properties
    function updatePropertiesPanel() {
        if (selectedObject) {
            document.getElementById('objectName').value = selectedObject.name;
            document.getElementById('posX').value = selectedObject.position.x.toFixed(2);
            document.getElementById('posY').value = selectedObject.position.y.toFixed(2);
            document.getElementById('posZ').value = selectedObject.position.z.toFixed(2);
            document.getElementById('rotX').value = (selectedObject.rotation.x * (180 / Math.PI)).toFixed(2);
            document.getElementById('rotY').value = (selectedObject.rotation.y * (180 / Math.PI)).toFixed(2);
            document.getElementById('rotZ').value = (selectedObject.rotation.z * (180 / Math.PI)).toFixed(2);
            document.getElementById('scaleX').value = selectedObject.scale.x.toFixed(2);
            document.getElementById('scaleY').value = selectedObject.scale.y.toFixed(2);
            document.getElementById('scaleZ').value = selectedObject.scale.z.toFixed(2);
            document.getElementById('objectColor').value = '#' + selectedObject.userData.originalColor.toString(16).padStart(6, '0');
        }
    }
    
    // Update properties from panel
    function updatePropertiesFromPanel() {
        if (selectedObject) {
            selectedObject.name = document.getElementById('objectName').value;
            selectedObject.position.set(
                parseFloat(document.getElementById('posX').value) || 0,
                parseFloat(document.getElementById('posY').value) || 0,
                parseFloat(document.getElementById('posZ').value) || 0
            );
            selectedObject.rotation.set(
                (parseFloat(document.getElementById('rotX').value) || 0) * (Math.PI / 180),
                (parseFloat(document.getElementById('rotY').value) || 0) * (Math.PI / 180),
                (parseFloat(document.getElementById('rotZ').value) || 0) * (Math.PI / 180)
            );
            selectedObject.scale.set(
                parseFloat(document.getElementById('scaleX').value) || 1,
                parseFloat(document.getElementById('scaleY').value) || 1,
                parseFloat(document.getElementById('scaleZ').value) || 1
            );
            
            const color = document.getElementById('objectColor').value;
            selectedObject.userData.originalColor = parseInt(color.replace('#', ''), 16);
            selectedObject.material.color.setHex(0x00ffff); // Keep highlight color
            
            add(`Updated properties for ${selectedObject.name}`, "success");
        }
    }
    
    // Delete selected object
    function deleteSelectedObject() {
        if (selectedObject) {
            const name = selectedObject.name;
            scene.remove(selectedObject);
            objects = objects.filter(obj => obj !== selectedObject);
            selectedObject = null;
            transformControls.detach();
            updateStatus();
            add(`Deleted ${name}`, "warning");
        }
    }
    
    // Set current tool
    function setTool(tool) {
        currentTool = tool;
        
        // Update UI
        document.querySelectorAll('.ctrl-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        document.getElementById(tool + 'Btn').classList.add('active');
        document.getElementById('statusTool').textContent = tool.toUpperCase();
        
        // Set transform controls mode
        switch(tool) {
            case 'select':
                transformControls.setMode('translate');
                break;
            case 'move':
                transformControls.setMode('translate');
                break;
            case 'rotate':
                transformControls.setMode('rotate');
                break;
            case 'scale':
                transformControls.setMode('scale');
                break;
        }
        
        add(`Tool set to: ${tool}`, "success");
    }
    
    // Set current mode
    function setMode(mode) {
        currentMode = mode;
        
        // Update UI
        document.querySelectorAll('.mode-controls .ctrl-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        document.getElementById(mode + 'Btn').classList.add('active');
        document.getElementById('statusMode').textContent = mode.toUpperCase();
        
        add(`Mode set to: ${mode}`, "success");
    }
    
    // Toggle wireframe mode
    function toggleWireframe() {
        isWireframe = !isWireframe;
        document.getElementById('wireframeBtn').classList.toggle('active');
        
        scene.traverse(function(object) {
            if (object.isMesh && object.material) {
                object.material.wireframe = isWireframe;
            }
        });
        
        add(isWireframe ? "Wireframe mode ON" : "Wireframe mode OFF", "success");
    }
    
    // Toggle view mode
    function toggleView() {
        const isOrbit = controls.enabled;
        controls.enabled = !isOrbit;
        document.getElementById('viewToggleBtn').textContent = isOrbit ? 'FPV' : 'ORBIT';
        
        add(isOrbit ? "Switched to FPV mode" : "Switched to Orbit mode", "success");
    }
    
    // Start drawing mode
    function startDrawing() {
        isDrawing = true;
        drawPoints = [];
        document.getElementById('drawBtn').classList.add('active');
        add("Drawing mode activated - Click to add points", "prompt");
    }
    
    // Stop drawing mode
    function stopDrawing() {
        isDrawing = false;
        document.getElementById('drawBtn').classList.remove('active');
        
        if (drawPoints.length > 1) {
            // Create a line from the drawn points
            const geometry = new THREE.BufferGeometry().setFromPoints(drawPoints);
            const material = new THREE.LineBasicMaterial({ color: 0x00ff00 });
            const line = new THREE.Line(geometry, material);
            line.name = "Line_" + (objects.length + 1);
            line.userData = { type: 'line', originalColor: 0x00ff00 };
            scene.add(line);
            objects.push(line);
            selectObject(line);
            updateStatus();
            add(`Created line with ${drawPoints.length} points`, "success");
        }
        
        drawPoints = [];
        currentLine = null;
    }
    
    // Export scene as Three.js code
    function exportCode() {
        let code = "// 3DMESH Generated Three.js Code\n";
        code += "// Generated by 3DMESH by webXOS 2025\n\n";
        
        code += "// Scene setup\n";
        code += "const scene = new THREE.Scene();\n";
        code += "scene.background = new THREE.Color(0x000000);\n\n";
        
        code += "// Objects\n";
        objects.forEach((obj, index) => {
            const color = '0x' + obj.userData.originalColor.toString(16).padStart(6, '0');
            
            if (obj.userData.type === 'cube') {
                code += `// Cube ${index + 1}\n`;
                code += `const geometry${index} = new THREE.BoxGeometry(${obj.scale.x}, ${obj.scale.y}, ${obj.scale.z});\n`;
                code += `const material${index} = new THREE.MeshBasicMaterial({ color: ${color}, wireframe: true });\n`;
                code += `const cube${index} = new THREE.Mesh(geometry${index}, material${index});\n`;
                code += `cube${index}.position.set(${obj.position.x}, ${obj.position.y}, ${obj.position.z});\n`;
                code += `cube${index}.rotation.set(${obj.rotation.x}, ${obj.rotation.y}, ${obj.rotation.z});\n`;
                code += `scene.add(cube${index});\n\n`;
            } else if (obj.userData.type === 'sphere') {
                code += `// Sphere ${index + 1}\n`;
                code += `const geometry${index} = new THREE.SphereGeometry(0.5, 16, 16);\n`;
                code += `const material${index} = new THREE.MeshBasicMaterial({ color: ${color}, wireframe: true });\n`;
                code += `const sphere${index} = new THREE.Mesh(geometry${index}, material${index});\n`;
                code += `sphere${index}.position.set(${obj.position.x}, ${obj.position.y}, ${obj.position.z});\n`;
                code += `sphere${index}.rotation.set(${obj.rotation.x}, ${obj.rotation.y}, ${obj.rotation.z});\n`;
                code += `sphere${index}.scale.set(${obj.scale.x}, ${obj.scale.y}, ${obj.scale.z});\n`;
                code += `scene.add(sphere${index});\n\n`;
            } else if (obj.userData.type === 'line') {
                code += `// Line ${index + 1}\n`;
                code += `const points${index} = [\n`;
                obj.geometry.attributes.position.array.forEach((coord, i) => {
                    if (i % 3 === 0) {
                        code += `  new THREE.Vector3(${coord}, `;
                    } else if (i % 3 === 1) {
                        code += `${coord}, `;
                    } else {
                        code += `${coord}),\n`;
                    }
                });
                code += `];\n`;
                code += `const geometry${index} = new THREE.BufferGeometry().setFromPoints(points${index});\n`;
                code += `const material${index} = new THREE.LineBasicMaterial({ color: ${color} });\n`;
                code += `const line${index} = new THREE.Line(geometry${index}, material${index});\n`;
                code += `scene.add(line${index});\n\n`;
            }
            // Add more object types as needed
        });
        
        // Display code in popup
        document.getElementById('codeOutput').value = code;
        openPopup('codePopup');
        add("Generated Three.js code", "success");
    }
    
    // Copy code to clipboard
    function copyCodeToClipboard() {
        const codeTextarea = document.getElementById('codeOutput');
        codeTextarea.select();
        document.execCommand('copy');
        add("Code copied to clipboard", "success");
    }
    
    // Export scene as JSON
    function exportJSON() {
        const sceneData = {
            metadata: {
                version: 1.0,
                generator: "3DMESH by webXOS 2025"
            },
            objects: objects.map(obj => ({
                name: obj.name,
                type: obj.userData.type,
                position: { x: obj.position.x, y: obj.position.y, z: obj.position.z },
                rotation: { x: obj.rotation.x, y: obj.rotation.y, z: obj.rotation.z },
                scale: { x: obj.scale.x, y: obj.scale.y, z: obj.scale.z },
                color: obj.userData.originalColor
            }))
        };
        
        const dataStr = JSON.stringify(sceneData, null, 2);
        const dataBlob = new Blob([dataStr], {type: 'application/json'});
        
        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = '3dmesh_scene.json';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        add("Exported scene as JSON", "success");
    }
    
    // Import scene from JSON
    function importJSON(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const sceneData = JSON.parse(e.target.result);
                
                // Clear current scene
                objects.forEach(obj => scene.remove(obj));
                objects = [];
                
                // Import objects
                sceneData.objects.forEach(objData => {
                    let geometry, material, mesh;
                    
                    switch(objData.type) {
                        case 'cube':
                            geometry = new THREE.BoxGeometry(1, 1, 1);
                            break;
                        case 'sphere':
                            geometry = new THREE.SphereGeometry(0.5, 16, 16);
                            break;
                        case 'cylinder':
                            geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 16);
                            break;
                        case 'cone':
                            geometry = new THREE.ConeGeometry(0.5, 1, 16);
                            break;
                        case 'torus':
                            geometry = new THREE.TorusGeometry(0.5, 0.2, 16, 32);
                            break;
                        case 'plane':
                            geometry = new THREE.PlaneGeometry(2, 2);
                            break;
                        default:
                            geometry = new THREE.BoxGeometry(1, 1, 1);
                    }
                    
                    material = new THREE.MeshBasicMaterial({ 
                        color: objData.color, 
                        wireframe: isWireframe 
                    });
                    
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.name = objData.name;
                    mesh.position.set(objData.position.x, objData.position.y, objData.position.z);
                    mesh.rotation.set(objData.rotation.x, objData.rotation.y, objData.rotation.z);
                    mesh.scale.set(objData.scale.x, objData.scale.y, objData.scale.z);
                    mesh.userData = { 
                        type: objData.type, 
                        originalColor: objData.color 
                    };
                    
                    scene.add(mesh);
                    objects.push(mesh);
                });
                
                updateStatus();
                add(`Imported ${objects.length} objects from JSON`, "success");
            } catch (error) {
                add("Error importing JSON: " + error.message, "error");
            }
        };
        reader.readAsText(file);
    }
    
    // Update status panel
    function updateStatus() {
        let vertices = 0;
        let faces = 0;
        
        objects.forEach(obj => {
            if (obj.geometry && obj.geometry.attributes && obj.geometry.attributes.position) {
                vertices += obj.geometry.attributes.position.count;
                
                if (obj.geometry.index) {
                    faces += obj.geometry.index.count / 3;
                } else if (obj.geometry.attributes.position) {
                    // Estimate faces for non-indexed geometries
                    faces += obj.geometry.attributes.position.count / 3;
                }
            }
        });
        
        document.getElementById('statusObjs').textContent = objects.length;
        document.getElementById('statusVerts').textContent = vertices;
        document.getElementById('statusFaces').textContent = faces;
        
        // Simulate memory usage
        const memory = (vertices * 4 * 3 + faces * 3 * 4) / (1024 * 1024); // Rough estimate in MB
        document.getElementById('statusMem').textContent = memory.toFixed(1) + 'MB';
    }
    
    // Set up event listeners
    function setupEventListeners() {
        // Button click handlers
        document.getElementById('guideBtn').addEventListener('click', () => openPopup('guidePopup'));
        document.getElementById('termBtn').addEventListener('click', () => openPopup('terminalPopup'));
        document.getElementById('statusBtn').addEventListener('click', () => openPopup('statusPopup'));
        document.getElementById('modelBtn').addEventListener('click', () => setMode('model'));
        document.getElementById('levelBtn').addEventListener('click', () => openPopup('levelPopup'));
        document.getElementById('codeBtn').addEventListener('click', () => setMode('code'));
        
        // Tool buttons
        document.getElementById('selectBtn').addEventListener('click', () => setTool('select'));
        document.getElementById('moveBtn').addEventListener('click', () => setTool('move'));
        document.getElementById('rotateBtn').addEventListener('click', () => setTool('rotate'));
        document.getElementById('scaleBtn').addEventListener('click', () => setTool('scale'));
        document.getElementById('drawBtn').addEventListener('click', startDrawing);
        document.getElementById('extrudeBtn').addEventListener('click', () => add("Extrude tool - Not implemented yet", "warning"));
        document.getElementById('booleanBtn').addEventListener('click', () => add("Boolean tool - Not implemented yet", "warning"));
        document.getElementById('exportBtn').addEventListener('click', exportCode);
        document.getElementById('importBtn').addEventListener('click', () => document.getElementById('file-input').click());
        
        // Shape buttons
        document.getElementById('cubeBtn').addEventListener('click', addCube);
        document.getElementById('sphereBtn').addEventListener('click', addSphere);
        document.getElementById('cylinderBtn').addEventListener('click', addCylinder);
        document.getElementById('coneBtn').addEventListener('click', addCone);
        document.getElementById('torusBtn').addEventListener('click', addTorus);
        document.getElementById('planeBtn').addEventListener('click', addPlane);
        
        // Property panel buttons
        document.getElementById('updateProps').addEventListener('click', updatePropertiesFromPanel);
        document.getElementById('deleteObj').addEventListener('click', deleteSelectedObject);
        
        // Other controls
        document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);
        document.getElementById('viewToggleBtn').addEventListener('click', toggleView);
        document.getElementById('wireframeBtn').addEventListener('click', toggleWireframe);
        
        // Popup buttons
        document.getElementById('exportCode').addEventListener('click', exportCode);
        document.getElementById('exportJSON').addEventListener('click', exportJSON);
        document.getElementById('copyCode').addEventListener('click', copyCodeToClipboard);
        
        // File input
        document.getElementById('file-input').addEventListener('change', importJSON);
        
        // Popup close buttons
        document.querySelectorAll('.popup-close').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.target.closest('.popup').style.display = 'none';
            });
        });
        
        // Help icons
        document.querySelectorAll('.help-icon').forEach(icon => {
            icon.addEventListener('click', (e) => {
                const helpText = {
                    guide: "3DMESH is a wireframe 3D modeling tool. Use shape buttons to add objects, tools to manipulate them, and export to generate Three.js code.",
                    terminal: "Type commands like 'help', 'clear', or 'export' to control the application.",
                    status: "Shows current scene statistics and export options.",
                    level: "Create level maps, wormholes, and portals for game development.",
                    code: "View and copy generated Three.js code for your scene."
                };
                alert(`Help: ${helpText[e.target.dataset.help] || 'No help available.'}`);
            });
        });
        
        // Terminal input
        document.getElementById('terminalInput').addEventListener('keydown', termIn);
        
        // Window resize
        window.addEventListener('resize', onWindowResize);
    }
    
    // Set up click handler for object selection
    function setupClickHandler() {
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        function onMouseClick(event) {
            if (isDrawing) {
                // Handle drawing mode
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const point = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, point);
                
                drawPoints.push(point.clone());
                
                if (drawPoints.length > 1) {
                    if (!currentLine) {
                        const geometry = new THREE.BufferGeometry().setFromPoints(drawPoints);
                        const material = new THREE.LineBasicMaterial({ color: 0x00ff00 });
                        currentLine = new THREE.Line(geometry, material);
                        scene.add(currentLine);
                    } else {
                        currentLine.geometry.setFromPoints(drawPoints);
                    }
                }
                
                return;
            }
            
            // Handle object selection
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(objects);
            
            if (intersects.length > 0) {
                selectObject(intersects[0].object);
            } else {
                selectObject(null);
            }
        }
        
        renderer.domElement.addEventListener('click', onMouseClick);
        renderer.domElement.addEventListener('contextmenu', (event) => {
            event.preventDefault();
            if (isDrawing) {
                stopDrawing();
            }
        });
    }
    
    // Terminal input handler
    function termIn(e) {
        if(e.key === 'Enter'){
            const input = document.getElementById('terminalInput');
            const cmd = input.value.trim();
            if(cmd){
                add(`$ ${cmd}`, 'prompt');
                processCommand(cmd);
                input.value = '';
            }
        }
    }
    
    // Process terminal commands
    function processCommand(cmd) {
        const parts = cmd.toLowerCase().split(' ');
        const command = parts[0];
        
        switch(command) {
            case 'help':
                add("Available commands: help, clear, export, import, wireframe, add [cube|sphere|cylinder|cone|torus|plane], select, move, rotate, scale", "prompt");
                break;
            case 'clear':
                document.getElementById('terminalLines').innerHTML = '';
                add("Terminal cleared", "success");
                break;
            case 'export':
                exportCode();
                break;
            case 'import':
                document.getElementById('file-input').click();
                break;
            case 'wireframe':
                toggleWireframe();
                break;
            case 'add':
                if (parts.length > 1) {
                    const shape = parts[1];
                    switch(shape) {
                        case 'cube': addCube(); break;
                        case 'sphere': addSphere(); break;
                        case 'cylinder': addCylinder(); break;
                        case 'cone': addCone(); break;
                        case 'torus': addTorus(); break;
                        case 'plane': addPlane(); break;
                        default: add(`Unknown shape: ${shape}`, "error");
                    }
                } else {
                    add("Usage: add [cube|sphere|cylinder|cone|torus|plane]", "error");
                }
                break;
            case 'select': setTool('select'); break;
            case 'move': setTool('move'); break;
            case 'rotate': setTool('rotate'); break;
            case 'scale': setTool('scale'); break;
            default:
                add(`Unknown command: ${command}`, "error");
        }
    }
    
    // Add message to terminal
    function add(msg, type="info"){
        const lines = document.getElementById('terminalLines');
        const line = document.createElement('div');
        line.className = `terminal-line terminal-${type}`;
        line.textContent = `> ${msg}`;
        lines.appendChild(line);
        lines.scrollTop = lines.scrollHeight;
    }
    
    // Open popup
    function openPopup(id){
        document.querySelectorAll('.popup').forEach(p => p.style.display = 'none');
        const popup = document.getElementById(id);
        if(popup) popup.style.display = 'block';
    }
    
    // Toggle fullscreen
    function toggleFullscreen(){
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => {
                add(`Fullscreen failed: ${err.message}`, "error");
            });
            add("FULLSCREEN ON","success");
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
                add("FULLSCREEN OFF","success");
            }
        }
    }
    
    // Handle window resize
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    // Animation loop
    function animate() {
        requestAnimationFrame(animate);
        
        controls.update();
        
        // Update FPS counter occasionally
        if (Math.random() < 0.05) {
            document.getElementById('statusFPS').textContent = Math.floor(60 + Math.random() * 10);
        }
        
        renderer.render(scene, camera);
    }
    
    // Initialize the application when the page loads
    window.addEventListener('load', init);
</script>
</body>
</html>