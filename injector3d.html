<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Injector</title>
  <style>
    body {
      margin: 0;
      background: #000;
      color: #00FF00;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }
    #console {
      flex-grow: 1;
      padding: 1rem;
      overflow-y: auto;
      font-size: clamp(12px, 3vw, 14px);
    }
    #input-area {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      padding: 1rem;
      background: #111;
    }
    #command-input {
      flex-grow: 1;
      background: #000;
      color: #00FF00;
      border: 1px solid #00FF00;
      padding: 0.5rem;
      font-family: inherit;
      font-size: clamp(12px, 3vw, 14px);
      min-width: 200px;
    }
    .button {
      background: #000;
      color: #00FF00;
      border: 1px solid #00FF00;
      padding: 0.5rem 1rem;
      margin: 0 0.3rem;
      cursor: pointer;
      font-family: inherit;
      font-size: clamp(12px, 3vw, 14px);
      white-space: nowrap;
    }
    .button:hover {
      background: #00FF00;
      color: #000;
    }
    #py-popup {
      display: none;
      position: fixed;
      top: 10%;
      left: 5%;
      width: 90%;
      max-width: 800px;
      height: 80%;
      background: #111;
      border: 1px solid #00FF00;
      padding: 1rem;
      box-sizing: border-box;
      z-index: 1000;
    }
    #py-input {
      width: 100%;
      height: 60%;
      background: #000;
      color: #00FF00;
      border: 1px solid #00FF00;
      font-family: inherit;
      font-size: clamp(12px, 3vw, 14px);
      resize: none;
      box-sizing: border-box;
    }
    #three-canvas {
      width: 100%;
      height: 30%;
      border: 1px solid #00FF00;
      margin-top: 0.5rem;
    }
    #controls-area {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }
    footer {
      text-align: center;
      padding: 0.5rem;
      font-size: clamp(10px, 2.5vw, 12px);
    }
    @media (min-width: 768px) {
      #console {
        padding: 10px;
        font-size: 14px;
      }
      #input-area {
        flex-wrap: nowrap;
        padding: 10px;
      }
      #command-input {
        font-size: 14px;
      }
      .button {
        padding: 5px 10px;
        margin: 0 5px;
        font-size: 14px;
      }
      #py-popup {
        top: 15%;
        left: 20%;
        width: 60%;
        height: 70%;
        padding: 10px;
      }
      #py-input {
        font-size: 14px;
      }
      #three-canvas {
        height: 35%;
      }
      footer {
        font-size: 12px;
      }
    }
  </style>
</head>
<body>
  <div id="console"></div>
  <div id="input-area">
    <input id="command-input" type="text" placeholder="Enter Python script (e.g., print('Hello') or 'test 1')" onkeypress="if(event.key === 'Enter') executeCommand()">
    <button class="button" onclick="executeCommand()">Execute</button>
    <button class="button" onclick="showPyPopup()">Inject</button>
    <button class="button" onclick="ejectPyConsole()">Eject</button>
    <button class="button" onclick="troubleshoot()">Troubleshoot</button>
  </div>
  <div id="py-popup">
    <textarea id="py-input" placeholder="Enter Python script (e.g., Test3DAgent code)"></textarea>
    <canvas id="three-canvas"></canvas>
    <div id="controls-area">
      <button class="button" onclick="injectPyScript()">Inject Script</button>
      <button class="button" onclick="closePyPopup()">Close</button>
      <button class="button" onclick="executeCommand('test 1')">Test 1</button>
      <button class="button" onclick="executeCommand('test 2')">Test 2</button>
      <button class="button" onclick="executeCommand('test 3')">Test 3</button>
      <button class="button" onclick="adjustRotation(0.1, 0)">Rotate Up</button>
      <button class="button" onclick="adjustRotation(-0.1, 0)">Rotate Down</button>
      <button class="button" onclick="adjustRotation(0, 0.1)">Rotate Left</button>
      <button class="button" onclick="adjustRotation(0, -0.1)">Rotate Right</button>
      <button class="button" onclick="adjustZoom(10)">Zoom In</button>
      <button class="button" onclick="adjustZoom(-10)">Zoom Out</button>
    </div>
  </div>
  <footer>WebXOS 2025</footer>

  <script src="https://cdn.jsdelivr.net/npm/skulpt@1.2.0/dist/skulpt.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/skulpt@1.2.0/dist/skulpt-stdlib.js"></script>
  <script>
    // Custom Mini3D Engine
    const Mini3D = {
      Scene: function() {
        this.children = [];
        this.background = { r: 0, g: 0, b: 0 };
        this.add = function(obj) { this.children.push(obj); };
        this.remove = function(obj) { this.children = this.children.filter(c => c !== obj); };
      },
      PerspectiveCamera: function(fov, aspect, near, far) {
        this.position = { x: 0, y: 0, z: 100 };
        this.quaternion = { x: 0, y: 0, z: 0, w: 1 };
        this.fov = fov;
        this.aspect = aspect;
        this.near = near;
        this.far = far;
        this.updateProjectionMatrix = function() {
          this.projectionMatrix = Mini3D.matrixPerspective(fov, aspect, near, far);
        };
        this.updateProjectionMatrix();
      },
      WebGLRenderer: function({ canvas, antialias }) {
        const gl = canvas.getContext('webgl', { antialias }) || canvas.getContext('experimental-webgl', { antialias });
        if (!gl) throw new Error('WebGL not supported');
        this.gl = gl;
        this.setSize = function(width, height) {
          canvas.width = width;
          canvas.height = height;
          gl.viewport(0, 0, width, height);
        };
        this.render = function(scene, camera) {
          gl.clearColor(scene.background.r, scene.background.g, scene.background.b, 1);
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
          gl.enable(gl.DEPTH_TEST);
          scene.children.forEach(obj => {
            if (obj.type === 'Mesh') this.renderMesh(obj, camera);
            else if (obj.type === 'Points') this.renderPoints(obj, camera);
          });
        };
        this.renderMesh = function(mesh, camera) {
          const program = this.createProgram(mesh.geometry, mesh.material);
          gl.useProgram(program);
          const positionLoc = gl.getAttribLocation(program, 'position');
          gl.enableVertexAttribArray(positionLoc);
          gl.bindBuffer(gl.ARRAY_BUFFER, mesh.geometry.positionBuffer);
          gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);
          const modelViewMatrix = Mini3D.matrixMultiply(Mini3D.matrixTranslate(mesh.position), Mini3D.matrixFromQuaternion(camera.quaternion));
          const mvpMatrix = Mini3D.matrixMultiply(modelViewMatrix, camera.projectionMatrix);
          const mvpLoc = gl.getUniformLocation(program, 'uMVPMatrix');
          gl.uniformMatrix4fv(mvpLoc, false, mvpMatrix);
          const colorLoc = gl.getUniformLocation(program, 'uColor');
          gl.uniform3f(colorLoc, mesh.material.color.r, mesh.material.color.g, mesh.material.color.b);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh.geometry.indexBuffer);
          gl.drawElements(gl.TRIANGLES, mesh.geometry.indices.length, gl.UNSIGNED_SHORT, 0);
        };
        this.renderPoints = function(points, camera) {
          const program = this.createProgram(points.geometry, points.material, true);
          gl.useProgram(program);
          const positionLoc = gl.getAttribLocation(program, 'position');
          gl.enableVertexAttribArray(positionLoc);
          gl.bindBuffer(gl.ARRAY_BUFFER, points.geometry.positionBuffer);
          gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);
          const mvpMatrix = Mini3D.matrixMultiply(Mini3D.matrixIdentity(), camera.projectionMatrix);
          const mvpLoc = gl.getUniformLocation(program, 'uMVPMatrix');
          gl.uniformMatrix4fv(mvpLoc, false, mvpMatrix);
          const colorLoc = gl.getUniformLocation(program, 'uColor');
          gl.uniform3f(colorLoc, points.material.color.r, points.material.color.g, points.material.color.b);
          const sizeLoc = gl.getUniformLocation(program, 'uSize');
          gl.uniform1f(sizeLoc, points.material.size);
          gl.drawArrays(gl.POINTS, 0, points.geometry.positionCount);
        };
        this.createProgram = function(geometry, material, isPoints = false) {
          const vsSource = `
            attribute vec3 position;
            uniform mat4 uMVPMatrix;
            void main() {
              gl_Position = uMVPMatrix * vec4(position, 1.0);
              ${isPoints ? 'gl_PointSize = 2.0;' : ''}
            }
          `;
          const fsSource = `
            precision mediump float;
            uniform vec3 uColor;
            void main() {
              gl_FragColor = vec4(uColor, 1.0);
            }
          `;
          const vs = gl.createShader(gl.VERTEX_SHADER);
          gl.shaderSource(vs, vsSource);
          gl.compileShader(vs);
          const fs = gl.createShader(gl.FRAGMENT_SHADER);
          gl.shaderSource(fs, fsSource);
          gl.compileShader(fs);
          const program = gl.createProgram();
          gl.attachShader(program, vs);
          gl.attachShader(program, fs);
          gl.linkProgram(program);
          return program;
        };
      },
      Color: function(hex) {
        const r = (hex >> 16 & 255) / 255;
        const g = (hex >> 8 & 255) / 255;
        const b = (hex & 255) / 255;
        this.r = r; this.g = g; this.b = b;
      },
      BoxGeometry: function(width, height, depth) {
        const hw = width / 2, hh = height / 2, hd = depth / 2;
        const vertices = [
          -hw, -hh, -hd, hw, -hh, -hd, hw, hh, -hd, -hw, hh, -hd,
          -hw, -hh, hd, hw, -hh, hd, hw, hh, hd, -hw, hh, hd
        ];
        const indices = [
          0, 1, 2, 2, 3, 0, 1, 5, 6, 6, 2, 1, 5, 4, 7, 7, 6, 5,
          4, 0, 3, 3, 7, 4, 3, 2, 6, 6, 7, 3, 4, 5, 1, 1, 0, 4
        ];
        this.positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        this.indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
        this.indices = indices;
      },
      SphereGeometry: function(radius, widthSegments, heightSegments) {
        const vertices = [];
        const indices = [];
        for (let y = 0; y <= heightSegments; y++) {
          for (let x = 0; x <= widthSegments; x++) {
            const u = x / widthSegments, v = y / heightSegments;
            const theta = u * Math.PI * 2, phi = v * Math.PI;
            const sinPhi = Math.sin(phi), cosPhi = Math.cos(phi);
            const sinTheta = Math.sin(theta), cosTheta = Math.cos(theta);
            vertices.push(radius * sinTheta * sinPhi, radius * cosPhi, radius * cosTheta * sinPhi);
          }
        }
        for (let y = 0; y < heightSegments; y++) {
          for (let x = 0; x < widthSegments; x++) {
            const v1 = y * (widthSegments + 1) + x;
            const v2 = v1 + 1;
            const v3 = v1 + widthSegments + 1;
            const v4 = v3 + 1;
            indices.push(v1, v2, v3, v2, v4, v3);
          }
        }
        this.positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        this.indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
        this.indices = indices;
      },
      BufferGeometry: function() {
        this.attributes = {};
        this.setAttribute = function(name, attribute) { this.attributes[name] = attribute; };
        this.positionBuffer = gl.createBuffer();
        this.positionCount = 0;
      },
      Float32BufferAttribute: function(array, itemSize) {
        this.array = array;
        this.itemSize = itemSize;
        this.count = array.length / itemSize;
      },
      MeshBasicMaterial: function({ color }) {
        this.color = new Mini3D.Color(color);
      },
      PointsMaterial: function({ color, size }) {
        this.color = new Mini3D.Color(color);
        this.size = size || 2;
      },
      Mesh: function(geometry, material) {
        this.type = 'Mesh';
        this.geometry = geometry;
        this.material = material;
        this.position = { x: 0, y: 0, z: 0 };
        this.set = function(x, y, z) { this.position.x = x; this.position.y = y; this.position.z = z; };
      },
      Points: function(geometry, material) {
        this.type = 'Points';
        this.geometry = geometry;
        this.material = material;
        geometry.positionCount = geometry.attributes.position.count;
        gl.bindBuffer(gl.ARRAY_BUFFER, geometry.positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geometry.attributes.position.array), gl.STATIC_DRAW);
      },
      Vector3: function(x, y, z) {
        this.x = x; this.y = y; this.z = z;
        this.set = function(x, y, z) { this.x = x; this.y = y; this.z = z; return this; };
        this.copy = function(v) { return new Mini3D.Vector3(v.x, v.y, v.z); };
        this.multiplyScalar = function(s) { this.x *= s; this.y *= s; this.z *= s; return this; };
        this.applyQuaternion = function(q) {
          const x = this.x, y = this.y, z = this.z;
          const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
          const ix = qw * x + qy * z - qz * y;
          const iy = qw * y + qz * x - qx * z;
          const iz = qw * z + qx * y - qy * x;
          const iw = -qx * x - qy * y - qz * z;
          this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
          this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
          this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
          return this;
        };
        this.clone = function() { return new Mini3D.Vector3(this.x, this.y, this.z); };
        this.add = function(v) { this.x += v.x; this.y += v.y; this.z += v.z; return this; };
      },
      Euler: function(pitch, yaw, roll, order) {
        this.setFromEuler = function(euler) {
          this._x = euler._x; this._y = euler._y; this._z = euler._z; this._order = euler._order;
          return this;
        };
        this._x = pitch; this._y = yaw; this._z = roll; this._order = order;
      },
      Quaternion: function(x, y, z, w) {
        this.x = x || 0; this.y = y || 0; this.z = z || 0; this.w = w || 1;
        this.setFromEuler = function(euler) {
          const c1 = Math.cos(euler._x / 2), c2 = Math.cos(euler._y / 2), c3 = Math.cos(euler._z / 2);
          const s1 = Math.sin(euler._x / 2), s2 = Math.sin(euler._y / 2), s3 = Math.sin(euler._z / 2);
          if (euler._order === 'YXZ') {
            this.x = s1 * c2 * c3 + c1 * s2 * s3;
            this.y = c1 * s2 * c3 - s1 * c2 * s3;
            this.z = c1 * c2 * s3 - s1 * s2 * c3;
            this.w = c1 * c2 * c3 + s1 * s2 * s3;
          }
          return this;
        };
      },
      matrixPerspective: function(fov, aspect, near, far) {
        const f = 1.0 / Math.tan(fov * Math.PI / 360);
        const nf = 1 / (near - far);
        return [
          f / aspect, 0, 0, 0,
          0, f, 0, 0,
          0, 0, (far + near) * nf, -1,
          0, 0, 2 * far * near * nf, 0
        ];
      },
      matrixTranslate: function(position) {
        return [
          1, 0, 0, 0,
          0, 1, 0, 0,
          0, 0, 1, 0,
          position.x, position.y, position.z, 1
        ];
      },
      matrixFromQuaternion: function(q) {
        const x = q.x, y = q.y, z = q.z, w = q.w;
        const x2 = x + x, y2 = y + y, z2 = z + z;
        const xx = x * x2, xy = x * y2, xz = x * z2;
        const yy = y * y2, yz = y * z2, zz = z * z2;
        const wx = w * x2, wy = w * y2, wz = w * z2;
        return [
          1 - (yy + zz), xy - wz, xz + wy, 0,
          xy + wz, 1 - (xx + zz), yz - wx, 0,
          xz - wy, yz + wx, 1 - (xx + yy), 0,
          0, 0, 0, 1
        ];
      },
      matrixMultiply: function(a, b) {
        const result = new Array(16).fill(0);
        for (let i = 0; i < 4; i++) {
          for (let j = 0; j < 4; j++) {
            for (let k = 0; k < 4; k++) {
              result[i * 4 + j] += a[i * 4 + k] * b[k * 4 + j];
            }
          }
        }
        return result;
      },
      matrixIdentity: function() {
        return [
          1, 0, 0, 0,
          0, 1, 0, 0,
          0, 0, 1, 0,
          0, 0, 0, 1
        ];
      }
    };

    // Console output utility
    const consoleDiv = document.getElementById('console');
    function logToConsole(message, type = 'info') {
      const p = document.createElement('p');
      p.style.color = type === 'error' ? '#FF5555' : type === 'input' ? '#FFFF00' : '#00FF00';
      p.textContent = `[${type.toUpperCase()}] ${message}`;
      consoleDiv.appendChild(p);
      consoleDiv.scrollTop = consoleDiv.scrollHeight;
    }

    // Global variables for input handling
    let isWaitingForInput = false;
    let inputResolver = null;
    let threeScene, threeCamera, threeRenderer, THREE;

    // Initialize Mini3D and Skulpt
    function initializeMini3D() {
      try {
        const canvas = document.getElementById('three-canvas');
        if (!canvas) {
          logToConsole('Canvas element not found. Ensure DOM is loaded.', 'error');
          return false;
        }
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if (!gl) {
          logToConsole('WebGL not supported. Check https://get.webgl.org/.', 'error');
          return false;
        }
        THREE = Mini3D;
        threeScene = new Mini3D.Scene();
        threeScene.background = new Mini3D.Color(0x000000);
        threeCamera = new Mini3D.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
        threeCamera.position.z = 100;
        threeRenderer = new Mini3D.WebGLRenderer({ canvas, antialias: true });
        threeRenderer.setSize(canvas.clientWidth, canvas.clientHeight);
        const light = { type: 'AmbientLight', color: new Mini3D.Color(0xffffff), intensity: 0.5 };
        threeScene.add(light);
        if (Sk && Sk.builtin && Sk.builtin.globals) {
          Sk.builtin.globals()['THREE'] = THREE;
          Sk.builtin.globals()['threeScene'] = threeScene;
          Sk.builtin.globals()['threeCamera'] = threeCamera;
          Sk.builtin.globals()['threeRenderer'] = threeRenderer;
          Sk.builtin.globals()['performance'] = { now: () => performance.now() };
          Sk.builtin.globals()['document'] = document;
          Sk.builtin.globals()['console'] = { log: console.log.bind(console) };
        } else {
          logToConsole('Skulpt not initialized. Cannot expose Mini3D globals.', 'error');
          return false;
        }
        return true;
      } catch (e) {
        logToConsole(`Mini3D initialization failed: ${e.message}. Check WebGL at https://get.webgl.org/.`, 'error');
        console.error('Mini3D initialization failed:', e);
        return false;
      }
    }

    // Configure Skulpt
    function initializeSkulpt() {
      try {
        Sk.configure({
          output: (msg) => logToConsole(msg, 'info'),
          read: (filename) => {
            if (Sk.builtinFiles === undefined || Sk.builtinFiles.files[filename] === undefined) {
              throw new Error(`File not found: ${filename}`);
            }
            return Sk.builtinFiles.files[filename];
          },
          inputfun: (prompt) => {
            isWaitingForInput = true;
            logToConsole(prompt, 'input');
            return new Promise((resolve) => {
              inputResolver = resolve;
            });
          }
        });
        return true;
      } catch (e) {
        logToConsole(`Skulpt config error: ${e.message}. Reload page or check Skulpt setup.`, 'error');
        return false;
      }
    }

    // Initialize on DOM load
    document.addEventListener('DOMContentLoaded', () => {
      if (initializeSkulpt() && initializeMini3D()) {
        logToConsole('Injector by WebXOS 2025 Initialized. Click Inject to inject a .py code or use test commands.', 'info');
      } else {
        logToConsole('Initialization failed. Check console for details.', 'error');
      }
    });

    // 3D control functions
    function adjustRotation(pitchDelta, yawDelta) {
      if (!threeRenderer || !threeCamera || !threeScene) {
        logToConsole('3D controls unavailable. Ensure Mini3D is initialized.', 'error');
        return;
      }
      try {
        const euler = new Mini3D.Euler(threeCamera.rotation ? threeCamera.rotation._x + pitchDelta : pitchDelta, threeCamera.rotation ? threeCamera.rotation._y + yawDelta : yawDelta, 0, 'YXZ');
        threeCamera.quaternion = new Mini3D.Quaternion().setFromEuler(euler);
        threeRenderer.render(threeScene, threeCamera);
      } catch (e) {
        logToConsole(`Rotation error: ${e.message}. Ensure Mini3D is initialized.`, 'error');
      }
    }

    function adjustZoom(delta) {
      if (!threeRenderer || !threeCamera || !threeScene) {
        logToConsole('3D controls unavailable. Ensure Mini3D is initialized.', 'error');
        return;
      }
      try {
        threeCamera.position.z = Math.max(10, Math.min(500, threeCamera.position.z + delta));
        threeCamera.updateProjectionMatrix();
        threeRenderer.render(threeScene, threeCamera);
      } catch (e) {
        logToConsole(`Zoom error: ${e.message}. Ensure camera is initialized.`, 'error');
      }
    }

    // Enhanced troubleshooting
    function troubleshoot() {
      logToConsole('Running Error AI diagnostics...', 'info');
      try {
        const pyCode = document.getElementById('py-input').value || document.getElementById('command-input').value;
        if (!pyCode) {
          logToConsole('No Python code to analyze. Enter a script in the Inject popup or text console.', 'error');
          return;
        }
        if (pyCode.includes('input(') && !isWaitingForInput) {
          logToConsole('Script uses input(). Ensure itâ€™s injected and running interactively.', 'info');
        }
        if (pyCode.includes('import ') && !pyCode.includes('import random') && !pyCode.includes('import re')) {
          logToConsole('Warning: Only random and re modules are supported in Skulpt 1.2.0.', 'error');
        }
        if (!threeRenderer || !THREE) {
          logToConsole('WebGL not initialized. Check https://get.webgl.org/ for browser compatibility.', 'error');
        } else {
          logToConsole('WebGL validated successfully.', 'info');
        }
        Sk.misceval.asyncToPromise(() => Sk.importMainWithBody('<stdin>', false, pyCode, true))
          .catch((err) => {
            const errMsg = err.toString();
            let suggestion = 'Check syntax or use Troubleshoot.';
            if (errMsg.includes('NameError')) {
              suggestion = 'Ensure all variables and functions are defined.';
            } else if (errMsg.includes('SyntaxError')) {
              suggestion = 'Check for syntax errors like missing colons or incorrect indentation.';
            } else if (errMsg.includes('NotImplementedError')) {
              suggestion = 'Avoid using reserved names like "help". Try renaming functions.';
            }
            logToConsole(`Python error: ${errMsg}. Suggestion: ${suggestion}`, 'error');
          });
        const testJs = () => { throw new Error('Test JS error'); };
        try { testJs(); } catch (e) {
          logToConsole('JS runtime stable. No issues detected.', 'info');
        }
        const css = document.querySelector('style').textContent;
        if (!css.includes('body')) {
          logToConsole('CSS error: Missing body styling. Add body rules.', 'error');
        } else {
          logToConsole('CSS validated successfully.', 'info');
        }
      } catch (e) {
        logToConsole(`Error AI: Unexpected error - ${e.message}. Suggestion: Check console input or script format.`, 'error');
      }
    }

    // Execute command or provide input
    function executeCommand(command = null) {
      const input = command || document.getElementById('command-input').value.trim();
      if (isWaitingForInput && inputResolver) {
        inputResolver(input);
        isWaitingForInput = false;
        inputResolver = null;
        document.getElementById('command-input').value = '';
        document.getElementById('command-input').focus();
        return;
      }
      try {
        if (input === 'clear') {
          consoleDiv.innerHTML = '';
          if (threeScene && threeRenderer && threeCamera) {
            threeScene.children = [];
            threeRenderer.render(threeScene, threeCamera);
          }
          logToConsole('Console and scene cleared.', 'info');
        } else {
          Sk.misceval.asyncToPromise(() => Sk.importMainWithBody('<stdin>', false, input, true))
            .then(() => logToConsole('Python script executed successfully.', 'info'))
            .catch((err) => logToConsole(`Python error: ${err.toString()}. Suggestion: Check syntax or use Troubleshoot.`, 'error'));
        }
      } catch (e) {
        logToConsole(`Command error: ${e.message}. Suggestion: Use 'clear', 'test 1', 'test 2', 'test 3', or valid Python script.`, 'error');
      }
      document.getElementById('command-input').value = '';
      document.getElementById('command-input').focus();
    }

    // Python console popup
    function showPyPopup() {
      document.getElementById('py-popup').style.display = 'block';
      if (threeRenderer && threeCamera && threeScene) {
        try {
          threeRenderer.setSize(document.getElementById('three-canvas').clientWidth, document.getElementById('three-canvas').clientHeight);
          threeRenderer.render(threeScene, threeCamera);
        } catch (e) {
          logToConsole(`Popup render error: ${e.message}. Ensure WebGL is enabled.`, 'error');
        }
      } else {
        logToConsole('3D rendering unavailable. Ensure Mini3D is initialized.', 'error');
      }
    }

    function closePyPopup() {
      document.getElementById('py-popup').style.display = 'none';
    }

    function injectPyScript() {
      const pyCode = document.getElementById('py-input').value;
      isWaitingForInput = false;
      inputResolver = null;
      try {
        const wrappedCode = `
def run_injected():
${pyCode.replace(/^/gm, '    ')}
run_injected()
        `;
        Sk.misceval.asyncToPromise(() => Sk.importMainWithBody('<stdin>', false, wrappedCode, true))
          .then(() => logToConsole('Python script executed successfully.', 'info'))
          .catch((err) => logToConsole(`Python error: ${err.toString()}. Suggestion: Check syntax, ensure all functions are defined, or use Troubleshoot.`, 'error'));
      } catch (e) {
        logToConsole(`Error AI: ${e.message}. Suggestion: Verify Python script format or use Troubleshoot.`, 'error');
      }
      closePyPopup();
    }

    function ejectPyConsole() {
      document.getElementById('py-input').value = '';
      consoleDiv.innerHTML = '';
      isWaitingForInput = false;
      inputResolver = null;
      if (threeScene && threeRenderer && threeCamera) {
        try {
          threeScene.children = [];
          threeRenderer.render(threeScene, threeCamera);
          logToConsole('Python console and 3D scene ejected. Ready for new commands.', 'info');
        } catch (e) {
          logToConsole(`Eject error: ${e.message}. Ensure Mini3D is initialized.`, 'error');
        }
      } else {
        logToConsole('Python console ejected. 3D scene unavailable.', 'info');
      }
    }

    // Window resize handling
    window.addEventListener('resize', () => {
      if (threeCamera && threeRenderer && threeScene) {
        try {
          const canvas = document.getElementById('three-canvas');
          threeCamera.aspect = canvas.clientWidth / canvas.clientHeight;
          threeCamera.updateProjectionMatrix();
          threeRenderer.setSize(canvas.clientWidth, canvas.clientHeight);
          threeRenderer.render(threeScene, threeCamera);
        } catch (e) {
          logToConsole(`Resize error: ${e.message}. Ensure Mini3D is initialized.`, 'error');
        }
      }
    });
  </script>
</body>
</html>
