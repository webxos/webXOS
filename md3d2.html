<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta http-equiv="Permissions-Policy" content="clipboard-write=(self)">
  <title>MD3D</title>
  <style>
    body { font-family: monospace; margin: 0; padding: 10px; background: #000; color: #0f0; }
    #console, #error-console, #input, #md-input, canvas { border: 1px solid #0f0; background: #000; color: #0f0; }
    #console { width: 100%; height: 200px; overflow-y: auto; padding: 10px; font-size: 14px; box-sizing: border-box; }
    #error-console { width: 100%; height: 150px; overflow-y: auto; padding: 10px; font-size: 14px; margin-top: 10px; box-sizing: border-box; }
    #input-area { margin-top: 10px; display: flex; flex-direction: column; gap: 10px; }
    #input { padding: 10px; font-size: 16px; width: 100%; box-sizing: border-box; }
    #md-popup, #md3d-popup { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); border: 2px solid #0f0; padding: 15px; z-index: 1000; background: #000; box-sizing: border-box; }
    #md-input { width: 100%; height: 250px; font-family: monospace; font-size: 14px; box-sizing: border-box; }
    button { padding: 12px; font-size: 16px; cursor: pointer; width: 100%; box-sizing: border-box; background: #4a0; color: #000; border: none;}
    button:hover:not(:disabled) { background: #2c0; }
    button:disabled { background: #222; opacity: 0.5; cursor: not-allowed; }
    #close3d-popup { position: absolute; top: 10px; right: 10px; padding: 8px; width: auto; }
    #md3d-popup { width: calc(100% - 40px); max-width: 800px; height: calc(100vh - 40px); max-height: 600px; }
    #status-area { margin: 10px 0; font-size: 12px; }
    .log-info { color: #0f0; }
    .log-error { color: #f00; }
    .log-warning { color: #ff0; }
    #log-output { display: none; margin-top: 10px; width: 100%; height: 100px; }
    #line-count { margin-top: 5px; font-size: 12px; color: #ff0; }
    @media (min-width: 768px) {
      #input-area { flex-direction: row; }
      button { width: 100px; }
      #input { width: calc(100% - 420px); }
    }
  </style>
</head>
<body>
  <div id="console" role="log"></div>
  <div id="error-console"></div>
  <button id="copy-log-btn" disabled aria-label="Copy error log to clipboard">Copy to Clipboard</button>
  <div id="status-area">
    <span id="webgl-status">N/A</span> | 
    <span id="webgpu-status">Checking...</span> | 
    <span id="wasm-status">Checking...</span> |
    <span id="fps">0.00</span> FPS | 
    <span id="memory">0.00</span> MB | 
    <span id="time">0.00</span> ms
  </div>
  <div id="input-area">
    <input id="input" placeholder="Enter command" aria-label="Command input" />
    <button id="execute" disabled aria-label="Execute command">Run</button>
    <button id="markdown-btn" disabled aria-label="Open markdown popup">MD3D</button>
    <button id="clear-btn" disabled aria-label="Clear app">Clear</button>
    <button id="debug-btn" disabled aria-label="Run diagnostics">Debug</button>
  </div>
  <div id="md-popup" style="display: none;">
    <select id="code-type" aria-label="Code type">
      <option value="text/markdown">Markdown (.md)</option>
    </select>
    <textarea id="md-input" placeholder="Paste Markdown with code block (e.g., ```javascript, ```glsl, ```wgsl, ```wasm, ```text) and optional commands (add_shape, add_light, set_camera)."></textarea>
    <div id="line-count">Lines: 0</div>
    <div style="margin-top: 10px; display: flex; gap: 10px;">
      <button onclick="injectMD()" aria-label="Inject markdown">Inject</button>
      <button onclick="closePopup()" aria-label="Close markdown popup">Close</button>
    </div>
  </div>
  <div id="md3d-popup" style="display: none;">
    <button id="close3d-popup" onclick="close3D()" aria-label="Close 3D canvas">X</button>
    <canvas id="md3d-canvas" aria-label="3D rendering canvas"></canvas>
  </div>
  <textarea id="log-output" readonly placeholder="Error log for manual copy" aria-label="Error log"></textarea>
  <script>
    // Math utilities (unchanged)
    const MathUtils = {
      mat4: {
        create: () => new Float32Array(16),
        identity: (m = MathUtils.mat4.create()) => {
          m.set([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
          return m;
        },
        perspective: (fovy, aspect, near, far, m = MathUtils.mat4.create()) => {
          const f = 1 / Math.tan(fovy / 2), d = near - far;
          m.set([
            f / aspect, 0, 0, 0,
            0, f, 0, 0,
            0, 0, (far + near) / d, -1,
            0, 0, 2 * far * near / d, 0
          ]);
          return m;
        },
        lookAt: (eye, center, up, m = MathUtils.mat4.create()) => {
          const z = [eye[0] - center[0], eye[1] - center[1], eye[2] - center[2]];
          const zl = Math.hypot(...z);
          if (zl < 0.0001) return MathUtils.mat4.identity(m);
          z[0] /= zl; z[1] /= zl; z[2] /= zl;
          let x = [up[1] * z[2] - up[2] * z[1], up[2] * z[0] - up[0] * z[2], up[0] * z[1] - up[1] * z[0]];
          let xl = Math.hypot(...x);
          if (xl < 0.0001) return MathUtils.mat4.identity(m);
          x[0] /= xl; x[1] /= xl; x[2] /= xl;
          const y = [z[1] * x[2] - z[2] * x[1], z[2] * x[0] - z[0] * x[2], z[0] * x[1] - z[1] * x[0]];
          m.set([
            x[0], y[0], -z[0], 0,
            x[1], y[1], -z[1], 0,
            x[2], y[2], -z[2], 0,
            -(x[0] * eye[0] + x[1] * eye[1] + x[2] * eye[2]),
            -(y[0] * eye[0] + y[1] * eye[1] + y[2] * eye[2]),
            z[0] * eye[0] + z[1] * eye[1] + z[2] * eye[2], 1
          ]);
          return m;
        },
        multiply: (a, b, m = MathUtils.mat4.create()) => {
          if (!a || !b || !a.set || !b.set) throw new Error('Invalid matrix input');
          const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
                a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
                a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
                a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
          const b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
          m[0] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
          m[1] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
          m[2] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
          m[3] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
          const b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
          m[4] = a00 * b4 + a10 * b5 + a20 * b6 + a30 * b7;
          m[5] = a01 * b4 + a11 * b5 + a21 * b6 + a31 * b7;
          m[6] = a02 * b4 + a12 * b5 + a22 * b6 + a32 * b7;
          m[7] = a03 * b4 + a13 * b5 + a23 * b6 + a33 * b7;
          const b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
          m[8] = a00 * b8 + a10 * b9 + a20 * b10 + a30 * b11;
          m[9] = a01 * b8 + a11 * b9 + a21 * b10 + a31 * b11;
          m[10] = a02 * b8 + a12 * b9 + a22 * b10 + a32 * b11;
          m[11] = a03 * b8 + a13 * b9 + a23 * b10 + a33 * b11;
          const b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
          m[12] = a00 * b12 + a10 * b13 + a20 * b14 + a30 * b15;
          m[13] = a01 * b12 + a11 * b13 + a21 * b14 + a31 * b15;
          m[14] = a02 * b12 + a12 * b13 + a22 * b14 + a32 * b15;
          m[15] = a03 * b12 + a13 * b13 + a23 * b14 + a33 * b15;
          return m;
        },
        translate: (m, v, out = MathUtils.mat4.create()) => {
          if (!m || !m.set || !v || v.length !== 3) throw new Error('Invalid translate input');
          out.set(m);
          out[12] = m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12];
          out[13] = m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13];
          out[14] = m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14];
          out[15] = m[3] * v[0] + m[7] * v[1] + m[11] * v[2] + m[15];
          return out;
        },
        rotateX: (m, rad, out = MathUtils.mat4.create()) => {
          if (!m || !m.set || isNaN(rad)) throw new Error('Invalid rotateX input');
          const s = Math.sin(rad), c = Math.cos(rad);
          const a10 = m[4], a11 = m[5], a12 = m[6], a13 = m[7],
                a20 = m[8], a21 = m[9], a22 = m[10], a23 = m[11];
          out.set(m);
          out[4] = a10 * c + a20 * s;
          out[5] = a11 * c + a21 * s;
          out[6] = a12 * c + a22 * s;
          out[7] = a13 * c + a23 * s;
          out[8] = a20 * c - a10 * s;
          out[9] = a21 * c - a11 * s;
          out[10] = a22 * c - a12 * s;
          out[11] = a23 * c - a13 * s;
          return out;
        },
        rotateY: (m, rad, out = MathUtils.mat4.create()) => {
          if (!m || !m.set || isNaN(rad)) throw new Error('Invalid rotateY input');
          const s = Math.sin(rad), c = Math.cos(rad);
          const a00 = m[0], a01 = m[1], a02 = m[2], a03 = m[3],
                a20 = m[8], a21 = m[9], a22 = m[10], a23 = m[11];
          out.set(m);
          out[0] = a00 * c - a20 * s;
          out[1] = a01 * c - a21 * s;
          out[2] = a02 * c - a22 * s;
          out[3] = a03 * c - a23 * s;
          out[8] = a00 * s + a20 * c;
          out[9] = a01 * s + a21 * c;
          out[10] = a02 * s + a22 * c;
          out[11] = a03 * s + a23 * c;
          return out;
        }
      },
      vec3: {
        subtract: (a, b, out = [0,0,0]) => { out[0] = a[0] - b[0]; out[1] = a[1] - b[1]; out[2] = a[2] - b[2]; return out; },
        normalize: (v, out = [0,0,0]) => { const l = Math.hypot(...v); out[0] = l > 0 ? v[0] / l : 0; out[1] = l > 0 ? v[1] / l : 0; out[2] = l > 0 ? v[2] / l : 0; return out; },
        dot: (a, b) => a[0] * b[0] + a[1] * b[1] + a[2] * b[2]
      }
    };

    // WebGPU Renderer
    class WebGPURenderer {
      constructor(canvas) {
        this.canvas = canvas;
        this.objects = [];
        this.lights = [];
        this.camera = { position: [0, 0, 20], rotation: [0, 0, 0], fov: 45 * Math.PI / 180, near: 0.1, far: 1000 };
        this.device = null;
        this.context = null;
        this.pipeline = null;
        this.bindGroup = null;
        this.uniformBuffer = null;
        this.vertexBuffer = null;
        this.normalBuffer = null;
        this.indexBuffer = null;
        this.depthTexture = null;
        this.initPromise = this.init();
      }

      async init() {
        if (!navigator.gpu) throw new Error('WebGPU not supported');
        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) throw new Error('No WebGPU adapter found');
        this.device = await adapter.requestDevice();
        this.context = this.canvas.getContext('webgpu');
        if (!this.context) throw new Error('WebGPU context not available');

        const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
        this.context.configure({
          device: this.device,
          format: presentationFormat,
          alphaMode: 'opaque'
        });

        const shaderModule = this.device.createShaderModule({
          code: `
            struct Uniforms {
              mvp : mat4x4<f32>,
              model : mat4x4<f32>,
              color : vec3<f32>,
              // padding
              _p1: f32,
              lightPos : vec3<f32>,
               // padding
              _p2: f32,
              lightColor : vec3<f32>,
              lightIntensity : f32,
            };
            @group(0) @binding(0) var<uniform> uniforms : Uniforms;

            struct VertexOutput {
              @builtin(position) position : vec4<f32>,
              @location(0) normal : vec3<f32>,
              @location(1) worldPos : vec3<f32>,
            };

            @vertex
            fn vs_main(@location(0) pos: vec3<f32>, @location(1) norm: vec3<f32>) -> VertexOutput {
              var out : VertexOutput;
              out.position = uniforms.mvp * vec4<f32>(pos, 1.0);
              out.normal = (uniforms.model * vec4<f32>(norm, 0.0)).xyz;
              out.worldPos = (uniforms.model * vec4<f32>(pos, 1.0)).xyz;
              return out;
            }

            @fragment
            fn fs_main(in : VertexOutput) -> @location(0) vec4<f32> {
              let normal = normalize(in.normal);
              let lightDir = normalize(uniforms.lightPos - in.worldPos);
              let diff = max(dot(normal, lightDir), 0.0);
              let diffuse = diff * uniforms.lightColor * uniforms.lightIntensity;
              return vec4<f32>(uniforms.color * diffuse, 1.0);
            }
          `
        });

        this.pipeline = this.device.createRenderPipeline({
          layout: 'auto',
          vertex: {
            module: shaderModule,
            entryPoint: 'vs_main',
            buffers: [
              { arrayStride: 12, attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x3' }] },
              { arrayStride: 12, attributes: [{ shaderLocation: 1, offset: 0, format: 'float32x3' }] }
            ]
          },
          fragment: {
            module: shaderModule,
            entryPoint: 'fs_main',
            targets: [{ format: presentationFormat }]
          },
          primitive: { topology: 'triangle-list' },
          depthStencil: {
            depthWriteEnabled: true,
            depthCompare: 'less',
            format: 'depth24plus'
          }
        });

        const vertices = new Float32Array([-0.5,-0.5,0.5,0.5,-0.5,0.5,0.5,0.5,0.5,-0.5,0.5,0.5,-0.5,-0.5,-0.5,-0.5,0.5,-0.5,0.5,0.5,-0.5,0.5,-0.5,-0.5,-0.5,0.5,-0.5,-0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,-0.5,-0.5,-0.5,-0.5,0.5,-0.5,-0.5,0.5,-0.5,0.5,-0.5,-0.5,0.5,0.5,-0.5,-0.5,0.5,0.5,0.5,0.5,-0.5,0.5,-0.5,-0.5,-0.5,-0.5,-0.5,0.5,-0.5,0.5,0.5,-0.5,0.5,-0.5]);
        const normals = new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0]);
        const indices = new Uint16Array([0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23]);

        this.vertexBuffer = this.device.createBuffer({ size: vertices.byteLength, usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST });
        this.normalBuffer = this.device.createBuffer({ size: normals.byteLength, usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST });
        this.indexBuffer = this.device.createBuffer({ size: indices.byteLength, usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST });

        this.device.queue.writeBuffer(this.vertexBuffer, 0, vertices);
        this.device.queue.writeBuffer(this.normalBuffer, 0, normals);
        this.device.queue.writeBuffer(this.indexBuffer, 0, indices);

        // Uniform buffer size must be a multiple of 16
        this.uniformBuffer = this.device.createBuffer({ size: 160, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });

        this.bindGroup = this.device.createBindGroup({
          layout: this.pipeline.getBindGroupLayout(0),
          entries: [{ binding: 0, resource: { buffer: this.uniformBuffer } }]
        });
      }

      setSize(w, h) {
        if (!this.device) return;
        this.canvas.width = w * devicePixelRatio;
        this.canvas.height = h * devicePixelRatio;
        this.canvas.style.width = `${w}px`;
        this.canvas.style.height = `${h}px`;
        this.depthTexture?.destroy();
        this.depthTexture = this.device.createTexture({
          size: [this.canvas.width, this.canvas.height],
          format: 'depth24plus',
          usage: GPUTextureUsage.RENDER_ATTACHMENT
        });
      }

      addCube(name, position, size, color) { this.objects.push({ name, type: 'cube', position: position.map(Number), size: Number(size), color: color.map(Number), rotation: [0, 0, 0] }); }
      addLight(name, position, color, intensity) { this.lights.push({ name, type: 'point', position: position.map(Number), color: color.map(Number), intensity: Number(intensity) }); }
      setCamera(position, rotation) { this.camera.position = position.map(Number); this.camera.rotation = rotation.map(Number); }

      async render() {
        await this.initPromise;
        if (!this.context || !this.device) return;

        const commandEncoder = this.device.createCommandEncoder();
        const renderPass = commandEncoder.beginRenderPass({
          colorAttachments: [{
            view: this.context.getCurrentTexture().createView(),
            clearValue: { r: 0, g: 0, b: 0, a: 1 },
            loadOp: 'clear', storeOp: 'store'
          }],
          depthStencilAttachment: {
            view: this.depthTexture.createView(),
            depthClearValue: 1.0, depthLoadOp: 'clear', depthStoreOp: 'store'
          }
        });

        renderPass.setPipeline(this.pipeline);
        renderPass.setVertexBuffer(0, this.vertexBuffer);
        renderPass.setVertexBuffer(1, this.normalBuffer);
        renderPass.setIndexBuffer(this.indexBuffer, 'uint16');

        const aspect = this.canvas.width / this.canvas.height;
        const proj = MathUtils.mat4.perspective(this.camera.fov, aspect, this.camera.near, this.camera.far);
        const view = MathUtils.mat4.lookAt(this.camera.position, [0, 0, 0], [0, 1, 0]);
        const vp = MathUtils.mat4.multiply(proj, view);

        for (const obj of this.objects) {
          let model = MathUtils.mat4.identity();
          model = MathUtils.mat4.translate(model, obj.position);
          model = MathUtils.mat4.rotateX(model, obj.rotation[0]);
          model = MathUtils.mat4.rotateY(model, obj.rotation[1]);
          const mvp = MathUtils.mat4.multiply(vp, model);

          const light = this.lights[0] || { position: [5, 5, 5], color: [1, 1, 1], intensity: 1 };
          const uniformData = new Float32Array(40); // 160 bytes
          uniformData.set(mvp, 0);
          uniformData.set(model, 16);
          uniformData.set(obj.color, 32);
          uniformData.set(light.position, 36);
          uniformData.set(light.color, 40);
          uniformData[43] = light.intensity;

          this.device.queue.writeBuffer(this.uniformBuffer, 0, uniformData);
          renderPass.setBindGroup(0, this.bindGroup);
          renderPass.drawIndexed(36);
        }

        renderPass.end();
        this.device.queue.submit([commandEncoder.finish()]);
      }

      clear() { this.objects = []; this.lights = []; }
    }

    // Application logic
    let log = [], renderer, objects = [], animations = [], groups = [], lights = [];
    let rendering = false, renderId, perfId, lastTime = 0;
    let updateFn;
    let keys = {}, touch = { x0: 0, y0: 0, dx: 0, dy: 0, dragging: false };
    let wasmModule = null;

    const debugMD = `
# Debug MD3D

\`\`\`javascript
function customUpdate(md3d, scene, camera, renderer, sceneObjects, animations, groups, lights, keyboardState, touchState) {
  const now = performance.now();
  if (now - (window.lastDebugLog || 0) < 5000) return;
  window.lastDebugLog = now;
  console.log(\`[MD3D] Rendering \${sceneObjects.length} objects\`);
  const cube = sceneObjects.find(obj => obj.name === 'debug_cube');
  if (cube) {
    cube.rotation[0] += 0.01;
    cube.rotation[1] += 0.01;
  }
}
\`\`\`

add_shape(cube, debug_cube, position=(0,0,0), size=1, color=(1,0,0))
add_light(debug_light, point, position=(5,5,5), color=(1,1,1), intensity=1)
set_camera(position=(0,0,10), rotation=(0,0,0))
`.trim();

    function logInfo(msg, level = 'info') {
      const c = document.getElementById('console');
      const isScrolledToBottom = c.scrollHeight - c.clientHeight <= c.scrollTop + 1;
      const div = document.createElement('div');
      div.className = `log-${level}`;
      div.textContent = `[MD3D] ${msg}`;
      c.appendChild(div);
      if (isScrolledToBottom) c.scrollTop = c.scrollHeight;
      log.push({ time: new Date().toISOString(), level: level.toUpperCase(), msg });
      if (log.length > 200) log.shift();
      document.getElementById('log-output').value = log.map(e => `[${e.time}] [${e.level}] ${e.msg}`).join('\n');
    }

    function logError(msg) {
      logInfo(msg, 'error');
      const ec = document.getElementById('error-console');
      const div = document.createElement('div');
      div.className = 'log-error';
      div.textContent = `[ERROR] ${msg}`;
      ec.appendChild(div);
      while (ec.children.length > 100) ec.removeChild(ec.firstChild);
      ec.scrollTop = ec.scrollHeight;
    }

    class MD3D {
      constructor() { this.renderer = renderer; this.objects = objects; this.animations = animations; this.groups = groups; this.lights = lights; }
      add_shape(type, name, params) { try { if (type !== 'cube') throw new Error(`Unsupported shape type: ${type}`); const { position, size, color } = params; if (!name || !Array.isArray(position) || position.length !== 3 || isNaN(size) || size <= 0 || !Array.isArray(color) || color.length !== 3) throw new Error('Invalid cube params'); renderer.addCube(name, position, size, color); objects.push({ name, type: 'cube', position: position.map(Number), size: Number(size), color: color.map(Number), rotation: [0, 0, 0] }); logInfo(`Cube ${name} added, total: ${objects.length}`); } catch (e) { logError(`Add shape ${name} failed: ${e.message}`); } }
      add_light(name, type, params) { try { const { position, color, intensity } = params; if (!name || !type || !Array.isArray(position) || position.length !== 3 || !Array.isArray(color) || color.length !== 3 || isNaN(intensity)) throw new Error('Invalid light params'); if (type !== 'point') throw new Error('Only point lights supported'); if (lights.find(l => l.name === name)) throw new Error(`Duplicate light: ${name}`); renderer.addLight(name, position, color, intensity); lights.push({ name, type, position: position.map(Number), color: color.map(Number), intensity: Number(intensity) }); logInfo(`Light ${name} added, total: ${lights.length}`); } catch (e) { logError(`Add light ${name} failed: ${e.message}`); } }
      set_camera(params) { try { const { position, rotation } = params; if (!Array.isArray(position) || position.length !== 3 || !Array.isArray(rotation) || rotation.length !== 3) throw new Error('Invalid camera params'); renderer.setCamera(position, rotation); logInfo(`Camera set: pos=[${position}], rot=[${rotation}]`); } catch (e) { logError(`Set camera failed: ${e.message}`); } }
      clear() { try { if (renderer) renderer.clear(); objects = []; animations = []; groups = []; lights = []; updateFn = null; logInfo(`Cleared: shapes=${objects.length}, animations=${animations.length}, groups=${groups.length}, lights=${lights.length}`); } catch (e) { logError(`Clear failed: ${e.message}`); } }
    }

    const md3d = new MD3D();

    async function init() {
      try {
        logInfo('Initializing...');
        document.getElementById('webgl-status').textContent = 'N/A';
        await init3D();
        await initWASM();
        initControls();
        logInfo('Initialized');
        ['execute', 'markdown-btn', 'clear-btn', 'debug-btn', 'copy-log-btn'].forEach(id => {
          document.getElementById(id).disabled = false;
        });
        updatePerf();
      } catch (e) {
        logError(`Init failed: ${e.message}`);
        disableUI();
      }
    }

    function disableUI() { ['execute', 'markdown-btn', 'clear-btn', 'debug-btn', 'copy-log-btn'].forEach(id => { const el = document.getElementById(id); if (el) el.disabled = true; }); }

    async function init3D() {
      try {
        const canvas = document.getElementById('md3d-canvas');
        renderer = new WebGPURenderer(canvas);
        await renderer.initPromise;
        document.getElementById('webgpu-status').textContent = 'WebGPU';
        logInfo('WebGPU Initialized');
        resize();
        logInfo('3D system ready');
      } catch (e) {
        logError(`3D init failed: ${e.message}`);
        document.getElementById('webgpu-status').textContent = 'Failed';
        throw e;
      }
    }

    async function initWASM() {
      try {
        const wasmBytes = new Uint8Array([0,97,115,109,1,0,0,0,1,7,1,96,2,127,127,1,127,3,2,1,0,7,7,1,3,97,100,100,0,0,10,9,1,7,0,32,0,32,1,106,11]);
        const wasmInstance = await WebAssembly.instantiate(wasmBytes);
        wasmModule = wasmInstance.instance;
        document.getElementById('wasm-status').textContent = 'WASM Ready';
        logInfo('WASM module loaded.');
      } catch (e) {
        logError(`WASM initialization failed: ${e.message}`);
        document.getElementById('wasm-status').textContent = 'WASM Failed';
        wasmModule = null;
      }
    }

    async function renderLoop() {
      if (!rendering) return;
      try {
        const now = performance.now();
        const delta = now - (lastTime || now);
        lastTime = now;

        if (document.getElementById('md3d-popup').style.display === 'none') { close3D(); return; }
        if (updateFn) { updateFn(md3d, renderer.objects, renderer.camera, renderer, objects, animations, groups, lights, keys, touch); }
        await renderer.render();
        const frameTime = performance.now() - now;
        if (delta > 0) document.getElementById('fps').textContent = (1000 / delta).toFixed(2);
        document.getElementById('time').textContent = frameTime.toFixed(2);
      } catch (e) {
        logError(`Render loop failed unexpectedly: ${e.message}`);
        close3D();
      }
      renderId = requestAnimationFrame(renderLoop);
    }

    function updatePerf() {
      const memory = performance.memory;
      if (memory) { document.getElementById('memory').textContent = (memory.usedJSHeapSize / 1048576).toFixed(2); }
      perfId = setTimeout(updatePerf, 2000);
    }

    function parseCommandArgs(argsStr) {
      const args = [];
      const kwargs = {};
      const argParts = argsStr.match(/([^=,]+\([^)]+\)|[^,]+)/g) || [];
      argParts.forEach(part => {
        part = part.trim();
        if (part.includes('=')) {
          const [key, rawValue] = part.split('=').map(s => s.trim());
          let value = rawValue;
          if (rawValue.startsWith('(') && rawValue.endsWith(')')) {
            value = rawValue.slice(1, -1).split(',').map(n => parseFloat(n.trim()));
          } else { value = parseFloat(rawValue); }
          kwargs[key] = value;
        } else { args.push(part); }
      });
      return { args, kwargs };
    }

    function parseMD(code) {
      logInfo(`Parsing ${code.split('\n').length} lines`);
      const lines = code.replace(/\r\n/g, '\n').trim().split('\n');
      let inCodeBlock = false, codeBlockLang = '', codeBlockContent = '';
      lines.forEach((line, index) => {
        const trimmed = line.trim();
        if (trimmed.startsWith('```')) {
          if (inCodeBlock) {
            inCodeBlock = false;
            if (codeBlockLang === 'javascript') {
              try {
                updateFn = new Function('md3d', 'scene', 'camera', 'renderer', 'sceneObjects', 'animations', 'groups', 'lights', 'keyboardState', 'touchState', codeBlockContent);
                logInfo(`JS block parsed at line ${index + 1}: ${codeBlockContent.substring(0, 40).replace(/\n/g, ' ')}...`);
                logInfo('JS update function loaded');
              } catch (e) { logError(`JS block parsing failed: ${e.message}`); }
            }
          } else { inCodeBlock = true; codeBlockLang = trimmed.substring(3).trim(); codeBlockContent = ''; logInfo(`Code block (${codeBlockLang}) started at line ${index + 1}`); }
        } else if (inCodeBlock) {
          codeBlockContent += line + '\n';
        } else if (trimmed && !trimmed.startsWith('#')) {
          const match = trimmed.match(/^(\w+)\((.*)\)$/); // FIXED: Correct regex
          if (match) {
            const cmd = match[1], fullArgsStr = match[2];
            try {
              const { args, kwargs } = parseCommandArgs(fullArgsStr);
              if (typeof md3d[cmd] === 'function') {
                if (cmd === 'add_shape') { md3d.add_shape(args[0], args[1], kwargs); }
                else if (cmd === 'add_light') { md3d.add_light(args[0], args[1], kwargs); }
                else if (cmd === 'set_camera') { md3d.set_camera(kwargs); }
                else { md3d[cmd](); }
                logInfo(`Generated: ${cmd}`);
              } else { logError(`Unknown command: ${cmd}`); }
            } catch (e) { logError(`Command '${cmd}' failed: ${e.message}`); }
          }
        } else if (trimmed.startsWith('#')) { logInfo(`Skipped line ${index + 1}: ${line}`); }
      });
      logInfo(`MD ran: shapes=${objects.length}, animations=${animations.length}, groups=${groups.length}, lights=${lights.length}`);
    }

    function open3D() {
      const popup = document.getElementById('md3d-popup');
      popup.style.display = 'block';
      logInfo('3D canvas opened');
      resize();
      rendering = true;
      lastTime = performance.now();
      renderLoop();
    }

    function close3D() {
      const popup = document.getElementById('md3d-popup');
      popup.style.display = 'none';
      if (rendering) {
        rendering = false;
        if (renderId) cancelAnimationFrame(renderId);
        renderId = null;
        logInfo('3D canvas closed');
        logInfo('Render stopped');
      }
    }

    function injectMD(sourceMD = null) {
      const mdInput = document.getElementById('md-input');
      const code = sourceMD || mdInput.value;
      if (sourceMD) { mdInput.value = ''; document.getElementById('line-count').textContent = 'Lines: 0'; }
      if (code !== debugMD) { md3d.clear(); }
      parseMD(code);
      if (objects.length > 0 || lights.length > 0) { open3D(); }
    }
    
    // All functions below are reconstructed/completed
    function openPopup() { document.getElementById('md-popup').style.display = 'block'; }
    function closePopup() { document.getElementById('md-popup').style.display = 'none'; }
    function resize() { if (renderer) renderer.setSize(renderer.canvas.parentElement.clientWidth, renderer.canvas.parentElement.clientHeight); }

    function debug() {
      logInfo('Debug running...');
      md3d.clear();
      close3D();
      injectMD(debugMD);
      logInfo(`Embedded debug.md executed successfully`);
      setTimeout(() => {
        logInfo(`--- DEBUG CHECKS ---`);
        const checks = {
          '3D Init': !!renderer?.device,
          'Scene Objects': !!objects,
          'Camera': !!renderer?.camera,
          'Renderer Pipeline': !!renderer?.pipeline,
          'Rendering Loop': rendering,
          'WASM Module': !!wasmModule,
          'Debug MD Execution': objects.some(o => o.name === 'debug_cube') && lights.some(l => l.name === 'debug_light'),
          'Render Status': rendering ? 'OK' : 'Stopped'
        };
        Object.entries(checks).forEach(([name, check], i) => {
          const status = check ? 'OK' : 'Failed';
          logInfo(`[CHECK ${i + 1}] ${name}: ${status}`);
        });
        logInfo('Debug done');
      }, 100);
    }
    
    function initControls() {
      document.getElementById('execute').onclick = () => {
        const input = document.getElementById('input');
        const cmd = input.value.trim();
        if (cmd) { logInfo(`Executing: ${cmd}`); parseMD(cmd); input.value = ''; }
      };
      document.getElementById('input').onkeydown = (e) => { if (e.key === 'Enter') document.getElementById('execute').click(); };
      document.getElementById('markdown-btn').onclick = openPopup;
      document.getElementById('clear-btn').onclick = () => { md3d.clear(); close3D(); updateFn = null; };
      document.getElementById('debug-btn').onclick = debug;
      document.getElementById('copy-log-btn').onclick = () => {
        navigator.clipboard.writeText(document.getElementById('log-output').value)
          .then(() => logInfo('Log copied to clipboard.'))
          .catch(err => logError('Failed to copy log: ' + err));
      };
      document.getElementById('md-input').addEventListener('input', e => {
        const count = e.target.value.split('\n').length;
        document.getElementById('line-count').textContent = `Lines: ${count}`;
      });
      window.onresize = resize;
      window.addEventListener('keydown', (e) => { keys[e.key] = true; });
      window.addEventListener('keyup', (e) => { keys[e.key] = false; });
    }

    window.onload = init;
  </script>
</body>
</html>
