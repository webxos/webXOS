<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>edTV: CHANNEL 10</title>
    <meta name="theme-color" content="#000000">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/objectron/objectron.js"></script>
    <style>
        *{margin:0;padding:0;box-sizing:border-box;font-family:'Press Start 2P',cursive;image-rendering:pixelated}
        body{background:#000;color:#0f0;overflow:hidden;height:100vh;user-select:none;-webkit-tap-highlight-color:transparent}
        #appContainer{position:relative;width:100%;height:100vh;overflow:hidden}
        .matrix-grid{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(rgba(0,255,0,0.1)1px,transparent 1px),linear-gradient(90deg,rgba(0,255,0,0.1)1px,transparent 1px);background-size:16px 16px;opacity:0.3}
        .crt-overlay{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(to bottom,transparent 50%,rgba(0,20,0,0.1)50%);background-size:100% 4px;z-index:5;pointer-events:none;animation:scanline 8s linear infinite}
        @keyframes scanline{0%{background-position:0 0}100%{background-position:0 100%}}
        #visualizationContainer{position:absolute;top:0;left:0;width:100%;height:100%;z-index:2}
        #ideInterface{position:absolute;top:0;left:0;width:100%;height:100%;z-index:10}
        
        /* Top Banner */
        .top-banner {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 40px;
            background: rgba(255, 0, 255, 0.9);
            border-bottom: 2px solid #f0f;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 12;
            overflow: hidden;
            animation: glitch 3s infinite;
        }
        @keyframes glitch {
            0%, 100% { transform: translateX(0); }
            5% { transform: translateX(-2px); }
            10% { transform: translateX(2px); }
            15% { transform: translateX(-1px); }
            20% { transform: translateX(1px); }
            25% { transform: translateX(0); }
            50% { transform: translateX(0); }
            55% { transform: translateX(-1px) skewX(-2deg); }
            60% { transform: translateX(1px) skewX(2deg); }
            65% { transform: translateX(-1px) skewX(-1deg); }
            70% { transform: translateX(1px) skewX(1deg); }
            75% { transform: translateX(0); }
        }
        .top-banner-text{font-size:12px;color:#000;text-shadow:1px 1px 0 #fff;letter-spacing:1px}

        /* Left Side Controls */
        .left-controls {
            position: absolute;
            top: 60px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 11;
        }
        .live-btn{width:180px;height:52px;background:#000;border:3px solid #0ff;color:#0ff;font-size:10px;display:flex;align-items:center;justify-content:center;cursor:pointer;box-shadow:3px 3px 0 #000;transform:skew(-2deg);transition:background 0.1s,color 0.1s;touch-action:none}
        .live-btn:hover,.live-btn:active{background:#0ff;color:#000}
        .live-btn.active{background:#0ff;color:#000}
        .object-btn{width:180px;height:52px;background:#000;border:3px solid #ff0;color:#ff0;font-size:10px;display:flex;align-items:center;justify-content:center;cursor:pointer;box-shadow:3px 3px 0 #000;transform:skew(-2deg);transition:background 0.1s,color 0.1s;touch-action:none}
        .object-btn:hover,.object-btn:active{background:#ff0;color:#000}
        .object-btn.active{background:#ff0;color:#000}
        .export-btn{width:180px;height:52px;background:#000;border:3px solid #0f0;color:#0f0;font-size:10px;display:flex;align-items:center;justify-content:center;cursor:pointer;box-shadow:3px 3px 0 #000;transform:skew(-2deg);transition:background 0.1s,color 0.1s;touch-action:none}
        .export-btn:hover,.export-btn:active{background:#0f0;color:#000}

        /* Right Side Controls */
        .right-controls {
            position: absolute;
            top: 60px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 11;
        }
        .zoom-in-btn{width:120px;height:40px;background:#000;border:3px solid #0f0;color:#0f0;font-size:10px;cursor:pointer;display:flex;align-items:center;justify-content:center;touch-action:none}
        .zoom-out-btn{width:120px;height:40px;background:#000;border:3px solid #f00;color:#f00;font-size:10px;cursor:pointer;display:flex;align-items:center;justify-content:center;touch-action:none}
        .reset-btn{width:120px;height:40px;background:#000;border:3px solid #ff0;color:#ff0;font-size:10px;cursor:pointer;display:flex;align-items:center;justify-content:center;touch-action:none}
        .zoom-in-btn:hover,.zoom-in-btn:active{background:#0f0;color:#000}
        .zoom-out-btn:hover,.zoom-out-btn:active{background:#f00;color:#000}
        .reset-btn:hover,.reset-btn:active{background:#ff0;color:#000}

        /* PIP Face View */
        .ppv-face-view {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 140px;
            height: 105px;
            background: #000;
            border: 2px solid #0ff;
            z-index: 15;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .ppv-face-view.expanded{width:300px;height:225px;z-index:20}
        .ppv-canvas{width:100%;height:100%}

        /* Status & Timer */
        .neurots-status{position:absolute;top:50px;left:10px;font-size:8px;color:#0ff;z-index:11;background:rgba(0,0,0,0.7);padding:5px;border:1px solid #0ff}
        .mode-indicator{position:absolute;top:120px;left:20px;font-size:10px;color:#ff0;z-index:11;background:rgba(0,0,0,0.7);padding:8px;border:1px solid #ff0}

        /* JSON Export Panel */
        .json-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            border: 3px solid #0ff;
            padding: 15px;
            z-index: 30;
            width: 80%;
            max-width: 500px;
            display: none;
        }
        .json-title{font-size:12px;color:#0ff;margin-bottom:10px;text-align:center}
        .json-content{width:100%;height:200px;background:#000;border:2px solid #0f0;color:#0f0;font-size:8px;padding:10px;margin-bottom:10px;overflow:auto;font-family:monospace;white-space:pre-wrap}
        .json-btn{width:120px;height:40px;background:#000;border:2px solid #0f0;color:#0f0;font-size:10px;cursor:pointer;margin:0 auto;display:flex;align-items:center;justify-content:center}
        .json-btn:hover,.json-btn:active{background:#0f0;color:#000}

        /* Scene Click Area */
        #sceneClickArea{position:absolute;top:0;left:0;width:100%;height:100%;z-index:3;cursor:pointer}

        /* Infrared Scanner */
        .infrared-scanner {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: rgba(255, 0, 0, 0.7);
            box-shadow: 0 0 10px 2px rgba(255, 0, 0, 0.8);
            z-index: 6;
            pointer-events: none;
            animation: scan 3s linear infinite;
        }
        @keyframes scan {
            0% { top: 0%; }
            100% { top: 100%; }
        }

        /* Mobile Optimization */
        @media (max-width:767px){
            .ppv-face-view{width:100px;height:75px}
            .ppv-face-view.expanded{width:280px;height:210px}
            .live-btn,.object-btn,.export-btn{width:160px;height:48px;font-size:9px}
            .left-controls{left:10px}
            .right-controls{right:10px}
            .zoom-in-btn,.zoom-out-btn,.reset-btn{width:100px;height:36px;font-size:9px}
            .mode-indicator{top:110px;left:10px;font-size:9px}
        }
    </style>
</head>
<body>
<div id="appContainer">
    <div class="matrix-grid"></div>
    <div class="crt-overlay"></div>
    <div class="infrared-scanner"></div>
    
    <!-- Top Banner -->
    <div class="top-banner">
        <div class="top-banner-text">edTV: CHANNEL 10</div>
    </div>
    
    <!-- PIP Face View -->
    <div class="ppv-face-view" id="ppvFaceView">
        <canvas class="ppv-canvas" id="ppvCanvas"></canvas>
    </div>
    
    <!-- Status & Mode -->
    <div class="neurots-status" id="neurotsStatus">LIVE: READY</div>
    <div class="mode-indicator" id="modeIndicator">
        MODE: <span id="modeDisplay">FACE</span><br>
        POINTS: <span id="pointsDisplay">0</span>
    </div>
    
    <!-- JSON Export Panel -->
    <div class="json-panel" id="jsonPanel">
        <div class="json-title">edTV DATA:</div>
        <div class="json-content" id="jsonContent"></div>
        <button class="json-btn" id="copyJsonBtn">CLIPBOARD</button>
    </div>
    
    <!-- 3D Scene -->
    <div id="visualizationContainer">
        <canvas id="visualizationCanvas"></canvas>
        <div id="sceneClickArea"></div>
    </div>
    
    <div id="ideInterface">
        <!-- Left Side -->
        <div class="left-controls">
            <button id="liveBtn" class="live-btn">LIVE</button>
            <button id="objectBtn" class="object-btn">OBJECT</button>
            <button id="exportBtn" class="export-btn">EXPORT</button>
        </div>
        
        <!-- Right Side -->
        <div class="right-controls">
            <button id="zoomInBtn" class="zoom-in-btn">ZOOM IN</button>
            <button id="zoomOutBtn" class="zoom-out-btn">ZOOM OUT</button>
            <button id="resetViewBtn" class="reset-btn">RESET VIEW</button>
        </div>
    </div>
</div>

<script>
    // Core Variables
    let scene, cam, ren;
    let faceMesh, objectron, camera;
    let stream;
    let isProcessing = false;
    let isObjectMode = false;
    let animationId = null;
    let cameraDistance = 3;
    let cameraAngleX = 0, cameraAngleY = 0;
    let isDragging = false;
    let lastMouseX = 0, lastMouseY = 0;
    let lastTouchX = 0, lastTouchY = 0;
    
    // Face and Object Data
    let facePoints = [];
    let faceLines = [];
    let objectPoints = [];
    let objectLines = [];
    let currentMode = "face";
    let scanCycle = 0;

    // Scene Data
    let sceneData = { 
        mode: "face", 
        timestamp: null, 
        facePoints: [], 
        objectPoints: [],
        objectType: null
    };

    // DOM
    const $ = s => document.querySelector(s);

    function init() {
        init3D();
        setupFaceDetection();
        setupObjectDetection();
        setupEventListeners();
        animate();
    }

    function init3D() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        
        cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        updateCameraPosition();
        
        const canvas = $('#visualizationCanvas');
        ren = new THREE.WebGLRenderer({ canvas, antialias: false, powerPreference: "high-performance" });
        ren.setSize(window.innerWidth, window.innerHeight);
        ren.setPixelRatio(1);
        
        // Lighting - Infrared simulation
        scene.add(new THREE.AmbientLight(0x330000));
        const dir = new THREE.DirectionalLight(0xff0000, 0.5);
        dir.position.set(5, 10, 5);
        scene.add(dir);
        
        // Add a point light that moves with the scanner
        const scannerLight = new THREE.PointLight(0xff0000, 1, 10);
        scannerLight.position.set(0, 5, 0);
        scene.add(scannerLight);
        
        cam.lookAt(0, 0, 0);
    }

    function updateCameraPosition() {
        const x = cameraDistance * Math.sin(cameraAngleY) * Math.cos(cameraAngleX);
        const y = cameraDistance * Math.sin(cameraAngleX) + 1.5;
        const z = cameraDistance * Math.cos(cameraAngleY) * Math.cos(cameraAngleX);
        cam.position.set(x, y, z);
        cam.lookAt(0, 0, 0);
    }

    function setupFaceDetection() {
        faceMesh = new FaceMesh({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
        });
        faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        faceMesh.onResults(onFaceMeshResults);
    }

    function setupObjectDetection() {
        objectron = new Objectron({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/objectron/${file}`
        });
        objectron.setOptions({
            maxNumObjects: 1,
            minDetectionConfidence: 0.5,
            modelName: 'Cup' // Can be changed based on what user is holding
        });
        objectron.onResults(onObjectronResults);
    }

    function onFaceMeshResults(results) {
        const userDetected = results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0;
        
        const ppvCanvas = $('#ppvCanvas');
        const ctx = ppvCanvas.getContext('2d');
        ctx.clearRect(0, 0, ppvCanvas.width, ppvCanvas.height);
        
        if (results.image) {
            ctx.drawImage(results.image, 0, 0, ppvCanvas.width, ppvCanvas.height);
        }

        if (userDetected && isProcessing && currentMode === "face") {
            const landmarks = results.multiFaceLandmarks[0];
            
            // Draw face mesh in PIP
            drawConnectors(ctx, landmarks, FACEMESH_TESSELATION, { color: '#00ffff', lineWidth: 1 });
            drawConnectors(ctx, landmarks, FACEMESH_FACE_OVAL, { color: '#00ff00', lineWidth: 2 });

            // Update 3D face geometry
            updateFaceGeometry(landmarks);
            
            $('#neurotsStatus').textContent = `edTV: FACE TRACKING`;
            $('#pointsDisplay').textContent = `${facePoints.length}`;
        } else if (isProcessing && currentMode === "face") {
            $('#neurotsStatus').textContent = 'edTV: NO FACE';
        }
    }

    function onObjectronResults(results) {
        const objectDetected = results.detectedObjects && results.detectedObjects.length > 0;
        
        const ppvCanvas = $('#ppvCanvas');
        const ctx = ppvCanvas.getContext('2d');
        ctx.clearRect(0, 0, ppvCanvas.width, ppvCanvas.height);
        
        if (results.image) {
            ctx.drawImage(results.image, 0, 0, ppvCanvas.width, ppvCanvas.height);
        }

        if (objectDetected && isProcessing && currentMode === "object") {
            const object = results.detectedObjects[0];
            
            // Draw object in PIP
            drawConnectors(ctx, object.landmarks, object.connections, { color: '#ff0', lineWidth: 2 });
            
            // Update 3D object geometry
            updateObjectGeometry(object);
            
            $('#neurotsStatus').textContent = `edTV: OBJECT TRACKING`;
            $('#pointsDisplay').textContent = `${objectPoints.length}`;
        } else if (isProcessing && currentMode === "object") {
            $('#neurotsStatus').textContent = 'edTV: NO OBJECT';
        }
    }

    function updateFaceGeometry(landmarks) {
        // Clear previous geometry
        facePoints.forEach(point => scene.remove(point));
        faceLines.forEach(line => scene.remove(line));
        facePoints = [];
        faceLines = [];
        sceneData.facePoints = [];
        
        // Create face geometry
        landmarks.forEach((lm, index) => {
            // Convert to 3D world space
            const x = (lm.x - 0.5) * 4;
            const y = (0.5 - lm.y) * 4;
            const z = lm.z * 5 - 2;

            // Add point
            const geom = new THREE.SphereGeometry(0.01, 4, 4);
            const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const point = new THREE.Mesh(geom, mat);
            point.position.set(x, y, z);
            scene.add(point);
            facePoints.push(point);
            
            // Store in scene data
            sceneData.facePoints.push({ x, y, z, index });
        });
        
        // Create face mesh connections
        FACEMESH_TESSELATION.forEach(connection => {
            const [start, end] = connection;
            if (start < landmarks.length && end < landmarks.length) {
                const startPoint = landmarks[start];
                const endPoint = landmarks[end];
                
                const startX = (startPoint.x - 0.5) * 4;
                const startY = (0.5 - startPoint.y) * 4;
                const startZ = startPoint.z * 5 - 2;
                
                const endX = (endPoint.x - 0.5) * 4;
                const endY = (0.5 - endPoint.y) * 4;
                const endZ = endPoint.z * 5 - 2;
                
                const lineGeom = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(startX, startY, startZ),
                    new THREE.Vector3(endX, endY, endZ)
                ]);
                const line = new THREE.Line(lineGeom, new THREE.LineBasicMaterial({ color: 0x00ff00, opacity: 0.5, transparent: true }));
                scene.add(line);
                faceLines.push(line);
            }
        });
    }

    function updateObjectGeometry(object) {
        // Clear previous geometry
        objectPoints.forEach(point => scene.remove(point));
        objectLines.forEach(line => scene.remove(line));
        objectPoints = [];
        objectLines = [];
        sceneData.objectPoints = [];
        
        // Create object geometry
        object.landmarks.forEach((lm, index) => {
            // Convert to 3D world space
            const x = (lm.x - 0.5) * 4;
            const y = (0.5 - lm.y) * 4;
            const z = lm.z * 5 - 2;

            // Add point
            const geom = new THREE.SphereGeometry(0.02, 4, 4);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const point = new THREE.Mesh(geom, mat);
            point.position.set(x, y, z);
            scene.add(point);
            objectPoints.push(point);
            
            // Store in scene data
            sceneData.objectPoints.push({ x, y, z, index });
        });
        
        // Create object connections
        object.connections.forEach(connection => {
            const [start, end] = connection;
            if (start < object.landmarks.length && end < object.landmarks.length) {
                const startPoint = object.landmarks[start];
                const endPoint = object.landmarks[end];
                
                const startX = (startPoint.x - 0.5) * 4;
                const startY = (0.5 - startPoint.y) * 4;
                const startZ = startPoint.z * 5 - 2;
                
                const endX = (endPoint.x - 0.5) * 4;
                const endY = (0.5 - endPoint.y) * 4;
                const endZ = endPoint.z * 5 - 2;
                
                const lineGeom = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(startX, startY, startZ),
                    new THREE.Vector3(endX, endY, endZ)
                ]);
                const line = new THREE.Line(lineGeom, new THREE.LineBasicMaterial({ color: 0xffff00, opacity: 0.7, transparent: true }));
                scene.add(line);
                objectLines.push(line);
            }
        });
        
        sceneData.objectType = object.className || "Unknown";
    }

    function startWebcam() {
        if (stream) return;
        navigator.mediaDevices.getUserMedia({ 
            video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } }
        }).then(s => {
            stream = s;
            const video = document.createElement('video');
            video.srcObject = stream;
            video.autoplay = true;
            video.playsInline = true;
            video.style.display = 'none';
            document.body.appendChild(video);

            camera = new Camera(video, {
                onFrame: async () => {
                    if (currentMode === "face") {
                        await faceMesh.send({ image: video });
                    } else {
                        await objectron.send({ image: video });
                    }
                },
                width: 640, height: 480
            });
            camera.start();

            const ppv = $('#ppvCanvas');
            ppv.width = $('#ppvFaceView').clientWidth;
            ppv.height = $('#ppvFaceView').clientHeight;

            startProcessing();
        }).catch(err => {
            $('#neurotsStatus').textContent = 'CAMERA DENIED';
            console.error(err);
        });
    }

    function startProcessing() {
        isProcessing = true;
        $('#liveBtn').classList.add('active');
        $('#liveBtn').textContent = 'LIVE ACTIVE';
        sceneData.timestamp = new Date().toISOString();
        sceneData.mode = currentMode;
    }

    function stopProcessing() {
        isProcessing = false;
        $('#liveBtn').classList.remove('active');
        $('#liveBtn').textContent = 'LIVE';
        $('#neurotsStatus').textContent = 'edTV: READY';
    }

    function toggleObjectMode() {
        isObjectMode = !isObjectMode;
        currentMode = isObjectMode ? "object" : "face";
        
        if (isObjectMode) {
            $('#objectBtn').classList.add('active');
            $('#objectBtn').textContent = 'OBJECT ACTIVE';
            $('#modeDisplay').textContent = 'OBJECT';
        } else {
            $('#objectBtn').classList.remove('active');
            $('#objectBtn').textContent = 'OBJECT';
            $('#modeDisplay').textContent = 'FACE';
        }
        
        // Clear the scene when switching modes
        facePoints.forEach(point => scene.remove(point));
        faceLines.forEach(line => scene.remove(line));
        objectPoints.forEach(point => scene.remove(point));
        objectLines.forEach(line => scene.remove(line));
        facePoints = [];
        faceLines = [];
        objectPoints = [];
        objectLines = [];
        
        $('#pointsDisplay').textContent = '0';
    }

    function exportData() {
        const json = JSON.stringify(sceneData, null, 2);
        $('#jsonContent').textContent = json;
        $('#jsonPanel').style.display = 'block';
    }

    function copyJSON() {
        navigator.clipboard.writeText($('#jsonContent').textContent).then(() => {
            alert('edTV geometry data copied to clipboard!');
        });
    }

    function setupEventListeners() {
        $('#liveBtn').addEventListener('click', () => {
            if (!isProcessing) {
                startWebcam();
            } else {
                stopProcessing();
            }
        });

        $('#objectBtn').addEventListener('click', toggleObjectMode);
        $('#exportBtn').addEventListener('click', exportData);
        $('#copyJsonBtn').addEventListener('click', copyJSON);

        $('#zoomInBtn').addEventListener('click', () => { cameraDistance = Math.max(1.5, cameraDistance * 0.8); updateCameraPosition(); });
        $('#zoomOutBtn').addEventListener('click', () => { cameraDistance = Math.min(15, cameraDistance * 1.2); updateCameraPosition(); });
        $('#resetViewBtn').addEventListener('click', () => { cameraDistance = 3; cameraAngleX = cameraAngleY = 0; updateCameraPosition(); });

        $('#ppvFaceView').addEventListener('click', () => {
            $('#ppvFaceView').classList.toggle('expanded');
            const c = $('#ppvCanvas');
            c.width = $('#ppvFaceView').clientWidth;
            c.height = $('#ppvFaceView').clientHeight;
        });

        const area = $('#sceneClickArea');
        area.addEventListener('mousedown', e => { isDragging = true; lastMouseX = e.clientX; lastMouseY = e.clientY; });
        document.addEventListener('mousemove', e => {
            if (!isDragging) return;
            cameraAngleY += (e.clientX - lastMouseX) * 0.01;
            cameraAngleX = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraAngleX - (e.clientY - lastMouseY) * 0.01));
            lastMouseX = e.clientX; lastMouseY = e.clientY;
            updateCameraPosition();
        });
        document.addEventListener('mouseup', () => isDragging = false);

        area.addEventListener('touchstart', e => { if (e.touches.length === 1) { isDragging = true; lastTouchX = e.touches[0].clientX; lastTouchY = e.touches[0].clientY; e.preventDefault(); } });
        area.addEventListener('touchmove', e => {
            if (isDragging && e.touches.length === 1) {
                cameraAngleY += (e.touches[0].clientX - lastTouchX) * 0.01;
                cameraAngleX = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraAngleX - (e.touches[0].clientY - lastTouchY) * 0.01));
                lastTouchX = e.touches[0].clientX; lastTouchY = e.touches[0].clientY;
                updateCameraPosition();
                e.preventDefault();
            }
        });
        area.addEventListener('touchend', () => isDragging = false);

        window.addEventListener('resize', () => {
            cam.aspect = window.innerWidth / window.innerHeight;
            cam.updateProjectionMatrix();
            ren.setSize(window.innerWidth, window.innerHeight);
            const c = $('#ppvCanvas');
            c.width = $('#ppvFaceView').clientWidth;
            c.height = $('#ppvFaceView').clientHeight;
        });
    }

    function animate() {
        animationId = requestAnimationFrame(animate);
        
        // Update scanner light position to simulate infrared scanning
        scanCycle = (scanCycle + 0.01) % (Math.PI * 2);
        const scannerLight = scene.getObjectByName("scannerLight");
        if (scannerLight) {
            scannerLight.position.y = 5 * Math.sin(scanCycle);
        }
        
        ren.render(scene, cam);
    }

    window.addEventListener('load', init);
</script>
</body>
</html>
