<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>edTV: CHANNEL 10</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box;font-family:'Courier New',monospace;image-rendering:pixelated}
        body{background:#000;color:#0f0;overflow:hidden;height:100vh;user-select:none;-webkit-tap-highlight-color:transparent}
        #appContainer{position:relative;width:100%;height:100vh;overflow:hidden}
        .matrix-grid{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(rgba(0,255,0,0.1)1px,transparent 1px),linear-gradient(90deg,rgba(0,255,0,0.1)1px,transparent 1px);background-size:16px 16px;opacity:0.3}
        .crt-overlay{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(to bottom,transparent 50%,rgba(0,20,0,0.1)50%);background-size:100% 4px;z-index:5;pointer-events:none;animation:scanline 8s linear infinite}
        @keyframes scanline{0%{background-position:0 0}100%{background-position:0 100%}}
        #visualizationContainer{position:absolute;top:0;left:0;width:100%;height:100%;z-index:2}
        #ideInterface{position:absolute;top:0;left:0;width:100%;height:100%;z-index:10}
        
        /* Top Banner */
        .top-banner {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 40px;
            background: rgba(255, 0, 255, 0.9);
            border-bottom: 2px solid #f0f;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 12;
            overflow: hidden;
            animation: glitch 3s infinite;
        }
        
        @keyframes glitch {
            0%, 100% { transform: translateX(0); }
            5% { transform: translateX(-2px); }
            10% { transform: translateX(2px); }
            15% { transform: translateX(-1px); }
            20% { transform: translateX(1px); }
            25% { transform: translateX(0); }
        }
        
        .top-banner-text {
            font-size: 12px;
            color: #000;
            text-shadow: 1px 1px 0 #fff;
            letter-spacing: 1px;
        }
        
        /* Control Buttons */
        .ctrl-btn{
            width:120px;height:52px;background:#000;border:3px solid #0ff;color:#0ff;
            font-size:10px;display:flex;align-items:center;justify-content:center;cursor:pointer;
            box-shadow:3px 3px 0 #000;transform:skew(-2deg);transition:background 0.1s,color 0.1s;
            touch-action:none;margin:10px;
        }
        .ctrl-btn:hover,.ctrl-btn:active{background:#0ff;color:#000}
        .ctrl-btn.active{background:#0ff;color:#000}
        
        .export-btn{
            border-color:#f0f;color:#f0f;
        }
        .export-btn:hover,.export-btn:active{background:#f0f;color:#000}
        .export-btn.active{background:#f0f;color:#000}
        
        .controls-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 11;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        /* Mirror Popup */
        .mirror-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 10, 0, 0.95);
            border: 3px solid #0ff;
            padding: 8px;
            z-index: 100;
            box-shadow: 6px 6px 0 #000, inset 2px 2px 0 #0ff;
            width: 320px;
            height: 300px;
            overflow: hidden;
            font-size: 8px;
            color: #0ff;
            border-radius: 4px;
        }
        
        .mirror-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 8px;
            background: rgba(0, 255, 255, 0.2);
            border-bottom: 2px solid #0ff;
            margin-bottom: 8px;
            cursor: move;
            user-select: none;
        }
        
        .mirror-title {
            font-size: 10px;
            color: #0ff;
            text-shadow: 1px 1px 0 #000;
        }
        
        .mirror-close {
            width: 24px;
            height: 24px;
            background: #000;
            border: 2px solid #f00;
            color: #f00;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
        }
        
        .mirror-close:hover,.mirror-close:active{background:#f00;color:#000}
        
        .mirror-content {
            width: 100%;
            height: calc(100% - 40px);
            position: relative;
        }
        
        /* Webcam Container */
        .webcam-container {
            width: 100%;
            height: 200px;
            background: #000;
            border: 2px solid #0f0;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #0f0;
            font-size: 10px;
        }
        
        #calibStatus{font-size:8px;color:#ff0;margin:4px 0;text-align:center}
        
        /* HUD Warning */
        #hudWarning{position:absolute;top:20%;left:50%;transform:translate(-50%,-50%);color:#f00;font-size:12px;text-shadow:1px 1px 0 #000;z-index:11;display:none}
        
        /* Mobile Optimization */
        @media (max-width:767px){
            .mirror-popup{width:300px;height:280px}
            .controls-container{flex-direction:column;align-items:center;}
            .ctrl-btn{width:140px;height:56px;font-size:12px}
        }
        
        /* Scene Click Area */
        #sceneClickArea {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: calc(100% - 80px);
            z-index: 3;
            cursor: pointer;
        }
        
        /* Status Panel */
        .status-panel {
            position: absolute;
            top: 50px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #0ff;
            padding: 8px;
            font-size: 8px;
            color: #0ff;
            max-width: 200px;
            z-index: 11;
        }
        
        /* Export Success Message */
        .export-success {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #0f0;
            padding: 20px;
            color: #0f0;
            font-size: 12px;
            text-align: center;
            z-index: 100;
            display: none;
        }
        
        /* Manual Input Panel */
        .manual-input {
            position: absolute;
            top: 100px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff0;
            padding: 8px;
            font-size: 8px;
            color: #ff0;
            max-width: 200px;
            z-index: 11;
        }
        
        .manual-input input {
            background: #000;
            border: 1px solid #ff0;
            color: #ff0;
            padding: 4px;
            margin: 2px 0;
            width: 100%;
            font-size: 8px;
        }
        
        .manual-input button {
            background: #000;
            border: 1px solid #ff0;
            color: #ff0;
            padding: 4px;
            margin-top: 4px;
            cursor: pointer;
            width: 100%;
        }
    </style>
</head>
<body>
<div id="appContainer">
    <div class="matrix-grid"></div>
    <div class="crt-overlay"></div>
    
    <!-- Top Banner -->
    <div class="top-banner">
        <div class="top-banner-text">edTV: CHANNEL 10</div>
    </div>
    
    <!-- 3D SCENE -->
    <div id="visualizationContainer">
        <canvas id="visualizationCanvas"></canvas>
        <div id="sceneClickArea" title="Click to center view"></div>
    </div>
    
    <!-- Status Panel -->
    <div class="status-panel">
        <div>POINTS: <span id="dataPointCount">0</span></div>
        <div>EXPORT READY: <span id="exportStatus">NO</span></div>
    </div>
    
    <!-- Manual Input Panel -->
    <div class="manual-input">
        <div>FACE GEOMETRY</div>
        <input type="number" id="faceWidth" placeholder="Face Width" value="1.5" step="0.1">
        <input type="number" id="faceHeight" placeholder="Face Height" value="2.0" step="0.1">
        <input type="number" id="faceDepth" placeholder="Face Depth" value="0.5" step="0.1">
        <button id="updateFace">UPDATE FACE</button>
    </div>
    
    <div id="ideInterface">
        <!-- CONTROL BUTTONS -->
        <div class="controls-container">
            <button id="mirrorBtn" class="ctrl-btn" aria-label="Open Capture">CAPTURE</button>
            <button id="exportBtn" class="ctrl-btn export-btn" aria-label="Export 3D Data">EXPORT</button>
            <button id="clearBtn" class="ctrl-btn" aria-label="Clear Data" style="border-color:#ff0;color:#ff0">CLEAR</button>
        </div>
        
        <!-- HUD -->
        <div id="hudWarning">NO USER</div>
    </div>

    <!-- MIRROR POPUP -->
    <div class="mirror-popup" id="mirrorPopup">
        <div class="mirror-header">
            <div class="mirror-title">FACE CAPTURE</div>
            <div class="mirror-close" aria-label="Close Mirror">X</div>
        </div>
        <div class="mirror-content">
            <div class="webcam-container" id="webcamContainer">
                CAMERA NOT AVAILABLE<br>USE MANUAL INPUT
            </div>
            <div id="calibStatus">READY FOR MANUAL INPUT</div>
        </div>
    </div>
    
    <!-- Export Success Message -->
    <div class="export-success" id="exportSuccess">
        <div>3D DATA EXPORTED</div>
        <div style="font-size:8px;margin-top:10px;">JSON data copied to clipboard</div>
    </div>
</div>

<script>
    // Main Application Variables
    let scene, cam, ren, clock;
    let faceMesh, faceDirection = 0;
    let animationId = null;
    let mirrorDragging = false;
    let mirrorOffset = { x: 0, y: 0 };

    // 3D Data Schema
    const geometryDataSchema = {
        version: "1.0",
        timestamp: "",
        metadata: {
            app: "edTV_CHANNEL_5",
            captureType: "face_geometry",
            coordinateSystem: "right_handed"
        },
        faceGeometry: {
            vertices: [],
            normals: [],
            faces: [],
            landmarks: [],
            dimensions: { width: 1.5, height: 2.0, depth: 0.5 }
        },
        camera: {
            position: { x: 0, y: 0, z: 0 },
            rotation: { x: 0, y: 0, z: 0 },
            fov: 75
        }
    };

    // DOM utility functions
    const $ = s => document.querySelector(s);
    const $$ = s => document.querySelectorAll(s);

    function init() {
        try {
            init3D();
            setupEventListeners();
            generateDefaultFace();
            animate();
            
            console.log("3D Face Capture initialized successfully");
        } catch (error) {
            console.error('Initialization error:', error);
        }
    }

    function init3D() {
        try {
            // Initialize Three.js scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            cam.position.set(0, 2, 5);
            
            const canvas = $('#visualizationCanvas');
            ren = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                antialias: false, 
                powerPreference: "high-performance" 
            });
            ren.setSize(window.innerWidth, window.innerHeight);
            ren.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            
            clock = new THREE.Clock();

            // Lighting
            scene.add(new THREE.AmbientLight(0x003300));
            const dir = new THREE.DirectionalLight(0x00ff00, 0.4);
            dir.position.set(5, 10, 5);
            scene.add(dir);

            // Grid
            const gridSize = 20, gridDiv = 20;
            const gridMat = new THREE.LineBasicMaterial({ color: 0x004400 });
            const gridGeo = new THREE.BufferGeometry();
            const positions = [];
            for (let i = -gridSize / 2; i <= gridSize / 2; i += gridSize / gridDiv) {
                positions.push(i, 0, -gridSize / 2, i, 0, gridSize / 2);
                positions.push(-gridSize / 2, 0, i, gridSize / 2, 0, i);
            }
            gridGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            scene.add(new THREE.LineSegments(gridGeo, gridMat));

            // Face mesh placeholder
            faceMesh = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 2.0, 0.5), 
                new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.7
                })
            );
            faceMesh.position.set(0, 1.5, 0);
            scene.add(faceMesh);

            cam.lookAt(faceMesh.position);
            ren.render(scene, cam);
            
        } catch (error) {
            console.error('3D initialization error:', error);
            throw new Error(`3D setup failed: ${error.message}`);
        }
    }

    function generateFaceGeometry(width, height, depth) {
        const vertices = [];
        const normals = [];
        const faces = [];
        const landmarks = [];
        
        // Update dimensions
        geometryDataSchema.faceGeometry.dimensions = { width, height, depth };
        
        // Generate a simple face-like geometry (ellipsoid approximation)
        const segments = 12;
        const rings = 8;
        
        // Generate vertices for ellipsoid
        for (let ring = 0; ring <= rings; ring++) {
            const phi = (ring / rings) * Math.PI;
            for (let segment = 0; segment <= segments; segment++) {
                const theta = (segment / segments) * Math.PI * 2;
                
                const x = Math.sin(phi) * Math.cos(theta) * width/2;
                const y = Math.cos(phi) * height/2 + height/2;
                const z = Math.sin(phi) * Math.sin(theta) * depth/2;
                
                vertices.push(x, y, z);
                normals.push(Math.sin(phi) * Math.cos(theta), Math.cos(phi), Math.sin(phi) * Math.sin(theta));
                
                // Store as landmark
                landmarks.push({
                    x: x / (width/2),
                    y: (y - height/2) / (height/2),
                    z: z / (depth/2),
                    index: ring * (segments + 1) + segment
                });
            }
        }
        
        // Generate faces
        for (let ring = 0; ring < rings; ring++) {
            for (let segment = 0; segment < segments; segment++) {
                const a = ring * (segments + 1) + segment;
                const b = a + 1;
                const c = a + (segments + 1);
                const d = c + 1;
                
                faces.push(a, b, d);
                faces.push(a, d, c);
            }
        }
        
        return { vertices, normals, faces, landmarks };
    }

    function updateFaceGeometry(width, height, depth) {
        // Clear previous geometry
        if (faceMesh.geometry) faceMesh.geometry.dispose();
        
        // Generate new geometry
        const faceGeometry = generateFaceGeometry(width, height, depth);
        geometryDataSchema.faceGeometry = faceGeometry;
        
        // Update 3D mesh
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(faceGeometry.vertices, 3));
        geometry.setIndex(faceGeometry.faces);
        geometry.computeVertexNormals();
        
        faceMesh.geometry = geometry;
        
        // Update camera data
        geometryDataSchema.camera.position = {
            x: cam.position.x,
            y: cam.position.y,
            z: cam.position.z
        };
        geometryDataSchema.camera.rotation = {
            x: cam.rotation.x,
            y: cam.rotation.y,
            z: cam.rotation.z
        };
        
        updateStatusPanel();
        $('#hudWarning').style.display = 'none';
        $('#exportStatus').textContent = 'YES';
    }

    function generateDefaultFace() {
        const width = parseFloat($('#faceWidth').value) || 1.5;
        const height = parseFloat($('#faceHeight').value) || 2.0;
        const depth = parseFloat($('#faceDepth').value) || 0.5;
        
        updateFaceGeometry(width, height, depth);
    }

    function updateStatusPanel() {
        const vertices = geometryDataSchema.faceGeometry.vertices;
        $('#dataPointCount').textContent = vertices ? vertices.length / 3 : 0;
    }

    function exportGeometryData() {
        try {
            // Update timestamp
            geometryDataSchema.timestamp = new Date().toISOString();
            
            // Prepare data
            const exportData = JSON.parse(JSON.stringify(geometryDataSchema, (key, value) => {
                if (typeof value === 'string') {
                    return value.replace(/[<>"'&]/g, '');
                }
                if (typeof value === 'number' && !isFinite(value)) {
                    return 0;
                }
                return value;
            }));
            
            // Copy to clipboard
            navigator.clipboard.writeText(JSON.stringify(exportData, null, 2))
                .then(() => {
                    $('#calibStatus').textContent = 'DATA COPIED TO CLIPBOARD';
                    $('#exportBtn').classList.add('active');
                    
                    // Show success message
                    $('#exportSuccess').style.display = 'block';
                    setTimeout(() => {
                        $('#exportSuccess').style.display = 'none';
                        $('#exportBtn').classList.remove('active');
                    }, 2000);
                    
                    console.log("Face geometry data exported:", exportData);
                })
                .catch(error => {
                    console.error('Clipboard error:', error);
                    $('#calibStatus').textContent = 'EXPORT FAILED';
                });
                
        } catch (error) {
            console.error('Export error:', error);
            $('#calibStatus').textContent = 'EXPORT ERROR';
        }
    }

    function clearData() {
        // Reset to default face
        $('#faceWidth').value = 1.5;
        $('#faceHeight').value = 2.0;
        $('#faceDepth').value = 0.5;
        
        generateDefaultFace();
        $('#calibStatus').textContent = 'DATA CLEARED';
        $('#exportStatus').textContent = 'NO';
        
        setTimeout(() => {
            $('#calibStatus').textContent = 'READY FOR INPUT';
        }, 1000);
    }

    function openMirror() {
        $('#mirrorPopup').style.display = 'block';
        $('#mirrorBtn').classList.add('active');
    }

    function closeMirror() {
        $('#mirrorPopup').style.display = 'none';
        $('#mirrorBtn').classList.remove('active');
    }

    function centerView() {
        cam.position.set(0, 2, 5);
        cam.lookAt(faceMesh.position);
    }

    function setupEventListeners() {
        // Mirror button
        $('#mirrorBtn').addEventListener('click', () => {
            if ($('#mirrorPopup').style.display === 'block') {
                closeMirror();
            } else {
                openMirror();
            }
        });
        
        // Export button
        $('#exportBtn').addEventListener('click', exportGeometryData);
        
        // Clear button
        $('#clearBtn').addEventListener('click', clearData);
        
        // Update face button
        $('#updateFace').addEventListener('click', generateDefaultFace);
        
        // Mirror close button
        $('.mirror-close').addEventListener('click', closeMirror);
        
        // Scene click area
        $('#sceneClickArea').addEventListener('click', centerView);
        
        // Mirror dragging
        const mirrorHeader = $('.mirror-header');
        const mirrorPopup = $('#mirrorPopup');
        
        mirrorHeader.addEventListener('mousedown', startDrag);
        mirrorHeader.addEventListener('touchstart', startDrag);
        
        function startDrag(e) {
            e.preventDefault();
            mirrorDragging = true;
            
            const rect = mirrorPopup.getBoundingClientRect();
            if (e.type === 'mousedown') {
                mirrorOffset.x = e.clientX - rect.left;
                mirrorOffset.y = e.clientY - rect.top;
            } else if (e.type === 'touchstart') {
                mirrorOffset.x = e.touches[0].clientX - rect.left;
                mirrorOffset.y = e.touches[0].clientY - rect.top;
            }
            
            document.addEventListener('mousemove', dragMirror);
            document.addEventListener('touchmove', dragMirror);
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchend', stopDrag);
        }
        
        function dragMirror(e) {
            if (!mirrorDragging) return;
            e.preventDefault();
            
            let clientX, clientY;
            if (e.type === 'mousemove') {
                clientX = e.clientX;
                clientY = e.clientY;
            } else if (e.type === 'touchmove') {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            }
            
            mirrorPopup.style.left = (clientX - mirrorOffset.x) + 'px';
            mirrorPopup.style.top = (clientY - mirrorOffset.y) + 'px';
            mirrorPopup.style.transform = 'none';
        }
        
        function stopDrag() {
            mirrorDragging = false;
            document.removeEventListener('mousemove', dragMirror);
            document.removeEventListener('touchmove', dragMirror);
            document.removeEventListener('mouseup', stopDrag);
            document.removeEventListener('touchend', stopDrag);
        }
        
        // Window resize
        window.addEventListener('resize', () => {
            cam.aspect = window.innerWidth / window.innerHeight;
            cam.updateProjectionMatrix();
            ren.setSize(window.innerWidth, window.innerHeight);
        }, { passive: true });
        
        // Cleanup
        window.addEventListener('beforeunload', cleanup);
        
        console.log("Event listeners setup complete");
    }

    function cleanup() {
        if (animationId) {
            cancelAnimationFrame(animationId);
        }
        
        if (scene) {
            scene.traverse(object => {
                if (object.geometry) object.geometry.dispose();
                if (object.material) {
                    if (Array.isArray(object.material)) {
                        object.material.forEach(material => material.dispose());
                    } else {
                        object.material.dispose();
                    }
                }
            });
        }
    }

    function animate() {
        animationId = requestAnimationFrame(animate);
        const deltaTime = clock.getDelta();
        
        // Rotate face mesh slowly
        faceMesh.rotation.y += deltaTime * 0.5;
        
        // Render scene
        ren.render(scene, cam);
    }

    // Initialize Three.js and start the application
    // Inline minimal Three.js library (core components only)
    const THREE = (function() {
        // Minimal Three.js implementation for basic 3D rendering
        // This is a severely reduced version for demo purposes
        const THREE = {};
        
        // Vector3
        THREE.Vector3 = function(x, y, z) {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
        };
        
        THREE.Vector3.prototype.copy = function(v) {
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            return this;
        };
        
        // Color
        THREE.Color = function(color) {
            this.r = 1;
            this.g = 1;
            this.b = 1;
            if (color !== undefined) this.set(color);
        };
        
        THREE.Color.prototype.set = function(value) {
            if (typeof value === 'number') {
                this.r = value;
                this.g = value;
                this.b = value;
            }
            return this;
        };
        
        // BufferGeometry
        THREE.BufferGeometry = function() {
            this.attributes = {};
            this.index = null;
        };
        
        THREE.BufferGeometry.prototype.setAttribute = function(name, attribute) {
            this.attributes[name] = attribute;
            return this;
        };
        
        THREE.BufferGeometry.prototype.setIndex = function(index) {
            this.index = index;
            return this;
        };
        
        THREE.BufferGeometry.prototype.computeVertexNormals = function() {
            // Simplified normal calculation
            const position = this.attributes.position;
            if (position) {
                const normals = new Float32Array(position.count * 3);
                for (let i = 0; i < normals.length; i += 3) {
                    normals[i] = 0;
                    normals[i + 1] = 1;
                    normals[i + 2] = 0;
                }
                this.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
            }
        };
        
        // BufferAttribute
        THREE.BufferAttribute = function(array, itemSize) {
            this.array = array;
            this.itemSize = itemSize;
            this.count = array ? array.length / itemSize : 0;
        };
        
        THREE.Float32BufferAttribute = function(array, itemSize) {
            THREE.BufferAttribute.call(this, array, itemSize);
        };
        THREE.Float32BufferAttribute.prototype = Object.create(THREE.BufferAttribute.prototype);
        
        // Materials
        THREE.Material = function() {
            this.transparent = false;
            this.opacity = 1;
        };
        
        THREE.MeshBasicMaterial = function(parameters) {
            THREE.Material.call(this);
            parameters = parameters || {};
            this.color = parameters.color !== undefined ? new THREE.Color(parameters.color) : new THREE.Color(0xffffff);
            this.wireframe = parameters.wireframe !== undefined ? parameters.wireframe : false;
            this.transparent = parameters.transparent !== undefined ? parameters.transparent : false;
            this.opacity = parameters.opacity !== undefined ? parameters.opacity : 1;
        };
        THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);
        
        THREE.LineBasicMaterial = function(parameters) {
            THREE.Material.call(this);
            parameters = parameters || {};
            this.color = parameters.color !== undefined ? new THREE.Color(parameters.color) : new THREE.Color(0xffffff);
        };
        THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype);
        
        // Geometries
        THREE.BoxGeometry = function(width, height, depth) {
            THREE.BufferGeometry.call(this);
            
            width = width || 1;
            height = height || 1;
            depth = depth || 1;
            
            const vertices = [
                // Front face
                -width/2, -height/2, depth/2, width/2, -height/2, depth/2, width/2, height/2, depth/2, -width/2, height/2, depth/2,
                // Back face
                -width/2, -height/2, -depth/2, -width/2, height/2, -depth/2, width/2, height/2, -depth/2, width/2, -height/2, -depth/2,
                // Top face
                -width/2, height/2, -depth/2, -width/2, height/2, depth/2, width/2, height/2, depth/2, width/2, height/2, -depth/2,
                // Bottom face
                -width/2, -height/2, -depth/2, width/2, -height/2, -depth/2, width/2, -height/2, depth/2, -width/2, -height/2, depth/2,
                // Right face
                width/2, -height/2, -depth/2, width/2, height/2, -depth/2, width/2, height/2, depth/2, width/2, -height/2, depth/2,
                // Left face
                -width/2, -height/2, -depth/2, -width/2, -height/2, depth/2, -width/2, height/2, depth/2, -width/2, height/2, -depth/2
            ];
            
            const indices = [
                0, 1, 2, 0, 2, 3, // front
                4, 5, 6, 4, 6, 7, // back
                8, 9, 10, 8, 10, 11, // top
                12, 13, 14, 12, 14, 15, // bottom
                16, 17, 18, 16, 18, 19, // right
                20, 21, 22, 20, 22, 23  // left
            ];
            
            this.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            this.setIndex(indices);
            this.computeVertexNormals();
        };
        THREE.BoxGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
        
        // Objects
        THREE.Object3D = function() {
            this.position = new THREE.Vector3();
            this.rotation = new THREE.Vector3();
            this.scale = new THREE.Vector3(1, 1, 1);
            this.children = [];
        };
        
        THREE.Object3D.prototype.add = function(object) {
            this.children.push(object);
        };
        
        THREE.Mesh = function(geometry, material) {
            THREE.Object3D.call(this);
            this.geometry = geometry;
            this.material = material;
        };
        THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype);
        
        THREE.LineSegments = function(geometry, material) {
            THREE.Object3D.call(this);
            this.geometry = geometry;
            this.material = material;
        };
        THREE.LineSegments.prototype = Object.create(THREE.Object3D.prototype);
        
        // Scene
        THREE.Scene = function() {
            THREE.Object3D.call(this);
            this.background = null;
        };
        THREE.Scene.prototype = Object.create(THREE.Object3D.prototype);
        
        // Camera
        THREE.PerspectiveCamera = function(fov, aspect, near, far) {
            THREE.Object3D.call(this);
            this.fov = fov || 50;
            this.aspect = aspect || 1;
            this.near = near || 0.1;
            this.far = far || 2000;
            this.updateProjectionMatrix();
        };
        THREE.PerspectiveCamera.prototype = Object.create(THREE.Object3D.prototype);
        
        THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function() {
            // Simplified projection matrix calculation
        };
        
        THREE.PerspectiveCamera.prototype.lookAt = function(target) {
            // Simplified lookAt function
        };
        
        // Lights
        THREE.Light = function(color, intensity) {
            THREE.Object3D.call(this);
            this.color = new THREE.Color(color);
            this.intensity = intensity !== undefined ? intensity : 1;
        };
        THREE.Light.prototype = Object.create(THREE.Object3D.prototype);
        
        THREE.AmbientLight = function(color, intensity) {
            THREE.Light.call(this, color, intensity);
        };
        THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype);
        
        THREE.DirectionalLight = function(color, intensity) {
            THREE.Light.call(this, color, intensity);
        };
        THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype);
        
        // Renderer
        THREE.WebGLRenderer = function(parameters) {
            parameters = parameters || {};
            this.domElement = parameters.canvas || document.createElement('canvas');
            this.context = this.domElement.getContext('webgl') || this.domElement.getContext('experimental-webgl');
            this.pixelRatio = 1;
        };
        
        THREE.WebGLRenderer.prototype.setSize = function(width, height) {
            this.domElement.width = width * this.pixelRatio;
            this.domElement.height = height * this.pixelRatio;
            this.domElement.style.width = width + 'px';
            this.domElement.style.height = height + 'px';
        };
        
        THREE.WebGLRenderer.prototype.setPixelRatio = function(value) {
            this.pixelRatio = value;
        };
        
        THREE.WebGLRenderer.prototype.render = function(scene, camera) {
            // Simplified rendering - just clear the canvas
            const gl = this.context;
            if (gl) {
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            }
        };
        
        // Clock
        THREE.Clock = function() {
            this.startTime = Date.now();
            this.oldTime = this.startTime;
        };
        
        THREE.Clock.prototype.getDelta = function() {
            const newTime = Date.now();
            const delta = (newTime - this.oldTime) / 1000;
            this.oldTime = newTime;
            return Math.min(delta, 0.1); // Cap delta to avoid large jumps
        };
        
        return THREE;
    })();

    // Initialize the application
    window.addEventListener('load', init);
</script>
</body>
</html>
