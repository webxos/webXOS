<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>edTV: CHANNEL 10</title>
    <meta name="theme-color" content="#000000">
    <link rel="manifest" href="data:application/manifest+json,{%22name%22:%223D%20Data%20Capture%22,%22short_name%22:%223D%20Capture%22,%22description%22:%223D%20geometry%20data%20capture%20and%20export%22,%22start_url%22:%22./%22,%22display%22:%22fullscreen%22,%22background_color%22:%22%23000000%22,%22theme_color%22:%22%23000000%22,%22icons%22:[{%22src%22:%22data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkyIiBoZWlnaHQ9IjE5MiIgdmlld0JveD0iMCAwIDE5MiAxOTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI%2BCjxyZWN0IHdpZHRoPSIxOTIiIGhlaWdodD0iMTkyIiBmaWxsPSIjMDAwMDAwIi8%2BCjxwYXRoIGQ9Ik05NiAxMjhMMTI4IDk2SDY0TDEyOCA2NEw5NiAzMkw2NCA2NEgxMjhMNjQgOTZIMTI4TDk2IDEyOFoiIGZpbGw9IiMwMGZmMDAiLz4KPC9zdmc%2BCg%3D%3D%22,%22sizes%22:%22192x192%22,%22type%22:%22image/svg%2Bxml%22}]}">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js"></script>
    <script src="https://docs.opencv.org/4.5.0/opencv.js"></script>
    <style>
        *{margin:0;padding:0;box-sizing:border-box;font-family:'Press Start 2P',cursive;image-rendering:pixelated}
        body{background:#000;color:#0f0;overflow:hidden;height:100vh;user-select:none;-webkit-tap-highlight-color:transparent}
        #appContainer{position:relative;width:100%;height:100vh;overflow:hidden}
        .matrix-grid{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(rgba(0,255,0,0.1)1px,transparent 1px),linear-gradient(90deg,rgba(0,255,0,0.1)1px,transparent 1px);background-size:16px 16px;opacity:0.3}
        .crt-overlay{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(to bottom,transparent 50%,rgba(0,20,0,0.1)50%);background-size:100% 4px;z-index:5;pointer-events:none;animation:scanline 8s linear infinite}
        @keyframes scanline{0%{background-position:0 0}100%{background-position:0 100%}}
        #visualizationContainer{position:absolute;top:0;left:0;width:100%;height:100%;z-index:2}
      
        /* Top Banner */
        .top-banner {
            position: absolute;top: 0;left: 0;width: 100%;height: 40px;
            background: rgba(255, 0, 255, 0.9);border-bottom: 2px solid #f0f;
            display: flex;align-items: center;justify-content: center;
            z-index: 12;overflow: hidden;animation: glitch 3s infinite;
        }
        @keyframes glitch {
            0%,100%{transform:translateX(0)}5%{transform:translateX(-2px)}
            10%{transform:translateX(2px)}15%{transform:translateX(-1px)}
            20%{transform:translateX(1px)}25%{transform:translateX(0)}
            55%{transform:translateX(-1px) skewX(-2deg)}
            60%{transform:translateX(1px) skewX(2deg)}
            65%{transform:translateX(-1px) skewX(-1deg)}
            70%{transform:translateX(1px) skewX(1deg)}75%{transform:translateX(0)}
        }
        .top-banner-text {font-size:12px;color:#000;text-shadow:1px 1px 0 #fff;letter-spacing:1px}
      
        /* PiP AR Webcam (Top Right) */
        #pipAR {
            position: absolute;top: 50px;right: 10px;width: 140px;height: 105px;
            border: 2px solid #0ff;border-radius: 6px;overflow: hidden;
            z-index: 100;box-shadow: 0 0 15px rgba(0,255,255,0.6);
            background: #000;cursor: move;display: none;
        }
        #pipVideo {width:100%;height:100%;object-fit:cover;transform:scaleX(-1)}
        #pipCanvas {position:absolute;top:0;left:0;width:100%;height:100%;z-index:2}
      
        /* Status Panel (Top Left) */
        .status-panel {
            position: absolute;top: 50px;left: 10px;background: rgba(0,0,0,0.8);
            border: 2px solid #0ff;padding: 6px;font-size: 7px;color: #0ff;
            max-width: 160px;z-index: 11;line-height:1.4;
        }
      
        /* Red Error Log Terminal */
        #errorTerminal {
            position: absolute;bottom: 70px;left: 50%;transform: translateX(-50%);
            width: 90%;max-width: 500px;height: 120px;
            background: rgba(20,0,0,0.95);border: 2px solid #f00;
            color: #f00;font-family: monospace;font-size: 8px;
            padding: 6px;overflow-y: auto;z-index: 99;
            display: none;box-shadow: 0 0 20px rgba(255,0,0,0.6);
            border-radius: 4px;white-space: pre-wrap;
        }
        #errorTerminal.visible {display: block;}
        .error-line {margin: 2px 0;animation: blink 1s infinite;}
        @keyframes blink {0%,100%{opacity:1}50%{opacity:0.5}}
        #errorTerminal::before {
            content: "WEBCAM ERROR LOG";display: block;color: #ff0;
            font-weight: bold;margin-bottom: 4px;border-bottom: 1px solid #f00;padding-bottom: 2px;
        }
      
        /* Control Buttons (Bottom Center, Mobile-First) */
        .controls-container {
            position: absolute;bottom: 15px;left: 50%;transform: translateX(-50%);
            display: flex;gap: 8px;z-index: 11;flex-wrap: wrap;justify-content: center;
            padding: 0 10px;
        }
        .ctrl-btn{
            min-width: 100px;height: 48px;background:#000;border:3px solid #0ff;color:#0ff;
            font-size:9px;display:flex;align-items:center;justify-content:center;cursor:pointer;
            box-shadow:3px 3px 0 #000;transform:skew(-2deg);transition:0.15s;
            touch-action:none;flex: 1 1 90px;max-width: 140px;
        }
        .ctrl-btn:hover,.ctrl-btn:active,.ctrl-btn.active{background:#0ff;color:#000}
        .export-btn{border-color:#f0f;color:#f0f}
        .export-btn:hover,.export-btn:active{background:#f0f;color:#000}
        .calib-btn{border-color:#ff0;color:#ff0}
        .calib-btn:hover,.calib-btn:active{background:#ff0;color:#000}
      
        /* HUD Warning */
        #hudWarning{
            position:absolute;top:20%;left:50%;transform:translate(-50%,-50%);
            color:#f00;font-size:11px;text-shadow:1px 1px 0 #000;z-index:11;display:none
        }
      
        /* Mobile Optimization */
        @media (max-width:767px){
            .top-banner{height:36px}.top-banner-text{font-size:10px}
            #pipAR{top:44px;right:8px;width:120px;height:90px}
            .status-panel{top:44px;left:8px;font-size:6px;padding:5px;max-width:140px}
            .controls-container{bottom:10px;gap:6px}
            .ctrl-btn{height:44px;font-size:8px;min-width:80px}
            #errorTerminal{bottom: 60px;height: 100px;font-size: 7px;}
        }
        @media (max-height:500px){
            .controls-container{bottom:8px}
            .ctrl-btn{height:38px;font-size:7px}
            #errorTerminal{bottom: 50px;height: 80px;}
        }
    </style>
</head>
<body>
<div id="appContainer">
    <div class="matrix-grid"></div>
    <div class="crt-overlay"></div>
  
    <!-- Top Banner -->
    <div class="top-banner">
        <div class="top-banner-text">edTV: CHANNEL 10</div>
    </div>
  
    <!-- 3D SCENE -->
    <div id="visualizationContainer">
        <canvas id="visualizationCanvas"></canvas>
    </div>
  
    <!-- Status Panel -->
    <div class="status-panel">
        <div>OBJECTS: <span id="objectCount">0</span></div>
        <div>FACES: <span id="faceCount">0</span></div>
        <div>POINTS: <span id="dataPointCount">0</span></div>
    </div>
  
    <!-- PiP AR Webcam (Top Right) -->
    <div id="pipAR">
        <video id="pipVideo" autoplay playsinline></video>
        <canvas id="pipCanvas"></canvas>
    </div>
  
    <!-- Red Error Log Terminal -->
    <div id="errorTerminal"></div>
  
    <!-- Control Buttons -->
    <div class="controls-container">
        <button id="captureBtn" class="ctrl-btn">CAPTURE</button>
        <button id="exportBtn" class="ctrl-btn export-btn">EXPORT</button>
        <button id="clearBtn" class="ctrl-btn" style="border-color:#ff0;color:#ff0">CLEAR</button>
        <button id="calibBtn" class="ctrl-btn calib-btn">CALIBRATE</button>
    </div>
  
    <!-- HUD -->
    <div id="hudWarning">NO DATA CAPTURED</div>

    <!-- Hidden Video -->
    <video id="webcamVideo" style="display:none" autoplay playsinline></video>
</div>

<script>
    // === GLOBALS ===
    let scene, cam, ren, clock, controls;
    let userObj, objects = [], faceMeshObj;
    let faceDirection = 0, userDetected = false;
    let stream, faceMesh, camera, objectDetector;
    let isFrontCam = true;
    const user = new THREE.Vector3(0, 0, 0);
    let animationId = null;
    let pipDragging = false, pipOffset = { x: 0, y: 0 };
    let calibMode = false;

    const geometryDataSchema = {
        version: "1.0", timestamp: "", metadata: { app: "edTV_CHANNEL_10", captureType: "face_objects_3d", coordinateSystem: "right_handed" },
        faceGeometry: { vertices: [], normals: [], faces: [], landmarks: [] },
        environmentObjects: [], camera: { position: { x: 0, y: 0, z: 0 }, rotation: { x: 0, y: 0, z: 0 }, fov: 75 }
    };

    const $ = s => document.querySelector(s);
    const $$ = s => document.querySelectorAll(s);

    // === ERROR LOG SYSTEM ===
    const errorTerminal = $('#errorTerminal');
    let errorTimeout = null;

    function logError(message, type = 'ERROR') {
        const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false });
        const line = `[${timestamp}] ${type}: ${message}`;
        const span = document.createElement('div');
        span.className = 'error-line';
        span.textContent = line;
        errorTerminal.appendChild(span);
        errorTerminal.scrollTop = errorTerminal.scrollHeight;
        errorTerminal.classList.add('visible');

        // Auto-hide after 8 seconds
        if (errorTimeout) clearTimeout(errorTimeout);
        errorTimeout = setTimeout(() => {
            errorTerminal.classList.remove('visible');
            setTimeout(() => { errorTerminal.innerHTML = ''; }, 500);
        }, 8000);
    }

    function clearErrorLog() {
        errorTerminal.innerHTML = '';
        errorTerminal.classList.remove('visible');
        if (errorTimeout) clearTimeout(errorTimeout);
    }

    // === INIT ===
    async function init() {
        await initOpenCV();
        init3D();
        await setupFaceDetection();
        await setupObjectDetection();
        setupEventListeners();
        animate();
        console.log("edTV: CHANNEL 10 Ready");
    }

    function initOpenCV() {
        return new Promise(resolve => {
            if (typeof cv !== 'undefined') {
                cv.onRuntimeInitialized = () => { console.log("OpenCV Ready"); resolve(); };
            } else setTimeout(() => initOpenCV().then(resolve), 100);
        });
    }

    function init3D() {
        scene = new THREE.Scene(); scene.background = new THREE.Color(0x000000);
        cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        cam.position.set(0, 0, 5);

        const canvas = $('#visualizationCanvas');
        ren = new THREE.WebGLRenderer({ canvas, antialias: false, powerPreference: "high-performance" });
        ren.setSize(window.innerWidth, window.innerHeight);
        ren.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        clock = new THREE.Clock();

        scene.add(new THREE.AmbientLight(0x003300));
        const dir = new THREE.DirectionalLight(0x00ff00, 0.4); dir.position.set(5, 10, 5); scene.add(dir);

        const gridSize = 20, gridDiv = 20;
        const positions = [];
        for (let i = -gridSize / 2; i <= gridSize / 2; i += gridSize / gridDiv) {
            positions.push(i, 0, -gridSize / 2, i, 0, gridSize / 2);
            positions.push(-gridSize / 2, 0, i, gridSize / 2, 0, i);
        }
        const gridGeo = new THREE.BufferGeometry();
        gridGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        scene.add(new THREE.LineSegments(gridGeo, new THREE.LineBasicMaterial({ color: 0x004400 })));

        userObj = new THREE.Mesh(
            new THREE.SphereGeometry(0.1, 16, 16),
            new THREE.MeshBasicMaterial({ color: 0x00ffff })
        );
        userObj.position.copy(user); scene.add(userObj);

        const arrow = new THREE.Mesh(
            new THREE.ConeGeometry(0.1, 0.3, 8),
            new THREE.MeshBasicMaterial({ color: 0xff0000 })
        );
        arrow.position.set(0, 0.3, 0); arrow.rotation.x = Math.PI / 2;
        userObj.add(arrow);

        controls = new THREE.OrbitControls(cam, canvas);
        controls.target.set(0, 0, 0); controls.enableDamping = true; controls.dampingFactor = 0.05;
        controls.minDistance = 0.1; controls.maxDistance = 10;

        const faceGeo = new THREE.BufferGeometry();
        faceMeshObj = new THREE.Points(faceGeo, new THREE.PointsMaterial({ color: 0x00ff00, size: 0.05 }));
        scene.add(faceMeshObj);
    }

    async function setupFaceDetection() {
        const { FaceMesh, FACEMESH_TESSELATION } = window;
        faceMesh = new FaceMesh({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
        });
        faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        faceMesh.onResults(onFaceMeshResults);
        window.FACEMESH_TESSELATION = FACEMESH_TESSELATION;
    }

    async function setupObjectDetection() {
        const { cocoSsd } = window;
        objectDetector = await cocoSsd.load();
    }

    function onFaceMeshResults(results) {
        userDetected = results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0;
        const pipCanvas = $('#pipCanvas');
        const ctx = pipCanvas.getContext('2d');
        ctx.clearRect(0, 0, pipCanvas.width, pipCanvas.height);
        if (results.image) ctx.drawImage(results.image, 0, 0, pipCanvas.width, pipCanvas.height);

        if (userDetected) {
            const lm = results.multiFaceLandmarks[0];
            const { drawConnectors } = window;
            drawConnectors(ctx, lm, window.FACEMESH_TESSELATION, { color: '#0ff', lineWidth: 1 });

            geometryDataSchema.faceGeometry.landmarks = lm.map(p => ({ x: p.x, y: p.y, z: p.z }));

            const positions = [];
            lm.forEach(p => {
                positions.push((p.x - 0.5) * 4, (0.5 - p.y) * 4, -p.z * 8);
            });
            faceMeshObj.geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            faceMeshObj.geometry.attributes.position.needsUpdate = true;

            const left = lm[234], right = lm[454];
            faceDirection = Math.atan2(right.x - left.x, right.z - left.z) * 180 / Math.PI;
        }
        updateStatusPanel();
    }

    function onObjectDetectionResults(results) {
        if (!results.detections) return;
        results.detections.forEach(d => {
            if (d.score > 0.5) addDetectedObject(d, d.class);
        });
    }

    function addDetectedObject(detection, className) {
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * 5 + 2;
        const pos = new THREE.Vector3(Math.sin(angle) * distance, Math.random() * 2, Math.cos(angle) * distance);
        const geometry = className === 'person' ? new THREE.BoxGeometry(0.3, 0.6, 0.3) : new THREE.SphereGeometry(0.2, 8, 6);
        const obj = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color: 0xff00ff, wireframe: true }));
        obj.position.copy(pos); scene.add(obj); objects.push(obj);
        geometryDataSchema.environmentObjects.push({
            class: className, type: geometry.type,
            position: { x: pos.x, y: pos.y, z: pos.z }, parameters: geometry.parameters
        });
        updateStatusPanel();
    }

    function detectArUco(video) { if (!cv) return; }
    function detectSphere(video) { if (!cv) return; }

    function updateStatusPanel() {
        $('#objectCount').textContent = objects.length;
        $('#faceCount').textContent = userDetected ? 1 : 0;
        $('#dataPointCount').textContent = geometryDataSchema.faceGeometry.landmarks.length;
    }

    function setupEventListeners() {
        $('#captureBtn').onclick = () => {
            const pip = $('#pipAR');
            if (pip.style.display === 'block') {
                pip.style.display = 'none';
                if (stream) stream.getTracks().forEach(t => t.stop());
                if (camera) camera.stop();
                stream = null;
                clearErrorLog();
            } else {
                $('#pipAR').style.display = 'block';
                startWebcam();
            }
        };

        $('#exportBtn').onclick = () => {
            geometryDataSchema.timestamp = new Date().toISOString();
            geometryDataSchema.camera.position = { x: cam.position.x, y: cam.position.y, z: cam.position.z };
            geometryDataSchema.camera.rotation = { x: cam.rotation.x, y: cam.rotation.y, z: cam.rotation.z };
            const blob = new Blob([JSON.stringify(geometryDataSchema, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = 'edtv10_capture.json'; a.click();
            URL.revokeObjectURL(url);
            $('#hudWarning').style.display = objects.length === 0 ? 'block' : 'none';
        };

        $('#clearBtn').onclick = () => {
            objects.forEach(o => scene.remove(o)); objects = [];
            geometryDataSchema.environmentObjects = []; geometryDataSchema.faceGeometry.landmarks = [];
            faceMeshObj.geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(), 3));
            updateStatusPanel();
        };

        $('#calibBtn').onclick = () => {
            calibMode = !calibMode;
            $('#calibBtn').classList.toggle('active', calibMode);
            if (calibMode) {
                logError("CALIBRATION MODE ACTIVATED - REINITIALIZING CAMERA...", "INFO");
                if (stream) stream.getTracks().forEach(t => t.stop());
                if (camera) camera.stop();
                setTimeout(startWebcam, 500);
            } else {
                logError("CALIBRATION MODE DEACTIVATED", "INFO");
            }
        };

        // PiP Drag
        const pip = $('#pipAR');
        pip.onmousedown = pip.ontouchstart = e => {
            e.preventDefault(); pipDragging = true;
            const rect = pip.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            pipOffset.x = clientX - rect.left; pipOffset.y = clientY - rect.top;
        };
        document.onmousemove = document.ontouchmove = e => {
            if (!pipDragging) return; e.preventDefault();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            pip.style.right = 'auto'; pip.style.top = (clientY - pipOffset.y) + 'px';
            pip.style.left = (clientX - pipOffset.x) + 'px';
        };
        document.onmouseup = document.ontouchend = () => pipDragging = false;

        window.onresize = () => {
            cam.aspect = window.innerWidth / window.innerHeight;
            cam.updateProjectionMatrix(); ren.setSize(window.innerWidth, window.innerHeight);
        };
    }

    async function startWebcam() {
        if (stream) return;
        clearErrorLog();
        logError("INITIALIZING WEBCAM...", "INFO");

        try {
            const isMobile = /Mobi|Android|iPhone/i.test(navigator.userAgent);
            isFrontCam = isMobile;

            // Check permissions first
            const permission = await navigator.permissions.query({ name: 'camera' });
            if (permission.state === 'denied') {
                throw new Error('Camera access permanently denied');
            }

            stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: isFrontCam ? 'user' : 'environment', width: { ideal: 640 }, height: { ideal: 480 } }
            });

            const video = $('#webcamVideo'); video.srcObject = stream;
            const pipVideo = $('#pipVideo'); pipVideo.srcObject = stream;
            const pipCanvas = $('#pipCanvas'); pipCanvas.width = 140; pipCanvas.height = 105;

            const { Camera } = window;
            camera = new Camera(video, {
                onFrame: async () => {
                    try {
                        await faceMesh.send({ image: video });
                        const detections = await objectDetector.detect(video);
                        onObjectDetectionResults({ detections });
                        detectArUco(video); detectSphere(video);
                    } catch (err) {
                        logError(`FRAME PROCESSING ERROR: ${err.message}`, "WARNING");
                    }
                },
                width: 640, height: 480
            });
            camera.start();

            logError("WEBCAM READY - CALIBRATION COMPLETE", "SUCCESS");
        } catch (err) {
            console.error("Webcam error:", err);
            let msg = "UNKNOWN CAMERA ERROR";
            if (err.name === 'NotAllowedError') msg = "CAMERA ACCESS DENIED BY USER";
            else if (err.name === 'NotFoundError') msg = "NO CAMERA FOUND ON DEVICE";
            else if (err.name === 'NotSupportedError') msg = "CAMERA NOT SUPPORTED (HTTPS REQUIRED)";
            else if (err.name === 'OverconstrainedError') msg = "CAMERA CONSTRAINTS NOT MET";
            else if (err.message.includes('denied')) msg = "CAMERA PERMANENTLY BLOCKED";

            logError(msg, "CRITICAL");
            $('#pipAR').style.display = 'none';
        }
    }

    function animate() {
        animationId = requestAnimationFrame(animate);
        const delta = clock.getDelta();
        if (userObj.children[0]) userObj.children[0].rotation.y = -faceDirection * Math.PI / 180;
        objects.forEach((o, i) => {
            o.rotation.y += delta * 0.5;
            o.position.y += Math.sin(Date.now() * 0.001 + i) * 0.005;
        });
        controls.update(); ren.render(scene, cam);
    }

    window.onload = init;
</script>
</body>
</html>
