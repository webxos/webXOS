<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>webXOS: TOKEN FORGED ∞</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap" rel="stylesheet">
    <style>
        /* ========== 8-BIT RESET & BASE ========== */
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
            image-rendering: pixelated;
            font-family: 'VT323', monospace;
            text-shadow: 0 0 1px currentColor;
        }
        
        html, body { 
            height: 100vh; 
            overflow: hidden; 
            background: #000; 
            color: #0f0; 
            display: flex; 
            flex-direction: column;
            position: relative;
            font-size: 16px;
            letter-spacing: 0.5px;
        }
        
        /* ========== CRT SCREEN EFFECT ========== */
        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15) 0px,
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 9999;
        }
        
        body::after {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                linear-gradient(
                    rgba(0, 255, 0, 0.03) 50%,
                    transparent 50%
                ),
                linear-gradient(
                    90deg,
                    rgba(0, 255, 0, 0.03) 50%,
                    transparent 50%
                );
            background-size: 20px 20px;
            pointer-events: none;
            z-index: -1;
        }
        
        /* ========== HEADER ========== */
        header {
            padding: 10px;
            text-align: center;
            border-bottom: 2px solid #0f0;
            background: rgba(0, 20, 0, 0.8);
            z-index: 10;
            flex-shrink: 0;
        }
        
        h1 {
            font-family: 'Press Start 2P', monospace;
            font-size: 1.6rem;
            text-shadow: 0 0 5px #0f0;
            margin-bottom: 5px;
        }
        
        .header-info {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            margin-top: 5px;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .header-info span {
            white-space: nowrap;
        }
        
        /* ========== 4-AGENT VIAL DISPLAY ========== */
        #vial-status {
            height: 120px;
            margin: 10px;
            display: flex;
            gap: 8px;
            flex-shrink: 0;
        }
        
        .vial-container {
            flex: 1;
            background: rgba(0, 20, 0, 0.7);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 8px;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }
        
        .vial-container::before {
            content: "";
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                45deg,
                transparent 30%,
                rgba(0, 255, 0, 0.1) 50%,
                transparent 70%
            );
            animation: agent-scan 4s infinite linear;
        }
        
        @keyframes agent-scan {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .vial-header {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            margin-bottom: 5px;
            position: relative;
            z-index: 2;
        }
        
        .vial-name {
            font-family: 'Press Start 2P', monospace;
            font-weight: bold;
            font-size: 10px;
        }
        
        .vial-status {
            color: #0f0;
            font-size: 9px;
        }
        
        .vial-status.mining {
            color: #ff0;
            animation: pulse 1s infinite;
        }
        
        .metric-bar {
            height: 8px;
            background: #333;
            border: 1px solid #0f0;
            border-radius: 2px;
            margin: 3px 0;
            overflow: hidden;
            position: relative;
            z-index: 2;
        }
        
        .metric-fill {
            height: 100%;
            transition: width 0.3s;
        }
        
        .hash-fill {
            background: linear-gradient(90deg, #0f0, #0ff);
        }
        
        .progress-fill {
            background: linear-gradient(90deg, #ff0, #f80);
        }
        
        .vial-metrics {
            font-size: 0.6rem;
            margin-top: 5px;
            position: relative;
            z-index: 2;
        }
        
        /* ========== TERMINAL ========== */
        #terminal {
            flex: 1;
            margin: 0 10px 10px;
            background: rgba(0, 20, 0, 0.7);
            border: 2px solid #0f0;
            border-radius: 5px;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            min-height: 0;
        }
        
        #terminal-log {
            flex: 1;
            overflow-y: auto;
            padding-right: 5px;
        }
        
        #terminal-log p {
            margin: 5px 0;
            font-size: 0.8rem;
            line-height: 1.3;
        }
        
        #terminal-input {
            display: flex;
            margin-top: 10px;
            border-top: 1px solid #0f0;
            padding-top: 10px;
        }
        
        #prompt-input {
            flex: 1;
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 8px;
            font-size: 0.8rem;
            font-family: 'VT323', monospace;
        }
        
        #send-button {
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 8px 15px;
            margin-left: 5px;
            cursor: pointer;
            font-family: 'Press Start 2P', monospace;
            font-size: 0.7rem;
        }
        
        #send-button:hover {
            background: #0f0;
            color: #000;
        }
        
        /* ========== BUTTON GROUP ========== */
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 0 10px 10px;
            justify-content: center;
            flex-shrink: 0;
        }
        
        button {
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 8px 12px;
            font-size: 0.7rem;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.3s;
            font-family: 'Press Start 2P', monospace;
        }
        
        button:hover {
            background: #0f0;
            color: #000;
        }
        
        button.active {
            background: #0f0;
            color: #000;
        }
        
        /* ========== MINING INDICATOR ========== */
        .mining-indicator {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 20, 0, 0.8);
            border: 1px solid #0f0;
            padding: 5px 10px;
            font-size: 0.6rem;
            border-radius: 3px;
            display: flex;
            align-items: center;
            gap: 5px;
            display: none;
        }
        
        .mining-dot {
            width: 6px;
            height: 6px;
            background: #0f0;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }
        
        /* ========== TEXT COLORS ========== */
        .command { color: #0ff; }
        .success { color: #0f0; }
        .error { color: #f00; }
        .warning { color: #ff0; }
        .info { color: #0af; }
        .balance { color: #f0f; }
        .network { color: #ff8000; }
        .hash { color: #0f0; }
        .agent { color: #0ff; }
        .markdown { color: #8f8; }
        .bot { color: #0ff; font-style: italic; }
        .parameter { color: #0af; }
        .hash-earnings { color: #0f0; font-weight: bold; }
        
        /* ========== SCROLLBAR ========== */
        #terminal-log::-webkit-scrollbar {
            width: 8px;
        }
        
        #terminal-log::-webkit-scrollbar-track {
            background: rgba(0, 30, 0, 0.5);
        }
        
        #terminal-log::-webkit-scrollbar-thumb {
            background: #0f0;
            border-radius: 4px;
        }
        
        /* ========== ANIMATIONS ========== */
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        /* ========== RESPONSIVE ========== */
        @media (max-width: 768px) {
            #vial-status {
                flex-wrap: wrap;
                height: auto;
            }
            
            .vial-container {
                min-width: calc(50% - 4px);
            }
            
            .button-group {
                flex-wrap: wrap;
            }
            
            button {
                flex: 1;
                min-width: 120px;
            }
        }
        
        @media (max-width: 480px) {
            .header-info {
                flex-direction: column;
                align-items: center;
                gap: 5px;
            }
            
            .vial-container {
                min-width: 100%;
            }
            
            h1 {
                font-size: 1.2rem;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header>
        <h1>webXOS: TOKEN FORGED ∞</h1>
        <div class="header-info">
            <span>NET: <span id="network-status">AUTO-AUTH</span></span>
            <span>WALLET: <span id="wallet-address">0x...</span></span>
            <span>TOKENS: <span id="token-count">∞</span></span>
            <span>HASH/S: <span id="hash-rate">0</span></span>
            <span>AGENTS: <span id="agent-count">4/4</span></span>
        </div>
    </header>
    
    <!-- 4-Agent Vial Display -->
    <div id="vial-status">
        <!-- Vials will be populated here -->
    </div>
    
    <!-- Terminal -->
    <div id="terminal">
        <div id="terminal-log">
            <p>> webXOS: TOKEN FORGED v2.0 ∞</p>
            <p class="success">✓ System: AUTO-AUTHENTICATED</p>
            <p class="agent">[AGENT-A] Initialized: Sequential Network</p>
            <p class="agent">[AGENT-B] Initialized: Convolutional Network</p>
            <p class="agent">[AGENT-C] Initialized: Transformer Network</p>
            <p class="agent">[AGENT-D] Initialized: Modular Network</p>
            <p class="success">✓ 4-Agent System: READY</p>
            <p class="warning">! TOKEN SUPPLY: UNLIMITED ∞</p>
            <p class="bot">BOT: Type 'help' for commands or click buttons below</p>
        </div>
        <div id="terminal-input">
            <input type="text" id="prompt-input" placeholder="Enter command..." autofocus>
            <button id="send-button">EXECUTE</button>
        </div>
    </div>
    
    <!-- Button Group -->
    <div class="button-group">
        <button id="createButton">CREATE NETWORK</button>
        <button id="mineButton">START MINING</button>
        <button id="stopButton">STOP MINING</button>
        <button id="exportButton">EXPORT WALLET</button>
        <button id="importButton">IMPORT WALLET</button>
        <button id="balanceButton">SHOW BALANCE</button>
        <button id="agentsButton">SHOW AGENTS</button>
        <button id="clearButton">CLEAR TERMINAL</button>
        <button id="voidButton">VOID SESSION</button>
    </div>
    
    <!-- Mining Indicator -->
    <div class="mining-indicator" id="mining-indicator">
        <div class="mining-dot"></div>
        <span>MINING: <span id="mining-network">NONE</span></span>
    </div>
    
    <!-- Hidden File Input -->
    <input type="file" id="file-input" accept=".md,.txt" style="display: none;">

    <script>
        // ============================================
        // GLOBAL STATE & CONFIGURATION
        // ============================================
        
        const AGENT_TEMPLATES = [
            `# AGENT-A: Sequential
nn.Sequential(
    nn.Linear(128, 64),
    nn.ReLU(),
    nn.Linear(64, 32)
)`,
            `# AGENT-B: Convolutional
nn.Sequential(
    nn.Conv1d(1, 32, 3),
    nn.ReLU(),
    nn.Flatten(),
    nn.Linear(32 * 30, 64)
)`,
            `# AGENT-C: Transformer
nn.TransformerEncoder(
    nn.TransformerEncoderLayer(
        d_model=512,
        nhead=8
    ),
    num_layers=3
)`,
            `# AGENT-D: Modular
class ModularNet(nn.Module):
    def __init__(self):
        super().__init__()
        self.layer1 = nn.Linear(256, 128)
        self.layer2 = nn.Linear(128, 64)
        self.dropout = nn.Dropout(0.2)
    
    def forward(self, x):
        x = F.relu(self.layer1(x))
        x = self.dropout(x)
        return self.layer2(x)`
        ];
        
        let agents = [];
        let wallet = {
            address: null,
            balance: Infinity, // Unlimited supply
            tokens: Infinity, // Unlimited supply
            hashes: 0,
            networks: [],
            created: Date.now()
        };
        
        let miningActive = false;
        let currentNetwork = null;
        let hashRate = 0;
        let hashInterval = null;
        let hashesThisSecond = 0;
        let lastHashRateUpdate = Date.now();

        // ============================================
        // 4-AGENT SYSTEM (VIAIS)
        // ============================================
        
        class Agent {
            constructor(id, template) {
                this.id = id;
                this.name = `AGENT-${String.fromCharCode(65 + id)}`;
                this.template = template;
                this.hash = null;
                this.status = 'idle';
                this.hashRate = 0;
                this.hashesGenerated = 0;
                this.progress = 0;
                this.lastHashTime = Date.now();
                
                this.initialize();
            }
            
            async initialize() {
                this.hash = await this.generateHash(this.template);
                this.updateVialDisplay();
                this.log(`${this.name} initialized`, 'agent');
            }
            
            async generateHash(data) {
                const combined = this.template + data + Date.now() + Math.random();
                const encoder = new TextEncoder();
                const hashBuffer = await crypto.subtle.digest('SHA-256', encoder.encode(combined));
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                
                this.hashesGenerated++;
                this.status = 'mining';
                this.progress = (this.progress + 5) % 100;
                
                // Update hash rate
                const now = Date.now();
                if (now - this.lastHashTime >= 1000) {
                    this.hashRate = Math.round(this.hashesGenerated / ((now - this.lastHashTime) / 1000));
                    this.lastHashTime = now;
                }
                
                this.hash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                this.updateVialDisplay();
                
                return this.hash;
            }
            
            updateVialDisplay() {
                const vialIndex = this.id;
                const vial = document.querySelector(`.vial-container[data-vial-id="${vialIndex}"]`);
                if (!vial) return;
                
                const nameEl = vial.querySelector('.vial-name');
                const statusEl = vial.querySelector('.vial-status');
                const hashBar = vial.querySelector('.hash-fill');
                const progressBar = vial.querySelector('.progress-fill');
                const metricsEl = vial.querySelector('.vial-metrics');
                
                if (nameEl) nameEl.textContent = this.name;
                if (statusEl) {
                    statusEl.textContent = this.status.toUpperCase();
                    statusEl.className = `vial-status ${this.status === 'mining' ? 'mining' : ''}`;
                }
                if (hashBar) {
                    hashBar.style.width = `${Math.min(this.hashRate * 2, 100)}%`;
                }
                if (progressBar) {
                    progressBar.style.width = `${this.progress}%`;
                }
                if (metricsEl) {
                    metricsEl.innerHTML = `
                        HASH: ${Math.round(this.hashRate)}<br>
                        MINED: ${this.hashesGenerated}<br>
                        TOKENS: ∞
                    `;
                }
            }
            
            log(message, type = '') {
                logEvent(`[${this.name}] ${message}`, type);
            }
        }
        
        // ============================================
        // TERMINAL FUNCTIONS
        // ============================================
        
        function logEvent(message, type = '') {
            const log = document.getElementById('terminal-log');
            const p = document.createElement('p');
            p.textContent = message;
            if (type) p.className = type;
            log.appendChild(p);
            // Auto-scroll to bottom
            log.scrollTop = log.scrollHeight;
        }
        
        function clearTerminal() {
            document.getElementById('terminal-log').innerHTML = '';
            logEvent('Terminal cleared', 'info');
        }
        
        // ============================================
        // WALLET FUNCTIONS
        // ============================================
        
        function generateAddress() {
            const bytes = crypto.getRandomValues(new Uint8Array(20));
            return '0x' + Array.from(bytes)
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }
        
        function updateWalletDisplay() {
            document.getElementById('wallet-address').textContent = 
                wallet.address ? `${wallet.address.substring(0, 8)}...` : '0x...';
            document.getElementById('token-count').textContent = '∞';
            document.getElementById('hash-rate').textContent = hashRate;
            document.getElementById('agent-count').textContent = '4/4';
        }
        
        // ============================================
        // NETWORK FUNCTIONS
        // ============================================
        
        async function createNetwork() {
            const name = prompt("Enter network name:");
            if (!name) return;
            
            const network = {
                id: generateId(),
                name: name,
                symbol: name.substring(0, 4).toUpperCase(),
                created: Date.now(),
                creator: wallet.address,
                genesisHash: await generateGenesisHash(name),
                agentHashes: [],
                tokens: Infinity // Unlimited supply
            };
            
            // Generate agent hashes for this network
            const agentPromises = agents.map(agent =>
                agent.generateHash(`NETWORK-${name}`)
            );
            
            const agentHashes = await Promise.all(agentPromises);
            network.agentHashes = agentHashes;
            
            wallet.networks.push(network);
            currentNetwork = network.id;
            
            logEvent(`Network "${name}" created!`, 'success');
            logEvent(`Symbol: ${network.symbol}`, 'network');
            logEvent(`Genesis Hash: ${network.genesisHash.substring(0, 32)}...`, 'hash');
            logEvent(`Agent validation: 4/4`, 'agent');
            logEvent(`Token Supply: UNLIMITED ∞`, 'warning');
            
            saveToLocalStorage();
            return network;
        }
        
        async function generateGenesisHash(name) {
            const encoder = new TextEncoder();
            const data = `${name}-${Date.now()}-${wallet.address}`;
            const hash = await crypto.subtle.digest('SHA-256', encoder.encode(data));
            const hashArray = Array.from(new Uint8Array(hash));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }
        
        // ============================================
        // MINING FUNCTIONS
        // ============================================
        
        async function startMining() {
            if (miningActive) {
                logEvent('Mining already active', 'warning');
                return;
            }
            
            if (!currentNetwork) {
                logEvent('No active network. Create one first.', 'error');
                return;
            }
            
            miningActive = true;
            document.getElementById('mining-indicator').style.display = 'flex';
            
            const network = wallet.networks.find(n => n.id === currentNetwork);
            if (network) {
                document.getElementById('mining-network').textContent = network.name;
            }
            
            logEvent('Starting 4-agent mining...', 'info');
            logEvent('Each agent generating hashes...', 'agent');
            logEvent('Tokens: UNLIMITED ∞', 'warning');
            
            hashesThisSecond = 0;
            lastHashRateUpdate = Date.now();
            
            hashInterval = setInterval(async () => {
                if (!miningActive) return;
                
                try {
                    // Each agent generates a hash
                    const miningData = `MINING-${Date.now()}-${Math.random()}`;
                    await Promise.all(agents.map(agent => 
                        agent.generateHash(miningData)
                    ));
                    
                    // Unlimited tokens - no increment needed
                    wallet.hashes++;
                    hashesThisSecond++;
                    
                    // Update hash rate every second
                    const now = Date.now();
                    if (now - lastHashRateUpdate >= 1000) {
                        hashRate = Math.round((hashesThisSecond * 1000) / (now - lastHashRateUpdate));
                        hashesThisSecond = 0;
                        lastHashRateUpdate = now;
                        updateWalletDisplay();
                        
                        // Show mining status
                        document.getElementById('hash-rate').textContent = hashRate;
                    }
                    
                    // Log every 10 hashes
                    if (wallet.hashes % 10 === 0) {
                        logEvent(`Mined ${wallet.hashes} hashes | Tokens: ∞`, 'hash-earnings');
                    }
                    
                    saveToLocalStorage();
                    
                } catch (error) {
                    console.error('Mining error:', error);
                    logEvent(`Mining error: ${error.message}`, 'error');
                }
            }, 100);
        }
        
        function stopMining() {
            miningActive = false;
            if (hashInterval) {
                clearInterval(hashInterval);
                hashInterval = null;
            }
            
            agents.forEach(agent => {
                agent.status = 'idle';
                agent.updateVialDisplay();
            });
            
            document.getElementById('mining-indicator').style.display = 'none';
            logEvent('Mining stopped', 'warning');
            logEvent(`Total hashes: ${wallet.hashes}`, 'info');
            logEvent(`Total tokens: ∞`, 'balance');
            
            // Reset hash rate
            hashRate = 0;
            updateWalletDisplay();
        }
        
        // ============================================
        // MARKDOWN WALLET FORMAT
        // ============================================
        
        function exportWallet() {
            const markdown = generateMarkdownWallet();
            
            // Create download
            const blob = new Blob([markdown], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `webxos_wallet_${Date.now()}.md`;
            a.click();
            URL.revokeObjectURL(url);
            
            logEvent('Wallet exported as webXOS Markdown', 'markdown');
            logEvent(`Saved as: ${a.download}`, 'info');
            logEvent('Import this .md file to restore wallet and agents', 'bot');
        }
        
        function generateMarkdownWallet() {
            let md = `# webXOS: TOKEN FORGED WALLET ∞\n\n`;
            md += `## WALLET INFORMATION\n`;
            md += `- Address: ${wallet.address}\n`;
            md += `- Created: ${new Date(wallet.created).toISOString()}\n`;
            md += `- Balance: ∞ tokens (UNLIMITED SUPPLY)\n`;
            md += `- Total Hashes: ${wallet.hashes}\n`;
            md += `- Networks: ${wallet.networks.length}\n\n`;
            
            md += `## 4-AGENT SYSTEM (PyTorch Networks)\n`;
            agents.forEach((agent, i) => {
                md += `### ${agent.name}\n`;
                md += `- Status: ${agent.status}\n`;
                md += `- Hashes Generated: ${agent.hashesGenerated}\n`;
                md += `- Current Hash: ${agent.hash}\n`;
                md += `- PyTorch Template:\n\`\`\`python\n${agent.template}\n\`\`\`\n\n`;
            });
            
            md += `## NETWORKS\n`;
            wallet.networks.forEach((network, i) => {
                md += `### Network: ${network.name}\n`;
                md += `- Symbol: ${network.symbol}\n`;
                md += `- Created: ${new Date(network.created).toISOString()}\n`;
                md += `- Genesis Hash: ${network.genesisHash}\n`;
                md += `- Creator: ${network.creator}\n`;
                md += `- Token Supply: UNLIMITED ∞\n`;
                if (network.agentHashes && network.agentHashes.length > 0) {
                    md += `- Agent Validation: ${network.agentHashes.length}/4\n`;
                }
                md += `\n`;
            });
            
            md += `## SYSTEM INFO\n`;
            md += `- App: webXOS: TOKEN FORGED v2.0\n`;
            md += `- Tokens: UNLIMITED ∞\n`;
            md += `- Agents: 4 PyTorch Networks\n`;
            md += `- Export Date: ${new Date().toISOString()}\n\n`;
            
            md += `## IMPORT INSTRUCTIONS\n`;
            md += `1. Load this .md file in webXOS: TOKEN FORGED\n`;
            md += `2. System will restore wallet and all 4 agents\n`;
            md += `3. Continue mining with unlimited tokens\n`;
            md += `4. Token supply remains unlimited (∞)\n`;
            
            return md;
        }
        
        function importWallet() {
            document.getElementById('file-input').click();
        }
        
        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            logEvent(`Importing ${file.name}...`, 'command');
            
            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const content = e.target.result;
                    await parseMarkdownWallet(content);
                    logEvent('Wallet imported successfully', 'success');
                    logEvent(`Networks restored: ${wallet.networks.length}`, 'network');
                    logEvent('4-Agent system restored', 'agent');
                    logEvent('Token Supply: UNLIMITED ∞', 'warning');
                    
                    // Update agents with imported data
                    updateVialDisplay();
                    saveToLocalStorage();
                    
                    // Auto-start mining if there are networks
                    if (wallet.networks.length > 0 && !currentNetwork) {
                        currentNetwork = wallet.networks[0].id;
                        logEvent(`Auto-selected network: ${wallet.networks[0].name}`, 'network');
                    }
                    
                } catch (error) {
                    logEvent(`Import failed: ${error.message}`, 'error');
                }
            };
            reader.readAsText(file);
        }
        
        async function parseMarkdownWallet(markdown) {
            const lines = markdown.split('\n');
            let inAgent = false;
            let currentAgent = null;
            let agentData = [];
            let networkName = null;
            
            for (let line of lines) {
                line = line.trim();
                
                if (line.startsWith('- Address:')) {
                    wallet.address = line.split(':')[1].trim();
                } else if (line.startsWith('- Total Hashes:')) {
                    wallet.hashes = parseInt(line.split(':')[1].trim()) || 0;
                } else if (line.startsWith('### Network:')) {
                    networkName = line.split(':')[1].trim();
                } else if (networkName && line.startsWith('- Genesis Hash:')) {
                    const genesisHash = line.split(':')[1].trim();
                    const network = {
                        id: generateId(),
                        name: networkName,
                        symbol: networkName.substring(0, 4).toUpperCase(),
                        created: Date.now(),
                        creator: wallet.address,
                        genesisHash: genesisHash,
                        tokens: Infinity,
                        agentHashes: []
                    };
                    wallet.networks.push(network);
                    networkName = null;
                } else if (line.startsWith('### AGENT-')) {
                    inAgent = true;
                    currentAgent = {
                        name: line.substring(4),
                        template: ''
                    };
                } else if (line.startsWith('```python')) {
                    // Skip
                } else if (line.startsWith('```')) {
                    if (currentAgent) {
                        agentData.push(currentAgent);
                        currentAgent = null;
                    }
                    inAgent = false;
                } else if (inAgent && currentAgent) {
                    currentAgent.template += line + '\n';
                }
            }
            
            // Update agents with imported templates
            if (agentData.length >= 4) {
                for (let i = 0; i < 4; i++) {
                    if (agents[i] && agentData[i]) {
                        agents[i].template = agentData[i].template.trim();
                        agents[i].hash = await agents[i].generateHash('IMPORTED');
                    }
                }
            }
            
            updateWalletDisplay();
            logEvent(`Wallet address: ${wallet.address}`, 'balance');
        }
        
        // ============================================
        // UI FUNCTIONS
        // ============================================
        
        function showBalance() {
            logEvent(`=== WALLET BALANCE ===`, 'command');
            logEvent(`Address: ${wallet.address}`, 'balance');
            logEvent(`Tokens: ∞ (UNLIMITED SUPPLY)`, 'balance');
            logEvent(`Hashes: ${wallet.hashes}`, 'hash');
            logEvent(`Networks: ${wallet.networks.length}`, 'network');
            logEvent(`Active Network: ${currentNetwork ? 'YES' : 'NONE'}`, 'network');
            logEvent(`Mining: ${miningActive ? 'ACTIVE' : 'INACTIVE'}`, miningActive ? 'success' : 'warning');
        }
        
        function showAgents() {
            logEvent(`=== 4-AGENT SYSTEM ===`, 'command');
            agents.forEach(agent => {
                logEvent(`${agent.name}:`, 'agent');
                logEvent(`  Status: ${agent.status}`, agent.status === 'mining' ? 'warning' : 'info');
                logEvent(`  Hashes: ${agent.hashesGenerated}`, 'hash');
                logEvent(`  Rate: ${agent.hashRate}/s`, 'hash');
                logEvent(`  Current: ${agent.hash ? agent.hash.substring(0, 16) + '...' : 'N/A'}`, 'info');
            });
            logEvent(`Total agent hashes: ${agents.reduce((sum, a) => sum + a.hashesGenerated, 0)}`, 'hash-earnings');
        }
        
        function updateVialDisplay() {
            const vialStatus = document.getElementById('vial-status');
            vialStatus.innerHTML = '';
            
            agents.forEach((agent, index) => {
                const vial = document.createElement('div');
                vial.className = 'vial-container';
                vial.setAttribute('data-vial-id', index);
                vial.innerHTML = `
                    <div class="vial-header">
                        <span class="vial-name">${agent.name}</span>
                        <span class="vial-status ${agent.status === 'mining' ? 'mining' : ''}">${agent.status.toUpperCase()}</span>
                    </div>
                    <div class="metric-bar">
                        <div class="metric-fill hash-fill" style="width: 0%"></div>
                    </div>
                    <div class="metric-bar">
                        <div class="metric-fill progress-fill" style="width: 0%"></div>
                    </div>
                    <div class="vial-metrics">
                        HASH: 0<br>
                        MINED: 0<br>
                        TOKENS: ∞
                    </div>
                `;
                vialStatus.appendChild(vial);
                
                // Update with current data
                agent.updateVialDisplay();
            });
        }
        
        // ============================================
        // COMMAND SYSTEM
        // ============================================
        
        function executeCommand() {
            const input = document.getElementById('prompt-input');
            const command = input.value.trim();
            
            if (!command) return;
            
            logEvent(`> ${command}`, 'command');
            input.value = '';
            
            const parts = command.split(' ');
            const action = parts[0].toLowerCase();
            const args = parts.slice(1);
            
            switch (action) {
                case 'help':
                    showHelp();
                    break;
                    
                case 'create':
                    createNetwork();
                    break;
                    
                case 'mine':
                case 'start':
                    startMining();
                    break;
                    
                case 'stop':
                    stopMining();
                    break;
                    
                case 'export':
                    exportWallet();
                    break;
                    
                case 'import':
                    importWallet();
                    break;
                    
                case 'balance':
                    showBalance();
                    break;
                    
                case 'agents':
                    showAgents();
                    break;
                    
                case 'clear':
                    clearTerminal();
                    break;
                    
                case 'networks':
                    showNetworks();
                    break;
                    
                case 'void':
                    voidSession();
                    break;
                    
                case 'status':
                    showStatus();
                    break;
                    
                default:
                    logEvent(`Unknown command: ${action}`, 'error');
                    logEvent("Type 'help' for commands", 'info');
            }
            
            // Keep input focused
            input.focus();
        }
        
        function showHelp() {
            logEvent(`=== webXOS: TOKEN FORGED ∞ ===`, 'command');
            logEvent(`create - Create new network (unlimited tokens)`, 'info');
            logEvent(`mine/start - Start 4-agent mining`, 'info');
            logEvent(`stop - Stop mining`, 'info');
            logEvent(`export - Export markdown wallet`, 'info');
            logEvent(`import - Import markdown wallet`, 'info');
            logEvent(`balance - Show wallet info`, 'info');
            logEvent(`agents - Show agent status`, 'info');
            logEvent(`networks - List networks`, 'info');
            logEvent(`status - Show system status`, 'info');
            logEvent(`clear - Clear terminal`, 'info');
            logEvent(`void - Clear all data`, 'info');
            logEvent(`help - Show this help`, 'info');
        }
        
        function showNetworks() {
            if (wallet.networks.length === 0) {
                logEvent('No networks created', 'info');
                return;
            }
            
            logEvent(`=== NETWORKS (${wallet.networks.length}) ===`, 'command');
            wallet.networks.forEach((network, i) => {
                const isActive = currentNetwork === network.id;
                logEvent(`${i + 1}. ${network.name} ${isActive ? '[ACTIVE]' : ''}`, 'network');
                logEvent(`   Symbol: ${network.symbol}`, 'parameter');
                logEvent(`   Created: ${new Date(network.created).toLocaleDateString()}`, 'info');
                logEvent(`   Genesis: ${network.genesisHash.substring(0, 16)}...`, 'hash');
                logEvent(`   Tokens: UNLIMITED ∞`, 'warning');
            });
        }
        
        function showStatus() {
            logEvent(`=== SYSTEM STATUS ===`, 'command');
            logEvent(`Wallet: ${wallet.address.substring(0, 8)}...`, 'balance');
            logEvent(`Tokens: ∞`, 'balance');
            logEvent(`Hashes: ${wallet.hashes}`, 'hash');
            logEvent(`Hash Rate: ${hashRate}/s`, 'hash');
            logEvent(`Mining: ${miningActive ? 'ACTIVE' : 'INACTIVE'}`, miningActive ? 'success' : 'warning');
            logEvent(`Networks: ${wallet.networks.length}`, 'network');
            logEvent(`Agents: 4/4 ${agents.every(a => a.status === 'ready') ? 'READY' : 'ACTIVE'}`, 'agent');
            logEvent(`Token Supply: UNLIMITED ∞`, 'warning');
        }
        
        function voidSession() {
            if (!confirm('VOID will clear ALL data. Continue?')) return;
            
            wallet = {
                address: generateAddress(),
                balance: Infinity,
                tokens: Infinity,
                hashes: 0,
                networks: [],
                created: Date.now()
            };
            
            currentNetwork = null;
            miningActive = false;
            hashRate = 0;
            
            if (hashInterval) {
                clearInterval(hashInterval);
                hashInterval = null;
            }
            
            // Reinitialize agents
            agents.forEach(agent => {
                agent.status = 'idle';
                agent.hashesGenerated = 0;
                agent.hashRate = 0;
                agent.progress = 0;
                agent.hash = null;
                agent.initialize();
            });
            
            document.getElementById('mining-indicator').style.display = 'none';
            
            localStorage.removeItem('tokenforged_wallet');
            
            updateWalletDisplay();
            updateVialDisplay();
            
            logEvent('Session voided. New wallet generated.', 'warning');
            logEvent(`Address: ${wallet.address}`, 'balance');
            logEvent('Tokens: ∞ (UNLIMITED SUPPLY)', 'balance');
            logEvent('4-Agent system reinitialized', 'agent');
        }
        
        // ============================================
        // UTILITY FUNCTIONS
        // ============================================
        
        function generateId() {
            const bytes = crypto.getRandomValues(new Uint8Array(16));
            return Array.from(bytes)
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }
        
        function saveToLocalStorage() {
            try {
                const data = {
                    wallet: wallet,
                    agents: agents.map(a => ({
                        id: a.id,
                        name: a.name,
                        template: a.template,
                        hash: a.hash,
                        status: a.status,
                        hashRate: a.hashRate,
                        hashesGenerated: a.hashesGenerated,
                        progress: a.progress
                    })),
                    currentNetwork: currentNetwork,
                    timestamp: Date.now()
                };
                localStorage.setItem('tokenforged_wallet', JSON.stringify(data));
            } catch (error) {
                console.error('Save error:', error);
            }
        }
        
        function loadFromLocalStorage() {
            try {
                const saved = localStorage.getItem('tokenforged_wallet');
                if (!saved) return;
                
                const data = JSON.parse(saved);
                
                if (data.wallet) {
                    wallet = { ...wallet, ...data.wallet };
                    // Ensure unlimited supply
                    wallet.balance = Infinity;
                    wallet.tokens = Infinity;
                }
                
                if (data.currentNetwork) {
                    currentNetwork = data.currentNetwork;
                }
                
                // Update agents with saved data
                if (data.agents && data.agents.length >= 4) {
                    data.agents.forEach((savedAgent, i) => {
                        if (agents[i]) {
                            agents[i].hash = savedAgent.hash || agents[i].hash;
                            agents[i].status = savedAgent.status || agents[i].status;
                            agents[i].hashesGenerated = savedAgent.hashesGenerated || 0;
                            agents[i].hashRate = savedAgent.hashRate || 0;
                            agents[i].progress = savedAgent.progress || 0;
                        }
                    });
                }
                
                updateWalletDisplay();
                updateVialDisplay();
                
            } catch (error) {
                console.error('Load error:', error);
            }
        }
        
        // ============================================
        // INITIALIZATION
        // ============================================
        
        async function initialize() {
            // Initialize wallet
            wallet.address = generateAddress();
            
            // Initialize 4 agents
            for (let i = 0; i < 4; i++) {
                const agent = new Agent(i, AGENT_TEMPLATES[i]);
                agents.push(agent);
            }
            
            // Wait for agents to initialize
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Load saved data
            loadFromLocalStorage();
            
            // Update UI
            updateWalletDisplay();
            updateVialDisplay();
            
            // Set up event listeners
            const promptInput = document.getElementById('prompt-input');
            promptInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    executeCommand();
                }
            });
            
            // Button event listeners
            document.getElementById('createButton').addEventListener('click', createNetwork);
            document.getElementById('mineButton').addEventListener('click', startMining);
            document.getElementById('stopButton').addEventListener('click', stopMining);
            document.getElementById('exportButton').addEventListener('click', exportWallet);
            document.getElementById('importButton').addEventListener('click', importWallet);
            document.getElementById('balanceButton').addEventListener('click', showBalance);
            document.getElementById('agentsButton').addEventListener('click', showAgents);
            document.getElementById('clearButton').addEventListener('click', clearTerminal);
            document.getElementById('voidButton').addEventListener('click', voidSession);
            document.getElementById('send-button').addEventListener('click', executeCommand);
            
            document.getElementById('file-input').addEventListener('change', handleFileImport);
            
            // Prevent scrolling on the whole page
            document.addEventListener('touchmove', (e) => {
                e.preventDefault();
            }, { passive: false });
            
            // Auto-scroll log to bottom
            const log = document.getElementById('terminal-log');
            const scrollToBottom = () => {
                log.scrollTop = log.scrollHeight;
            };
            
            // Scroll on new content
            const observer = new MutationObserver(scrollToBottom);
            observer.observe(log, { childList: true, subtree: true });
            
            // Focus input
            promptInput.focus();
            
            logEvent('webXOS: TOKEN FORGED initialized', 'success');
            logEvent(`Wallet: ${wallet.address}`, 'balance');
            logEvent('Token Supply: UNLIMITED ∞', 'warning');
            logEvent('4 PyTorch agents ready for mining', 'agent');
            logEvent('Ready for unlimited token forging', 'info');
        }
        
        // ============================================
        // START APPLICATION
        // ============================================
        
        window.addEventListener('load', initialize);
    </script>
</body>
</html>