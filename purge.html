<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRIOS: PURGE... BETA TEST</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', Courier, monospace;
        }
        
        #gameCanvas {
            image-rendering: pixelated;
        }
        
        body {
            background: #000;
            color: #0f0;
            overflow: hidden;
            height: 100vh;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }
        
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        /* Menu Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            background: #000;
            color: #0f0;
            text-align: center;
        }
        
        #endGameScreen {
            display: none;
            z-index: 200;
            background: rgba(0, 0, 0, 0.9);
        }
        
        .end-game-stats {
            background: rgba(0, 20, 0, 0.8);
            border: 3px solid #0f0;
            padding: 30px;
            border-radius: 10px;
            max-width: 600px;
            width: 90%;
        }
        
        .end-game-title {
            font-size: 28px;
            color: #0f0;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #0f0;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-size: 14px;
            color: #0f0;
        }
        
        .stat-label {
            text-align: left;
        }
        
        .stat-value {
            text-align: right;
            color: #ff0;
        }
        
        .final-score {
            font-size: 24px;
            color: #ff0;
            margin: 20px 0;
            text-shadow: 0 0 10px #ff0;
        }
        
        #webxosIntro {
            background: #000;
        }
        
        #bootSequence {
            background: #000;
        }
        
        #storyScroll {
            background: #000;
            overflow: hidden;
            perspective: 400px;
        }
        
        #mainMenu {
            background: #000;
        }
        
        /* Skip Button */
        .skip-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 8px 16px;
            background: #000;
            border: 2px solid #0f0;
            color: #0f0;
            font-size: 10px;
            cursor: pointer;
            z-index: 101;
        }
        
        .skip-btn:hover {
            background: #0f0;
            color: #000;
        }
        
        /* WEBXOS Intro */
        .webxos-title {
            font-size: 60px;
            color: #fff;
            text-shadow: 0 0 10px #fff, 0 0 20px #fff;
            margin-bottom: 20px;
            animation: glow 2s infinite alternate;
        }
        
        .webxos-subtitle {
            font-size: 18px;
            color: #0f0;
            margin-bottom: 10px;
        }
        
        .webxos-copyright {
            font-size: 12px;
            color: #0f0;
            position: absolute;
            bottom: 60px;
        }
        
        /* Boot Sequence */
        .boot-title {
            font-size: 48px;
            color: #0f0;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #0f0;
        }
        
        .boot-subtitle {
            font-size: 24px;
            color: #f00;
            margin-bottom: 30px;
            text-shadow: 0 0 10px #f00;
        }
        
        .boot-progress {
            width: 400px;
            height: 20px;
            background: #000;
            border: 2px solid #0f0;
            margin: 20px 0;
            overflow: hidden;
        }
        
        .boot-progress-fill {
            height: 100%;
            background: #0f0;
            width: 0%;
            transition: width 0.5s;
        }
        
        .boot-text {
            font-size: 14px;
            color: #0f0;
            margin-top: 20px;
            height: 20px;
        }
        
        /* Story Scroll */
        .story-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: rotateX(30deg) translateY(100%);
            animation: scroll 60s linear forwards;
        }
        
        .story-content {
            width: 80%;
            max-width: 800px;
            margin: 0 auto;
            color: #ff0;
            font-size: 24px;
            line-height: 1.5;
            text-align: justify;
        }
        
        .story-title {
            font-size: 36px;
            text-align: center;
            margin-bottom: 40px;
            color: #0f0;
        }
        
        /* Main Menu */
        .menu-title {
            position: relative;
            font-size: 36px;
            color: #0f0;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #0f0;
        }
        
        .glitch {
            position: relative;
        }
        
        .glitch::before,
        .glitch::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .glitch::before {
            color: #ff00ff;
            left: 2px;
            text-shadow: -2px 0 #ff00ff;
            clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%);
            animation: glitch-1 3s infinite linear alternate-reverse;
        }
        
        .glitch::after {
            color: #00ffff;
            left: -2px;
            text-shadow: 2px 0 #00ffff;
            clip-path: polygon(0 55%, 100% 55%, 100% 100%, 0 100%);
            animation: glitch-2 2s infinite linear alternate-reverse;
        }
        
        @keyframes glitch-1 {
            0%,100% { clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%); }
            20% { clip-path: polygon(0 20%, 100% 20%, 100% 80%, 0 80%); }
            40% { clip-path: polygon(0 10%, 100% 10%, 100% 40%, 0 40%); }
            60% { clip-path: polygon(0 60%, 100% 60%, 100% 90%, 0 90%); }
            80% { clip-path: polygon(0 30%, 100% 30%, 100% 70%, 0 70%); }
        }
        
        @keyframes glitch-2 {
            0%,100% { clip-path: polygon(0 55%, 100% 55%, 100% 100%, 0 100%); }
            15% { clip-path: polygon(0 70%, 100% 70%, 100% 100%, 0 100%); }
            35% { clip-path: polygon(0 40%, 100% 40%, 100% 100%, 0 100%); }
            55% { clip-path: polygon(0 90%, 100% 90%, 100% 100%, 0 100%); }
            75% { clip-path: polygon(0 55%, 100% 55%, 100% 100%, 0 100%); }
        }
        
        .menu-subtitle {
            font-size: 18px;
            color: #f00;
            margin-bottom: 5px;
        }
        
        .menu-version {
            font-size: 14px;
            color: #0f0;
            margin-bottom: 40px;
        }
        
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .menu-btn {
            padding: 12px 24px;
            background: #000;
            border: 2px solid #0f0;
            color: #0f0;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .menu-btn:hover {
            background: #0f0;
            color: #000;
        }
        
        /* HUD Elements */
        .hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }
        
        .fps-counter {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 12px;
            color: #0f0;
            background: rgba(0, 0, 0, 0.8);
            padding: 3px 6px;
            border: 1px solid #0f0;
        }
        
        .dragon-health-container {
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #f00;
            padding: 3px;
            display: none;
        }
        
        .dragon-health-label {
            font-size: 10px;
            text-align: center;
            color: #f00;
            margin-bottom: 2px;
        }
        
        .dragon-health-bar {
            width: 100%;
            height: 12px;
            background: rgba(50, 0, 0, 0.7);
            border: 1px solid #f00;
            position: relative;
            overflow: hidden;
        }
        
        .dragon-health-fill {
            height: 100%;
            background: #f00;
            width: 100%;
        }
        
        .dragon-health-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: #fff;
        }
        
        .health-container {
            position: absolute;
            top: 5px;
            left: 5px;
            width: 150px;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px;
            border: 1px solid #0f0;
        }
        
        .health-label {
            font-size: 9px;
            margin-bottom: 3px;
            color: #0f0;
        }
        
        .health-bar {
            width: 100%;
            height: 12px;
            background: rgba(0, 20, 0, 0.7);
            border: 1px solid #0f0;
            position: relative;
            overflow: hidden;
        }
        
        .health-fill {
            height: 100%;
            background: #0f0;
            width: 100%;
        }
        
        .health-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: #000;
            font-weight: bold;
        }
        
        .boost-container {
            position: absolute;
            top: 60px;
            left: 5px;
            width: 150px;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px;
            border: 1px solid #0f0;
        }
        
        .boost-label {
            font-size: 9px;
            margin-bottom: 3px;
            color: #0f0;
        }
        
        .boost-bar {
            width: 100%;
            height: 12px;
            background: rgba(20, 20, 0, 0.7);
            border: 1px solid #0f0;
            position: relative;
            overflow: hidden;
        }
        
        .boost-fill {
            height: 100%;
            background: #ff0;
            width: 100%;
        }
        
        .boost-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: #000;
            font-weight: bold;
        }
        
        .ammo-container {
            position: absolute;
            bottom: 5px;
            right: 5px;
            text-align: right;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px;
            border: 1px solid #0f0;
        }
        
        .ammo-count {
            font-size: 14px;
            margin-bottom: 2px;
            color: #0f0;
        }
        
        .weapon-name {
            font-size: 9px;
            opacity: 0.9;
            color: #0f0;
        }
        
        .dragon-counter {
            position: absolute;
            top: 40px;
            right: 5px;
            font-size: 11px;
            color: #0f0;
            background: rgba(0, 0, 0, 0.8);
            padding: 3px 6px;
            border: 1px solid #0f0;
        }
        
        .heat-container {
            position: absolute;
            bottom: 40px;
            left: 5px;
            width: 150px;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px;
            border: 1px solid #0f0;
            display: none;
        }
        
        .heat-label {
            font-size: 9px;
            margin-bottom: 3px;
            color: #0f0;
        }
        
        .heat-bar {
            width: 100%;
            height: 12px;
            background: rgba(20, 0, 0, 0.7);
            border: 1px solid #0f0;
            position: relative;
            overflow: hidden;
        }
        
        .heat-fill {
            height: 100%;
            background: #0f0;
            width: 0%;
            transition: width 0.3s;
        }
        
        .heat-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: #fff;
            font-weight: bold;
        }
        
        .companion-dragon-container {
            position: absolute;
            bottom: 80px;
            left: 5px;
            width: 150px;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px;
            border: 1px solid #0f0;
        }
        
        .companion-dragon-label {
            font-size: 9px;
            margin-bottom: 3px;
            color: #0f0;
        }
        
        .companion-dragon-bar {
            width: 100%;
            height: 12px;
            background: rgba(0, 20, 0, 0.7);
            border: 1px solid #0f0;
            position: relative;
            overflow: hidden;
        }
        
        .companion-dragon-fill {
            height: 100%;
            background: #0f0;
            width: 100%;
        }
        
        .companion-dragon-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: #fff;
            font-weight: bold;
        }
        
        .companion-dragon-status {
            font-size: 9px;
            margin-top: 3px;
            color: #0f0;
            text-align: center;
        }
        
        .zone-progress-container {
            position: absolute;
            top: 120px;
            left: 5px;
            font-size: 11px;
            color: #0f0;
            background: rgba(0, 0, 0, 0.8);
            padding: 3px 6px;
            border: 1px solid #0f0;
        }
        
        .mission-info {
            position: absolute;
            top: 40px;
            left: 5px;
            font-size: 11px;
            color: #0f0;
            background: rgba(0, 0, 0, 0.8);
            padding: 3px 6px;
            border: 1px solid #0f0;
        }
        
        .level-info {
            position: absolute;
            top: 80px;
            left: 5px;
            font-size: 11px;
            color: #0f0;
            background: rgba(0, 0, 0, 0.8);
            padding: 3px 6px;
            border: 1px solid #0f0;
        }
        
        .save-load-container {
            position: absolute;
            bottom: 5px;
            left: 5px;
            font-size: 11px;
            color: #0f0;
            background: rgba(0, 0, 0, 0.8);
            padding: 3px 6px;
            border: 1px solid #0f0;
        }
        
        /* Timer positioning at center top */
        .timer-container {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            z-index: 10;
        }
        
        .buzzer-timer {
            font-size: 20px;
            color: #f00;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 16px;
            border: 3px solid #f00;
            border-radius: 10px;
            text-shadow: 0 0 10px #f00;
            font-weight: bold;
        }
        
        .countdown-timer {
            font-size: 24px;
            color: #ff0;
            text-shadow: 0 0 10px #ff0;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px 10px;
            border-radius: 5px;
        }
        
        .portal-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border: 2px solid #0ff;
            border-radius: 10px;
            z-index: 10;
            display: none;
            animation: portalGlow 2s infinite;
        }
        
        .laser-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 0, 0, 0.2);
            z-index: 3;
            pointer-events: none;
            display: none;
        }
        
        .tower-status {
            position: absolute;
            bottom: 120px;
            left: 5px;
            font-size: 11px;
            color: #0f0;
            background: rgba(0, 0, 0, 0.8);
            padding: 3px 6px;
            border: 1px solid #0f0;
        }
        
        /* Dragon Health Bars */
        .dragon-health-bar-overhead {
            position: absolute;
            width: 100px;
            height: 10px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #f00;
            z-index: 5;
            display: none;
        }
        
        .dragon-health-fill-overhead {
            height: 100%;
            background: #f00;
            width: 100%;
        }
        
        /* Animations */
        @keyframes glow {
            from { text-shadow: 0 0 10px #fff, 0 0 20px #fff; }
            to { text-shadow: 0 0 20px #fff, 0 0 30px #fff, 0 0 40px #fff; }
        }
        
        @keyframes scroll {
            0% { transform: rotateX(30deg) translateY(100%); }
            100% { transform: rotateX(30deg) translateY(-300%); }
        }
        
        @keyframes laserPulse {
            0% { opacity: 0.2; }
            50% { opacity: 0.4; }
            100% { opacity: 0.2; }
        }
        
        @keyframes portalGlow {
            0% { opacity: 0.5; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            100% { opacity: 0.5; transform: translate(-50%, -50%) scale(1); }
        }
        
        /* Mobile Controls */
        #mobileControls {
            position: absolute;
            bottom: 10px;
            left: 0;
            width: 100%;
            display: none;
            z-index: 10;
        }
        
        .mobile-controls-row {
            display: flex;
            justify-content: space-between;
            padding: 0 10px;
            margin-bottom: 10px;
        }
        
        .mobile-btn {
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #0f0;
            color: #0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            border-radius: 50%;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        .mobile-joystick {
            width: 80px;
            height: 80px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #0f0;
            border-radius: 50%;
            position: relative;
            touch-action: none;
        }
        
        .mobile-joystick-handle {
            width: 40px;
            height: 40px;
            background: rgba(0, 255, 0, 0.5);
            border-radius: 50%;
            position: absolute;
            top: 20px;
            left: 20px;
        }
        
        @media (max-width: 768px) {
            #mobileControls {
                display: block;
            }
        }
        
        /* Canvas fallback */
        .canvas-fallback {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
            color: #f00;
            font-size: 18px;
            z-index: 1;
        }
    </style>
    <!-- Removed Google Fonts dependency for offline compatibility -->
</head>
<body>
    <div id="gameContainer">
        <!-- Menu Screens -->
        <div id="webxosIntro" class="screen">
            <div class="webxos-title">WEBXOS</div>
            <div class="webxos-subtitle">Browser Based Games</div>
            <div class="webxos-copyright">Â© 2025 WEBXOS GAMES</div>
            <button class="skip-btn" id="skipIntro" style="display: none;">SKIP INTRO</button>
        </div>
        
        <div id="bootSequence" class="screen" style="display: none;">
            <div class="boot-title">TRIOS</div>
            <div class="boot-subtitle">PURGE... BETA TEST</div>
            <div class="boot-progress">
                <div class="boot-progress-fill" id="bootProgress"></div>
            </div>
            <div class="boot-text" id="bootText">LOADING BETA TEST...</div>
        </div>
        
        <div id="storyScroll" class="screen" style="display: none;">
            <div class="story-container">
                <div class="story-content">
                    <div class="story-title">TRIOS: PURGE... BETA TEST</div>
                    <p>It is the year 2048.</p>
                    <p>Humans thrive as a global neural network is providing energy for the entire globe...</p>
                    <p>Thus awakes the grid dragon TRIOS and his menacing DATA STORM.</p>
                    <p>The red dragon scours the earth to evoke a dark age by siphoning energy and data into its endless void...</p>
                    <p>Power fails. Chaos reigns.</p>
                    <p>Captain Purge is forging a drone based CYBORG CYCLOPS using his home lab...</p>
                    <p>Quantum qubit logic. Wireframe VR headset. Armed with a demoscene neural core with a NEUROT GATLING BLASTER and X-RAY LASER.</p>
                    <p>Virtual drones accompany the hero: neural beasts to aid in his efforts.</p>
                    <p>Help test his VR engine, the weapons, and dragon enemies in preparation for the launch...</p>
                    <p>TRIOS: PURGE... BETA TEST</p>
                </div>
            </div>
            <button class="skip-btn" id="skipStory" style="display: none;">SKIP STORY</button>
        </div>
        
        <div id="mainMenu" class="screen" style="display: none;">
            <div class="menu-title glitch" data-text="TRIOS: PURGE... Dragon Hunter">TRIOS: PURGE... BETA TEST</div>
            <div class="menu-subtitle">COMING SOON</div>
            <div class="menu-version">webXOS Games 2025</div>
            <div class="menu-buttons">
                <button class="menu-btn" id="startBtn">START TEST</button>
                <button class="menu-btn" id="loadBtn">LOAD DATA</button>
                <button class="menu-btn" id="settingsBtn">SETTINGS</button>
            </div>
        </div>
        
        <!-- End Game Screen -->
        <div id="endGameScreen" class="screen">
            <div class="end-game-stats">
                <div class="end-game-title">BETA TEST COMPLETE</div>
                <div class="stat-row">
                    <div class="stat-label">TIME ELAPSED:</div>
                    <div class="stat-value" id="endTime">00:00</div>
                </div>
                <div class="stat-row">
                    <div class="stat-label">DRAGONS SLAYED:</div>
                    <div class="stat-value" id="endDragons">0</div>
                </div>
                <div class="stat-row">
                    <div class="stat-label">DAMAGE TAKEN:</div>
                    <div class="stat-value" id="endDamage">0</div>
                </div>
                <div class="stat-row">
                    <div class="stat-label">ACCURACY:</div>
                    <div class="stat-value" id="endAccuracy">0%</div>
                </div>
                <div class="final-score" id="finalScore">SCORE: 0</div>
                <div class="menu-buttons">
                    <button class="menu-btn" id="restartBtn">NEW TEST</button>
                    <button class="menu-btn" id="menuBtn">MAIN MENU</button>
                </div>
            </div>
        </div>
        
        <!-- Game Canvas with fallback -->
        <canvas id="gameCanvas">
            <div class="canvas-fallback">
                Your browser does not support the HTML5 Canvas element required to play this game.
                Please update your browser or try a different one like Chrome, Firefox, or Edge.
            </div>
        </canvas>
        
        <!-- HUD Elements -->
        <div class="hud">
            <div class="fps-counter" id="fpsCounter">FPS: 60</div>
            
            <div class="dragon-health-container" id="dragonHealthContainer">
                <div class="dragon-health-label" id="dragonHealthLabel">BOSS HEALTH</div>
                <div class="dragon-health-bar">
                    <div class="dragon-health-fill" id="dragonHealthFill"></div>
                    <div class="dragon-health-text">HEALTH: <span id="dragonHealthPercent">100%</span></div>
                </div>
            </div>
            
            <div class="health-container">
                <div class="health-label">TESTER INTEGRITY</div>
                <div class="health-bar">
                    <div class="health-fill" id="healthFill"></div>
                    <div class="health-text">HEALTH: <span id="healthPercent">100%</span></div>
                </div>
            </div>
            
            <div class="boost-container">
                <div class="boost-label">BOOST FUEL</div>
                <div class="boost-bar">
                    <div class="boost-fill" id="boostFill"></div>
                    <div class="boost-text">BOOST: <span id="boostPercent">100%</span></div>
                </div>
            </div>
            
            <div class="ammo-container">
                <div class="ammo-count" id="ammoCount">UNLIMITED</div>
                <div class="weapon-name">NEUROT GATLING</div>
            </div>
            
            <div class="dragon-counter">
                ZONE: <span id="waveCount">1</span>/4
            </div>
            
            <div class="heat-container" id="heatContainer">
                <div class="heat-label">LASER COOLDOWN</div>
                <div class="heat-bar">
                    <div class="heat-fill" id="heatFill"></div>
                    <div class="heat-text">COOLDOWN: <span id="heatPercent">0%</span></div>
                </div>
            </div>
            
            <div class="companion-dragon-container">
                <div class="companion-dragon-label">DRONES</div>
                <div class="companion-dragon-bar">
                    <div class="companion-dragon-fill" id="companionDragonFill"></div>
                    <div class="companion-dragon-text">GROWTH</div>
                </div>
                <div class="companion-dragon-status" id="companionDragonStatus">READY</div>
            </div>
            
            <div class="zone-progress-container">
                PACKS CLEARED: <span id="zoneProgress">0</span>/<span id="zoneTotal">3</span>
            </div>
            
            <div class="mission-info">
                MISSION: <span id="missionName">HUNT DRAGONS</span>
            </div>
            
            <div class="level-info">
                LEVEL: <span id="playerLevel">1</span> | EXP: <span id="playerExp">0</span>/<span id="nextLevelExp">100</span>
            </div>
            
            <div class="save-load-container">
                SAVE/LOAD
            </div>
            
            <div class="tower-status">
                TOWERS: <span id="towerStatus">0</span>/8
            </div>
            
            <!-- Timer Container at Center Top -->
            <div class="timer-container">
                <div class="buzzer-timer" id="buzzerTimer">
                    00:00
                </div>
                <div class="countdown-timer" id="countdownTimer" style="display: none;">
                    III
                </div>
            </div>
            
            <div class="portal-notification" id="portalNotification">
                PORTAL ACTIVATED! ENTER TO PROCEED
            </div>
            
            <div class="crosshair">
                <div class="crosshair-dot"></div>
            </div>
            
            <div class="laser-overlay" id="laserOverlay"></div>
        </div>
        
        <!-- Dragon Health Bars Container -->
        <div id="dragonHealthBars"></div>
        
        <!-- Mobile Controls -->
        <div id="mobileControls">
            <div class="mobile-controls-row">
                <div class="mobile-joystick" id="moveJoystick">
                    <div class="mobile-joystick-handle"></div>
                </div>
                <div class="mobile-btn" id="boostBtn">BOOST</div>
                <div class="mobile-btn" id="speedBtn">SPEED</div>
            </div>
            <div class="mobile-controls-row">
                <div class="mobile-btn" id="fireGatlingBtn">GATLING</div>
                <div class="mobile-btn" id="fireLaserBtn">LASER</div>
                <div class="mobile-btn" id="companionBtn">DRONES</div>
                <div class="mobile-btn" id="cpuBtn">CPU</div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ============================
        // EPIC GAME STATE AND VARIABLES
        // ============================
        
        // Game State
        const GameState = {
            MENU: 0,
            PLAYING: 1,
            GAME_OVER: 2,
            LOADING: 3,
            WAVE_TRANSITION: 4,
            COUNTDOWN: 5,
            CINEMATIC: 6,
            END_GAME: 7
        };
        
        let currentState = GameState.LOADING;
        let mouseSensitivity = 0.002;
        let pointerLocked = false;
        let immortalMode = true; // Set to true for testing
        let cpuMode = false;

        // Three.js variables
        let scene, camera, renderer;
        let player, dragons = [], companionDragons = [], projectiles = [], particles = [];
        let buildings = [], gridFloor = null, portal = null, towers = [];
        let clock = new THREE.Clock();
        let gameStartTime = 0;
        let gameTimer = 0;
        let runTime = 0;
        let timerInterval;
        let frameCount = 0;
        let lastFpsUpdate = 0;
        let fps = 60;
        let animationFrameId;
        
        // Gatling gun variables
        let gatlingGun = null;
        let gatlingBarrels = null;
        let gatlingBarrelRotation = 0;
        let gatlingBarrelSpeed = 0;
        
        // Laser Beam variables
        let laserActive = false;
        let laserCooldown = 0;
        let laserMaxCooldown = 0.2; // Faster cooldown for stream
        let laserDamage = 400;
        
        // Companion Dragon variables
        let companionDragonCooldown = 0;
        let companionDragonMaxCooldown = 50;
        let companionDragonActive = false;
        let companionDragonAttackTime = 0;
        let companionDragonAttackDuration = 12;
        let companionDragonEnraged = false;
        
        // Boost variables
        let boostFuel = 100;
        let maxBoostFuel = 100;
        let boostFuelRegenRate = 25;
        let boostActive = false;
        
        // Leveling system
        let playerLevel = 1;
        let playerExp = 0;
        let nextLevelExp = 100;
        
        // Timer variables
        let buzzerTimer = 0;
        let countdownTimer = 10;
        let countdownActive = false;
        let countdownInterval = null;
        let romanNumerals = ['X', 'IX', 'VIII', 'VII', 'VI', 'V', 'IV', 'III', 'II', 'I'];
        
        // Portal variables
        let portalActive = false;
        let portalSpawned = false;
        let portalTriggerTime = 0;
        
        // Tower variables
        let totalTowers = 8;
        let activeTowers = 0;
        let triosSpawned = false;
        
        // Wind tunnel effect for Trios
        let triosWindTunnelActive = false;
        let triosWindTunnelCooldown = 0;
        let triosWindTunnelMaxCooldown = 15;
        let triosWindTunnelDuration = 3;
        let triosWindTunnelTime = 0;
        
        // Game stats for end screen
        let gameStats = {
            score: 0,
            currentWave: 1,
            totalWaves: 4,
            playerHealth: 100,
            maxPlayerHealth: 100,
            playerSpeed: 12,
            speedBoost: false,
            playerDamage: 200,
            gunHeat: 0,
            maxHeat: 100,
            heatPerShot: 0,
            coolingRate: 30,
            isOverheated: false,
            fireRate: 25,
            lastFireTime: 0,
            damageTaken: 0,
            dragonsSlayed: 0,
            dragonPacksCleared: 0,
            totalPacks: 3, // Now 3 dragons per zone
            dragonCount: 0,
            shotsFired: 0,
            shotsHit: 0
        };
        
        // Enhanced Save system
        let saveData = {
            playerLevel: 1,
            playerExp: 0,
            nextLevelExp: 100,
            companionLevel: 1,
            towersActivated: 0,
            gameStats: {}
        };
        
        // Quake 3 Arena Dragon AI System
        const dragonAITypes = {
            AGGRESSIVE: {
                name: "AGGRESSIVE",
                attackRange: 25,
                chargeDistance: 15,
                strafeChance: 0.3,
                accuracy: 0.7,
                aggression: 0.8,
                movement: "strafe_charge"
            },
            TACTICAL: {
                name: "TACTICAL",
                attackRange: 35,
                chargeDistance: 20,
                strafeChance: 0.6,
                accuracy: 0.9,
                aggression: 0.5,
                movement: "circle_strafe"
            },
            AMBUSH: {
                name: "AMBUSH",
                attackRange: 20,
                chargeDistance: 10,
                strafeChance: 0.2,
                accuracy: 0.8,
                aggression: 0.9,
                movement: "teleport_attack"
            }
        };

        // TRIOS boss combines all three AI types
        let triosAI = {
            phase1: dragonAITypes.AGGRESSIVE,
            phase2: dragonAITypes.TACTICAL, 
            phase3: dragonAITypes.AMBUSH,
            currentPhase: 1
        };
        
        // Controls
        const controls = {
            moveForward: false,
            moveBackward: false,
            moveLeft: false,
            moveRight: false,
            fireGatling: false,
            fireLaser: false,
            speedBoost: false,
            jetpack: false,
            summonCompanions: false,
            mouseX: 0,
            mouseY: 0
        };

        // ============================
        // EPIC MENU SYSTEM
        // ============================

        // Start the menu sequence
        function startMenuSequence() {
            // Show WEBXOS intro
            document.getElementById('webxosIntro').style.display = 'flex';
            
            // Show skip button after 2 seconds
            setTimeout(() => {
                document.getElementById('skipIntro').style.display = 'block';
            }, 2000);
            
            // Auto-advance after 5 seconds
            setTimeout(() => {
                if (document.getElementById('webxosIntro').style.display !== 'none') {
                    showBootSequence();
                }
            }, 5000);
        }

        // Show boot sequence
        function showBootSequence() {
            document.getElementById('webxosIntro').style.display = 'none';
            document.getElementById('bootSequence').style.display = 'flex';
            
            let progress = 0;
            const bootTexts = [
                "LOADING NEURAL INTERFACE...",
                "INITIALIZING NEUROT GATLING...",
                "CALIBRATING X-RAY LASER...",
                "SYNCING DRAGON DRONES...",
                "SYSTEMS READY. LAUNCHING..."
            ];
            let textIndex = 0;
            
            const bootInterval = setInterval(() => {
                progress += 20;
                document.getElementById('bootProgress').style.width = `${progress}%`;
                
                if (progress % 20 === 0 && textIndex < bootTexts.length) {
                    document.getElementById('bootText').textContent = bootTexts[textIndex];
                    textIndex++;
                }
                
                if (progress >= 100) {
                    clearInterval(bootInterval);
                    setTimeout(() => {
                        showStoryScroll();
                    }, 1000);
                }
            }, 500);
        }

        // Show story scroll
        function showStoryScroll() {
            document.getElementById('bootSequence').style.display = 'none';
            document.getElementById('storyScroll').style.display = 'flex';
            
            // Show skip button after 2 seconds
            setTimeout(() => {
                document.getElementById('skipStory').style.display = 'block';
            }, 2000);
            
            // Auto-advance after 30 seconds
            setTimeout(() => {
                if (document.getElementById('storyScroll').style.display !== 'none') {
                    showMainMenu();
                }
            }, 30000);
        }

        // Show main menu
        function showMainMenu() {
            document.getElementById('storyScroll').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'flex';
        }

        // Show end game screen
        function showEndGameScreen() {
            document.getElementById('endGameScreen').style.display = 'flex';
            
            // Calculate stats
            const accuracy = gameStats.shotsFired > 0 ? 
                Math.round((gameStats.shotsHit / gameStats.shotsFired) * 100) : 0;
            
            // Calculate score
            const timeBonus = Math.max(0, 10000 - (buzzerTimer * 10));
            const accuracyBonus = accuracy * 50;
            const healthBonus = gameStats.playerHealth * 20;
            const killBonus = gameStats.dragonsSlayed * 500;
            
            const finalScore = timeBonus + accuracyBonus + healthBonus + killBonus;
            
            // Update UI
            document.getElementById('endTime').textContent = 
                `${Math.floor(buzzerTimer / 60).toString().padStart(2, '0')}:${(buzzerTimer % 60).toString().padStart(2, '0')}`;
            document.getElementById('endDragons').textContent = gameStats.dragonsSlayed;
            document.getElementById('endDamage').textContent = gameStats.damageTaken;
            document.getElementById('endAccuracy').textContent = `${accuracy}%`;
            document.getElementById('finalScore').textContent = `SCORE: ${finalScore}`;
            
            currentState = GameState.END_GAME;
        }

        // ============================
        // EPIC GAME INITIALIZATION
        // ============================

        // Initialize the game
        function init() {
            try {
                // Start the menu sequence
                startMenuSequence();
                
                // Set up Three.js
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000000);
                scene.fog = new THREE.Fog(0x000000, 30, 300);
                
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                
                const canvas = document.getElementById('gameCanvas');
                renderer = new THREE.WebGLRenderer({
                    canvas: canvas,
                    antialias: false,
                    powerPreference: "low-power"
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = false;
                renderer.setPixelRatio(window.devicePixelRatio || 1);
                
                const ambientLight = new THREE.AmbientLight(0x202020);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0x00ff00, 0.6);
                directionalLight.position.set(12, 12, 12);
                scene.add(directionalLight);
                
                createPlayer();
                createCompanionDragons();
                setupEventListeners();
                
                // Set up mobile controls if needed
                if (isMobile()) {
                    setupMobileControls();
                }
                
                // Load saved game if available
                loadGame();
                
                animate();
            } catch (error) {
                console.error("Error during game initialization:", error);
                alert("Failed to initialize the game. Please refresh the page.");
            }
        }

        // Check if mobile device
        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                   window.innerWidth <= 768;
        }

        // Set up mobile controls
        function setupMobileControls() {
            try {
                const moveJoystick = document.getElementById('moveJoystick');
                const boostBtn = document.getElementById('boostBtn');
                const speedBtn = document.getElementById('speedBtn');
                const fireGatlingBtn = document.getElementById('fireGatlingBtn');
                const fireLaserBtn = document.getElementById('fireLaserBtn');
                const companionBtn = document.getElementById('companionBtn');
                const cpuBtn = document.getElementById('cpuBtn');
                
                // Move joystick
                let joystickActive = false;
                let joystickStartX = 0;
                let joystickStartY = 0;
                let joystickHandle = moveJoystick.querySelector('.mobile-joystick-handle');
                
                moveJoystick.addEventListener('touchstart', (e) => {
                    joystickActive = true;
                    const rect = moveJoystick.getBoundingClientRect();
                    joystickStartX = rect.left + rect.width / 2;
                    joystickStartY = rect.top + rect.height / 2;
                    e.preventDefault();
                });
                
                document.addEventListener('touchmove', (e) => {
                    if (!joystickActive) return;
                    
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - joystickStartX;
                    const deltaY = touch.clientY - joystickStartY;
                    
                    // Calculate distance and angle
                    const distance = Math.min(30, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
                    const angle = Math.atan2(deltaY, deltaX);
                    
                    // Update handle position
                    const handleX = Math.cos(angle) * distance;
                    const handleY = Math.sin(angle) * distance;
                    joystickHandle.style.transform = `translate(${handleX}px, ${handleY}px)`;
                    
                    // Update controls based on angle and distance
                    const threshold = 10;
                    controls.moveForward = deltaY < -threshold;
                    controls.moveBackward = deltaY > threshold;
                    controls.moveLeft = deltaX < -threshold;
                    controls.moveRight = deltaX > threshold;
                    
                    e.preventDefault();
                });
                
                document.addEventListener('touchend', (e) => {
                    if (joystickActive) {
                        joystickActive = false;
                        joystickHandle.style.transform = 'translate(0, 0)';
                        controls.moveForward = false;
                        controls.moveBackward = false;
                        controls.moveLeft = false;
                        controls.moveRight = false;
                        e.preventDefault();
                    }
                });
                
                // Button controls
                boostBtn.addEventListener('touchstart', () => { controls.jetpack = true; });
                boostBtn.addEventListener('touchend', () => { controls.jetpack = false; });
                
                speedBtn.addEventListener('touchstart', () => { controls.speedBoost = true; });
                speedBtn.addEventListener('touchend', () => { controls.speedBoost = false; });
                
                fireGatlingBtn.addEventListener('touchstart', () => { controls.fireGatling = true; });
                fireGatlingBtn.addEventListener('touchend', () => { controls.fireGatling = false; });
                
                fireLaserBtn.addEventListener('touchstart', () => { 
                    controls.fireLaser = true; 
                    fireLaser();
                });
                fireLaserBtn.addEventListener('touchend', () => { controls.fireLaser = false; });
                
                companionBtn.addEventListener('touchstart', () => { 
                    if (!controls.summonCompanions) {
                        controls.summonCompanions = true;
                        activateCompanionDragons();
                    }
                });
                companionBtn.addEventListener('touchend', () => { controls.summonCompanions = false; });
                
                cpuBtn.addEventListener('touchstart', () => { 
                    cpuMode = !cpuMode;
                    cpuBtn.style.background = cpuMode ? 'rgba(0, 255, 0, 0.8)' : 'rgba(0, 0, 0, 0.6)';
                });
            } catch (error) {
                console.error("Error setting up mobile controls:", error);
            }
        }

        // Create the player
        function createPlayer() {
            player = new THREE.Object3D();
            player.position.set(0, 1.7, 0);
            player.rotation.y = Math.PI;
            scene.add(player);
            
            camera.position.set(0, 1.7, 0);
            player.add(camera);
            
            createGatlingGun();
            
            player.velocity = new THREE.Vector3();
            player.isGrounded = true;
            player.currentTarget = null;
        }

        // Create the Neurot Green Gatling Gun
        function createGatlingGun() {
            const gunGroup = new THREE.Group();
            
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 0.4, 1.2),
                new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true })
            );
            gunGroup.add(body);
            
            const barrelGroup = new THREE.Group();
            const barrelCount = 8;
            const barrelRadius = 0.15;
            
            for (let i = 0; i < barrelCount; i++) {
                const angle = (i / barrelCount) * Math.PI * 2;
                const x = Math.cos(angle) * barrelRadius;
                const y = Math.sin(angle) * barrelRadius;
                
                const barrel = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.03, 0.03, 1.2, 6),
                    new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true })
                );
                barrel.position.set(x, y, 0);
                barrel.rotation.x = Math.PI / 2;
                barrelGroup.add(barrel);
            }
            
            barrelGroup.position.z = 0.8;
            gunGroup.add(barrelGroup);
            gatlingBarrels = barrelGroup;
            
            const drum = new THREE.Mesh(
                new THREE.CylinderGeometry(0.4, 0.4, 0.6, 8),
                new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true })
            );
            drum.position.set(0, 0, -0.3);
            drum.rotation.x = Math.PI / 2;
            gunGroup.add(drum);
            
            gunGroup.position.set(0.3, -0.4, -0.8);
            gunGroup.rotation.y = Math.PI;
            camera.add(gunGroup);
            
            gatlingGun = gunGroup;
        }

        // Create SNAKE-LIKE DRAGON with large bat wings
        function createSnakeDragon(color = 0xFF0000, size = 1.0, isBoss = false) {
            const dragonGroup = new THREE.Group();
            
            // Snake-like body - long cylindrical segments
            const bodySegments = 12;
            const segmentLength = 0.8 * size;
            const segmentRadius = 0.4 * size;
            
            for (let i = 0; i < bodySegments; i++) {
                const segmentGeometry = new THREE.CylinderGeometry(
                    segmentRadius * (1 - i * 0.05), 
                    segmentRadius * (1 - (i+1) * 0.05), 
                    segmentLength, 
                    8
                );
                const segment = new THREE.LineSegments(
                    new THREE.WireframeGeometry(segmentGeometry),
                    new THREE.LineBasicMaterial({ color: color })
                );
                segment.position.set(0, 0, -i * segmentLength * 0.9);
                dragonGroup.add(segment);
            }
            
            // Head - more defined and dragon-like
            const headGeometry = new THREE.ConeGeometry(0.6 * size, 1.2 * size, 8);
            const head = new THREE.LineSegments(
                new THREE.WireframeGeometry(headGeometry),
                new THREE.LineBasicMaterial({ color: color })
            );
            head.position.set(0, 0, segmentLength * 0.5);
            head.rotation.x = Math.PI / 2;
            dragonGroup.add(head);
            
            // Large bat wings
            const wingGeometry = new THREE.ConeGeometry(1.5 * size, 3.0 * size, 8);
            
            const leftWing = new THREE.LineSegments(
                new THREE.WireframeGeometry(wingGeometry),
                new THREE.LineBasicMaterial({ color: color })
            );
            leftWing.position.set(-1.5 * size, 0.5 * size, -3 * size);
            leftWing.rotation.z = Math.PI / 3;
            leftWing.rotation.x = -Math.PI / 4;
            dragonGroup.add(leftWing);
            
            const rightWing = new THREE.LineSegments(
                new THREE.WireframeGeometry(wingGeometry),
                new THREE.LineBasicMaterial({ color: color })
            );
            rightWing.position.set(1.5 * size, 0.5 * size, -3 * size);
            rightWing.rotation.z = -Math.PI / 3;
            rightWing.rotation.x = -Math.PI / 4;
            dragonGroup.add(rightWing);
            
            // Tail - long and snake-like
            const tailSegments = 8;
            for (let i = 0; i < tailSegments; i++) {
                const tailGeometry = new THREE.ConeGeometry(
                    0.3 - (i * 0.035) * size, 
                    0.8 * size, 
                    6
                );
                const tailSegment = new THREE.LineSegments(
                    new THREE.WireframeGeometry(tailGeometry),
                    new THREE.LineBasicMaterial({ color: color })
                );
                tailSegment.position.set(0, 0, -bodySegments * segmentLength * 0.9 - i * 0.7 * size);
                tailSegment.rotation.x = Math.PI / 2;
                dragonGroup.add(tailSegment);
            }
            
            // Legs - more defined
            for (let i = 0; i < 4; i++) {
                const isBackLeg = i >= 2;
                const legGeometry = new THREE.CylinderGeometry(0.15 * size, 0.15 * size, 1.0 * size, 6);
                const leg = new THREE.LineSegments(
                    new THREE.WireframeGeometry(legGeometry),
                    new THREE.LineBasicMaterial({ color: color })
                );
                const xPos = isBackLeg ? -0.8 + (i % 2) * 1.6 : -0.5 + (i % 2) * 1.0;
                const zPos = isBackLeg ? -5 * size : -2 * size;
                leg.position.set(xPos * size, -0.5 * size, zPos);
                dragonGroup.add(leg);
                
                // Feet
                const footGeometry = new THREE.ConeGeometry(0.2 * size, 0.4 * size, 6);
                const foot = new THREE.LineSegments(
                    new THREE.WireframeGeometry(footGeometry),
                    new THREE.LineBasicMaterial({ color: color })
                );
                foot.position.set(xPos * size, -1.0 * size, zPos);
                dragonGroup.add(foot);
            }
            
            // Create point cloud mist effect
            const mistParticles = createPointCloudMist(color, size * 2, color === 0xFF0000);
            dragonGroup.add(mistParticles);
            dragonGroup.userData.mistParticles = mistParticles;
            
            return dragonGroup;
        }

        // Create point cloud mist effect with glitch
        function createPointCloudMist(color, size, isGlitch = false) {
            const particleCount = isGlitch ? 150 : 200;
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const glitchOffsets = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount * 3; i += 3) {
                const radius = size * (0.8 + Math.random() * 0.4);
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                positions[i] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i + 2] = radius * Math.cos(phi);
                
                // Enhanced color with glitch variations
                const r = (color >> 16 & 255) / 255;
                const g = (color >> 8 & 255) / 255;
                const b = (color & 255) / 255;
                
                if (isGlitch) {
                    // Red dragon data glitch effect
                    colors[i] = r * (0.5 + Math.random() * 0.5);
                    colors[i + 1] = g * (0.1 + Math.random() * 0.2);
                    colors[i + 2] = b * (0.1 + Math.random() * 0.2);
                } else {
                    colors[i] = r * (0.7 + Math.random() * 0.3);
                    colors[i + 1] = g * (0.7 + Math.random() * 0.3);
                    colors[i + 2] = b * (0.7 + Math.random() * 0.3);
                }
                
                // Glitch offset for animation
                glitchOffsets[i] = (Math.random() - 0.5) * 0.1;
                glitchOffsets[i + 1] = (Math.random() - 0.5) * 0.1;
                glitchOffsets[i + 2] = (Math.random() - 0.5) * 0.1;
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('glitchOffset', new THREE.BufferAttribute(glitchOffsets, 3));
            
            const material = new THREE.PointsMaterial({
                size: size * 0.05,
                vertexColors: true,
                transparent: true,
                opacity: isGlitch ? 0.8 : 0.6,
                blending: THREE.AdditiveBlending
            });
            
            const pointCloud = new THREE.Points(geometry, material);
            pointCloud.userData.isGlitch = isGlitch;
            pointCloud.userData.glitchTime = 0;
            
            return pointCloud;
        }

        // Update point cloud mist with glitch effects
        function updatePointCloudMist(mistParticles, delta) {
            if (!mistParticles || !mistParticles.geometry) return;
            
            const positions = mistParticles.geometry.attributes.position.array;
            const glitchOffsets = mistParticles.geometry.attributes.glitchOffset.array;
            const time = performance.now() * 0.001;
            
            mistParticles.userData.glitchTime += delta;
            
            for (let i = 0; i < positions.length; i += 3) {
                // Base floating motion
                positions[i] += (Math.sin(time + i) * 0.01) * delta * 60;
                positions[i + 1] += (Math.cos(time + i * 0.7) * 0.01) * delta * 60;
                positions[i + 2] += (Math.sin(time + i * 0.3) * 0.01) * delta * 60;
                
                // Enhanced glitch effect for red dragons
                if (mistParticles.userData.isGlitch) {
                    const glitchIntensity = 0.3 + Math.sin(mistParticles.userData.glitchTime * 5) * 0.2;
                    
                    // Data corruption glitch effect
                    if (Math.random() < 0.1) {
                        positions[i] += (Math.random() - 0.5) * glitchIntensity;
                        positions[i + 1] += (Math.random() - 0.5) * glitchIntensity;
                        positions[i + 2] += (Math.random() - 0.5) * glitchIntensity;
                    }
                    
                    // Digital static effect
                    if (Math.random() < 0.05) {
                        positions[i] = glitchOffsets[i] * glitchIntensity * 10;
                        positions[i + 1] = glitchOffsets[i + 1] * glitchIntensity * 10;
                        positions[i + 2] = glitchOffsets[i + 2] * glitchIntensity * 10;
                    }
                }
            }
            
            mistParticles.geometry.attributes.position.needsUpdate = true;
        }

        // Create TRIOS boss with enhanced snake-like model
        function createTriosBoss(color = 0xFF0000, size = 1.0) {
            const dragonGroup = new THREE.Group();
            
            // Use the snake-like dragon model but make it massive
            const bossDragon = createSnakeDragon(color, size, true);
            
            // Make all materials wireframe for Trios
            bossDragon.traverse((child) => {
                if (child.isLineSegments) {
                    child.material = new THREE.LineBasicMaterial({ 
                        color: color,
                        wireframe: false // Already wireframe from LineSegments
                    });
                }
            });
            
            dragonGroup.add(bossDragon);
            
            return dragonGroup;
        }

        // Create Companion Neon Green Dragon Drones with snake-like models
        function createCompanionDragons() {
            companionDragons = [];
            
            for (let i = 0; i < 2; i++) {
                const dragon = createSnakeDragon(0x00ff00, 0.7);
                
                const playerPos = player ? player.position : new THREE.Vector3(0, 0, 0);
                dragon.position.set(playerPos.x + (i === 0 ? -5 : 5), playerPos.y + 2, playerPos.z + 3);
                dragon.visible = false;
                
                dragon.orbitAngle = i * Math.PI;
                dragon.orbitRadius = 8;
                dragon.heightOffset = 3;
                dragon.lastFire = 0;
                dragon.fireRate = 500;
                dragon.damage = 150;
                dragon.isActive = false;
                dragon.color = 0x00ff00;
                dragon.scale.set(1, 1, 1);
                dragon.enraged = false;
                dragon.level = 1;
                dragon.isCompanion = true;
                dragon.lastAttack = 0;
                
                scene.add(dragon);
                companionDragons.push(dragon);
            }
        }

        // Create neon grid floor
        function createGridFloor() {
            try {
                if (gridFloor && scene) scene.remove(gridFloor);
                
                const gridSize = 300;
                const gridDivisions = 100;
                const gridColor = 0x00ff00;
                
                const gridGeometry = new THREE.PlaneGeometry(gridSize, gridSize, gridDivisions, gridDivisions);
                const gridMaterial = new THREE.MeshBasicMaterial({ 
                    color: gridColor, 
                    wireframe: true,
                    transparent: true,
                    opacity: 0.3
                });
                
                gridFloor = new THREE.Mesh(gridGeometry, gridMaterial);
                gridFloor.rotation.x = -Math.PI / 2;
                gridFloor.position.y = 0.1;
                scene.add(gridFloor);
            } catch (error) {
                console.error("Error creating grid floor:", error);
            }
        }

        // Update grid floor pulse
        function updateGridFloor(delta) {
            try {
                if (!gridFloor || !gridFloor.material) return;
                
                const pulseSpeed = 1;
                const minOpacity = 0.1;
                const maxOpacity = 0.5;
                
                // Calculate pulse based on time
                const time = performance.now() * 0.001;
                const pulse = (Math.sin(time * pulseSpeed) + 1) * 0.5;
                gridFloor.material.opacity = minOpacity + pulse * (maxOpacity - minOpacity);
            } catch (error) {
                console.error("Error updating grid floor:", error);
            }
        }

        // Create the Cyber Wireframe Towers
        function createTowers() {
            try {
                // Clean up existing towers
                if (towers && towers.length > 0) {
                    towers.forEach(tower => {
                        if (tower && scene) scene.remove(tower);
                    });
                }
                towers = [];
                
                const towerMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
                
                // Create 8 towers in a circle around the center
                const towerCount = 8;
                const towerRadius = 100;
                
                for (let i = 0; i < towerCount; i++) {
                    const angle = (i / towerCount) * Math.PI * 2;
                    const x = Math.cos(angle) * towerRadius;
                    const z = Math.sin(angle) * towerRadius;
                    
                    const height = 30 + Math.random() * 20;
                    const width = 4 + Math.random() * 3;
                    const depth = 4 + Math.random() * 3;
                    
                    const towerGeometry = new THREE.BoxGeometry(width, height, depth);
                    const tower = new THREE.Mesh(towerGeometry, towerMaterial);
                    
                    tower.position.set(x, height / 2, z);
                    tower.userData = {
                        isActive: false,
                        index: i
                    };
                    
                    scene.add(tower);
                    towers.push(tower);
                }
                
                updateTowerStatus();
            } catch (error) {
                console.error("Error creating towers:", error);
            }
        }

        // Activate a tower
        function activateTower() {
            if (activeTowers >= totalTowers) return;
            
            // Find an inactive tower
            const inactiveTowers = towers.filter(tower => !tower.userData.isActive);
            if (inactiveTowers.length === 0) return;
            
            // Activate a random inactive tower
            const randomTower = inactiveTowers[Math.floor(Math.random() * inactiveTowers.length)];
            randomTower.userData.isActive = true;
            randomTower.material.color.set(0xff0000);
            
            activeTowers++;
            updateTowerStatus();
            
            // Check if all towers are activated
            if (activeTowers >= totalTowers && !triosSpawned) {
                spawnTrios();
            }
        }

        // Update tower status display
        function updateTowerStatus() {
            document.getElementById('towerStatus').textContent = activeTowers;
        }

        // Spawn Trios world boss
        function spawnTrios() {
            triosSpawned = true;
            
            const bossPosition = new THREE.Vector3(0, 60, 0);
            const boss = createEnhancedDragon(bossPosition, dragonTypes[3], dragonAITypes.AGGRESSIVE);
            boss.isBoss = true;
            boss.isTrios = true;
            boss.minionSpawnThresholds = [0.66, 0.33]; // Spawn minions at 66% and 33% health
            boss.minionsSpawned = 0;
            
            document.getElementById('dragonHealthContainer').style.display = 'block';
            document.getElementById('missionName').textContent = "DEFEAT TRIOS";
            
            // Show notification
            const portalNotification = document.getElementById('portalNotification');
            portalNotification.textContent = "TRIOS AWAKENED! THE FINAL BATTLE BEGINS!";
            portalNotification.style.display = 'block';
            setTimeout(() => {
                portalNotification.style.display = 'none';
            }, 5000);
        }

        // Create the Cyber Wireframe City
        function createCity() {
            try {
                // Clean up existing buildings
                if (buildings && buildings.length > 0) {
                    buildings.forEach(building => {
                        if (building && scene) scene.remove(building);
                    });
                }
                buildings = [];
                
                // Create grid floor
                createGridFloor();
                
                // Create towers
                createTowers();
                
                const buildingMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
                
                // Create optimized number of buildings for performance
                const buildingCount = 20;
                const zoneSize = 120;
                
                for (let i = 0; i < buildingCount; i++) {
                    const height = 15 + Math.random() * 25;
                    const width = 3 + Math.random() * 4;
                    const depth = 3 + Math.random() * 4;
                    
                    const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
                    const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                    
                    // Position buildings in a larger area
                    building.position.set(
                        (Math.random() - 0.5) * zoneSize,
                        height / 2,
                        (Math.random() - 0.5) * zoneSize
                    );
                    
                    scene.add(building);
                    buildings.push(building);
                }
                
                // Add stars for background
                const starGeometry = new THREE.BufferGeometry();
                const starMaterial = new THREE.PointsMaterial({ color: 0x00ff00, size: 0.3, sizeAttenuation: true });
                
                const starVertices = [];
                for (let i = 0; i < 300; i++) {
                    const x = (Math.random() - 0.5) * 1500;
                    const y = (Math.random() - 0.5) * 1500;
                    const z = (Math.random() - 0.5) * 1500;
                    starVertices.push(x, y, z);
                }
                
                starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
                const stars = new THREE.Points(starGeometry, starMaterial);
                scene.add(stars);
                buildings.push(stars);
            } catch (error) {
                console.error("Error creating city:", error);
            }
        }

        // EPIC Dragon types for hunt zones - 3 DRAGONS PER ZONE
        const dragonTypes = [
            { 
                name: "WHISP DRAGONS", 
                enemyName: "Whisp Dragon",
                color: 0xFF0000, 
                health: 15000, // 10x more health
                damage: 15, 
                speed: 18, 
                size: 4.0, // 2x bigger
                behavior: "wander", 
                xpReward: 300,
                count: 3, // 3 dragons per zone
                fireRate: 350,
                description: "Erratic orbit, rapid small red firebolts",
                aiType: dragonAITypes.AGGRESSIVE
            },
            { 
                name: "BULLDOG DRAGONS", 
                enemyName: "Bulldog Dragon",
                color: 0xFF0000, 
                health: 30000, // 10x more health
                damage: 25, 
                speed: 12, 
                size: 6.0, // 2x bigger
                behavior: "charge", 
                xpReward: 600,
                count: 3, // 3 dragons per zone
                fireRate: 800,
                description: "Ground-based, fast runners with melee attacks",
                aiType: dragonAITypes.TACTICAL
            },
            { 
                name: "WIZARD DRAGONS", 
                enemyName: "Wizard Dragon",
                color: 0xFF0000, // All dragons now red
                health: 45000, // 10x more health
                damage: 35, 
                speed: 15, 
                size: 8.0, // 2x bigger
                behavior: "teleport", 
                xpReward: 900,
                count: 3, // 3 dragons per zone
                fireRate: 1000,
                description: "Teleporting dragons with magical attacks",
                aiType: dragonAITypes.AMBUSH
            },
            { 
                name: "WORLD BOSS: TRIOS", 
                enemyName: "TRIOS",
                color: 0xFF0000, 
                health: 200000, // Adjusted health
                damage: 60, 
                speed: 2, 
                size: 50.0, // Massive leviathan
                behavior: "boss", 
                xpReward: 5000,
                count: 1,
                fireRate: 1500,
                description: "Massive red dragon, devastating attacks",
                aiType: dragonAITypes.AGGRESSIVE // Will change phases
            }
        ];

        // Create an enhanced dragon with AI
        function createEnhancedDragon(position, dragonType, aiType = dragonAITypes.AGGRESSIVE) {
            try {
                const isTrios = dragonType.name.includes("TRIOS");
                let dragon;
                
                if (isTrios) {
                    dragon = createTriosBoss(dragonType.color, dragonType.size);
                } else {
                    dragon = createSnakeDragon(dragonType.color, dragonType.size);
                }
                
                dragon.position.copy(position);
                
                dragon.health = dragonType.health;
                dragon.maxHealth = dragonType.health;
                dragon.speed = dragonType.speed;
                dragon.target = player;
                dragon.lastFire = 0;
                dragon.baseFireRate = dragonType.fireRate;
                dragon.damage = dragonType.damage;
                dragon.dragonType = dragonType;
                dragon.id = dragons.length;
                dragon.isAggressive = false;
                dragon.wanderDirection = new THREE.Vector3((Math.random() - 0.5) * 2, 0, (Math.random() - 0.5) * 2).normalize();
                dragon.wanderTime = 0;
                dragon.chargeCooldown = 0;
                dragon.teleportCooldown = 0;
                dragon.evadeChance = dragonType.behavior === "teleport" ? 0.4 : 0;
                dragon.isTrios = isTrios;
                dragon.aiType = aiType;
                
                // Mark wings for Spyro animations
                dragon.children.forEach((child, index) => {
                    if (index >= dragon.children.length - 2) { // Assuming last two are wings
                        child.userData.isWing = true;
                    }
                });
                
                // Create health bar for non-boss dragons
                if (!isTrios) {
                    const healthBar = document.createElement('div');
                    healthBar.className = 'dragon-health-bar-overhead';
                    healthBar.id = `dragonHealthBar${dragon.id}`;
                    
                    const healthFill = document.createElement('div');
                    healthFill.className = 'dragon-health-fill-overhead';
                    healthBar.appendChild(healthFill);
                    
                    document.getElementById('dragonHealthBars').appendChild(healthBar);
                    dragon.healthBar = healthBar;
                    dragon.healthFill = healthFill;
                }
                
                scene.add(dragon);
                dragons.push(dragon);
                
                gameStats.dragonCount++;
                updateDragonCounter();
                
                return dragon;
            } catch (error) {
                console.error("Error creating dragon:", error);
                return null;
            }
        }

        // Update dragon health bars
        function updateDragonHealthBars() {
            dragons.forEach(dragon => {
                if (dragon.healthBar && dragon.health > 0) {
                    // Calculate screen position
                    const vector = new THREE.Vector3();
                    dragon.getWorldPosition(vector);
                    vector.project(camera);
                    
                    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;
                    
                    // Position health bar above dragon
                    dragon.healthBar.style.display = 'block';
                    dragon.healthBar.style.left = `${x - 50}px`;
                    dragon.healthBar.style.top = `${y - 50}px`;
                    
                    // Update health fill
                    const healthPercent = (dragon.health / dragon.maxHealth) * 100;
                    dragon.healthFill.style.width = `${healthPercent}%`;
                } else if (dragon.healthBar) {
                    dragon.healthBar.style.display = 'none';
                }
            });
        }

        // Create ENHANCED RED PORTAL GATE
        function createPortal() {
            try {
                if (portal && scene) scene.remove(portal);
                
                const portalGroup = new THREE.Group();
                
                // Main portal frame - triangular arch (matching dragon theme)
                const frameWidth = 10;
                const frameHeight = 15;
                const frameDepth = 1;
                
                // Left pillar
                const leftPillarGeometry = new THREE.CylinderGeometry(0.5, 0.5, frameHeight, 3);
                const leftPillarMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff0000, 
                    wireframe: true 
                });
                const leftPillar = new THREE.Mesh(leftPillarGeometry, leftPillarMaterial);
                leftPillar.position.set(-frameWidth/2, frameHeight/2, 0);
                leftPillar.rotation.y = Math.PI / 6;
                portalGroup.add(leftPillar);
                
                // Right pillar
                const rightPillarGeometry = new THREE.CylinderGeometry(0.5, 0.5, frameHeight, 3);
                const rightPillarMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff0000, 
                    wireframe: true 
                });
                const rightPillar = new THREE.Mesh(rightPillarGeometry, rightPillarMaterial);
                rightPillar.position.set(frameWidth/2, frameHeight/2, 0);
                rightPillar.rotation.y = -Math.PI / 6;
                portalGroup.add(rightPillar);
                
                // Top arch - triangular
                const topArchGeometry = new THREE.ConeGeometry(1.2, 2, 3);
                const topArchMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff0000, 
                    wireframe: true 
                });
                const topArch = new THREE.Mesh(topArchGeometry, topArchMaterial);
                topArch.position.set(0, frameHeight + 1, 0);
                topArch.rotation.x = Math.PI;
                portalGroup.add(topArch);
                
                // Portal energy field - triangular pattern with particle effect
                const energyGeometry = new THREE.ConeGeometry(frameWidth/2 - 0.5, frameHeight - 2, 3);
                const energyMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff0000, 
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide,
                    wireframe: true
                });
                const energyField = new THREE.Mesh(energyGeometry, energyMaterial);
                energyField.rotation.y = Math.PI / 2; // Make it face the player
                portalGroup.add(energyField);
                
                // Particle effect inside portal
                const portalParticles = createPointCloudMist(0xff0000, 6, true);
                portalGroup.add(portalParticles);
                portalGroup.userData.portalParticles = portalParticles;
                
                // Rotating rings
                const ringCount = 3;
                for (let i = 0; i < ringCount; i++) {
                    const ringGeometry = new THREE.TorusGeometry(4 - i * 1.2, 0.2, 8, 20);
                    const ringMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xff0000, 
                        wireframe: true 
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.position.y = 2 + i * 2;
                    ring.rotation.x = Math.PI / 2;
                    portalGroup.add(ring);
                    portalGroup.userData[`ring${i}`] = ring;
                }
                
                portalGroup.position.set(0, 0, 0);
                scene.add(portalGroup);
                
                portal = portalGroup;
                portalActive = true;
                portalSpawned = true;
                
                // Show portal notification
                const portalNotification = document.getElementById('portalNotification');
                portalNotification.textContent = "PORTAL ACTIVATED! ENTER TO PROCEED";
                portalNotification.style.display = 'block';
                setTimeout(() => {
                    portalNotification.style.display = 'none';
                }, 3000);
            } catch (error) {
                console.error("Error creating portal:", error);
            }
        }

        // Update portal animation
        function updatePortal(delta) {
            try {
                if (!portal || !portalActive) return;
                
                portal.rotation.y += 0.01 * delta * 60;
                
                const time = performance.now() * 0.005;
                
                // Update portal particles
                if (portal.userData.portalParticles) {
                    updatePointCloudMist(portal.userData.portalParticles, delta);
                }
                
                // Rotate rings at different speeds
                for (let i = 0; i < 3; i++) {
                    const ring = portal.userData[`ring${i}`];
                    if (ring) {
                        ring.rotation.z += (0.02 + i * 0.01) * delta * 60;
                    }
                }
                
                // Pulse energy field
                const energyField = portal.children[3]; // Energy field
                if (energyField) {
                    energyField.material.opacity = 0.5 + 0.3 * Math.sin(time * 2);
                }
            } catch (error) {
                console.error("Error updating portal:", error);
            }
        }

        // Start the game
        function startGame() {
            try {
                document.getElementById('mainMenu').style.display = 'none';
                document.getElementById('endGameScreen').style.display = 'none';
                
                // Clear any existing health bars
                document.getElementById('dragonHealthBars').innerHTML = '';
                
                // Reset game stats
                gameStats = {
                    score: 0,
                    currentWave: 1,
                    playerHealth: 100,
                    maxPlayerHealth: 100,
                    playerSpeed: 12,
                    speedBoost: false,
                    playerDamage: 200,
                    gunHeat: 0,
                    maxHeat: 100,
                    heatPerShot: 0,
                    coolingRate: 30,
                    isOverheated: false,
                    fireRate: 25,
                    lastFireTime: 0,
                    damageTaken: 0,
                    dragonsSlayed: 0,
                    dragonPacksCleared: 0,
                    totalPacks: 3, // Now 3 dragons per zone
                    dragonCount: 0,
                    shotsFired: 0,
                    shotsHit: 0
                };
                
                playerLevel = saveData.playerLevel || 1;
                playerExp = saveData.playerExp || 0;
                nextLevelExp = saveData.nextLevelExp || 100;
                updateLevelInfo();
                
                companionDragonCooldown = 0;
                companionDragonActive = false;
                companionDragonEnraged = false;
                companionDragons.forEach(dragon => {
                    if (dragon) {
                        dragon.visible = false;
                        dragon.isActive = false;
                        dragon.enraged = false;
                        const scale = Math.min(3, 0.7 + (playerLevel / 33));
                        dragon.scale.set(scale, scale, scale);
                        dragon.damage = 150 + (playerLevel * 3);
                    }
                });
                updateCompanionDragonUI();
                
                laserCooldown = 0;
                updateLaserCooldownVisual();
                
                boostFuel = 100;
                updateBoostBar();
                
                buzzerTimer = 0;
                updateBuzzerTimer();
                
                portalActive = false;
                portalSpawned = false;
                portalTriggerTime = 0;
                
                triosSpawned = false;
                activeTowers = saveData.towersActivated || 0;
                updateTowerStatus();
                
                // Reset wind tunnel effect
                triosWindTunnelActive = false;
                triosWindTunnelCooldown = 0;
                triosWindTunnelTime = 0;
                
                // Reset Trios AI
                triosAI.currentPhase = 1;
                
                if (player) {
                    player.position.set(0, 1.7, 0);
                    player.rotation.y = Math.PI;
                    player.velocity.set(0, 0, 0);
                }
                
                clearEntities();
                
                updateHealthBar();
                updateDragonCounter();
                updateZoneProgress();
                
                // Create city once at the start
                createCity();
                
                startWave(1);
                
                currentState = GameState.PLAYING;
                gameStartTime = performance.now();
                runTime = 0;
                
                // Clear any existing timer intervals
                if (timerInterval) clearInterval(timerInterval);
                if (countdownInterval) clearInterval(countdownInterval);
                
                // Start buzzer timer
                timerInterval = setInterval(() => {
                    if (currentState === GameState.PLAYING) {
                        buzzerTimer++;
                        updateBuzzerTimer();
                    }
                }, 1000);
            } catch (error) {
                console.error("Error starting game:", error);
            }
        }

        // Start a wave
        function startWave(waveNumber) {
            try {
                gameStats.currentWave = waveNumber;
                gameStats.dragonPacksCleared = 0;
                clearEntities();
                
                const dragonType = dragonTypes[waveNumber-1];
                
                // Update mission info
                document.getElementById('missionName').textContent = `HUNT ${dragonType.name}`;
                document.getElementById('zoneTotal').textContent = dragonType.count;
                document.getElementById('zoneProgress').textContent = '0';
                
                if (waveNumber < 4) {
                    gameStats.totalPacks = dragonType.count;
                    
                    // Create 3 dragons in each zone
                    const dragonCount = dragonType.count;
                    
                    for (let i = 0; i < dragonCount; i++) {
                        const angle = (i / dragonCount) * Math.PI * 2;
                        const radius = 60;
                        const x = Math.cos(angle) * radius;
                        const z = Math.sin(angle) * radius;
                        
                        createEnhancedDragon(new THREE.Vector3(x, 15, z), dragonType, dragonType.aiType);
                    }
                    
                    updateZoneProgress();
                    
                    // Start countdown
                    startCountdown();
                    
                } else {
                    // Boss zone - only if Trios hasn't been spawned yet
                    if (!triosSpawned) {
                        gameStats.totalPacks = 1;
                        
                        const bossPosition = new THREE.Vector3(0, 40, 0);
                        const boss = createEnhancedDragon(bossPosition, dragonType, dragonType.aiType);
                        boss.isBoss = true;
                        boss.minionSpawnThresholds = [0.66, 0.33];
                        boss.minionsSpawned = 0;
                        
                        updateZoneProgress();
                        
                        document.getElementById('dragonHealthContainer').style.display = 'block';
                        
                        // Start countdown
                        startCountdown();
                    }
                }
                
                updateDragonCounter();
                updateZoneProgress();
            } catch (error) {
                console.error("Error starting wave:", error);
            }
        }

        // Start countdown for zone
        function startCountdown() {
            try {
                countdownActive = true;
                countdownTimer = 10;
                document.getElementById('countdownTimer').style.display = 'block';
                updateCountdownTimer();
                
                // Clear any existing countdown interval
                if (countdownInterval) clearInterval(countdownInterval);
                
                countdownInterval = setInterval(() => {
                    if (currentState !== GameState.PLAYING) {
                        clearInterval(countdownInterval);
                        return;
                    }
                    
                    countdownTimer--;
                    updateCountdownTimer();
                    
                    if (countdownTimer <= 0) {
                        clearInterval(countdownInterval);
                        document.getElementById('countdownTimer').style.display = 'none';
                        countdownActive = false;
                        
                        // Apply penalty for not clearing zone in time
                        if (dragons.length > 0 && !portalActive) {
                            gameStats.playerHealth -= 10;
                            gameStats.damageTaken += 10;
                            updateHealthBar();
                            checkPlayerDeath();
                        }
                    }
                }, 1000);
            } catch (error) {
                console.error("Error starting countdown:", error);
            }
        }

        // Update countdown timer display
        function updateCountdownTimer() {
            if (countdownTimer > 0 && countdownTimer <= 10) {
                document.getElementById('countdownTimer').textContent = romanNumerals[10 - countdownTimer];
            } else {
                document.getElementById('countdownTimer').textContent = "X";
            }
        }

        // Update buzzer timer display
        function updateBuzzerTimer() {
            const minutes = Math.floor(buzzerTimer / 60);
            const seconds = buzzerTimer % 60;
            document.getElementById('buzzerTimer').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Update level info
        function updateLevelInfo() {
            document.getElementById('playerLevel').textContent = playerLevel;
            document.getElementById('playerExp').textContent = playerExp;
            document.getElementById('nextLevelExp').textContent = nextLevelExp;
        }

        // Clear entities
        function clearEntities() {
            try {
                // Remove dragons from scene
                dragons.forEach(dragon => {
                    if (dragon && scene) {
                        scene.remove(dragon);
                        // Dispose of geometries and materials
                        dragon.traverse(child => {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(m => m.dispose());
                                } else {
                                    child.material.dispose();
                                }
                            }
                        });
                        
                        // Remove health bar
                        if (dragon.healthBar) {
                            dragon.healthBar.remove();
                        }
                    }
                });
                dragons = [];
                gameStats.dragonCount = 0;
                
                // Remove projectiles from scene
                projectiles.forEach(projectile => {
                    if (projectile && scene) {
                        scene.remove(projectile);
                        if (projectile.geometry) projectile.geometry.dispose();
                        if (projectile.material) projectile.material.dispose();
                    }
                });
                projectiles = [];
                
                // Remove particles from scene
                particles.forEach(particle => {
                    if (particle && scene) {
                        scene.remove(particle);
                        if (particle.geometry) particle.geometry.dispose();
                        if (particle.material) particle.material.dispose();
                    }
                });
                particles = [];
                
                // Remove portal
                if (portal && scene) {
                    scene.remove(portal);
                    portal.traverse(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(m => m.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    });
                    portal = null;
                    portalActive = false;
                    portalSpawned = false;
                }
                
                document.getElementById('dragonHealthContainer').style.display = 'none';
            } catch (error) {
                console.error("Error clearing entities:", error);
            }
        }

        // Update dragon counter
        function updateDragonCounter() {
            document.getElementById('waveCount').textContent = gameStats.currentWave;
        }

        // Update zone progress
        function updateZoneProgress() {
            document.getElementById('zoneProgress').textContent = gameStats.dragonPacksCleared;
            document.getElementById('zoneTotal').textContent = gameStats.totalPacks;
        }

        // Update dragon health display
        function updateDragonHealthDisplay(dragon) {
            if (!dragon) return;
            
            const healthPercent = (dragon.health / dragon.maxHealth) * 100;
            document.getElementById('dragonHealthFill').style.width = `${healthPercent}%`;
            document.getElementById('dragonHealthPercent').textContent = `${Math.round(healthPercent)}%`;
            document.getElementById('dragonHealthLabel').textContent = `${dragon.dragonType.enemyName.toUpperCase()} HEALTH`;
            
            if (dragon.health > 0 && dragon.isBoss) {
                document.getElementById('dragonHealthContainer').style.display = 'block';
            } else {
                document.getElementById('dragonHealthContainer').style.display = 'none';
            }
        }

        // Update health bar
        function updateHealthBar() {
            const healthPercent = (gameStats.playerHealth / gameStats.maxPlayerHealth) * 100;
            document.getElementById('healthFill').style.width = `${healthPercent}%`;
            document.getElementById('healthPercent').textContent = `${Math.round(healthPercent)}%`;
        }

        // Update boost bar
        function updateBoostBar() {
            const boostPercent = (boostFuel / maxBoostFuel) * 100;
            document.getElementById('boostFill').style.width = `${boostPercent}%`;
            document.getElementById('boostPercent').textContent = `${Math.round(boostPercent)}%`;
        }

        // Update companion dragon UI
        function updateCompanionDragonUI() {
            const cooldownPercent = (companionDragonCooldown / companionDragonMaxCooldown) * 100;
            document.getElementById('companionDragonFill').style.width = `${100 - cooldownPercent}%`;
            
            if (companionDragonCooldown > 0) {
                document.getElementById('companionDragonStatus').textContent = `GROWTH: ${Math.ceil(companionDragonCooldown)}s`;
            } else if (companionDragonActive) {
                document.getElementById('companionDragonStatus').textContent = `ENRAGED: ${Math.ceil(companionDragonAttackDuration - companionDragonAttackTime)}s`;
            } else {
                document.getElementById('companionDragonStatus').textContent = "READY [R]";
            }
        }

        // Update laser cooldown visual
        function updateLaserCooldownVisual() {
            const cooldownPercent = laserCooldown / laserMaxCooldown;
            document.getElementById('heatFill').style.width = `${cooldownPercent * 100}%`;
            document.getElementById('heatPercent').textContent = `${Math.round(cooldownPercent * 100)}%`;
            
            const ammoDisplay = document.getElementById('ammoCount');
            if (laserCooldown > 0) {
                ammoDisplay.textContent = "COOLDOWN";
                ammoDisplay.style.color = '#ff0000';
            } else {
                ammoDisplay.textContent = immortalMode ? "INF" : "READY";
                ammoDisplay.style.color = '#0f0';
            }
        }

        // Create projectile system with glitch effects
        function createProjectile(position, direction, speed, color, damage, isPlayerProjectile = false) {
            try {
                // Create triangular projectiles to match the theme
                const geometry = new THREE.ConeGeometry(0.1, 0.3, 3);
                const material = new THREE.MeshBasicMaterial({ 
                    color: color,
                    wireframe: true // Wireframe projectiles
                });
                const projectile = new THREE.Mesh(geometry, material);
                projectile.position.copy(position);
                
                // Orient the projectile in the direction it's moving
                projectile.lookAt(position.clone().add(direction));
                
                // Add glitch trail for red projectiles
                if (color === 0xFF0000) {
                    const trailGeometry = new THREE.BufferGeometry();
                    const trailPositions = new Float32Array(30 * 3); // 10 point trail
                    trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
                    
                    const trailMaterial = new THREE.LineBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.6
                    });
                    
                    const trail = new THREE.Line(trailGeometry, trailMaterial);
                    projectile.add(trail);
                    projectile.userData.trail = trail;
                    projectile.userData.trailPositions = trailPositions;
                    projectile.userData.trailIndex = 0;
                    projectile.userData.isGlitch = true;
                }
                
                projectile.userData.direction = direction.clone().normalize();
                projectile.userData.speed = speed;
                projectile.userData.damage = damage;
                projectile.userData.isPlayerProjectile = isPlayerProjectile;
                projectile.userData.lifetime = 3.0;
                
                scene.add(projectile);
                projectiles.push(projectile);
                return projectile;
            } catch (error) {
                console.error("Error creating projectile:", error);
                return null;
            }
        }

        // Update projectile glitch effects
        function updateProjectileGlitch(projectile, delta) {
            if (!projectile.userData.isGlitch) return;
            
            // Update glitch trail
            const trail = projectile.userData.trail;
            const trailPositions = projectile.userData.trailPositions;
            const trailIndex = projectile.userData.trailIndex;
            
            // Add current position to trail
            const currentIndex = (trailIndex % 10) * 3;
            trailPositions[currentIndex] = projectile.position.x;
            trailPositions[currentIndex + 1] = projectile.position.y;
            trailPositions[currentIndex + 2] = projectile.position.z;
            
            projectile.userData.trailIndex = (trailIndex + 1) % 10;
            trail.geometry.attributes.position.needsUpdate = true;
            
            // Random glitch offset
            if (Math.random() < 0.1) {
                projectile.position.x += (Math.random() - 0.5) * 0.2;
                projectile.position.y += (Math.random() - 0.5) * 0.2;
                projectile.position.z += (Math.random() - 0.5) * 0.2;
            }
        }

        // Create laser beam effect
        function createLaserBeam(start, end, color) {
            try {
                const direction = new THREE.Vector3().subVectors(end, start);
                const length = direction.length();
                const geometry = new THREE.CylinderGeometry(0.05, 0.05, length, 8);
                const material = new THREE.MeshBasicMaterial({ 
                    color: color,
                    wireframe: true // Wireframe laser
                });
                const laser = new THREE.Mesh(geometry, material);
                
                // Position the laser
                laser.position.copy(start).add(end).multiplyScalar(0.5);
                
                // Orient the laser
                laser.lookAt(end);
                laser.rotateX(Math.PI / 2);
                
                scene.add(laser);
                
                // Remove after a short time
                setTimeout(() => {
                    if (scene && laser) {
                        scene.remove(laser);
                        if (laser.geometry) laser.geometry.dispose();
                        if (laser.material) laser.material.dispose();
                    }
                }, 100);
                
                return laser;
            } catch (error) {
                console.error("Error creating laser beam:", error);
                return null;
            }
        }

        // Update projectiles
        function updateProjectiles(delta) {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const projectile = projectiles[i];
                if (!projectile) continue;
                
                // Move projectile
                projectile.position.add(projectile.userData.direction.clone().multiplyScalar(projectile.userData.speed * delta));
                
                // Update glitch effects
                updateProjectileGlitch(projectile, delta);
                
                // Update lifetime
                projectile.userData.lifetime -= delta;
                if (projectile.userData.lifetime <= 0) {
                    scene.remove(projectile);
                    if (projectile.geometry) projectile.geometry.dispose();
                    if (projectile.material) projectile.material.dispose();
                    projectiles.splice(i, 1);
                    continue;
                }
                
                // Check collisions
                if (projectile.userData.isPlayerProjectile) {
                    // Player projectiles hit dragons
                    for (let j = 0; j < dragons.length; j++) {
                        const dragon = dragons[j];
                        if (dragon && dragon.health > 0 && projectile.position.distanceTo(dragon.position) < dragon.dragonType.size * 2) {
                            // Hit dragon
                            dragon.health -= projectile.userData.damage;
                            createExplosion(projectile.position, 0xff0000, 5);
                            
                            gameStats.shotsHit++;
                            
                            // Award EXP equal to damage dealt
                            playerExp += projectile.userData.damage;
                            
                            if (dragon.health <= 0) {
                                dragonDefeated(dragon);
                            } else if (gameStats.currentWave === 4 || dragon.isTrios) {
                                updateDragonHealthDisplay(dragon);
                                
                                // Check for Trios minion spawning
                                if (dragon.isTrios && dragon.minionSpawnThresholds) {
                                    const healthPercent = dragon.health / dragon.maxHealth;
                                    
                                    // Check if we've crossed a threshold
                                    for (let k = 0; k < dragon.minionSpawnThresholds.length; k++) {
                                        if (healthPercent < dragon.minionSpawnThresholds[k] && 
                                            dragon.minionsSpawned <= k) {
                                            
                                            // Spawn 3 minions
                                            for (let m = 0; m < 3; m++) {
                                                const offset = new THREE.Vector3(
                                                    (Math.random() - 0.5) * 40,
                                                    30,
                                                    (Math.random() - 0.5) * 40
                                                );
                                                createEnhancedDragon(dragon.position.clone().add(offset), dragonTypes[0], dragonTypes[0].aiType); // Spawn Whisp Dragons
                                            }
                                            
                                            dragon.minionsSpawned = k + 1;
                                            
                                            // Show minion spawn notification
                                            const portalNotification = document.getElementById('portalNotification');
                                            portalNotification.textContent = "TRIOS SUMMONS MINIONS!";
                                            portalNotification.style.display = 'block';
                                            setTimeout(() => {
                                                portalNotification.style.display = 'none';
                                            }, 2000);
                                            
                                            break;
                                        }
                                    }
                                }
                                
                                // Update Trios AI phases
                                if (dragon.isTrios) {
                                    if (healthPercent < 0.66 && triosAI.currentPhase === 1) {
                                        triosAI.currentPhase = 2;
                                        dragon.aiType = triosAI.phase2;
                                        console.log("TRIOS PHASE 2: TACTICAL MODE");
                                    } else if (healthPercent < 0.33 && triosAI.currentPhase === 2) {
                                        triosAI.currentPhase = 3;
                                        dragon.aiType = triosAI.phase3;
                                        console.log("TRIOS PHASE 3: AMBUSH MODE");
                                    }
                                }
                            }
                            
                            scene.remove(projectile);
                            if (projectile.geometry) projectile.geometry.dispose();
                            if (projectile.material) projectile.material.dispose();
                            projectiles.splice(i, 1);
                            break;
                        }
                    }
                } else {
                    // Enemy projectiles hit player
                    if (player && projectile.position.distanceTo(player.position) < 1.5) {
                        // Hit player
                        if (!immortalMode) {
                            gameStats.playerHealth -= projectile.userData.damage;
                            gameStats.damageTaken += projectile.userData.damage;
                            updateHealthBar();
                            createExplosion(projectile.position, 0x00ff00, 3);
                            checkPlayerDeath();
                        }
                        
                        scene.remove(projectile);
                        if (projectile.geometry) projectile.geometry.dispose();
                        if (projectile.material) projectile.material.dispose();
                        projectiles.splice(i, 1);
                    }
                }
            }
        }

        // Create explosion particles
        function createExplosion(position, color, count) {
            try {
                for (let i = 0; i < count; i++) {
                    const geometry = new THREE.SphereGeometry(0.05 + Math.random() * 0.1, 4, 4);
                    const material = new THREE.MeshBasicMaterial({ 
                        color: color,
                        wireframe: true // Wireframe explosions
                    });
                    const particle = new THREE.Mesh(geometry, material);
                    particle.position.copy(position);
                    particle.userData = {
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 10,
                            (Math.random() - 0.5) * 10,
                            (Math.random() - 0.5) * 10
                        ),
                        lifetime: 1.0 + Math.random() * 0.5
                    };
                    scene.add(particle);
                    particles.push(particle);
                }
            } catch (error) {
                console.error("Error creating explosion:", error);
            }
        }

        // Update particles
        function updateParticles(delta) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                if (!particle) continue;
                
                particle.userData.lifetime -= delta;
                if (particle.userData.lifetime <= 0) {
                    scene.remove(particle);
                    if (particle.geometry) particle.geometry.dispose();
                    if (particle.material) particle.material.dispose();
                    particles.splice(i, 1);
                    continue;
                }
                
                // Move particle
                particle.position.add(particle.userData.velocity.clone().multiplyScalar(delta));
                
                // Fade out
                particle.material.opacity = particle.userData.lifetime;
            }
        }

        // Check player death
        function checkPlayerDeath() {
            if (gameStats.playerHealth <= 0 && !immortalMode) {
                gameStats.playerHealth = 0;
                updateHealthBar();
                console.log("GAME OVER - Player defeated");
                saveGame();
                showEndGameScreen();
            }
        }

        // Save game function
        function saveGame() {
            try {
                saveData = {
                    playerLevel: playerLevel,
                    playerExp: playerExp,
                    nextLevelExp: nextLevelExp,
                    companionLevel: Math.max(1, Math.floor(playerLevel / 3)),
                    towersActivated: activeTowers,
                    gameStats: { ...gameStats }
                };
                
                localStorage.setItem('triosPurgeSave', JSON.stringify(saveData));
                console.log("Game saved successfully");
                
                // Show save notification
                const portalNotification = document.getElementById('portalNotification');
                portalNotification.textContent = "GAME SAVED!";
                portalNotification.style.display = 'block';
                setTimeout(() => {
                    portalNotification.style.display = 'none';
                }, 2000);
            } catch (error) {
                console.error("Error saving game:", error);
            }
        }

        // Load game function
        function loadGame() {
            try {
                const savedData = localStorage.getItem('triosPurgeSave');
                if (savedData) {
                    saveData = JSON.parse(savedData);
                    console.log("Game loaded successfully");
                    
                    // Update load button text
                    document.getElementById('loadBtn').textContent = `LOAD (Lvl ${saveData.playerLevel})`;
                }
            } catch (error) {
                console.error("Error loading game:", error);
            }
        }

        // Set up event listeners
        function setupEventListeners() {
            // Menu event listeners
            document.getElementById('skipIntro').addEventListener('click', showBootSequence);
            document.getElementById('skipStory').addEventListener('click', showMainMenu);
            document.getElementById('startBtn').addEventListener('click', startGame);
            document.getElementById('loadBtn').addEventListener('click', () => {
                if (saveData.playerLevel > 1) {
                    playerLevel = saveData.playerLevel;
                    playerExp = saveData.playerExp;
                    nextLevelExp = saveData.nextLevelExp;
                    activeTowers = saveData.towersActivated;
                    startGame();
                } else {
                    alert("No saved game found!");
                }
            });
            document.getElementById('settingsBtn').addEventListener('click', () => {
                alert("Settings would show control list here");
            });
            
            // End game screen buttons
            document.getElementById('restartBtn').addEventListener('click', startGame);
            document.getElementById('menuBtn').addEventListener('click', showMainMenu);
            
            // Game control event listeners
            document.addEventListener('keydown', (e) => {
                if (currentState !== GameState.PLAYING) return;
                
                switch(e.code) {
                    case 'KeyW': controls.moveForward = true; break;
                    case 'KeyS': controls.moveBackward = true; break;
                    case 'KeyA': controls.moveLeft = true; break;
                    case 'KeyD': controls.moveRight = true; break;
                    case 'Space': controls.jetpack = true; break;
                    case 'ShiftLeft':
                    case 'ShiftRight': controls.speedBoost = true; break;
                    case 'KeyR':
                        if (!controls.summonCompanions) {
                            controls.summonCompanions = true;
                            activateCompanionDragons();
                        }
                        break;
                    case 'KeyC': 
                        cpuMode = !cpuMode;
                        break;
                    case 'KeyP':
                        // Portal interaction
                        if (portalActive && player && portal) {
                            const distance = player.position.distanceTo(portal.position);
                            if (distance < 5) {
                                portalTriggerTime = performance.now();
                            }
                        }
                        break;
                    case 'KeyO': // Save game
                        saveGame();
                        break;
                    case 'KeyL': // Load game
                        if (confirm("Load saved game? Current progress will be lost.")) {
                            loadGame();
                            startGame();
                        }
                        break;
                    case 'Escape': 
                        if (currentState === GameState.PLAYING) {
                            showMainMenu();
                            currentState = GameState.MENU;
                            saveGame();
                        }
                        break;
                }
            });
            
            document.addEventListener('keyup', (e) => {
                switch(e.code) {
                    case 'KeyW': controls.moveForward = false; break;
                    case 'KeyS': controls.moveBackward = false; break;
                    case 'KeyA': controls.moveLeft = false; break;
                    case 'KeyD': controls.moveRight = false; break;
                    case 'Space': controls.jetpack = false; break;
                    case 'ShiftLeft':
                    case 'ShiftRight': controls.speedBoost = false; break;
                    case 'KeyR': controls.summonCompanions = false; break;
                }
            });
            
            document.addEventListener('mousedown', (e) => {
                if (currentState === GameState.PLAYING && pointerLocked) {
                    if (e.button === 0) controls.fireGatling = true;
                    else if (e.button === 2) {
                        controls.fireLaser = true;
                        fireLaser();
                    }
                }
            });
            
            document.addEventListener('mouseup', (e) => {
                if (e.button === 0) controls.fireGatling = false;
                else if (e.button === 2) controls.fireLaser = false;
            });
            
            document.addEventListener('contextmenu', (e) => { e.preventDefault(); });
            
            // Pointer lock setup
            const canvas = document.getElementById('gameCanvas');
            
            canvas.addEventListener('click', () => {
                if (!pointerLocked && currentState === GameState.PLAYING) {
                    if ('pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document) {
                        canvas.requestPointerLock();
                    } else {
                        alert("Pointer lock not supported in this browser");
                    }
                }
            });
            
            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === canvas) {
                    pointerLocked = true;
                } else {
                    pointerLocked = false;
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                if (pointerLocked && currentState === GameState.PLAYING) {
                    controls.mouseX = e.movementX * mouseSensitivity;
                    controls.mouseY = e.movementY * mouseSensitivity;
                    
                    if (player) {
                        player.rotation.y -= controls.mouseX;
                        camera.rotation.x -= controls.mouseY;
                        
                        camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                    }
                }
            });
            
            window.addEventListener('resize', () => {
                if (camera) {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                }
                if (renderer) {
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
            });
        }

        // Fire gatling gun
        function fireGatlingGun() {
            const now = Date.now();
            if (now - gameStats.lastFireTime < gameStats.fireRate) return;
            
            const cameraWorldPosition = new THREE.Vector3();
            camera.getWorldPosition(cameraWorldPosition);
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            
            // Minimal spread for accuracy
            const spread = 0.02;
            direction.x += (Math.random() - 0.5) * spread;
            direction.y += (Math.random() - 0.5) * spread;
            direction.z += (Math.random() - 0.5) * spread;
            direction.normalize();
            
            // Create projectile
            createProjectile(cameraWorldPosition, direction, 50, 0x00ff00, gameStats.playerDamage, true);
            
            gameStats.lastFireTime = now;
            gameStats.shotsFired++;
        }

        // Fire laser - Continuous stream with companion dragons
        function fireLaser() {
            if (laserCooldown > 0) return;
            
            laserCooldown = laserMaxCooldown;
            updateLaserCooldownVisual();
            
            // Show laser overlay
            const laserOverlay = document.getElementById('laserOverlay');
            laserOverlay.style.display = 'block';
            laserOverlay.style.animation = 'laserPulse 0.5s';
            
            setTimeout(() => {
                laserOverlay.style.display = 'none';
            }, 500);
            
            const cameraWorldPosition = new THREE.Vector3();
            camera.getWorldPosition(cameraWorldPosition);
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            
            // Create laser projectile (fast and powerful)
            const laserEnd = cameraWorldPosition.clone().add(direction.clone().multiplyScalar(100));
            createLaserBeam(cameraWorldPosition, laserEnd, 0xff0000);
            createProjectile(cameraWorldPosition, direction, 100, 0xff0000, laserDamage, true);
            
            gameStats.shotsFired++;
            
            // Fire companion dragon lasers if active
            if (companionDragonActive) {
                companionDragons.forEach(companion => {
                    if (companion && companion.isActive) {
                        const companionDirection = new THREE.Vector3();
                        companionDirection.subVectors(cameraWorldPosition, companion.position).normalize();
                        
                        // Create laser beam from companion
                        const companionLaserEnd = companion.position.clone().add(companionDirection.clone().multiplyScalar(100));
                        createLaserBeam(companion.position, companionLaserEnd, 0x00ff00);
                        
                        // Create companion projectile
                        createProjectile(companion.position, companionDirection, 120, 0x00ff00, companion.damage * 2, true);
                    }
                });
            }
        }

        // Activate companion dragons
        function activateCompanionDragons() {
            if (companionDragonCooldown > 0) {
                return;
            }
            
            if (companionDragonActive) {
                companionDragonAttackTime = 0;
                return;
            }
            
            companionDragonActive = true;
            companionDragonEnraged = true;
            companionDragonAttackTime = 0;
            
            companionDragons.forEach(dragon => {
                if (dragon) {
                    dragon.visible = true;
                    dragon.isActive = true;
                    dragon.enraged = true;
                    const scale = Math.min(5, 3 + (playerLevel / 25));
                    dragon.scale.set(scale, scale, scale);
                    dragon.damage = 600 + (playerLevel * 10);
                    if (player) {
                        dragon.position.copy(player.position);
                    } else {
                        dragon.position.set(0, 2, 0);
                    }
                    dragon.position.y += 2;
                }
            });
            
            // Show enraged message
            console.log("WARNING: DOUBLE DRAGON DRONES ENRAGED");
        }

        // Update companion dragons
        function updateCompanionDragons(delta) {
            if (!companionDragonActive || !player) return;
            companionDragonAttackTime += delta;
            const now = Date.now();
            
            companionDragons.forEach((companion, i) => {
                if (!companion || !companion.isActive) return;

                // Farther away orbit
                const offset = new THREE.Vector3(Math.cos(i * Math.PI) * 8, 3, Math.sin(i * Math.PI) * 8);
                const targetPosition = player.position.clone().add(offset);
                companion.position.lerp(targetPosition, 0.1);

                let nearestDragon = null;
                let minDistance = Infinity;
                dragons.forEach(dragon => {
                    if (dragon && dragon.health > 0) {
                        const distance = companion.position.distanceTo(dragon.position);
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestDragon = dragon;
                        }
                    }
                });
                
                // Set player's current target
                if (nearestDragon) {
                    player.currentTarget = nearestDragon;
                }
                
                if (nearestDragon && nearestDragon.health > 0) {
                    companion.lookAt(nearestDragon.position);
                    if (now - companion.lastFire > companion.fireRate) {
                        // Create companion projectile
                        const direction = new THREE.Vector3();
                        direction.subVectors(nearestDragon.position, companion.position).normalize();
                        createProjectile(companion.position, direction, 40, 0x00ff00, companion.damage, true);
                        
                        companion.lastFire = now;
                    }
                }
            });
            
            if (companionDragonAttackTime >= companionDragonAttackDuration) {
                companionDragonActive = false;
                companionDragonEnraged = false;
                companionDragonCooldown = companionDragonMaxCooldown;
                companionDragons.forEach(dragon => {
                    if (dragon) {
                        dragon.visible = false;
                        dragon.isActive = false;
                        dragon.enraged = false;
                        const scale = Math.min(3, 0.7 + (playerLevel / 33));
                        dragon.scale.set(scale, scale, scale);
                        dragon.damage = 150 + (playerLevel * 3);
                    }
                });
                updateCompanionDragonUI();
            }
        }

        // Update companion dragon cooldown
        function updateCompanionDragonCooldown(delta) {
            if (companionDragonCooldown > 0) {
                companionDragonCooldown -= delta;
                if (companionDragonCooldown < 0) companionDragonCooldown = 0;
                updateCompanionDragonUI();
            }
        }

        // Update boost system
        function updateBoostSystem(delta) {
            if (controls.jetpack && boostFuel > 0) {
                boostActive = true;
                boostFuel = Math.max(0, boostFuel - 30 * delta);
            } else {
                boostActive = false;
                if (boostFuel < maxBoostFuel) {
                    boostFuel = Math.min(maxBoostFuel, boostFuel + boostFuelRegenRate * delta);
                }
            }
            updateBoostBar();
        }

        // Quake 3 Arena Dragon AI Logic
        function updateDragonAI(dragon, delta) {
            if (!dragon || !player || dragon.health <= 0) return;
            
            const ai = dragon.aiType || dragonAITypes.AGGRESSIVE;
            const distanceToPlayer = dragon.position.distanceTo(player.position);
            
            // Smooth rotation towards player
            const direction = new THREE.Vector3();
            direction.subVectors(player.position, dragon.position).normalize();
            const targetQuaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), direction);
            dragon.quaternion.slerp(targetQuaternion, 0.1);

            // Banking tilt based on turning
            const sideVector = new THREE.Vector3().crossVectors(direction, dragon.up);
            const bankAngle = sideVector.dot(dragon.up) * 0.3;
            dragon.rotation.z = THREE.MathUtils.lerp(dragon.rotation.z, bankAngle, 0.1);
            
            // Quake 3 style decision making
            if (distanceToPlayer <= ai.chargeDistance && Math.random() < ai.aggression) {
                // Charge attack with knockback
                performChargeAttack(dragon);
            } else if (distanceToPlayer <= ai.attackRange) {
                // Strafe and fire
                if (Math.random() < ai.strafeChance) {
                    performStrafeMovement(dragon, delta);
                }
                if (Math.random() < ai.accuracy) {
                    fireAtPlayer(dragon);
                }
            } else {
                // Close distance
                moveTowardPlayer(dragon, delta);
            }
            
            // Spyro-inspired movement flourishes
            addSpyroMovement(dragon, delta);
        }

        function performChargeAttack(dragon) {
            const chargeDirection = new THREE.Vector3();
            chargeDirection.subVectors(player.position, dragon.position).normalize();
            
            // Add knockback force to player
            if (player) {
                player.velocity.add(chargeDirection.multiplyScalar(30));
            }
            
            // Create charge visual effect
            createChargeEffect(dragon.position, dragon.dragonType.color);
        }

        function performStrafeMovement(dragon, delta) {
            // Circle strafing like Quake bots
            const strafeDirection = new THREE.Vector3();
            strafeDirection.crossVectors(
                new THREE.Vector3(0, 1, 0),
                dragon.position.clone().sub(player.position).normalize()
            );
            
            if (Math.random() < 0.5) strafeDirection.negate();
            
            dragon.position.add(strafeDirection.multiplyScalar(dragon.speed * 0.7 * delta));
        }

        function addSpyroMovement(dragon, delta) {
            // Spyro-style wing flaps and bobbing
            const time = performance.now() * 0.001;
            dragon.position.y += Math.sin(time * 4) * 0.1 * delta * 60;
            
            // Gentle wing animation
            dragon.children.forEach(child => {
                if (child.userData && child.userData.isWing) {
                    child.rotation.x = Math.sin(time * 3) * 0.2;
                }
            });
        }

        function moveTowardPlayer(dragon, delta) {
            const direction = new THREE.Vector3();
            direction.subVectors(player.position, dragon.position).normalize();
            dragon.position.add(direction.multiplyScalar(dragon.speed * 0.5 * delta));
        }

        function fireAtPlayer(dragon) {
            const now = Date.now();
            if (now - dragon.lastFire < dragon.baseFireRate) return;
            
            const direction = new THREE.Vector3();
            direction.subVectors(player.position, dragon.position).normalize();
            
            // Add some spread based on AI accuracy
            const spread = 1 - dragon.aiType.accuracy;
            direction.x += (Math.random() - 0.5) * spread;
            direction.y += (Math.random() - 0.5) * spread;
            direction.z += (Math.random() - 0.5) * spread;
            direction.normalize();
            
            createProjectile(dragon.position, direction, 20, dragon.dragonType.color, dragon.damage, false);
            dragon.lastFire = now;
        }

        function createChargeEffect(position, color) {
            // Create a visual effect for charge attacks
            createExplosion(position, color, 10);
        }

        // Update player movement
        function updatePlayer(delta) {
            if (!player || currentState !== GameState.PLAYING) return;
            
            if (controls.fireGatling) fireGatlingGun();
            if (controls.fireLaser && laserCooldown <= 0) fireLaser();
            
            if (laserCooldown > 0) {
                laserCooldown -= delta;
                if (laserCooldown < 0) laserCooldown = 0;
                updateLaserCooldownVisual();
            }
            
            // Update boost system
            updateBoostSystem(delta);
            
            // Movement input
            const moveVector = new THREE.Vector3();
            if (controls.moveForward) moveVector.z -= 1;
            if (controls.moveBackward) moveVector.z += 1;
            if (controls.moveLeft) moveVector.x -= 1;
            if (controls.moveRight) moveVector.x += 1;
            if (moveVector.length() > 0) moveVector.normalize();
            moveVector.applyEuler(new THREE.Euler(0, player.rotation.y, 0));
            
            // Speed
            let speed = gameStats.playerSpeed;
            if (controls.speedBoost) speed *= 1.7;
            
            // Set horizontal velocity
            const horizontalVelocity = moveVector.multiplyScalar(speed);
            player.velocity.x = horizontalVelocity.x;
            player.velocity.z = horizontalVelocity.z;
            
            // Jetpack and gravity
            if (boostActive && boostFuel > 0) {
                player.velocity.y += 12 * delta;
            } else {
                player.velocity.y -= 10 * delta;
            }
            
            // Apply velocity to position
            player.position.add(player.velocity.clone().multiplyScalar(delta));
            
            // Bounds - larger for expanded map
            const zoneSize = 120;
            player.position.x = Math.max(-zoneSize, Math.min(zoneSize, player.position.x));
            player.position.z = Math.max(-zoneSize, Math.min(zoneSize, player.position.z));
            player.position.y = Math.max(1.7, Math.min(80, player.position.y));
            
            // Check portal interaction
            if (portalActive && portal) {
                const distance = player.position.distanceTo(portal.position);
                if (distance < 5) {
                    if (portalTriggerTime === 0) {
                        portalTriggerTime = performance.now();
                    } else if (performance.now() - portalTriggerTime > 1000) {
                        // Warp after 1 second in portal
                        if (gameStats.currentWave < 4) {
                            startWave(gameStats.currentWave + 1);
                        } else {
                            // Game completed
                            showEndGameScreen();
                        }
                        portalTriggerTime = 0;
                    }
                } else {
                    portalTriggerTime = 0;
                }
            }
            
            updateHealthBar();
            
            // Check for level up
            if (playerExp >= nextLevelExp) {
                playerLevel++;
                playerExp -= nextLevelExp;
                nextLevelExp = Math.floor(nextLevelExp * 1.2);
                
                // Level up benefits
                gameStats.maxPlayerHealth += 10;
                gameStats.playerHealth = gameStats.maxPlayerHealth;
                gameStats.playerDamage += 20;
                gameStats.playerSpeed += 0.5;
                
                // Update companion dragons
                companionDragons.forEach(dragon => {
                    if (dragon) {
                        const scale = Math.min(3, 0.7 + (playerLevel / 33));
                        dragon.scale.set(scale, scale, scale);
                        dragon.damage = 150 + (playerLevel * 3);
                    }
                });
                
                updateHealthBar();
                updateLevelInfo();
            }
        }

        // Create wind tunnel effect for Trios
        function createWindTunnel(dragon) {
            if (!dragon || !player) return;
            
            // Push player away from Trios
            const pushDirection = new THREE.Vector3();
            pushDirection.subVectors(player.position, dragon.position).normalize();
            player.velocity.add(pushDirection.multiplyScalar(50));
            
            // Create wind particles
            for (let i = 0; i < 200; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1, 4, 4);
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff0000, 
                    transparent: true, 
                    opacity: 0.6 
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // Position particles in front of Trios
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 5;
                const offset = new THREE.Vector3(
                    Math.cos(angle) * radius,
                    Math.random() * 10 - 5,
                    Math.sin(angle) * radius
                );
                
                particle.position.copy(dragon.position).add(offset);
                
                // Set velocity away from Trios
                particle.userData = {
                    velocity: pushDirection.clone().multiplyScalar(30 + Math.random() * 20),
                    lifetime: 2.0 + Math.random()
                };
                
                scene.add(particle);
                particles.push(particle);
            }
            
            // Show wind tunnel notification
            const portalNotification = document.getElementById('portalNotification');
            portalNotification.textContent = "WIND TUNNEL! HOLD YOUR GROUND!";
            portalNotification.style.display = 'block';
            setTimeout(() => {
                portalNotification.style.display = 'none';
            }, 2000);
        }

        // Update dragons with Quake 3 AI
        function updateDragons(delta) {
            const now = Date.now();
            for (let i = 0; i < dragons.length; i++) {
                const dragon = dragons[i];
                if (!dragon || dragon.health <= 0) continue;
                
                // Update point cloud mist
                if (dragon.userData.mistParticles) {
                    updatePointCloudMist(dragon.userData.mistParticles, delta);
                }
                
                // Update Trios wind tunnel
                if (dragon.isTrios) {
                    // Update wind tunnel cooldown
                    triosWindTunnelCooldown += delta;
                    
                    // Cast wind tunnel every 15 seconds
                    if (triosWindTunnelCooldown >= triosWindTunnelMaxCooldown && !triosWindTunnelActive) {
                        triosWindTunnelActive = true;
                        triosWindTunnelTime = 0;
                        createWindTunnel(dragon);
                    }
                    
                    // Update active wind tunnel
                    if (triosWindTunnelActive) {
                        triosWindTunnelTime += delta;
                        
                        // Continue pushing player during wind tunnel
                        if (triosWindTunnelTime < triosWindTunnelDuration) {
                            const pushDirection = new THREE.Vector3();
                            pushDirection.subVectors(player.position, dragon.position).normalize();
                            player.velocity.add(pushDirection.multiplyScalar(20 * delta));
                        } else {
                            // End wind tunnel
                            triosWindTunnelActive = false;
                            triosWindTunnelCooldown = 0;
                        }
                    }
                }
                
                // Use Quake 3 AI for all dragons
                updateDragonAI(dragon, delta);
                
                // Keep dragons in bounds
                dragon.position.x = Math.max(-100, Math.min(100, dragon.position.x));
                dragon.position.z = Math.max(-100, Math.min(100, dragon.position.z));
                dragon.position.y = Math.max(10, Math.min(40, dragon.position.y));
            }
        }

        // Dragon defeated
        function dragonDefeated(dragon) {
            if (!dragon) return;
            
            // Create explosion effect
            createExplosion(dragon.position, dragon.dragonType.color, 15);
            
            scene.remove(dragon);
            
            // Remove health bar
            if (dragon.healthBar) {
                dragon.healthBar.remove();
            }
            
            const index = dragons.indexOf(dragon);
            if (index > -1) dragons.splice(index, 1);
            
            gameStats.dragonsSlayed++;
            gameStats.dragonCount--;
            
            if (gameStats.currentWave < 4) {
                gameStats.dragonPacksCleared++;
                updateZoneProgress();
                
                // Check if all dragons are defeated
                if (dragons.length === 0 && !portalSpawned) {
                    createPortal();
                    
                    // Activate a tower when a wave is cleared
                    activateTower();
                }
            } else {
                // Hide boss health bar when boss defeated
                document.getElementById('dragonHealthContainer').style.display = 'none';
                
                // Check if boss is defeated
                if (dragon.isBoss && !portalSpawned) {
                    createPortal();
                    
                    // Activate a tower when a boss is defeated
                    if (!dragon.isTrios) {
                        activateTower();
                    }
                }
                
                // Special case for Trios
                if (dragon.isTrios) {
                    // Game completed - show victory message
                    const portalNotification = document.getElementById('portalNotification');
                    portalNotification.textContent = "TRIOS DEFEATED! YOU SAVED THE GRID!";
                    portalNotification.style.display = 'block';
                    
                    // Save game on victory
                    saveGame();
                    
                    // Show end game screen after a delay
                    setTimeout(() => {
                        showEndGameScreen();
                    }, 3000);
                }
            }
            
            updateDragonCounter();
            
            if (gameStats.currentWave >= gameStats.totalWaves && dragons.length === 0 && !portalSpawned) {
                // Game victory
                createPortal();
            }
        }

        // Update FPS counter
        function updateFPS(delta) {
            frameCount++;
            lastFpsUpdate += delta;
            if (lastFpsUpdate >= 1.0) {
                fps = Math.round(frameCount / lastFpsUpdate);
                document.getElementById('fpsCounter').textContent = `FPS: ${fps}`;
                frameCount = 0;
                lastFpsUpdate = 0;
            }
        }

        // Update gatling gun
        function updateGatlingGun(delta) {
            if (!gatlingBarrels) return;
            
            if (controls.fireGatling) {
                gatlingBarrelSpeed = Math.min(80, gatlingBarrelSpeed + 40 * delta);
            } else {
                gatlingBarrelSpeed = Math.max(0, gatlingBarrelSpeed - 80 * delta);
            }
            
            gatlingBarrelRotation += gatlingBarrelSpeed * delta;
            gatlingBarrels.rotation.z = gatlingBarrelRotation;
        }

        // CPU auto-mode
        function updateCPUMode(delta) {
            if (!cpuMode || !player) return;
            
            // Auto-target nearest dragon
            let nearestDragon = null;
            let minDistance = Infinity;
            dragons.forEach(dragon => {
                if (dragon && dragon.health > 0) {
                    const distance = player.position.distanceTo(dragon.position);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestDragon = dragon;
                    }
                }
            });
            
            if (nearestDragon) {
                // Look at the dragon
                const direction = new THREE.Vector3();
                direction.subVectors(nearestDragon.position, player.position).normalize();
                const targetYaw = Math.atan2(direction.x, direction.z);
                const targetPitch = Math.asin(-direction.y);
                
                player.rotation.y = THREE.MathUtils.lerp(player.rotation.y, targetYaw, 0.1);
                camera.rotation.x = THREE.MathUtils.lerp(camera.rotation.x, targetPitch, 0.1);
                
                // Auto-fire
                controls.fireGatling = true;
                
                // Auto-move to maintain distance
                const idealDistance = 25;
                if (minDistance < idealDistance - 5) {
                    controls.moveBackward = true;
                    controls.moveForward = false;
                } else if (minDistance > idealDistance + 5) {
                    controls.moveForward = true;
                    controls.moveBackward = false;
                } else {
                    controls.moveForward = false;
                    controls.moveBackward = false;
                }
                
                // Strafe randomly
                if (Math.random() < 0.01) {
                    controls.moveLeft = !controls.moveLeft;
                    controls.moveRight = !controls.moveRight;
                }
            } else {
                controls.fireGatling = false;
                controls.moveForward = false;
                controls.moveBackward = false;
                controls.moveLeft = false;
                controls.moveRight = false;
            }
        }

        // Main animation loop
        function animate() {
            try {
                animationFrameId = requestAnimationFrame(animate);
                const delta = Math.min(clock.getDelta(), 0.1);
                runTime += delta;
                
                updateFPS(delta);
                
                switch(currentState) {
                    case GameState.PLAYING:
                        if (cpuMode) updateCPUMode(delta);
                        updatePlayer(delta);
                        updateDragons(delta);
                        updateCompanionDragons(delta);
                        updateCompanionDragonCooldown(delta);
                        updateGatlingGun(delta);
                        updateProjectiles(delta);
                        updateParticles(delta);
                        updateGridFloor(delta);
                        updatePortal(delta);
                        updateDragonHealthBars();
                        break;
                }
                
                if (renderer && scene && camera) {
                    renderer.render(scene, camera);
                }
            } catch (error) {
                console.error("Error in animation loop:", error);
                // Attempt to recover by restarting animation
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }
                setTimeout(() => {
                    animate();
                }, 100);
            }
        }

        // Initialize the game when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
