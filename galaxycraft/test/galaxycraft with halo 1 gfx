<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>GalaxyCraft Enhanced | Halo-Inspired Retro Space Combat</title>
  <meta name="description" content="Experience enhanced GalaxyCraft with Halo: Combat Evolved-inspired visuals - low-poly models, flat shading, and retro effects.">
  <meta name="keywords" content="GalaxyCraft, Halo, space combat, WebGL, retro gaming, Xbox graphics">
  <meta name="author" content="WebXOS">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Orbitron', 'Courier New', monospace;
    }
    body {
      background: #000;
      color: #0ff;
      height: 100vh;
      overflow: hidden;
      touch-action: none;
      image-rendering: pixelated;
    }
    #gameCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      image-rendering: pixelated;
    }
    .crt-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(rgba(18, 16, 16, 0.1) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
      z-index: 100;
      background-size: 100% 4px, 6px 100%;
      pointer-events: none;
      opacity: 0.6;
    }
    .scanlines {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(to bottom, rgba(255,255,255,0.03) 50%, rgba(0,0,0,0.1) 50%);
      background-size: 100% 4px;
      z-index: 101;
      pointer-events: none;
      opacity: 0.4;
    }
    /* Main UI */
    .ui-container {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      z-index: 20;
      padding: 15px;
      background: rgba(0, 20, 30, 0.7);
      border-radius: 20px;
      border: 2px solid #0ff;
      backdrop-filter: blur(5px);
      transition: all 0.5s ease;
    }
    .ui-btn {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      background: linear-gradient(145deg, #003344, #001122);
      border: 2px solid #0ff;
      color: #0ff;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
      transition: all 0.2s ease;
    }
    .ui-btn:hover {
      background: linear-gradient(145deg, #004455, #002233);
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
    }
    .ui-btn.active {
      background: linear-gradient(145deg, #ff3300, #cc2200);
      border-color: #ff3300;
      box-shadow: 0 0 20px rgba(255, 51, 0, 0.8);
      color: #fff;
    }
    .ui-btn .key {
      font-size: 20px;
      font-weight: bold;
      margin-bottom: 4px;
    }
    
    /* Combat Mode UI - Halo Inspired */
    .combat-ui {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 5;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.5s ease;
    }
    .combat-ui.active {
      opacity: 1;
    }
    .halo-targeting-reticle {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 80px;
      height: 80px;
      border: 2px solid #0f0;
      border-radius: 50%;
      box-shadow: 0 0 20px rgba(0, 255, 0, 0.7);
      z-index: 15;
    }
    .halo-targeting-reticle::before, .halo-targeting-reticle::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #0f0;
    }
    .halo-targeting-reticle::before {
      width: 60px;
      height: 2px;
    }
    .halo-targeting-reticle::after {
      width: 2px;
      height: 60px;
    }
    
    .combat-stats {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border: 2px solid #0f0;
      border-radius: 10px;
      font-size: 16px;
      color: #0f0;
      z-index: 15;
    }
    .health-bar, .shield-bar {
      width: 200px;
      height: 20px;
      background: #333;
      border-radius: 10px;
      margin: 10px 0;
      overflow: hidden;
    }
    .health-fill {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, #f00, #ff3300);
      border-radius: 10px;
      transition: width 0.3s ease;
    }
    .shield-fill {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, #0cf, #06f);
      border-radius: 10px;
      transition: width 0.3s ease;
    }
    .warning-alert {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 36px;
      color: #f00;
      text-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
      text-align: center;
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: 25;
      pointer-events: none;
    }
    .warning-alert.active {
      animation: alert-flash 0.5s infinite alternate;
    }
    @keyframes alert-flash {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    /* Currency Display */
    .currency-display {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border: 2px solid #0f0;
      border-radius: 10px;
      font-size: 16px;
      color: #0f0;
      z-index: 15;
      display: flex;
      align-items: center;
    }
    .currency-icon {
      color: #0f0;
      font-size: 20px;
      margin-right: 10px;
    }
    
    /* Drone Status */
    .drone-status {
      position: absolute;
      top: 80px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border: 2px solid #0ff;
      border-radius: 10px;
      font-size: 14px;
      color: #0ff;
      z-index: 15;
      display: none;
    }
    .drone-status.active {
      display: block;
    }
    
    /* Main Menu */
    .main-menu {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 10, 20, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      color: #0ff;
    }
    .game-title {
      font-size: 60px;
      margin-bottom: 40px;
      text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
      letter-spacing: 4px;
    }
    .menu-options {
      display: flex;
      flex-direction: column;
      gap: 20px;
      width: 300px;
    }
    .menu-btn {
      padding: 15px 30px;
      background: linear-gradient(145deg, #003344, #001122);
      border: 2px solid #0ff;
      color: #0ff;
      font-size: 20px;
      text-align: center;
      cursor: pointer;
      border-radius: 10px;
      transition: all 0.3s ease;
    }
    .menu-btn:hover {
      background: linear-gradient(145deg, #004455, #002233);
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
      transform: translateY(-3px);
    }
    .settings-panel {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 20, 30, 0.9);
      padding: 30px;
      border: 2px solid #0ff;
      border-radius: 15px;
      width: 400px;
      display: none;
      z-index: 110;
    }
    .settings-panel h2 {
      margin-bottom: 20px;
      text-align: center;
    }
    .settings-row {
      display: flex;
      justify-content: space-between;
      margin: 15px 0;
    }
    .settings-row label {
      font-size: 18px;
    }
    .settings-row input {
      background: #002233;
      border: 1px solid #0ff;
      color: #0ff;
      padding: 5px 10px;
      border-radius: 5px;
      width: 80px;
    }
    .close-settings {
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      color: #0ff;
      font-size: 20px;
      cursor: pointer;
    }
    
    /* Console Messages */
    .console-message {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 10px 20px;
      border: 2px solid #0ff;
      border-radius: 10px;
      color: #0ff;
      font-size: 18px;
      opacity: 0;
      transition: opacity 0.5s ease;
      z-index: 25;
    }
    .console-message.active {
      opacity: 1;
    }
    
    /* Light Speed Effect */
    .light-speed-effect {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(0,0,0,0) 70%);
      z-index: 30;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease;
    }
    .light-speed-effect.active {
      opacity: 1;
      animation: lightSpeed 10s linear;
    }
    @keyframes lightSpeed {
      0% { transform: scale(1); opacity: 0.8; }
      100% { transform: scale(3); opacity: 0; }
    }
    
    /* Explosion Effect */
    .explosion-effect {
      position: absolute;
      width: 100px;
      height: 100px;
      border-radius: 50%;
      background: radial-gradient(circle, #ff3300 0%, rgba(255,51,0,0) 70%);
      box-shadow: 0 0 50px rgba(255, 100, 0, 0.8);
      z-index: 5;
      opacity: 0;
      pointer-events: none;
    }
    
    /* Halo-style low-poly aesthetic */
    .poly-count {
      position: absolute;
      bottom: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 5px 10px;
      border: 1px solid #0f0;
      border-radius: 5px;
      font-size: 12px;
      color: #0f0;
      z-index: 15;
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      .ui-container {
        bottom: 10px;
        padding: 10px;
        gap: 10px;
      }
      .ui-btn {
        width: 60px;
        height: 60px;
        font-size: 10px;
      }
      .ui-btn .key {
        font-size: 16px;
      }
      .game-title {
        font-size: 40px;
      }
      .menu-btn {
        padding: 12px 24px;
        font-size: 18px;
      }
      .combat-stats {
        bottom: 100px;
        left: 10px;
        font-size: 14px;
        padding: 10px;
      }
      .health-bar, .shield-bar {
        width: 150px;
        height: 15px;
      }
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    
    <!-- CRT and Scanline Effects -->
    <div class="crt-overlay"></div>
    <div class="scanlines"></div>
    
    <!-- Combat Mode UI -->
    <div class="combat-ui" id="combatUI">
      <div class="halo-targeting-reticle"></div>
    </div>
    
    <!-- Light Speed Effect -->
    <div class="light-speed-effect" id="lightSpeedEffect"></div>
    
    <!-- Combat Stats -->
    <div class="combat-stats">
      <div>WAVE: <span id="waveCount">1</span></div>
      <div>ENEMIES: <span id="enemyCount">0</span></div>
      <div>SCORE: <span id="combatScore">0</span></div>
      <div>HEALTH:</div>
      <div class="health-bar"><div class="health-fill" id="healthFill" style="width: 100%"></div></div>
      <div>SHIELD:</div>
      <div class="shield-bar"><div class="shield-fill" id="shieldFill" style="width: 100%"></div></div>
    </div>
    
    <!-- Currency Display -->
    <div class="currency-display">
      <span class="currency-icon">$</span>
      <span id="currencyCount">0</span>
    </div>
    
    <!-- Drone Status -->
    <div class="drone-status" id="droneStatus">
      <div>DRONES: <span id="droneCount">0</span>/3</div>
      <div>FORMATION: <span id="formationType">FOLLOW</span></div>
      <div>LEVEL: <span id="droneLevel">1</span></div>
    </div>
    
    <!-- Poly Count Display (Halo-style) -->
    <div class="poly-count">
      POLYS: <span id="polyCount">0</span>
    </div>
    
    <div class="warning-alert" id="warningAlert">INCOMING!</div>
    
    <!-- Main UI Controls -->
    <div class="ui-container">
      <div class="ui-btn" id="thrustBtn">
        <div class="key">W</div>
        <div>THRUST</div>
      </div>
      <div class="ui-btn" id="combatBtn">
        <div class="key">ALT</div>
        <div>SWARM</div>
      </div>
      <div class="ui-btn" id="ecoBtn">
        <div class="key">TAB</div>
        <div>ECO MODE</div>
      </div>
      <div class="ui-btn" id="fireBtn">
        <div class="key">SPC</div>
        <div>FIRE</div>
      </div>
      <div class="ui-btn" id="boostBtn">
        <div class="key">SHIFT</div>
        <div>BOOST</div>
      </div>
      <div class="ui-btn" id="menuBtn">
        <div class="key">ESC</div>
        <div>MENU</div>
      </div>
    </div>
    
    <!-- Console Messages -->
    <div class="console-message" id="consoleMessage"></div>
    
    <!-- Main Menu -->
    <div class="main-menu" id="mainMenu">
      <h1 class="game-title">GALAXYCRAFT ENHANCED</h1>
      <div class="menu-options">
        <div class="menu-btn" id="startBtn">SINGLE PLAYER</div>
        <div class="menu-btn" id="multiplayerBtn">MULTIPLAYER</div>
        <div class="menu-btn" id="settingsBtn">SETTINGS</div>
        <div class="menu-btn" id="quitBtn">QUIT</div>
      </div>
      
      <div class="settings-panel" id="settingsPanel">
        <button class="close-settings" id="closeSettings">X</button>
        <h2>GAME SETTINGS</h2>
        <div class="settings-row">
          <label>Mouse Sensitivity:</label>
          <input type="number" id="mouseSensitivity" value="0.003" step="0.001" min="0.001" max="0.01">
        </div>
        <div class="settings-row">
          <label>Invert Y-Axis:</label>
          <input type="checkbox" id="invertYAxis">
        </div>
        <div class="settings-row">
          <label>Flight Assist:</label>
          <input type="checkbox" id="flightAssist" checked>
        </div>
        <div class="settings-row">
          <label>Sound Volume:</label>
          <input type="range" id="soundVolume" min="0" max="100" value="80">
        </div>
        <div class="settings-row">
          <label>Retro Mode:</label>
          <input type="checkbox" id="retroMode" checked>
        </div>
        <div class="settings-row">
          <label>Polygon Limit:</label>
          <input type="range" id="polyLimit" min="500" max="5000" value="1500">
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
    // Game state and configuration
    const GameState = {
      MENU: 0,
      PLAYING: 1,
      COMBAT: 2,
      ECO: 3,
      PAUSED: 4
    };
    
    const FormationType = {
      FOLLOW: "FOLLOW",
      PATROL: "PATROL",
      COPY: "COPY"
    };
    
    let currentState = GameState.MENU;
    let mouseSensitivity = 0.003;
    let invertYAxis = false;
    let flightAssist = true;
    let retroMode = true;
    let polyLimit = 1500;
    let totalPolyCount = 0;
    
    // Initialize Three.js
    let scene, camera, renderer;
    let player, playerModel, enemies = [], projectiles = [], drones = [], celestialObjects = [], currency = [];
    let mixers = [];
    let clock = new THREE.Clock();
    
    // Post-processing variables for bloom effect
    let renderTarget, renderTarget2, bloomComposer, finalComposer;
    let bloomPass, copyPass;
    
    // Player controls state
    const controls = {
      forward: false,
      backward: false,
      left: false,
      right: false,
      up: false,
      down: false,
      boost: false,
      fire: false,
      combat: false,
      eco: false,
      rollLeft: false,
      rollRight: false,
      lightSpeed: false,
      spin180: false,
      deployNuke: false,
      deployDrone: false
    };
    
    // Player stats
    const playerStats = {
      health: 100,
      shield: 100,
      score: 0,
      currency: 0,
      wave: 1,
      speed: 30,
      ecoSpeed: 15,
      boostMultiplier: 2,
      lightSpeedMultiplier: 10,
      lightSpeedActive: false,
      lightSpeedCooldown: 0,
      fireRate: 0.05, // Faster firing rate
      lastFire: 0,
      rotationSpeed: 2.0,
      droneCount: 0,
      maxDrones: 3,
      droneLevel: 1,
      formation: FormationType.FOLLOW,
      experience: 0,
      level: 1,
      invincible: true // For testing
    };
    
    // Initialize the game
    function init() {
      // Set up scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000010);
      scene.fog = new THREE.Fog(0x000010, 50, 500);
      
      // Set up camera - Third person view like StarFox
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
      camera.position.set(0, 3, 10);
      
      // Set up renderer with lower resolution for retro feel
      renderer = new THREE.WebGLRenderer({ 
        canvas: document.getElementById('gameCanvas'),
        antialias: false, // Disable antialiasing for retro look
        powerPreference: "high-performance"
      });
      
      // Set a lower resolution for that authentic Xbox feel
      const dpr = retroMode ? Math.min(1, window.devicePixelRatio) : window.devicePixelRatio;
      renderer.setPixelRatio(dpr);
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.BasicShadowMap; // Basic shadows for performance
      
      // Setup post-processing for bloom effects (Halo-style glow)
      setupPostProcessing();
      
      // Add lighting - Halo used simple directional lighting
      const ambientLight = new THREE.AmbientLight(0x444455);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(5, 5, 5);
      directionalLight.castShadow = true;
      scene.add(directionalLight);
      
      // Create starfield with fewer stars for performance
      createStarfield();
      
      // Create celestial objects with low-poly models
      createCelestialObjects();
      
      // Create player ship with low-poly design
      createPlayerShip();
      
      // Create home planet with low-poly design
      createHomePlanet();
      
      // Create initial enemies with low-poly models
      spawnEnemyWave(10);
      
      // Set up event listeners
      setupEventListeners();
      
      // Start animation loop
      animate();
      
      // Show console message
      showConsoleMessage("GalaxyCraft Enhanced initialized. Ready for launch!");
      
      // Update poly count display
      updatePolyCount();
    }
    
    // Setup post-processing for bloom effects (Halo-style glow)
    function setupPostProcessing() {
      // Create render targets
      const parameters = {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat
      };
      
      renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, parameters);
      renderTarget2 = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, parameters);
      
      // Create bloom pass for Halo-style glow effects
      bloomPass = {
        render: function(renderer, writeBuffer, readBuffer) {
          // Simple bloom implementation
          renderer.setRenderTarget(renderTarget2);
          renderer.clear();
          renderer.render(scene, camera);
          
          // Apply blur for bloom effect
          renderer.setRenderTarget(renderTarget);
          renderer.clear();
          renderer.render(scene, camera);
          
          // Combine with original
          renderer.setRenderTarget(null);
          renderer.clear();
          renderer.render(scene, camera);
        }
      };
    }
    
    // Create starfield background with fewer stars
    function createStarfield() {
      const starGeometry = new THREE.BufferGeometry();
      const starMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.7, // Slightly larger stars for retro look
        sizeAttenuation: true
      });
      
      const starVertices = [];
      for (let i = 0; i < 5000; i++) { // Reduced star count for performance
        const x = (Math.random() - 0.5) * 2000;
        const y = (Math.random() - 0.5) * 2000;
        const z = (Math.random() - 0.5) * 2000;
        starVertices.push(x, y, z);
      }
      
      starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
      const stars = new THREE.Points(starGeometry, starMaterial);
      scene.add(stars);
      
      // Update poly count (points count as polys for our display)
      totalPolyCount += 5000;
    }
    
    // Create celestial objects (planets, asteroids, etc.) with low-poly models
    function createCelestialObjects() {
      // Create asteroid belt with low-poly models
      for (let i = 0; i < 50; i++) { // Reduced asteroid count for performance
        const size = 0.5 + Math.random() * 3;
        // Use low-poly geometry (BoxGeometry instead of Sphere for that angular look)
        const asteroidGeometry = new THREE.BoxGeometry(size, size, size, 3, 3, 3);
        const asteroidMaterial = new THREE.MeshPhongMaterial({
          color: 0x888888,
          emissive: 0x333333,
          specular: 0xaaaaaa,
          shininess: 30,
          flatShading: true // Flat shading for that Halo look
        });
        
        const asteroid = new THREE.Mesh(asteroidGeometry, asteroidMaterial);
        
        // Position in a belt formation
        const angle = Math.random() * Math.PI * 2;
        const radius = 100 + Math.random() * 50;
        const height = (Math.random() - 0.5) * 20;
        
        asteroid.position.set(
          Math.cos(angle) * radius,
          height,
          Math.sin(angle) * radius
        );
        
        asteroid.rotation.set(
          Math.random() * Math.PI,
          Math.random() * Math.PI,
          Math.random() * Math.PI
        );
        
        asteroid.velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 0.5,
          (Math.random() - 0.5) * 0.2,
          (Math.random() - 0.5) * 0.5
        );
        
        asteroid.isAsteroid = true;
        asteroid.health = size * 10;
        
        scene.add(asteroid);
        celestialObjects.push(asteroid);
        
        // Update poly count (box with 3x3x3 divisions has 96 faces)
        totalPolyCount += 96;
      }
      
      // Create some distant planets with low-poly models
      for (let i = 0; i < 5; i++) {
        const size = 10 + Math.random() * 20;
        // Use low-poly spheres (Icosphere with low detail)
        const planetGeometry = new THREE.IcosahedronGeometry(size, 1); // Low detail
        
        // Different colors for different planets
        const colors = [0x3366ff, 0xff6633, 0x33ff66, 0xff33cc, 0xffff33];
        const planetMaterial = new THREE.MeshPhongMaterial({
          color: colors[i],
          emissive: colors[i] - 0x222222,
          specular: 0xffffff,
          shininess: 50,
          flatShading: true // Flat shading for retro look
        });
        
        const planet = new THREE.Mesh(planetGeometry, planetMaterial);
        
        // Position planets far away
        const angle = (i / 5) * Math.PI * 2;
        const radius = 300 + Math.random() * 200;
        
        planet.position.set(
          Math.cos(angle) * radius,
          (Math.random() - 0.5) * 100,
          Math.sin(angle) * radius
        );
        
        planet.isPlanet = true;
        
        scene.add(planet);
        celestialObjects.push(planet);
        
        // Update poly count (icosphere with detail 1 has 80 faces)
        totalPolyCount += 80;
      }
    }
    
    // Create home planet with low-poly design
    function createHomePlanet() {
      const planetGeometry = new THREE.IcosahedronGeometry(25, 1); // Low-poly
      const planetMaterial = new THREE.MeshPhongMaterial({
        color: 0x00ff00,
        emissive: 0x00aa00,
        specular: 0xffffff,
        shininess: 70,
        flatShading: true, // Flat shading for retro look
        wireframe: false
      });
      
      const homePlanet = new THREE.Mesh(planetGeometry, planetMaterial);
      homePlanet.position.set(0, 0, -200);
      homePlanet.isHomePlanet = true;
      homePlanet.health = 1000;
      
      scene.add(homePlanet);
      celestialObjects.push(homePlanet);
      
      // Update poly count (icosphere with detail 1 has 80 faces)
      totalPolyCount += 80;
    }
    
    // Create player ship with low-poly design
    function createPlayerShip() {
      // Create a group for the player to allow for easier camera following
      player = new THREE.Group();
      scene.add(player);
      
      // Create the ship model with low-poly geometry
      const bodyGeometry = new THREE.CylinderGeometry(0.8, 1.2, 4, 6); // Low poly count
      const wingGeometry = new THREE.BoxGeometry(3, 0.2, 1.5, 1, 1, 1);
      const tailGeometry = new THREE.BoxGeometry(1, 1, 1, 1, 1, 1);
      
      const shipMaterial = new THREE.MeshPhongMaterial({
        color: 0x0066ff,
        emissive: 0x0033aa,
        specular: 0xffffff,
        shininess: 100,
        flatShading: true // Flat shading for retro look
      });
      
      // Main body
      playerModel = new THREE.Mesh(bodyGeometry, shipMaterial);
      playerModel.rotation.x = Math.PI / 2;
      playerModel.position.z = -2;
      player.add(playerModel);
      
      // Wings
      const leftWing = new THREE.Mesh(wingGeometry, shipMaterial);
      leftWing.position.set(-1.5, 0, -1.5);
      leftWing.rotation.z = Math.PI / 6;
      player.add(leftWing);
      
      const rightWing = new THREE.Mesh(wingGeometry, shipMaterial);
      rightWing.position.set(1.5, 0, -1.5);
      rightWing.rotation.z = -Math.PI / 6;
      player.add(rightWing);
      
      // Tail
      const tail = new THREE.Mesh(tailGeometry, shipMaterial);
      tail.position.set(0, 0, -3);
      tail.scale.set(0.5, 1, 2);
      player.add(tail);
      
      // Add engine glow with Halo-style effects
      const engineGeometry = new THREE.BoxGeometry(0.6, 0.6, 0.6, 1, 1, 1); // Low-poly
      const engineMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        emissive: 0x0088ff,
        transparent: true,
        opacity: 0.9
      });
      
      const leftEngine = new THREE.Mesh(engineGeometry, engineMaterial);
      leftEngine.position.set(-0.8, 0, -3.5);
      player.add(leftEngine);
      
      const rightEngine = new THREE.Mesh(engineGeometry, engineMaterial);
      rightEngine.position.set(0.8, 0, -3.5);
      player.add(rightEngine);
      
      // Center engine
      const centerEngine = new THREE.Mesh(engineGeometry, engineMaterial);
      centerEngine.position.set(0, 0, -3.5);
      centerEngine.scale.set(0.8, 0.8, 1.5);
      player.add(centerEngine);
      
      // Center the player in the scene
      player.position.set(0, 0, 0);
      
      // Add movement direction indicator
      player.movementDirection = new THREE.Vector3(0, 0, -1);
      
      // Update poly count
      // Cylinder with 6 segments: ~24 faces, 3 boxes: 18 faces, 3 engine boxes: 18 faces
      totalPolyCount += 24 + 18 + 18;
    }
    
    // Spawn a wave of enemies with low-poly models
    function spawnEnemyWave(count) {
      for (let i = 0; i < count; i++) {
        // Use low-poly pyramid instead of cone
        const enemyGeometry = new THREE.ConeGeometry(1.2, 2.5, 4); // Low poly count
        const enemyMaterial = new THREE.MeshPhongMaterial({
          color: 0xff0000,
          emissive: 0xaa0000,
          specular: 0xff6666,
          shininess: 100,
          flatShading: true // Flat shading for retro look
        });
        
        const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
        
        // Position enemies in front of the player
        const angle = Math.random() * Math.PI * 2;
        const radius = 50 + Math.random() * 100;
        const height = (Math.random() - 0.5) * 50;
        
        enemy.position.set(
          Math.cos(angle) * radius,
          height,
          Math.sin(angle) * radius - 100
        );
        
        enemy.rotation.x = Math.PI;
        
        enemy.velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 5,
          (Math.random() - 0.5) * 5,
          (Math.random() - 0.5) * 5
        );
        
        enemy.isEnemy = true;
        enemy.health = 30;
        enemy.shield = 10;
        enemy.shieldActive = true;
        enemy.lastFire = 0;
        enemy.fireRate = 0.5 + Math.random() * 0.5;
        
        scene.add(enemy);
        enemies.push(enemy);
        
        // Update poly count (cone with 4 segments: ~16 faces)
        totalPolyCount += 16;
      }
      
      // Update enemy count display
      document.getElementById('enemyCount').textContent = enemies.length;
    }
    
    // Set up event listeners
    function setupEventListeners() {
      // Keyboard controls
      document.addEventListener('keydown', (e) => {
        switch(e.key.toLowerCase()) {
          case 'w': controls.forward = true; break;
          case 's': controls.backward = true; break;
          case 'a': controls.left = true; break;
          case 'd': controls.right = true; break;
          case 'q': controls.rollLeft = true; break;
          case 'e': controls.rollRight = true; break;
          case ' ': controls.fire = true; break;
          case 'shift': controls.boost = true; break;
          case 'alt': controls.combat = true; break;
          case 'tab': controls.eco = true; break;
          case 'r': controls.lightSpeed = true; break;
          case 'f': controls.spin180 = true; break;
          case 'x': controls.deployNuke = true; break;
          case 'c': controls.deployDrone = true; break;
          case 'escape': toggleMenu(); break;
        }
      });
      
      document.addEventListener('keyup', (e) => {
        switch(e.key.toLowerCase()) {
          case 'w': controls.forward = false; break;
          case 's': controls.backward = false; break;
          case 'a': controls.left = false; break;
          case 'd': controls.right = false; break;
          case 'q': controls.rollLeft = false; break;
          case 'e': controls.rollRight = false; break;
          case ' ': controls.fire = false; break;
          case 'shift': controls.boost = false; break;
          case 'alt': controls.combat = false; break;
          case 'tab': controls.eco = false; break;
          case 'r': controls.lightSpeed = false; break;
          case 'f': controls.spin180 = false; break;
          case 'x': controls.deployNuke = false; break;
          case 'c': controls.deployDrone = false; break;
        }
      });
      
      // Mouse movement for camera control
      let mouseX = 0, mouseY = 0;
      document.addEventListener('mousemove', (e) => {
        mouseX = e.movementX * mouseSensitivity;
        mouseY = e.movementY * mouseSensitivity * (invertYAxis ? -1 : 1);
        
        // Rotate camera based on mouse movement
        if (currentState === GameState.PLAYING || currentState === GameState.COMBAT) {
          camera.rotation.y -= mouseX;
          camera.rotation.x -= mouseY;
          
          // Limit camera rotation
          camera.rotation.x = Math.max(-Math.PI/3, Math.min(Math.PI/3, camera.rotation.x));
        }
      });
      
      // UI button event listeners
      document.getElementById('startBtn').addEventListener('click', () => {
        startGame();
      });
      
      document.getElementById('settingsBtn').addEventListener('click', () => {
        document.getElementById('settingsPanel').style.display = 'block';
      });
      
      document.getElementById('closeSettings').addEventListener('click', () => {
        document.getElementById('settingsPanel').style.display = 'none';
      });
      
      document.getElementById('quitBtn').addEventListener('click', () => {
        // In a real game, this might quit to desktop
        showConsoleMessage("Game session saved. Safe travels, pilot!");
      });
      
      // Window resize handler
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }
    
    // Toggle menu
    function toggleMenu() {
      if (currentState === GameState.MENU) {
        document.getElementById('mainMenu').style.display = 'none';
        currentState = GameState.PLAYING;
      } else {
        document.getElementById('mainMenu').style.display = 'flex';
        currentState = GameState.MENU;
      }
    }
    
    // Start the game
    function startGame() {
      document.getElementById('mainMenu').style.display = 'none';
      currentState = GameState.PLAYING;
      playerStats.invincible = false;
      showConsoleMessage("Mission start! Protect the home planet from enemy forces.");
    }
    
    // Show console message
    function showConsoleMessage(message) {
      const consoleElement = document.getElementById('consoleMessage');
      consoleElement.textContent = message;
      consoleElement.classList.add('active');
      
      setTimeout(() => {
        consoleElement.classList.remove('active');
      }, 3000);
    }
    
    // Update poly count display
    function updatePolyCount() {
      document.getElementById('polyCount').textContent = totalPolyCount;
    }
    
    // Main animation loop
    function animate() {
      requestAnimationFrame(animate);
      
      const delta = clock.getDelta();
      
      // Update animations
      for (const mixer of mixers) {
        mixer.update(delta);
      }
      
      // Update game state based on current state
      switch(currentState) {
        case GameState.PLAYING:
        case GameState.COMBAT:
        case GameState.ECO:
          updatePlayer(delta);
          updateCamera(delta);
          updateEnemies(delta);
          updateProjectiles(delta);
          updateCelestialObjects(delta);
          updateCurrency(delta);
          updateDrones(delta);
          checkCollisions();
          break;
      }
      
      // Apply post-processing if enabled
      if (retroMode) {
        bloomPass.render(renderer, null, null);
      } else {
        renderer.render(scene, camera);
      }
    }
    
    // Update player position and rotation
    function updatePlayer(delta) {
      // Calculate movement speed based on mode
      let speed = playerStats.speed;
      if (controls.boost) speed *= playerStats.boostMultiplier;
      if (controls.eco) speed = playerStats.ecoSpeed;
      if (playerStats.lightSpeedActive) speed *= playerStats.lightSpeedMultiplier;
      
      // Movement direction based on camera orientation
      const direction = new THREE.Vector3();
      camera.getWorldDirection(direction);
      direction.y = 0; // Keep movement mostly horizontal
      direction.normalize();
      
      // Forward/backward movement
      if (controls.forward) {
        player.position.add(direction.clone().multiplyScalar(speed * delta));
      }
      if (controls.backward) {
        player.position.add(direction.clone().multiplyScalar(-speed * delta * 0.7));
      }
      
      // Strafe left/right
      const right = new THREE.Vector3();
      right.crossVectors(camera.up, direction).normalize();
      
      if (controls.left) {
        player.position.add(right.clone().multiplyScalar(-speed * delta * 0.7));
      }
      if (controls.right) {
        player.position.add(right.clone().multiplyScalar(speed * delta * 0.7));
      }
      
      // Up/down movement
      if (controls.up) {
        player.position.y += speed * delta * 0.7;
      }
      if (controls.down) {
        player.position.y -= speed * delta * 0.7;
      }
      
      // Roll left/right
      if (controls.rollLeft) {
        player.rotation.z += playerStats.rotationSpeed * delta;
      }
      if (controls.rollRight) {
        player.rotation.z -= playerStats.rotationSpeed * delta;
      }
      
      // Apply flight assist (gradual return to level flight)
      if (flightAssist && !controls.rollLeft && !controls.rollRight) {
        player.rotation.z *= 0.95;
        if (Math.abs(player.rotation.z) < 0.01) player.rotation.z = 0;
      }
      
      // Light speed effect
      if (controls.lightSpeed && playerStats.lightSpeedCooldown <= 0) {
        activateLightSpeed();
      }
      
      // Update light speed cooldown
      if (playerStats.lightSpeedCooldown > 0) {
        playerStats.lightSpeedCooldown -= delta;
      }
      
      // Firing weapons
      if (controls.fire && Date.now() - playerStats.lastFire > playerStats.fireRate * 1000) {
        fireWeapon();
        playerStats.lastFire = Date.now();
      }
      
      // Update player model tilt based on movement
      if (playerModel) {
        const targetTiltX = (controls.right ? -0.3 : 0) + (controls.left ? 0.3 : 0);
        const targetTiltZ = (controls.forward ? 0.2 : 0) + (controls.backward ? -0.2 : 0);
        
        playerModel.rotation.z = THREE.MathUtils.lerp(playerModel.rotation.z, targetTiltZ, 0.1);
        playerModel.rotation.x = THREE.MathUtils.lerp(playerModel.rotation.x, targetTiltX, 0.1);
      }
    }
    
    // Update camera position relative to player
    function updateCamera(delta) {
      // Camera follows player with a slight delay for smooth movement
      const targetPosition = player.position.clone();
      targetPosition.y += 3;
      targetPosition.z += 10;
      
      camera.position.lerp(targetPosition, 0.1);
      
      // Camera looks slightly ahead of the player
      const lookAtPosition = player.position.clone();
      lookAtPosition.z -= 10;
      
      camera.lookAt(lookAtPosition);
    }
    
    // Update enemy positions and behaviors
    function updateEnemies(delta) {
      for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        
        // Simple AI: Move toward player
        const direction = new THREE.Vector3();
        direction.subVectors(player.position, enemy.position).normalize();
        
        // Add some random movement to make it less predictable
        direction.x += (Math.random() - 0.5) * 0.3;
        direction.y += (Math.random() - 0.5) * 0.3;
        direction.z += (Math.random() - 0.5) * 0.3;
        direction.normalize();
        
        // Move toward player
        enemy.position.add(direction.multiplyScalar(15 * delta));
        
        // Rotate to face player
        enemy.lookAt(player.position);
        
        // Enemy firing logic
        if (Date.now() - enemy.lastFire > enemy.fireRate * 1000) {
          enemyFire(enemy);
          enemy.lastFire = Date.now();
        }
        
        // Check if enemy is too far away and remove it
        if (enemy.position.distanceTo(player.position) > 500) {
          scene.remove(enemy);
          enemies.splice(i, 1);
          
          // Update enemy count display
          document.getElementById('enemyCount').textContent = enemies.length;
        }
      }
      
      // Spawn new wave if all enemies are defeated
      if (enemies.length === 0) {
        playerStats.wave++;
        spawnEnemyWave(10 + playerStats.wave * 2);
        document.getElementById('waveCount').textContent = playerStats.wave;
        showConsoleMessage(`Wave ${playerStats.wave}! More enemies incoming!`);
      }
    }
    
    // Update projectile positions
    function updateProjectiles(delta) {
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const projectile = projectiles[i];
        
        // Move projectile
        projectile.position.add(projectile.velocity.clone().multiplyScalar(60 * delta));
        
        // Check if projectile is too far away
        if (projectile.position.distanceTo(player.position) > 300) {
          scene.remove(projectile);
          projectiles.splice(i, 1);
        }
      }
    }
    
    // Update celestial objects (asteroids, planets)
    function updateCelestialObjects(delta) {
      for (const obj of celestialObjects) {
        if (obj.isAsteroid) {
          // Rotate asteroids
          obj.rotation.x += 0.01;
          obj.rotation.y += 0.02;
          
          // Move asteroids slightly
          obj.position.add(obj.velocity.clone().multiplyScalar(delta));
        }
        
        if (obj.isPlanet) {
          // Rotate planets slowly
          obj.rotation.y += 0.001;
        }
      }
    }
    
    // Update currency items
    function updateCurrency(delta) {
      for (let i = currency.length - 1; i >= 0; i--) {
        const item = currency[i];
        
        // Rotate slowly
        item.rotation.y += 0.02;
        
        // Check if player is close enough to collect
        if (item.position.distanceTo(player.position) < 5) {
          playerStats.currency += 10;
          document.getElementById('currencyCount').textContent = playerStats.currency;
          scene.remove(item);
          currency.splice(i, 1);
          
          // Show visual feedback
          showConsoleMessage("+10 Credits");
        }
      }
    }
    
    // Update drone behaviors
    function updateDrones(delta) {
      for (let i = 0; i < drones.length; i++) {
        const drone = drones[i];
        const formationOffset = getFormationOffset(i);
        
        // Calculate target position based on formation
        const targetPosition = player.position.clone().add(formationOffset);
        
        // Move toward target position
        drone.position.lerp(targetPosition, 0.1);
        
        // Rotate to face forward
        drone.lookAt(player.position);
      }
    }
    
    // Get formation offset based on drone index and formation type
    function getFormationOffset(index) {
      switch(playerStats.formation) {
        case FormationType.FOLLOW:
          // Follow behind player in a line
          return new THREE.Vector3(
            (index - (playerStats.droneCount - 1) / 2) * 3,
            0,
            5
          );
          
        case FormationType.PATROL:
          // Circle around player
          const angle = (Date.now() / 1000) + (index / playerStats.droneCount) * Math.PI * 2;
          return new THREE.Vector3(
            Math.cos(angle) * 8,
            Math.sin(angle) * 3,
            -5
          );
          
        case FormationType.COPY:
          // Copy player's position with offset
          return new THREE.Vector3(
            (index % 2 === 0 ? -3 : 3),
            (index < 2 ? 2 : -2),
            -2
          );
          
        default:
          return new THREE.Vector3();
      }
    }
    
    // Check for collisions between objects
    function checkCollisions() {
      // Check player-projectile collisions
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const projectile = projectiles[i];
        
        if (projectile.isEnemyProjectile && 
            projectile.position.distanceTo(player.position) < 3) {
          // Player hit by enemy projectile
          if (!playerStats.invincible) {
            playerStats.shield -= 5;
            if (playerStats.shield < 0) {
              playerStats.health += playerStats.shield; // Shield overflow damages health
              playerStats.shield = 0;
            }
            
            // Update UI
            document.getElementById('shieldFill').style.width = `${playerStats.shield}%`;
            document.getElementById('healthFill').style.width = `${playerStats.health}%`;
            
            // Show warning if health is low
            if (playerStats.health < 30) {
              document.getElementById('warningAlert').classList.add('active');
            }
          }
          
          // Remove projectile
          scene.remove(projectile);
          projectiles.splice(i, 1);
        }
        
        // Check enemy-player projectile collisions
        if (!projectile.isEnemyProjectile) {
          for (let j = enemies.length - 1; j >= 0; j--) {
            const enemy = enemies[j];
            
            if (projectile.position.distanceTo(enemy.position) < 3) {
              // Enemy hit by player projectile
              if (enemy.shieldActive) {
                enemy.shield -= 10;
                if (enemy.shield <= 0) {
                  enemy.shieldActive = false;
                  enemy.material.emissive.set(0xff0000);
                }
              } else {
                enemy.health -= 20;
              }
              
              // Remove projectile
              scene.remove(projectile);
              projectiles.splice(i, 1);
              
              // Check if enemy is destroyed
              if (enemy.health <= 0) {
                // Create explosion effect
                createExplosion(enemy.position);
                
                // Add score
                playerStats.score += 100;
                document.getElementById('combatScore').textContent = playerStats.score;
                
                // Sometimes drop currency
                if (Math.random() > 0.7) {
                  createCurrencyItem(enemy.position);
                }
                
                // Remove enemy
                scene.remove(enemy);
                enemies.splice(j, 1);
                
                // Update enemy count display
                document.getElementById('enemyCount').textContent = enemies.length;
              }
              
              break;
            }
          }
        }
      }
      
      // Check player-enemy collisions
      for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        
        if (enemy.position.distanceTo(player.position) < 5) {
          // Collision with enemy
          if (!playerStats.invincible) {
            playerStats.health -= 10;
            
            // Update UI
            document.getElementById('healthFill').style.width = `${playerStats.health}%`;
            
            // Show warning if health is low
            if (playerStats.health < 30) {
              document.getElementById('warningAlert').classList.add('active');
            }
          }
          
          // Create explosion effect
          createExplosion(enemy.position);
          
          // Remove enemy
          scene.remove(enemy);
          enemies.splice(i, 1);
          
          // Update enemy count display
          document.getElementById('enemyCount').textContent = enemies.length;
        }
      }
      
      // Check player-asteroid collisions
      for (const asteroid of celestialObjects) {
        if (asteroid.isAsteroid && asteroid.position.distanceTo(player.position) < 5) {
          // Collision with asteroid
          if (!playerStats.invincible) {
            playerStats.health -= 5;
            
            // Update UI
            document.getElementById('healthFill').style.width = `${playerStats.health}%`;
            
            // Show warning if health is low
            if (playerStats.health < 30) {
              document.getElementById('warningAlert').classList.add('active');
            }
          }
          
          // Create explosion effect
          createExplosion(asteroid.position);
          
          // Damage asteroid
          asteroid.health -= 20;
          if (asteroid.health <= 0) {
            scene.remove(asteroid);
            celestialObjects.splice(celestialObjects.indexOf(asteroid), 1);
          }
        }
      }
      
      // Game over check
      if (playerStats.health <= 0) {
        gameOver();
      }
    }
    
    // Fire player weapon
    function fireWeapon() {
      // Create projectile
      const projectileGeometry = new THREE.SphereGeometry(0.2, 6, 6); // Low-poly sphere
      const projectileMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        emissive: 0x0088ff
      });
      
      const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
      
      // Position at player's ship
      projectile.position.copy(player.position);
      
      // Set velocity in the direction the player is facing
      const direction = new THREE.Vector3();
      camera.getWorldDirection(direction);
      projectile.velocity = direction.clone().normalize();
      
      scene.add(projectile);
      projectiles.push(projectile);
      
      // Update poly count (sphere with 6x6 segments: ~72 faces)
      totalPolyCount += 72;
    }
    
    // Enemy firing
    function enemyFire(enemy) {
      // Create projectile
      const projectileGeometry = new THREE.SphereGeometry(0.2, 6, 6); // Low-poly sphere
      const projectileMaterial = new THREE.MeshBasicMaterial({
        color: 0xff6666,
        emissive: 0xff0000
      });
      
      const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
      
      // Position at enemy
      projectile.position.copy(enemy.position);
      
      // Set velocity toward player
      const direction = new THREE.Vector3();
      direction.subVectors(player.position, enemy.position).normalize();
      projectile.velocity = direction.clone();
      
      projectile.isEnemyProjectile = true;
      
      scene.add(projectile);
      projectiles.push(projectile);
      
      // Update poly count (sphere with 6x6 segments: ~72 faces)
      totalPolyCount += 72;
    }
    
    // Create explosion effect
    function createExplosion(position) {
      // Create explosion geometry (low-poly)
      const explosionGeometry = new THREE.SphereGeometry(2, 5, 5); // Very low-poly
      const explosionMaterial = new THREE.MeshBasicMaterial({
        color: 0xff6600,
        emissive: 0xff3300,
        transparent: true,
        opacity: 0.8
      });
      
      const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
      explosion.position.copy(position);
      
      scene.add(explosion);
      
      // Animate explosion
      let scale = 1;
      const animateExplosion = () => {
        scale += 0.2;
        explosion.scale.set(scale, scale, scale);
        explosion.material.opacity -= 0.05;
        
        if (explosion.material.opacity <= 0) {
          scene.remove(explosion);
        } else {
          requestAnimationFrame(animateExplosion);
        }
      };
      
      animateExplosion();
      
      // Update poly count (sphere with 5x5 segments: ~50 faces)
      totalPolyCount += 50;
    }
    
    // Create currency item
    function createCurrencyItem(position) {
      const currencyGeometry = new THREE.BoxGeometry(1, 1, 0.2, 1, 1, 1); // Low-poly
      const currencyMaterial = new THREE.MeshBasicMaterial({
        color: 0xffff00,
        emissive: 0xffcc00,
        transparent: true,
        opacity: 0.9
      });
      
      const currencyItem = new THREE.Mesh(currencyGeometry, currencyMaterial);
      currencyItem.position.copy(position);
      
      scene.add(currencyItem);
      currency.push(currencyItem);
      
      // Update poly count (box: 12 faces)
      totalPolyCount += 12;
    }
    
    // Activate light speed
    function activateLightSpeed() {
      playerStats.lightSpeedActive = true;
      playerStats.lightSpeedCooldown = 10; // 10 second cooldown
      
      // Show visual effect
      document.getElementById('lightSpeedEffect').classList.add('active');
      
      // Move player forward quickly
      const direction = new THREE.Vector3();
      camera.getWorldDirection(direction);
      player.position.add(direction.multiplyScalar(100));
      
      // Hide effect after short time
      setTimeout(() => {
        document.getElementById('lightSpeedEffect').classList.remove('active');
        playerStats.lightSpeedActive = false;
      }, 1000);
    }
    
    // Game over
    function gameOver() {
      showConsoleMessage("Mission failed! Returning to base...");
      
      // Reset player stats
      playerStats.health = 100;
      playerStats.shield = 100;
      document.getElementById('healthFill').style.width = '100%';
      document.getElementById('shieldFill').style.width = '100%';
      
      // Hide warning alert
      document.getElementById('warningAlert').classList.remove('active');
      
      // Reset player position
      player.position.set(0, 0, 0);
      player.rotation.set(0, 0, 0);
      
      // Clear enemies
      for (const enemy of enemies) {
        scene.remove(enemy);
      }
      enemies = [];
      
      // Clear projectiles
      for (const projectile of projectiles) {
        scene.remove(projectile);
      }
      projectiles = [];
      
      // Spawn new wave
      spawnEnemyWave(10);
    }
    
    // Initialize the game when the page loads
    window.addEventListener('load', init);
  </script>
</body>
</html>
