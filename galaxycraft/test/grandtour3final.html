<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GALAXYCRAFT: GRAND TOUR - Winding Track</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: #000;
            color: white;
            cursor: none;
        }
        
        canvas {
            display: block;
        }
        
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #0ff;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            text-shadow: 0 0 5px #0ff, 0 0 10px #0ff;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 2px solid #0ff;
            border-radius: 5px;
            z-index: 10;
        }
        
        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 10;
        }
        
        #controls button {
            padding: 12px 25px;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            background: rgba(0, 0, 0, 0.7);
            color: #0ff;
            border: 2px solid #0ff;
            border-radius: 8px;
            cursor: pointer;
            touch-action: manipulation;
            box-shadow: 0 0 15px #0ff;
        }
        
        #controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #race-map {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 200px;
            height: 150px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #0ff;
            border-radius: 5px;
            z-index: 10;
            overflow: hidden;
        }
        
        .player-dot {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #0ff;
            border-radius: 50%;
            box-shadow: 0 0 5px #0ff;
        }
        
        .ai-dot {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #f00;
            border-radius: 50%;
            box-shadow: 0 0 5px #f00;
        }
        
        #race-info {
            position: absolute;
            bottom: 100px;
            left: 10px;
            color: #0ff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 2px solid #0ff;
            border-radius: 5px;
            z-index: 10;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #0ff;
            font-family: 'Courier New', monospace;
            font-size: 24px;
            text-align: center;
            z-index: 20;
        }
        
        .progress-bar {
            width: 300px;
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            margin: 20px auto;
            overflow: hidden;
        }
        
        .progress {
            height: 100%;
            background: #0ff;
            width: 0%;
            transition: width 0.3s;
            box-shadow: 0 0 10px #0ff;
        }
        
        .track-line {
            position: absolute;
            width: 100%;
            height: 2px;
            background: rgba(0, 255, 255, 0.5);
            left: 0;
        }
        
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #0ff;
            font-family: 'Courier New', monospace;
            font-size: 32px;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border: 3px solid #0ff;
            border-radius: 10px;
            z-index: 30;
            display: none;
        }
        
        #game-over button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 18px;
            background: rgba(0, 0, 0, 0.7);
            color: #0ff;
            border: 2px solid #0ff;
            border-radius: 5px;
            cursor: pointer;
        }
        
        #countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #0ff;
            font-family: 'Courier New', monospace;
            font-size: 72px;
            text-shadow: 0 0 10px #0ff;
            z-index: 25;
            display: none;
        }
        
        #webxos-counter {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff0;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            text-shadow: 0 0 5px #ff0, 0 0 10px #ff0;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 2px solid #ff0;
            border-radius: 5px;
            z-index: 10;
        }
        
        .medal {
            display: inline-block;
            margin-left: 10px;
            font-size: 24px;
        }
        
        #circuit-info {
            position: absolute;
            top: 70px;
            left: 10px;
            color: #ff0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 2px solid #ff0;
            border-radius: 5px;
            z-index: 10;
        }
        
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 5;
        }
        
        .crosshair::before, .crosshair::after {
            content: '';
            position: absolute;
            background: #0ff;
            box-shadow: 0 0 5px #0ff;
        }
        
        .crosshair::before {
            width: 20px;
            height: 2px;
            top: 9px;
            left: 0;
        }
        
        .crosshair::after {
            width: 2px;
            height: 20px;
            top: 0;
            left: 9px;
        }
    </style>
</head>
<body>
    <div id="hud">
        <div>POSITION: <span id="position">1/4</span></div>
        <div>SPEED: <span id="speed">100</span> km/s</div>
        <div>LAP: <span id="lap">1</span>/3</div>
        <div>NEXT: <span id="next-checkpoint">500</span> m</div>
    </div>
    
    <div id="webxos-counter">
        $WEBXOS: <span id="webxos-amount">0</span>
        <span id="medal-display" class="medal"></span>
    </div>
    
    <div id="circuit-info">
        CIRCUIT: <span id="circuit">1</span>/3 &bull; RACE: <span id="race-num">1</span>/7
    </div>
    
    <div id="race-map">
        <div class="track-line" style="top: 25%"></div>
        <div class="track-line" style="top: 50%"></div>
        <div class="track-line" style="top: 75%"></div>
        <div class="player-dot" id="player-dot"></div>
        <div class="ai-dot" id="ai1-dot"></div>
        <div class="ai-dot" id="ai2-dot"></div>
        <div class="ai-dot" id="ai3-dot"></div>
    </div>
    
    <div id="race-info">
        <div>RACE TIME: <span id="race-time">00:00</span></div>
        <div>BEST LAP: <span id="best-lap">--:--</span></div>
        <div>LEADER: <span id="leader">AI 1</span></div>
    </div>
    
    <div id="controls">
        <button id="shootBtn">SHOOT</button>
        <button id="lightspeedBtn">LIGHTSPEED</button>
        <button id="startRaceBtn">START RACE</button>
    </div>
    
    <div id="loading">
        GALAXYCRAFT: GRAND TOUR
        <div class="progress-bar">
            <div class="progress" id="progress"></div>
        </div>
        <div>Loading...</div>
    </div>
    
    <div id="game-over">
        <div id="game-result">RACE COMPLETED!</div>
        <div>Final Position: <span id="final-position">1st</span></div>
        <div>Total Time: <span id="total-time">00:00</span></div>
        <div>WEBXOS Earned: <span id="webxos-earned">0</span></div>
        <button id="restart-btn">CONTINUE TOUR</button>
    </div>
    
    <div id="countdown">3</div>
    <div class="crosshair"></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script>
        // Game state
        const gameState = {
            initialized: false,
            playerPosition: 1,
            playerSpeed: 100,
            currentLap: 1,
            totalLaps: 3,
            raceTime: 0,
            bestLapTime: null,
            nextCheckpoint: 500,
            leader: "NOVA",
            lightspeedActive: false,
            lightspeedCooldown: 0,
            raceStarted: false,
            playerProgress: 0,
            trackLength: 10000,
            lastCheckpoint: 0,
            lapStartTime: 0,
            gameOver: false,
            countdownActive: true,
            countdownValue: 3,
            playerHealth: 100,
            invulnerable: false,
            webxos: 0,
            circuit: 1,
            race: 1,
            autoMode: true,
            lastAutoAction: 0,
            totalCircuits: 3,
            racesPerCircuit: 7,
            trackTheme: 0,
            earnedWebxos: 0,
            drones: [],
            projectiles: [],
            droneSpawnTimer: 0
        };

        // AI Racers with unique names and characteristics
        const aiRacers = [
            { name: "NOVA", position: 2, speed: 95, progress: 0.2, lap: 1, color: 0xff3366, model: "triangular" },
            { name: "QUASAR", position: 3, speed: 90, progress: 0.1, lap: 1, color: 0x33ff66, model: "cylindrical" },
            { name: "PULSAR", position: 4, speed: 85, progress: 0.05, lap: 1, color: 0x3366ff, model: "boxy" }
        ];

        // Checkpoints
        const checkpoints = [];
        const checkpointDistance = 1000;
        
        // Initialize Three.js
        let scene, camera, renderer;
        let spaceship, aiShips = [];
        let stars = [];
        let tunnel;
        let tunnelSegments = [];
        let explosions = [];
        let startTime = 0;
        let nebulas = [];
        let planets = [];
        let comets = [];
        let rainbowHue = 0;
        
        // Initialize the game
        function initGame() {
            // Setup Three.js scene
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000);
            document.body.appendChild(renderer.domElement);
            
            // Create optimized starfield with instancing
            createStarfield();
            
            // Create nebula effects
            createNebulas();
            
            // Create planets
            createPlanets();
            
            // Create comets
            createComets();
            
            // Create track with rainbow effect
            createTunnel();
            
            // Create player spaceship
            createSpaceship();
            
            // Create AI ships with unique models
            createAIShips();
            
            // Create checkpoints
            createCheckpoints();
            
            // Position camera
            camera.position.set(0, 3, 5);
            
            // Setup event listeners
            setupEventListeners();
            
            // Start in auto tour mode
            gameState.autoMode = true;
            document.getElementById('startRaceBtn').textContent = 'START RACE';
            
            // Update circuit info
            updateCircuitInfo();
            
            // Hide loading screen
            document.getElementById('loading').style.display = 'none';
            gameState.initialized = true;
            
            // Start animation loop
            animate();
        }
        
        // Create optimized starfield with instanced meshes
        function createStarfield() {
            const starCount = 5000;
            const starGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);
            const sizes = new Float32Array(starCount);
            
            for (let i = 0; i < starCount; i++) {
                // Position
                const i3 = i * 3;
                positions[i3] = (Math.random() - 0.5) * 3000;
                positions[i3 + 1] = (Math.random() - 0.5) * 3000;
                positions[i3 + 2] = (Math.random() - 0.5) * 3000;
                
                // Color (some stars with color variation)
                if (Math.random() > 0.7) {
                    const hue = Math.random();
                    const color = new THREE.Color().setHSL(hue, 1.0, 0.5 + Math.random() * 0.5);
                    colors[i3] = color.r;
                    colors[i3 + 1] = color.g;
                    colors[i3 + 2] = color.b;
                } else {
                    colors[i3] = 1.0;
                    colors[i3 + 1] = 1.0;
                    colors[i3 + 2] = 1.0;
                }
                
                // Size
                sizes[i] = Math.random() * 2 + 0.5;
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            starGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const starMaterial = new THREE.PointsMaterial({
                size: 1,
                sizeAttenuation: true,
                vertexColors: true,
                transparent: true
            });
            
            const starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        }
        
        // Create nebula effects
        function createNebulas() {
            const nebulaCount = 15;
            
            for (let i = 0; i < nebulaCount; i++) {
                const particles = 100;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particles * 3);
                const colors = new Float32Array(particles * 3);
                const sizes = new Float32Array(particles);
                
                const hue = Math.random();
                const baseColor = new THREE.Color().setHSL(hue, 0.8, 0.5);
                const centerX = (Math.random() - 0.5) * 2000;
                const centerY = (Math.random() - 0.5) * 2000;
                const centerZ = (Math.random() - 0.5) * 2000 - 1000;
                
                for (let j = 0; j < particles; j++) {
                    const j3 = j * 3;
                    positions[j3] = centerX + (Math.random() - 0.5) * 300;
                    positions[j3 + 1] = centerY + (Math.random() - 0.5) * 300;
                    positions[j3 + 2] = centerZ + (Math.random() - 0.5) * 300;
                    
                    // Color variation
                    const colorVariation = new THREE.Color().setHSL(
                        (hue + Math.random() * 0.2) % 1,
                        0.8,
                        0.5 + Math.random() * 0.3
                    );
                    colors[j3] = colorVariation.r;
                    colors[j3 + 1] = colorVariation.g;
                    colors[j3 + 2] = colorVariation.b;
                    
                    // Size
                    sizes[j] = Math.random() * 3 + 1;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                const material = new THREE.PointsMaterial({
                    size: 1,
                    sizeAttenuation: true,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.4,
                    blending: THREE.AdditiveBlending
                });
                
                const nebula = new THREE.Points(geometry, material);
                scene.add(nebula);
                nebulas.push(nebula);
            }
        }
        
        // Create planets
        function createPlanets() {
            const planetCount = 8;
            
            for (let i = 0; i < planetCount; i++) {
                const size = Math.random() * 15 + 10;
                const geometry = new THREE.SphereGeometry(size, 32, 32);
                const hue = Math.random();
                const material = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(hue, 0.8, 0.5),
                    wireframe: true,
                    transparent: true,
                    opacity: 0.7
                });
                
                const planet = new THREE.Mesh(geometry, material);
                
                // Position planets around the track
                const angle = (i / planetCount) * Math.PI * 2;
                const distance = 500 + Math.random() * 300;
                planet.position.set(
                    Math.cos(angle) * distance,
                    Math.sin(angle) * distance * 0.5,
                    -1000 - Math.random() * 2000
                );
                
                scene.add(planet);
                planets.push({
                    mesh: planet,
                    rotationSpeed: (Math.random() - 0.5) * 0.005
                });
                
                // Add rings to some planets
                if (Math.random() > 0.5) {
                    const ringGeometry = new THREE.RingGeometry(size * 1.5, size * 2, 32);
                    const ringMaterial = new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setHSL((hue + 0.5) % 1, 0.8, 0.5),
                        side: THREE.DoubleSide,
                        wireframe: true,
                        transparent: true,
                        opacity: 0.5
                    });
                    
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = Math.PI / 2;
                    planet.add(ring);
                }
            }
        }
        
        // Create comets
        function createComets() {
            const cometCount = 5;
            
            for (let i = 0; i < cometCount; i++) {
                const geometry = new THREE.SphereGeometry(2, 16, 16);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    wireframe: true
                });
                
                const comet = new THREE.Mesh(geometry, material);
                
                // Position comets along random paths
                comet.position.set(
                    (Math.random() - 0.5) * 1000,
                    (Math.random() - 0.5) * 1000,
                    -500 - Math.random() * 1500
                );
                
                scene.add(comet);
                comets.push({
                    mesh: comet,
                    speed: Math.random() * 0.5 + 0.2,
                    direction: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.1,
                        (Math.random() - 0.5) * 0.1,
                        -1
                    ).normalize()
                });
            }
        }
        
        // Create winding, curving racing tunnel
        function createTunnel() {
            const segments = 200;
            const segmentLength = 50;
            const tunnelRadius = 20;
            
            // Create tunnel path points for a winding, curving track
            const pathPoints = [];
            for (let i = 0; i <= segments; i++) {
                const z = -i * segmentLength;
                
                // Create a winding, curving path with varying amplitude and frequency
                const curveFactor = i / segments;
                const amplitudeX = 50 * Math.sin(curveFactor * Math.PI * 2);
                const amplitudeY = 30 * Math.cos(curveFactor * Math.PI * 1.5);
                
                const x = Math.sin(i * 0.1) * amplitudeX;
                const y = Math.cos(i * 0.08) * amplitudeY;
                
                pathPoints.push(new THREE.Vector3(x, y, z));
            }
            
            // Create the tunnel geometry
            const tubeGeometry = new THREE.TubeGeometry(
                new THREE.CatmullRomCurve3(pathPoints),
                64, // tubular segments
                2,  // radius
                16,  // radial segments
                false // closed
            );
            
            // Create dynamic rainbow material
            const tunnelMaterial = new THREE.MeshBasicMaterial({
                wireframe: true,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            
            tunnel = new THREE.Mesh(tubeGeometry, tunnelMaterial);
            scene.add(tunnel);
            
            // Create tunnel segments for collision detection and visual reference
            for (let i = 0; i < segments; i += 5) {
                const ringGeometry = new THREE.RingGeometry(tunnelRadius - 0.5, tunnelRadius, 32);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(i / segments, 1.0, 0.5),
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.7
                });
                
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.copy(pathPoints[i]);
                
                // Orient the ring perpendicular to the tunnel path
                if (i < segments - 1) {
                    const direction = new THREE.Vector3().subVectors(pathPoints[i + 1], pathPoints[i]).normalize();
                    ring.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), direction);
                }
                
                scene.add(ring);
                tunnelSegments.push({
                    mesh: ring,
                    position: pathPoints[i],
                    normal: new THREE.Vector3().subVectors(pathPoints[i + 1], pathPoints[i]).normalize()
                });
            }
            
            // Store the path for ship navigation
            gameState.tunnelPath = pathPoints;
        }
        
        // Update tunnel colors for rainbow effect
        function updateTunnelColors() {
            rainbowHue = (rainbowHue + 0.005) % 1;
            
            if (tunnel && tunnel.material) {
                tunnel.material.color.setHSL(rainbowHue, 1.0, 0.5);
            }
            
            // Update rings with rainbow effect
            tunnelSegments.forEach((segment, i) => {
                const ringHue = (rainbowHue + i * 0.01) % 1;
                segment.mesh.material.color.setHSL(ringHue, 1.0, 0.5);
            });
        }
        
        // Create player spaceship
        function createSpaceship() {
            const geometry = new THREE.ConeGeometry(0.8, 2.5, 8);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff,
                wireframe: true
            });
            
            spaceship = new THREE.Mesh(geometry, material);
            spaceship.rotation.x = Math.PI / 2;
            scene.add(spaceship);
        }
        
        // Create AI ships with unique models
        function createAIShips() {
            aiRacers.forEach((racer, index) => {
                let geometry;
                
                switch (racer.model) {
                    case "triangular":
                        geometry = new THREE.ConeGeometry(0.6, 2.2, 3);
                        break;
                    case "cylindrical":
                        geometry = new THREE.CylinderGeometry(0.6, 0.6, 2.2, 12);
                        break;
                    case "boxy":
                        geometry = new THREE.BoxGeometry(1.2, 1.2, 2.2);
                        break;
                    default:
                        geometry = new THREE.ConeGeometry(0.6, 2.2, 8);
                }
                
                const material = new THREE.MeshBasicMaterial({
                    color: racer.color,
                    wireframe: true
                });
                
                const ship = new THREE.Mesh(geometry, material);
                ship.rotation.x = Math.PI / 2;
                ship.position.x = 3 - index * 2;
                ship.position.z = -20 - index * 10;
                scene.add(ship);
                
                aiShips.push(ship);
            });
        }
        
        // Create checkpoints along the track
        function createCheckpoints() {
            for (let i = 0; i < 10; i++) {
                const zPos = -i * checkpointDistance;
                const checkpoint = {
                    position: new THREE.Vector3(0, 0, zPos),
                    passed: false
                };
                checkpoints.push(checkpoint);
                
                // Visual marker
                const markerGeometry = new THREE.RingGeometry(8, 10, 16);
                const markerMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.5,
                    wireframe: true
                });
                
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.set(0, 0, zPos);
                marker.rotation.x = Math.PI / 2;
                scene.add(marker);
            }
        }
        
        // Setup event listeners
        function setupEventListeners() {
            // Button event listeners
            document.getElementById('shootBtn').addEventListener('click', shoot);
            document.getElementById('lightspeedBtn').addEventListener('click', activateLightspeed);
            document.getElementById('startRaceBtn').addEventListener('click', toggleRaceMode);
            document.getElementById('restart-btn').addEventListener('click', restartRace);
            
            // Keyboard controls
            window.addEventListener('keydown', (e) => {
                if (e.code === 'Space') {
                    e.preventDefault();
                    if (gameState.raceStarted) {
                        shoot();
                    } else {
                        toggleRaceMode();
                    }
                } else if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                    e.preventDefault();
                    activateLightspeed();
                } else if (e.code === 'KeyR') {
                    restartRace();
                } else if (e.code === 'Escape') {
                    // Toggle cursor
                    document.body.style.cursor = document.body.style.cursor === 'none' ? 'default' : 'none';
                }
            });
            
            // Window resize handler
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Mouse movement for ship control
            document.addEventListener('mousemove', (e) => {
                if (gameState.raceStarted && !gameState.autoMode) {
                    const moveX = (e.clientX / window.innerWidth - 0.5) * 2;
                    const moveY = (e.clientY / window.innerHeight - 0.5) * 2;
                    
                    // Update spaceship position based on mouse movement
                    spaceship.position.x = moveX * 5;
                    spaceship.position.y = -moveY * 5;
                }
            });
        }
        
        // Shoot weapon
        function shoot() {
            if (!gameState.raceStarted || gameState.gameOver) return;
            
            // Create projectile
            const geometry = new THREE.SphereGeometry(0.3, 8, 8);
            const material = new THREE.MeshBasicMaterial({ color: 0xff9900 });
            const projectile = new THREE.Mesh(geometry, material);
            projectile.position.copy(spaceship.position);
            projectile.position.z -= 2;
            scene.add(projectile);
            
            // Add to projectiles array
            gameState.projectiles.push({
                mesh: projectile,
                speed: 2,
                direction: new THREE.Vector3(0, 0, -1)
            });
        }
        
        // Activate lightspeed boost
        function activateLightspeed() {
            if (gameState.lightspeedCooldown > 0 || !gameState.raceStarted || gameState.gameOver) return;
            
            gameState.lightspeedActive = true;
            gameState.lightspeedCooldown = 300; // 5 seconds cooldown in frames
            
            // Visual effect - tunnel distortion
            const originalFov = camera.fov;
            camera.fov = 120;
            camera.updateProjectionMatrix();
            
            // Speed boost
            gameState.playerSpeed += 100;
            
            // Add screen glitch effect
            const glitchIntensity = 0.3;
            const glitchEffect = () => {
                camera.position.x += (Math.random() - 0.5) * glitchIntensity;
                camera.position.y += (Math.random() - 0.5) * glitchIntensity;
                
                if (gameState.lightspeedActive) {
                    requestAnimationFrame(glitchEffect);
                }
            };
            
            glitchEffect();
            
            // Reset after duration
            setTimeout(() => {
                gameState.lightspeedActive = false;
                camera.fov = originalFov;
                camera.updateProjectionMatrix();
                gameState.playerSpeed -= 100;
                camera.position.set(0, 3, 5);
            }, 2000);
        }
        
        // Toggle between race and tour mode
        function toggleRaceMode() {
            if (gameState.raceStarted) {
                // Stop race and return to tour mode
                gameState.raceStarted = false;
                gameState.autoMode = true;
                document.getElementById('startRaceBtn').textContent = 'START RACE';
            } else {
                // Start race countdown
                startRaceCountdown();
            }
        }
        
        // Start race countdown
        function startRaceCountdown() {
            gameState.countdownActive = true;
            gameState.countdownValue = 3;
            
            const countdownElement = document.getElementById('countdown');
            countdownElement.style.display = 'block';
            countdownElement.textContent = gameState.countdownValue;
            
            const countdownInterval = setInterval(() => {
                gameState.countdownValue--;
                
                if (gameState.countdownValue > 0) {
                    countdownElement.textContent = gameState.countdownValue;
                } else if (gameState.countdownValue === 0) {
                    countdownElement.textContent = 'GO!';
                } else {
                    clearInterval(countdownInterval);
                    countdownElement.style.display = 'none';
                    
                    // Start the race
                    gameState.raceStarted = true;
                    gameState.autoMode = false;
                    gameState.lapStartTime = Date.now();
                    document.getElementById('startRaceBtn').textContent = 'END RACE';
                    startTime = Date.now();
                }
            }, 1000);
        }
        
        // Restart race
        function restartRace() {
            // Reset game state
            gameState.playerPosition = 1;
            gameState.playerSpeed = 100;
            gameState.currentLap = 1;
            gameState.raceTime = 0;
            gameState.bestLapTime = null;
            gameState.nextCheckpoint = 500;
            gameState.leader = "NOVA";
            gameState.lightspeedActive = false;
            gameState.lightspeedCooldown = 0;
            gameState.raceStarted = false;
            gameState.playerProgress = 0;
            gameState.lastCheckpoint = 0;
            gameState.lapStartTime = 0;
            gameState.gameOver = false;
            gameState.countdownActive = false;
            gameState.playerHealth = 100;
            gameState.invulnerable = false;
            
            // Reset AI racers
            aiRacers.forEach((racer, index) => {
                racer.position = index + 2;
                racer.speed = 95 - index * 5;
                racer.progress = 0.2 - index * 0.05;
                racer.lap = 1;
            });
            
            // Reset positions
            spaceship.position.set(0, 0, 0);
            aiShips.forEach((ship, index) => {
                ship.position.x = 3 - index * 2;
                ship.position.z = -20 - index * 10;
            });
            
            // Reset checkpoints
            checkpoints.forEach(checkpoint => {
                checkpoint.passed = false;
            });
            
            // Hide game over screen
            document.getElementById('game-over').style.display = 'none';
            
            // Return to auto tour mode
            gameState.autoMode = true;
            document.getElementById('startRaceBtn').textContent = 'START RACE';
        }
        
        // Award WEBXOS tokens
        function awardWebxos(amount) {
            gameState.webxos += amount;
            gameState.earnedWebxos += amount;
            document.getElementById('webxos-amount').textContent = gameState.webxos;
            
            // Show medal for significant amounts
            const medalDisplay = document.getElementById('medal-display');
            if (gameState.webxos >= 100) {
                medalDisplay.textContent = 'ðŸ¥‡';
            } else if (gameState.webxos >= 50) {
                medalDisplay.textContent = 'ðŸ¥ˆ';
            } else if (gameState.webxos >= 25) {
                medalDisplay.textContent = 'ðŸ¥‰';
            }
        }
        
        // Update HUD
        function updateHUD() {
            document.getElementById('position').textContent = `${gameState.playerPosition}/${aiRacers.length + 1}`;
            document.getElementById('speed').textContent = Math.round(gameState.playerSpeed);
            document.getElementById('lap').textContent = `${gameState.currentLap}/${gameState.totalLaps}`;
            document.getElementById('next-checkpoint').textContent = Math.round(gameState.nextCheckpoint);
            
            // Update race time
            if (gameState.raceStarted && !gameState.gameOver) {
                gameState.raceTime = (Date.now() - startTime) / 1000;
                const minutes = Math.floor(gameState.raceTime / 60);
                const seconds = Math.floor(gameState.raceTime % 60);
                document.getElementById('race-time').textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            
            // Update best lap time
            if (gameState.bestLapTime) {
                const minutes = Math.floor(gameState.bestLapTime / 60);
                const seconds = Math.floor(gameState.bestLapTime % 60);
                document.getElementById('best-lap').textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            
            // Update leader
            document.getElementById('leader').textContent = gameState.leader;
            
            // Update lightspeed button
            const lightspeedBtn = document.getElementById('lightspeedBtn');
            lightspeedBtn.disabled = gameState.lightspeedCooldown > 0;
            lightspeedBtn.textContent = gameState.lightspeedCooldown > 0 ? 
                `LIGHTSPEED (${Math.ceil(gameState.lightspeedCooldown/60)})` : 
                'LIGHTSPEED';
            
            // Update mini-map
            updateMiniMap();
        }
        
        // Update mini-map
        function updateMiniMap() {
            const playerDot = document.getElementById('player-dot');
            playerDot.style.left = `${50 + (spaceship.position.x / 50) * 100}%`;
            playerDot.style.top = `${50 - (spaceship.position.z / 2000) * 100}%`;
            
            aiShips.forEach((ship, index) => {
                const aiDot = document.getElementById(`ai${index+1}-dot`);
                aiDot.style.left = `${50 + (ship.position.x / 50) * 100}%`;
                aiDot.style.top = `${50 - (ship.position.z / 2000) * 100}%`;
            });
        }
        
        // Update circuit info
        function updateCircuitInfo() {
            document.getElementById('circuit').textContent = gameState.circuit;
            document.getElementById('race-num').textContent = gameState.race;
        }
        
        // Update AI racers
        function updateAI(deltaTime) {
            aiRacers.forEach((racer, index) => {
                // Update progress based on speed
                racer.progress += (racer.speed * deltaTime) / gameState.trackLength;
                
                // Check for lap completion
                if (racer.progress >= 1) {
                    racer.progress = 0;
                    racer.lap++;
                    
                    // AI gets faster each lap
                    racer.speed += 5;
                }
                
                // Position AI ship along the winding track
                const ship = aiShips[index];
                const trackPos = racer.progress * gameState.trackLength;
                
                // Calculate position on winding path
                const pathIndex = Math.floor(trackPos / 50) % gameState.tunnelPath.length;
                const nextIndex = (pathIndex + 1) % gameState.tunnelPath.length;
                const progressBetween = (trackPos % 50) / 50;
                
                if (pathIndex < gameState.tunnelPath.length - 1) {
                    const position = new THREE.Vector3().lerpVectors(
                        gameState.tunnelPath[pathIndex],
                        gameState.tunnelPath[nextIndex],
                        progressBetween
                    );
                    
                    ship.position.copy(position);
                    
                    // Add some offset to make AI ships not follow exact same path
                    ship.position.x += Math.sin(trackPos * 0.01 + index) * 2;
                    ship.position.y += Math.cos(trackPos * 0.01 + index) * 1.5;
                }
                
                // Random speed variations
                if (Math.random() < 0.01) {
                    racer.speed += (Math.random() - 0.5) * 10;
                    racer.speed = Math.max(50, Math.min(200, racer.speed));
                }
                
                // Update leader
                if (racer.lap > gameState.currentLap || 
                    (racer.lap === gameState.currentLap && racer.progress > gameState.playerProgress)) {
                    gameState.leader = racer.name;
                }
            });
        }
        
        // Update player position and checkpoints
        function updatePlayer(deltaTime) {
            if (!gameState.raceStarted) return;
            
            // Update player progress based on speed
            gameState.playerProgress += (gameState.playerSpeed * deltaTime) / gameState.trackLength;
            
            // Check for lap completion
            if (gameState.playerProgress >= 1) {
                gameState.playerProgress = 0;
                gameState.currentLap++;
                
                // Record lap time
                const lapTime = (Date.now() - gameState.lapStartTime) / 1000;
                gameState.lapStartTime = Date.now();
                
                if (!gameState.bestLapTime || lapTime < gameState.bestLapTime) {
                    gameState.bestLapTime = lapTime;
                }
                
                // Check for race completion
                if (gameState.currentLap > gameState.totalLaps) {
                    gameOver("RACE COMPLETED!");
                    return;
                }
            }
            
            // Position player ship along the winding track
            const trackPos = gameState.playerProgress * gameState.trackLength;
            
            // Calculate position on winding path
            const pathIndex = Math.floor(trackPos / 50) % gameState.tunnelPath.length;
            const nextIndex = (pathIndex + 1) % gameState.tunnelPath.length;
            const progressBetween = (trackPos % 50) / 50;
            
            if (pathIndex < gameState.tunnelPath.length - 1) {
                const position = new THREE.Vector3().lerpVectors(
                    gameState.tunnelPath[pathIndex],
                    gameState.tunnelPath[nextIndex],
                    progressBetween
                );
                
                // Apply player's manual control adjustments
                position.x += spaceship.position.x;
                position.y += spaceship.position.y;
                
                spaceship.position.copy(position);
            }
            
            // Check checkpoints
            checkpoints.forEach((checkpoint, index) => {
                if (!checkpoint.passed && spaceship.position.z <= checkpoint.position.z) {
                    checkpoint.passed = true;
                    gameState.nextCheckpoint = checkpointDistance;
                    
                    // Award WEBXOS for checkpoint
                    awardWebxos(5);
                }
            });
            
            // Update next checkpoint distance
            const nextCheckpoint = checkpoints.find(checkpoint => !checkpoint.passed);
            if (nextCheckpoint) {
                gameState.nextCheckpoint = Math.abs(spaceship.position.z - nextCheckpoint.position.z);
            }
            
            // Update player position relative to AI
            let position = 1;
            for (const racer of aiRacers) {
                if ((racer.lap > gameState.currentLap) || 
                    (racer.lap === gameState.currentLap && racer.progress > gameState.playerProgress)) {
                    position++;
                }
            }
            gameState.playerPosition = position;
        }
        
        // Auto tour mode behavior
        function updateAutoTour(deltaTime) {
            if (!gameState.autoMode) return;
            
            // Move camera in a cinematic pattern
            const time = Date.now() * 0.001;
            
            // Camera follows a circular path around the spaceship
            camera.position.x = Math.sin(time * 0.2) * 10;
            camera.position.y = Math.cos(time * 0.3) * 6 + 3;
            camera.position.z = Math.cos(time * 0.2) * 10;
            
            camera.lookAt(spaceship.position);
            
            // Slowly move the spaceship forward along the winding track
            const trackPos = (Date.now() * 0.02) % gameState.trackLength;
            
            // Calculate position on winding path
            const pathIndex = Math.floor(trackPos / 50) % gameState.tunnelPath.length;
            const nextIndex = (pathIndex + 1) % gameState.tunnelPath.length;
            const progressBetween = (trackPos % 50) / 50;
            
            if (pathIndex < gameState.tunnelPath.length - 1) {
                const position = new THREE.Vector3().lerpVectors(
                    gameState.tunnelPath[pathIndex],
                    gameState.tunnelPath[nextIndex],
                    progressBetween
                );
                
                spaceship.position.copy(position);
            }
            
            // Move to next race in circuit after a while
            if (trackPos < 100) {
                gameState.race++;
                if (gameState.race > gameState.racesPerCircuit) {
                    gameState.race = 1;
                    gameState.circuit++;
                    if (gameState.circuit > gameState.totalCircuits) {
                        gameState.circuit = 1;
                    }
                }
                updateCircuitInfo();
            }
            
            // Occasionally perform automatic actions for demonstration
            gameState.lastAutoAction += deltaTime;
            if (gameState.lastAutoAction > 5) {
                gameState.lastAutoAction = 0;
                
                // Random action
                if (Math.random() < 0.3) {
                    shoot();
                } else if (Math.random() < 0.5) {
                    activateLightspeed();
                }
            }
        }
        
        // Main animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = Date.now();
            const deltaTime = (currentTime - (startTime || currentTime)) / 1000;
            startTime = currentTime;
            
            // Update game state
            if (gameState.lightspeedCooldown > 0) {
                gameState.lightspeedCooldown--;
            }
            
            // Update tunnel colors
            updateTunnelColors();
            
            // Update AI racers
            updateAI(deltaTime);
            
            // Update player
            updatePlayer(deltaTime);
            
            // Update auto tour
            updateAutoTour(deltaTime);
            
            // Update HUD
            updateHUD();
            
            // Render scene
            renderer.render(scene, camera);
        }
        
        // Start the game immediately
        window.onload = function() {
            initGame();
        };
    </script>
</body>
</html>