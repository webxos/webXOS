<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GALAXYCRAFT: GRAND TOUR</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: #000;
            color: white;
        }
        
        canvas {
            display: block;
        }
        
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #0ff;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            text-shadow: 0 0 5px #0ff, 0 0 10px #0ff;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 2px solid #0ff;
            border-radius: 5px;
            z-index: 10;
        }
        
        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 10;
        }
        
        #controls button {
            padding: 12px 25px;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            background: rgba(0, 0, 0, 0.7);
            color: #0ff;
            border: 2px solid #0ff;
            border-radius: 8px;
            cursor: pointer;
            touch-action: manipulation;
            box-shadow: 0 0 15px #0ff;
        }
        
        #controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #race-map {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 200px;
            height: 150px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #0ff;
            border-radius: 5px;
            z-index: 10;
            overflow: hidden;
        }
        
        .player-dot {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #0ff;
            border-radius: 50%;
            box-shadow: 0 0 5px #0ff;
        }
        
        .ai-dot {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #f00;
            border-radius: 50%;
            box-shadow: 0 0 5px #f00;
        }
        
        #race-info {
            position: absolute;
            bottom: 100px;
            left: 10px;
            color: #0ff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 2px solid #0ff;
            border-radius: 5px;
            z-index: 10;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #0ff;
            font-family: 'Courier New', monospace;
            font-size: 24px;
            text-align: center;
            z-index: 20;
        }
        
        .progress-bar {
            width: 300px;
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            margin: 20px auto;
            overflow: hidden;
        }
        
        .progress {
            height: 100%;
            background: #0ff;
            width: 0%;
            transition: width 0.3s;
            box-shadow: 0 0 10px #0ff;
        }
        
        .track-line {
            position: absolute;
            width: 100%;
            height: 2px;
            background: rgba(0, 255, 255, 0.5);
            left: 0;
        }
    </style>
</head>
<body>
    <div id="hud">
        <div>POSITION: <span id="position">1/4</span></div>
        <div>SPEED: <span id="speed">100</span> km/s</div>
        <div>LAP: <span id="lap">1</span>/3</div>
        <div>NEXT: <span id="next-checkpoint">500</span> m</div>
    </div>
    
    <div id="race-map">
        <div class="track-line" style="top: 25%"></div>
        <div class="track-line" style="top: 50%"></div>
        <div class="track-line" style="top: 75%"></div>
        <div class="player-dot" id="player-dot"></div>
        <div class="ai-dot" id="ai1-dot"></div>
        <div class="ai-dot" id="ai2-dot"></div>
        <div class="ai-dot" id="ai3-dot"></div>
    </div>
    
    <div id="race-info">
        <div>RACE TIME: <span id="race-time">00:00</span></div>
        <div>BEST LAP: <span id="best-lap">--:--</span></div>
        <div>LEADER: <span id="leader">AI 1</span></div>
    </div>
    
    <div id="controls">
        <button id="shootBtn">SHOOT</button>
        <button id="lightspeedBtn">LIGHTSPEED</button>
    </div>
    
    <div id="loading">
        GALAXYCRAFT: GRAND TOUR
        <div class="progress-bar">
            <div class="progress" id="progress"></div>
        </div>
        <div>Loading...</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script>
        // Game state
        const gameState = {
            initialized: false,
            playerPosition: 1,
            playerSpeed: 100,
            currentLap: 1,
            totalLaps: 3,
            raceTime: 0,
            bestLapTime: null,
            nextCheckpoint: 500,
            leader: "AI 1",
            lightspeedActive: false,
            lightspeedCooldown: 0,
            raceStarted: false,
            playerProgress: 0,
            trackLength: 1000
        };

        // AI Racers
        const aiRacers = [
            { name: "NOVA", position: 2, speed: 95, progress: 0.2 },
            { name: "QUASAR", position: 3, speed: 90, progress: 0.1 },
            { name: "PULSAR", position: 4, speed: 85, progress: 0.05 }
        ];

        // Initialize Three.js
        let scene, camera, renderer;
        let spaceship, aiShips = [];
        let stars = [];
        let drones = [];
        let track, tunnel;
        let tunnelSegments = [];
        
        // Initialize the game
        function initGame() {
            // Setup Three.js scene
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000);
            document.body.appendChild(renderer.domElement);
            
            // Create starfield
            createStarfield();
            
            // Create track
            createTunnel();
            
            // Create player spaceship
            createSpaceship();
            
            // Create AI ships
            createAIShips();
            
            // Position camera
            camera.position.set(0, 3, 5);
            
            // Setup event listeners
            setupEventListeners();
            
            // Start animation loop
            animate();
            
            // Start the race
            startRace();
            
            // Hide loading screen
            document.getElementById('loading').style.display = 'none';
            gameState.initialized = true;
        }
        
        // Create starfield background
        function createStarfield() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 1500;
            const starPositions = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount * 3; i += 3) {
                starPositions[i] = (Math.random() - 0.5) * 2000;
                starPositions[i + 1] = (Math.random() - 0.5) * 2000;
                starPositions[i + 2] = (Math.random() - 0.5) * 2000;
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
            
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1.5,
                sizeAttenuation: true
            });
            
            const starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
            stars.push(starField);
            
            // Add some colored stars for variety
            const colorStarGeometry = new THREE.BufferGeometry();
            const colorStarCount = 300;
            const colorStarPositions = new Float32Array(colorStarCount * 3);
            const colorStarColors = new Float32Array(colorStarCount * 3);
            
            for (let i = 0; i < colorStarCount * 3; i += 3) {
                colorStarPositions[i] = (Math.random() - 0.5) * 2000;
                colorStarPositions[i + 1] = (Math.random() - 0.5) * 2000;
                colorStarPositions[i + 2] = (Math.random() - 0.5) * 2000;
                
                // Random color (blue, cyan, or white)
                const colorChoice = Math.random();
                if (colorChoice < 0.3) {
                    colorStarColors[i] = 0; // R
                    colorStarColors[i + 1] = 0.5; // G
                    colorStarColors[i + 2] = 1; // B
                } else if (colorChoice < 0.6) {
                    colorStarColors[i] = 0; // R
                    colorStarColors[i + 1] = 1; // G
                    colorStarColors[i + 2] = 1; // B
                } else {
                    colorStarColors[i] = 1; // R
                    colorStarColors[i + 1] = 1; // G
                    colorStarColors[i + 2] = 1; // B
                }
            }
            
            colorStarGeometry.setAttribute('position', new THREE.BufferAttribute(colorStarPositions, 3));
            colorStarGeometry.setAttribute('color', new THREE.BufferAttribute(colorStarColors, 3));
            
            const colorStarMaterial = new THREE.PointsMaterial({
                size: 2.5,
                sizeAttenuation: true,
                vertexColors: true
            });
            
            const colorStarField = new THREE.Points(colorStarGeometry, colorStarMaterial);
            scene.add(colorStarField);
            stars.push(colorStarField);
        }
        
        // Create racing tunnel
        function createTunnel() {
            // Create tunnel path
            const pathPoints = [];
            const segments = 20;
            
            for (let i = 0; i <= segments; i++) {
                const z = -i * 50;
                // Create a winding path with some curves
                const x = Math.sin(i * 0.5) * 10;
                const y = Math.cos(i * 0.3) * 5;
                pathPoints.push(new THREE.Vector3(x, y, z));
            }
            
            // Create the tunnel
            const tunnelGeometry = new THREE.TubeGeometry(
                new THREE.CatmullRomCurve3(pathPoints),
                64, // tubular segments
                5,  // radius
                12,  // radial segments
                false // closed
            );
            
            const tunnelMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });
            
            tunnel = new THREE.Mesh(tunnelGeometry, tunnelMaterial);
            scene.add(tunnel);
            
            // Create tunnel segments for collision detection
            for (let i = 0; i < pathPoints.length - 1; i++) {
                tunnelSegments.push({
                    start: pathPoints[i],
                    end: pathPoints[i + 1]
                });
            }
            
            // Add some tunnel rings for visual reference
            for (let i = 0; i < pathPoints.length; i += 2) {
                const ringGeometry = new THREE.RingGeometry(4.5, 5, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.5
                });
                
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.copy(pathPoints[i]);
                
                // Orient the ring perpendicular to the tunnel path
                if (i < pathPoints.length - 1) {
                    const direction = new THREE.Vector3().subVectors(pathPoints[i + 1], pathPoints[i]).normalize();
                    ring.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), direction);
                }
                
                scene.add(ring);
            }
        }
        
        // Create player spaceship
        function createSpaceship() {
            const shipGeometry = new THREE.ConeGeometry(0.5, 1.5, 8);
            const shipMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                wireframe: false
            });
            
            spaceship = new THREE.Mesh(shipGeometry, shipMaterial);
            spaceship.rotation.x = Math.PI / 2;
            scene.add(spaceship);
            
            // Add engine glow
            const engineGlowGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const engineGlowMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.7
            });
            
            const engineGlow = new THREE.Mesh(engineGlowGeometry, engineGlowMaterial);
            engineGlow.position.set(0, 0, -0.8);
            spaceship.add(engineGlow);
            
            // Add wings
            const wingGeometry = new THREE.BoxGeometry(0.1, 0.8, 0.5);
            const wingMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                wireframe: false
            });
            
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(-0.6, 0, 0);
            spaceship.add(leftWing);
            
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(0.6, 0, 0);
            spaceship.add(rightWing);
        }
        
        // Create AI ships
        function createAIShips() {
            const colors = [0xff0000, 0x00ff00, 0xffff00];
            
            for (let i = 0; i < 3; i++) {
                const shipGeometry = new THREE.ConeGeometry(0.4, 1.2, 6);
                const shipMaterial = new THREE.MeshBasicMaterial({
                    color: colors[i],
                    wireframe: false
                });
                
                const aiShip = new THREE.Mesh(shipGeometry, shipMaterial);
                aiShip.rotation.x = Math.PI / 2;
                
                // Position AI ships behind the player
                aiShip.position.z = -15 - (i * 8);
                aiShip.position.x = (i - 1) * 3;
                
                // Add identifier
                const idGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const idMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff
                });
                
                const id = new THREE.Mesh(idGeometry, idMaterial);
                id.position.set(0, 0.5, 0);
                aiShip.add(id);
                
                scene.add(aiShip);
                aiShips.push(aiShip);
            }
        }
        
        // Setup event listeners
        function setupEventListeners() {
            const shootBtn = document.getElementById('shootBtn');
            const lightspeedBtn = document.getElementById('lightspeedBtn');
            
            shootBtn.addEventListener('click', fireWeapon);
            lightspeedBtn.addEventListener('click', activateLightspeed);
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Keyboard controls for testing
            window.addEventListener('keydown', (e) => {
                if (e.key === ' ') {
                    fireWeapon();
                } else if (e.key === 'l' || e.key === 'L') {
                    activateLightspeed();
                }
            });
        }
        
        // Fire weapon
        function fireWeapon() {
            if (drones.length < 10) {
                createDrone();
            }
        }
        
        // Create a drone (obstacle)
        function createDrone() {
            const droneGeometry = new THREE.TetrahedronGeometry(0.4);
            const droneMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                wireframe: false
            });
            
            const drone = new THREE.Mesh(droneGeometry, droneMaterial);
            
            // Position drone in front of the player
            drone.position.x = (Math.random() - 0.5) * 8;
            drone.position.y = (Math.random() - 0.5) * 8;
            drone.position.z = spaceship.position.z - 25;
            
            scene.add(drone);
            drones.push({
                mesh: drone,
                speed: 0.5,
                active: true
            });
            
            // Remove drone after a while
            setTimeout(() => {
                if (drone.parent) {
                    scene.remove(drone);
                    drones = drones.filter(d => d.mesh !== drone);
                }
            }, 5000);
        }
        
        // Activate lightspeed
        function activateLightspeed() {
            if (gameState.lightspeedCooldown <= 0) {
                gameState.lightspeedActive = true;
                gameState.lightspeedCooldown = 10; // 10 seconds cooldown
                gameState.playerSpeed = 200;
                
                // Visual effect
                if (spaceship.material) {
                    spaceship.material.color.set(0xffffff);
                }
                
                // Update button text
                document.getElementById('lightspeedBtn').textContent = 'COOLDOWN';
                document.getElementById('lightspeedBtn').disabled = true;
                
                // Reset after 3 seconds
                setTimeout(() => {
                    gameState.lightspeedActive = false;
                    gameState.playerSpeed = 100;
                    if (spaceship.material) {
                        spaceship.material.color.set(0x00ffff);
                    }
                }, 3000);
            }
        }
        
        // Start the race
        function startRace() {
            gameState.raceStarted = true;
            const startTime = Date.now();
            
            // Update race timer
            setInterval(() => {
                if (gameState.raceStarted) {
                    gameState.raceTime = (Date.now() - startTime) / 1000;
                    updateHUD();
                }
            }, 100);
        }
        
        // Update HUD
        function updateHUD() {
            document.getElementById('position').textContent = `${gameState.playerPosition}/4`;
            document.getElementById('speed').textContent = gameState.playerSpeed;
            document.getElementById('lap').textContent = `${gameState.currentLap}/${gameState.totalLaps}`;
            document.getElementById('next-checkpoint').textContent = Math.max(0, gameState.nextCheckpoint);
            
            // Format race time
            const minutes = Math.floor(gameState.raceTime / 60);
            const seconds = Math.floor(gameState.raceTime % 60);
            document.getElementById('race-time').textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // Update best lap time if available
            if (gameState.bestLapTime) {
                const bestMinutes = Math.floor(gameState.bestLapTime / 60);
                const bestSeconds = Math.floor(gameState.bestLapTime % 60);
                document.getElementById('best-lap').textContent = `${bestMinutes.toString().padStart(2, '0')}:${bestSeconds.toString().padStart(2, '0')}`;
            }
            
            // Update leader
            document.getElementById('leader').textContent = gameState.leader;
            
            // Update race map
            updateRaceMap();
            
            // Update lightspeed cooldown
            if (gameState.lightspeedCooldown > 0) {
                gameState.lightspeedCooldown -= 0.1;
                
                if (gameState.lightspeedCooldown <= 0) {
                    document.getElementById('lightspeedBtn').textContent = 'LIGHTSPEED';
                    document.getElementById('lightspeedBtn').disabled = false;
                }
            }
        }
        
        // Update race map
        function updateRaceMap() {
            // Update player position on map
            const playerDot = document.getElementById('player-dot');
            const playerProgress = (gameState.playerProgress / gameState.trackLength) * 100;
            playerDot.style.left = `${20 + (playerProgress * 1.6)}px`;
            playerDot.style.top = '75px';
            
            // Update AI positions on map
            for (let i = 0; i < aiRacers.length; i++) {
                const aiDot = document.getElementById(`ai${i+1}-dot`);
                const aiProgress = (aiRacers[i].progress / gameState.trackLength) * 100;
                aiDot.style.left = `${20 + (aiProgress * 1.6)}px`;
                aiDot.style.top = `${25 + (i * 25)}px`;
            }
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Move player forward through the tunnel
            gameState.playerProgress += gameState.playerSpeed * 0.01;
            gameState.nextCheckpoint = Math.max(0, 500 - (gameState.playerProgress % 500));
            
            // Update player position in tunnel
            const tunnelProgress = (gameState.playerProgress % gameState.trackLength) / gameState.trackLength;
            const segmentIndex = Math.floor(tunnelProgress * (tunnelSegments.length - 1));
            
            if (segmentIndex < tunnelSegments.length - 1) {
                const segment = tunnelSegments[segmentIndex];
                const nextSegment = tunnelSegments[segmentIndex + 1];
                const segmentProgress = (tunnelProgress * (tunnelSegments.length - 1)) % 1;
                
                // Interpolate position between segment points
                const position = new THREE.Vector3().lerpVectors(
                    segment.start, 
                    segment.end, 
                    segmentProgress
                );
                
                // Move player ship
                spaceship.position.copy(position);
                
                // Calculate direction for ship orientation
                const direction = new THREE.Vector3().subVectors(nextSegment.start, segment.start).normalize();
                spaceship.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), direction);
            }
            
            // Move AI ships through the tunnel
            for (let i = 0; i < aiShips.length; i++) {
                aiRacers[i].progress += aiRacers[i].speed * 0.01;
                const aiTunnelProgress = (aiRacers[i].progress % gameState.trackLength) / gameState.trackLength;
                const aiSegmentIndex = Math.floor(aiTunnelProgress * (tunnelSegments.length - 1));
                
                if (aiSegmentIndex < tunnelSegments.length - 1) {
                    const segment = tunnelSegments[aiSegmentIndex];
                    const nextSegment = tunnelSegments[aiSegmentIndex + 1];
                    const segmentProgress = (aiTunnelProgress * (tunnelSegments.length - 1)) % 1;
                    
                    // Interpolate position between segment points
                    const position = new THREE.Vector3().lerpVectors(
                        segment.start, 
                        segment.end, 
                        segmentProgress
                    );
                    
                    // Add some offset so AI ships don't follow exact same path
                    position.x += (Math.sin(aiRacers[i].progress * 0.05 + i) * 2);
                    position.y += (Math.cos(aiRacers[i].progress * 0.03 + i) * 1.5);
                    
                    // Move AI ship
                    aiShips[i].position.copy(position);
                    
                    // Calculate direction for ship orientation
                    const direction = new THREE.Vector3().subVectors(nextSegment.start, segment.start).normalize();
                    aiShips[i].quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), direction);
                }
            }
            
            // Move drones
            for (let i = drones.length - 1; i >= 0; i--) {
                if (drones[i].active) {
                    drones[i].mesh.position.z -= drones[i].speed;
                    drones[i].mesh.rotation.x += 0.1;
                    drones[i].mesh.rotation.y += 0.1;
                    
                    // Remove drones that are too far behind
                    if (drones[i].mesh.position.z < spaceship.position.z - 100) {
                        scene.remove(drones[i].mesh);
                        drones.splice(i, 1);
                    }
                }
            }
            
            // Update camera position to follow player
            camera.position.lerp(new THREE.Vector3(
                spaceship.position.x,
                spaceship.position.y + 3,
                spaceship.position.z + 7
            ), 0.1);
            
            camera.lookAt(spaceship.position.x, spaceship.position.y, spaceship.position.z - 5);
            
            // Rotate stars slightly for moving effect
            stars.forEach(star => {
                star.rotation.x += 0.0005;
                star.rotation.y += 0.0005;
            });
            
            // Update leaderboard
            updatePositions();
            
            // Render the scene
            renderer.render(scene, camera);
        }
        
        // Update race positions
        function updatePositions() {
            // Create array with all racers
            const allRacers = [
                { progress: gameState.playerProgress, isPlayer: true },
                { progress: aiRacers[0].progress, isPlayer: false, index: 0 },
                { progress: aiRacers[1].progress, isPlayer: false, index: 1 },
                { progress: aiRacers[2].progress, isPlayer: false, index: 2 }
            ];
            
            // Sort by progress (descending)
            allRacers.sort((a, b) => b.progress - a.progress);
            
            // Update positions
            for (let i = 0; i < allRacers.length; i++) {
                if (allRacers[i].isPlayer) {
                    gameState.playerPosition = i + 1;
                } else {
                    aiRacers[allRacers[i].index].position = i + 1;
                }
            }
            
            // Update leader
            if (!allRacers[0].isPlayer) {
                gameState.leader = aiRacers[allRacers[0].index].name;
            } else {
                gameState.leader = "YOU";
            }
            
            // Check for lap completion
            if (gameState.playerProgress >= gameState.currentLap * gameState.trackLength) {
                gameState.currentLap++;
                
                if (gameState.currentLap > gameState.totalLaps) {
                    // Race completed
                    gameState.raceStarted = false;
                    alert(`Race finished! Your position: ${gameState.playerPosition}`);
                }
            }
        }
        
        // Simulate loading process
        function simulateLoading() {
            let progress = 0;
            const progressBar = document.getElementById('progress');
            const loadingInterval = setInterval(() => {
                progress += Math.random() * 5;
                progressBar.style.width = `${progress}%`;
                
                if (progress >= 100) {
                    clearInterval(loadingInterval);
                    setTimeout(initGame, 500);
                }
            }, 100);
        }
        
        // Start loading
        simulateLoading();
    </script>
</body>
</html>