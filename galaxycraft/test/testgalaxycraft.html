<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GalaxyCraft - TESTING MODE</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
    }
    body {
      background: #000;
      color: #fff;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    #cosmicCanvas {
      flex: 1;
      width: 100%;
      touch-action: none;
      position: relative;
    }
    .controls {
      position: fixed;
      bottom: 0;
      width: 100%;
      background: rgba(20, 20, 50, 0.9);
      padding: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      backdrop-filter: blur(5px);
      z-index: 10;
    }
    .control-item {
      flex: 1;
      min-width: 80px;
      text-align: center;
    }
    button {
      background: #4a90e2;
      border: none;
      padding: 10px 20px;
      color: white;
      border-radius: 20px;
      cursor: pointer;
      font-size: 16px;
      transition: transform 0.2s, background 0.2s;
    }
    button:hover {
      background: #357abd;
    }
    button.active {
      background: #ff4444;
    }
    button:active {
      transform: scale(0.95);
    }
    .prompt {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 10px;
      font-size: 14px;
      max-width: 90%;
      text-align: center;
      opacity: 0;
      transition: opacity 0.5s;
      z-index: 5;
    }
    .prompt.active {
      opacity: 1;
    }
    .hud {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      opacity: 0.4;
      z-index: 1;
    }
    .hud::before {
      content: '';
      position: absolute;
      top: 10%;
      left: 10%;
      right: 10%;
      bottom: 10%;
      border: 2px solid rgba(74, 144, 226, 0);
      border-radius: 20px;
      box-shadow: none;
    }
    .hud::after {
      content: '+';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #4a90e2;
      font-size: 24px;
    }
    .throttle-indicator {
      position: absolute;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      color: #4a90e2;
      font-size: 12px;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 5;
    }
    .throttle-indicator.active {
      opacity: 1;
    }
    .status-overlay {
      position: absolute;
      top: 0;
      width: 100%;
      background: rgba(0, 0, 0, 0.3);
      padding: 5px 10px;
      font-size: 12px;
      text-align: left;
      color: #fff;
      text-shadow: 0 0 2px #000;
      z-index: 5;
      pointer-events: none;
    }
    .console {
      position: absolute;
      bottom: 60px;
      width: 100%;
      height: 25%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      flex-direction: column;
      z-index: 5;
      padding: 5px;
    }
    .console-log {
      flex: 1;
      overflow-y: auto;
      font-size: 12px;
      color: #fff;
      text-shadow: 0 0 2px #000;
      padding: 5px;
    }
    .console-log p {
      margin: 2px 0;
    }
    .console-input {
      width: 100%;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid #4a90e2;
      color: #fff;
      padding: 5px;
      font-size: 12px;
      outline: none;
    }
    .console-input::placeholder {
      color: #aaa;
    }
    .console::-webkit-scrollbar {
      width: 8px;
    }
    .console::-webkit-scrollbar-thumb {
      background: #4a90e2;
      border-radius: 4px;
    }
    .camera-controls {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 10px;
      z-index: 10;
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    .camera-controls button {
      padding: 8px 12px;
      font-size: 14px;
    }
    .resource-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 10px;
      z-index: 10;
      display: flex;
      flex-direction: column;
      gap: 5px;
      font-size: 14px;
    }
    .resource-item {
      display: flex;
      justify-content: space-between;
      width: 200px;
    }
    .testing-banner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 0, 0, 0.7);
      padding: 10px 20px;
      border-radius: 10px;
      font-size: 24px;
      font-weight: bold;
      z-index: 100;
      pointer-events: none;
    }
    .crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      border: 2px solid #0f0;
      border-radius: 50%;
      pointer-events: none;
      z-index: 5;
    }
  </style>
</head>
<body>
  <div id="cosmicCanvas">
    <div class="hud"></div>
    <div class="crosshair"></div>
    <div id="statusOverlay" class="status-overlay"></div>
    <div id="throttleIndicator" class="throttle-indicator"></div>
    <div id="console" class="console">
      <div id="consoleLog" class="console-log"></div>
      <input id="consoleInput" class="console-input" type="text" placeholder="Type /help for commands..." autocomplete="off">
    </div>
    <div class="testing-banner">TESTING MODE - UNLIMITED RESOURCES</div>
    <div class="camera-controls">
      <button id="cameraLockBtn">Lock Camera</button>
      <button id="resetViewBtn">Reset View</button>
      <button id="freeLookBtn">Free Look</button>
    </div>
    <div class="resource-panel">
      <div class="resource-item"><span>Credits:</span> <span id="creditsValue">∞</span></div>
      <div class="resource-item"><span>Ores:</span> <span id="oresValue">∞</span></div>
      <div class="resource-item"><span>Crystals:</span> <span id="crystalsValue">∞</span></div>
      <div class="resource-item"><span>Fuel:</span> <span id="fuelValue">∞</span></div>
      <div class="resource-item"><span>Energy:</span> <span id="energyValue">∞</span></div>
    </div>
  </div>
  <div class="controls">
    <div class="control-item">
      <button id="throttleBtn">Full Throttle</button>
    </div>
    <div class="control-item">
      <button id="mineBtn">Mine</button>
    </div>
    <div class="control-item">
      <button id="scanBtn">Scan</button>
    </div>
    <div class="control-item">
      <button id="addNode">Add Node</button>
    </div>
    <div class="control-item">
      <button id="autopilotBtn">Autopilot</button>
    </div>
    <div class="control-item">
      <button id="cameraBtn">Camera</button>
    </div>
    <div class="control-item">
      <button id="craftBtn">Craft</button>
    </div>
    <div class="control-item">
      <button id="resetBtn">Reset</button>
    </div>
  </div>
  <div id="prompt" class="prompt"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
    window.onload = () => {
      try {
        // Scene setup
        if (!window.THREE) throw new Error('Three.js not loaded');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 1);
        const canvas = document.getElementById('cosmicCanvas');
        if (!canvas) throw new Error('Canvas element not found');
        canvas.appendChild(renderer.domElement);

        camera.position.set(0, 0, 0);
        
        // Add some stars to the background
        const starGeometry = new THREE.BufferGeometry();
        const starVertices = [];
        for (let i = 0; i < 10000; i++) {
          const x = (Math.random() - 0.5) * 2000;
          const y = (Math.random() - 0.5) * 2000;
          const z = (Math.random() - 0.5) * 2000;
          starVertices.push(x, y, z);
        }
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.7 });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // Shared resources
        const sharedMaterials = {
          resource: new THREE.MeshBasicMaterial({ color: 0x00ff00 }),
          ore: new THREE.MeshBasicMaterial({ color: 0xcccccc }),
          crystal: new THREE.MeshBasicMaterial({ color: 0x8844ff }),
          node: new THREE.MeshBasicMaterial({ color: 0xff33cc }),
          line: new THREE.LineBasicMaterial({ color: 0x00ff00 })
        };
        const sharedGeometries = {
          resource: new THREE.SphereGeometry(10, 12, 12),
          node: new THREE.BoxGeometry(15, 15, 15)
        };

        // Game state
        let resources = [];
        let nodes = [];
        let nodeLines = [];
        let throttle = 0;
        let rotation = { x: 0, y: 0 };
        let velocity = new THREE.Vector3(0, 0, 0);
        let lastTime = performance.now();
        let entityCount = 0;
        let autopilotActive = false;
        let currentNodeIndex = 0;
        let cameraLocked = false;
        let freeLookActive = false;
        let isMouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        // Testing mode - unlimited resources
        const playerResources = {
          credits: Infinity,
          ores: Infinity,
          crystals: Infinity,
          fuel: Infinity,
          energy: Infinity
        };

        // Console and status
        const statusOverlay = document.getElementById('statusOverlay');
        const consoleLog = document.getElementById('consoleLog');
        const consoleInput = document.getElementById('consoleInput');
        const maxLogMessages = 50;
        let logMessages = [];

        function addConsoleMessage(message) {
          const timestamp = new Date().toLocaleTimeString();
          logMessages.push(`[${timestamp}] ${message}`);
          if (logMessages.length > maxLogMessages) {
            logMessages.shift();
          }
          consoleLog.innerHTML = logMessages.map(msg => `<p>${msg}</p>`).join('');
          consoleLog.scrollTop = consoleLog.scrollHeight;
        }

        function updateStatusOverlay() {
          statusOverlay.textContent = `Resources: ${resources.length} | Throttle: ${throttle} | Autopilot: ${autopilotActive ? 'On' : 'Off'} | Nodes: ${nodes.length}`;
        }

        // Initialize resources for testing
        function initializeTestResources() {
          // Create some test resources
          for (let i = 0; i < 20; i++) {
            const resource = new THREE.Mesh(
              sharedGeometries.resource, 
              Math.random() > 0.5 ? sharedMaterials.ore : sharedMaterials.crystal
            );
            
            const distance = 100 + Math.random() * 300;
            const angle = Math.random() * Math.PI * 2;
            
            resource.position.set(
              Math.cos(angle) * distance,
              (Math.random() - 0.5) * 200,
              Math.sin(angle) * distance
            );
            
            resource.userData = {
              type: Math.random() > 0.5 ? 'ore' : 'crystal',
              value: Math.floor(Math.random() * 50) + 10
            };
            
            scene.add(resource);
            resources.push(resource);
            entityCount++;
          }
          addConsoleMessage("Test resources created");
        }

        // Keyboard controls - Improved FPV controls
        const keys = { 
          w: false, a: false, s: false, d: false,
          ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
          Shift: false
        };
        
        window.addEventListener('keydown', e => {
          const key = e.key.toLowerCase();
          if (keys.hasOwnProperty(key)) {
            keys[key] = true;
            e.preventDefault();
          }
          
          // Special keys
          if (key === ' ') {
            toggleMining();
          } else if (key === 'c') {
            toggleCameraLock();
          } else if (key === 'm') {
            addConsoleMessage("TEST MODE: Mining resources added to inventory");
          } else if (key === 'p') {
            toggleAutopilot();
          }
        });
        
        window.addEventListener('keyup', e => {
          const key = e.key.toLowerCase();
          if (keys.hasOwnProperty(key)) {
            keys[key] = false;
            e.preventDefault();
          }
        });

        // Mouse controls for camera
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        
        function onMouseMove(e) {
          if (!cameraLocked || !isMouseDown) return;
          
          const deltaX = e.clientX - lastMouseX;
          const deltaY = e.clientY - lastMouseY;
          
          // Adjust rotation based on mouse movement
          rotation.y += deltaX * 0.003;
          rotation.x += deltaY * 0.003;
          
          // Limit vertical rotation to avoid flipping
          rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotation.x));
          
          lastMouseX = e.clientX;
          lastMouseY = e.clientY;
        }
        
        function onMouseDown(e) {
          if (cameraLocked) {
            isMouseDown = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
          }
        }
        
        function onMouseUp() {
          isMouseDown = false;
        }
        
        // Add event listeners for mouse control
        renderer.domElement.addEventListener('mousemove', onMouseMove);
        renderer.domElement.addEventListener('mousedown', onMouseDown);
        renderer.domElement.addEventListener('mouseup', onMouseUp);
        
        // Touch controls for mobile
        renderer.domElement.addEventListener('touchstart', e => {
          if (cameraLocked && e.touches.length === 1) {
            isMouseDown = true;
            lastMouseX = e.touches[0].clientX;
            lastMouseY = e.touches[0].clientY;
            e.preventDefault();
          }
        });
        
        renderer.domElement.addEventListener('touchmove', e => {
          if (cameraLocked && isMouseDown && e.touches.length === 1) {
            const deltaX = e.touches[0].clientX - lastMouseX;
            const deltaY = e.touches[0].clientY - lastMouseY;
            
            rotation.y += deltaX * 0.003;
            rotation.x += deltaY * 0.003;
            rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotation.x));
            
            lastMouseX = e.touches[0].clientX;
            lastMouseY = e.touches[0].clientY;
            e.preventDefault();
          }
        });
        
        renderer.domElement.addEventListener('touchend', () => {
          isMouseDown = false;
        });

        // Console commands
        function handleCommand(input) {
          const cmd = input.trim().toLowerCase();
          if (!cmd.startsWith('/')) {
            addConsoleMessage('Commands must start with "/". Type /help for commands.');
            return;
          }
          const parts = cmd.slice(1).split(' ');
          const command = parts[0];
          const args = parts.slice(1);

          switch (command) {
            case 'help':
              addConsoleMessage('Commands: /mine, /scan, /addnode, /autopilot, /camera, /reset, /throttle');
              break;
            case 'mine':
              toggleMining();
              break;
            case 'scan':
              scanArea();
              break;
            case 'addnode':
              addNode();
              break;
            case 'autopilot':
              toggleAutopilot();
              break;
            case 'camera':
              toggleCameraLock();
              break;
            case 'reset':
              reset();
              break;
            case 'throttle':
              toggleThrottle();
              break;
            default:
              addConsoleMessage('Unknown command. Type /help for commands.');
          }
        }

        consoleInput.addEventListener('keydown', e => {
          if (e.key === 'Enter') {
            const input = consoleInput.value;
            if (input) {
              addConsoleMessage(`> ${input}`);
              handleCommand(input);
              consoleInput.value = '';
            }
          }
        });

        // Add entities
        function addNode() {
          const node = new THREE.Mesh(sharedGeometries.node, sharedMaterials.node);
          const forward = new THREE.Vector3(0, 0, -1).applyEuler(new THREE.Euler(rotation.x, rotation.y, 0));
          node.position.copy(camera.position).add(forward.multiplyScalar(100));
          node.userData = { type: 'node', created: Date.now() };
          scene.add(node);
          nodes.push(node);
          entityCount++;

          if (nodes.length > 1) {
            const prevNode = nodes[nodes.length - 2];
            const geometry = new THREE.BufferGeometry().setFromPoints([
              prevNode.position,
              node.position
            ]);
            const line = new THREE.Line(geometry, sharedMaterials.line);
            scene.add(line);
            nodeLines.push(line);
          }

          showPrompt("Satellite node deployed.");
          addConsoleMessage('Satellite node deployed.');
          updateStatusOverlay();
        }

        function toggleMining() {
          // Find closest resource
          let closestResource = null;
          let closestDistance = Infinity;
          
          resources.forEach(resource => {
            const distance = camera.position.distanceTo(resource.position);
            if (distance < 50 && distance < closestDistance) {
              closestDistance = distance;
              closestResource = resource;
            }
          });
          
          if (closestResource) {
            // In testing mode, just add resources without removing them
            const resourceType = closestResource.userData.type;
            const resourceValue = closestResource.userData.value;
            
            addConsoleMessage(`TEST MODE: Mined ${resourceValue} ${resourceType} (resource remains)`);
            showPrompt(`Mined ${resourceValue} ${resourceType}`);
            
            // Visual feedback - pulse the resource
            const originalScale = closestResource.scale.clone();
            closestResource.scale.multiplyScalar(1.5);
            setTimeout(() => {
              closestResource.scale.copy(originalScale);
            }, 200);
          } else {
            addConsoleMessage("No resources nearby to mine");
            showPrompt("No resources nearby");
          }
        }

        function scanArea() {
          // Highlight nearby resources
          resources.forEach(resource => {
            const distance = camera.position.distanceTo(resource.position);
            if (distance < 200) {
              const originalColor = resource.material.color.clone();
              resource.material.color.set(0xffff00);
              
              setTimeout(() => {
                resource.material.color.copy(originalColor);
              }, 2000);
            }
          });
          
          addConsoleMessage("Area scanned. Nearby resources highlighted.");
          showPrompt("Scanning area...");
        }

        function reset() {
          // Remove nodes and lines
          nodes.forEach(node => scene.remove(node));
          nodes = [];
          nodeLines.forEach(line => scene.remove(line));
          nodeLines = [];
          
          // Reset camera and movement
          camera.position.set(0, 0, 0);
          rotation.x = 0;
          rotation.y = 0;
          velocity.set(0, 0, 0);
          throttle = 0;
          autopilotActive = false;
          currentNodeIndex = 0;
          
          const autopilotBtn = document.getElementById('autopilotBtn');
          if (autopilotBtn) autopilotBtn.classList.remove('active');
          const throttleBtn = document.getElementById('throttleBtn');
          if (throttleBtn) throttleBtn.classList.remove('active');
          const throttleIndicator = document.getElementById('throttleIndicator');
          if (throttleIndicator) {
            throttleIndicator.textContent = '';
            throttleIndicator.classList.remove('active');
          }
          
          showPrompt("Reset complete.");
          addConsoleMessage('Reset complete.');
          updateStatusOverlay();
        }

        // Throttle toggle for command
        function toggleThrottle() {
          throttle = throttle === 0 ? 50 : 0;
          const throttleBtn = document.getElementById('throttleBtn');
          if (throttleBtn) throttleBtn.classList.toggle('active', throttle > 0);
          const throttleIndicator = document.getElementById('throttleIndicator');
          if (throttleIndicator) {
            throttleIndicator.textContent = throttle > 0 ? `Thrust: ${throttle}` : '';
            throttleIndicator.classList.toggle('active', throttle > 0);
          }
          showPrompt(throttle > 0 ? "Throttle engaged!" : "Throttle disengaged.");
          addConsoleMessage(throttle > 0 ? 'Throttle engaged!' : 'Throttle disengaged.');
          updateStatusOverlay();
        }

        // Camera controls
        function toggleCameraLock() {
          cameraLocked = !cameraLocked;
          const cameraBtn = document.getElementById('cameraBtn');
          if (cameraBtn) cameraBtn.classList.toggle('active', cameraLocked);
          
          if (cameraLocked) {
            showPrompt("Camera control enabled - Click and drag to look around");
            addConsoleMessage("Camera control enabled");
          } else {
            showPrompt("Camera control disabled");
            addConsoleMessage("Camera control disabled");
          }
        }
        
        function resetView() {
          rotation.x = 0;
          rotation.y = 0;
          showPrompt("View reset");
          addConsoleMessage("View reset");
        }
        
        function toggleFreeLook() {
          freeLookActive = !freeLookActive;
          const freeLookBtn = document.getElementById('freeLookBtn');
          if (freeLookBtn) freeLookBtn.classList.toggle('active', freeLookActive);
          
          if (freeLookActive) {
            showPrompt("Free look mode enabled");
            addConsoleMessage("Free look mode enabled");
          } else {
            showPrompt("Free look mode disabled");
            addConsoleMessage("Free look mode disabled");
          }
        }

        // Autopilot
        function toggleAutopilot() {
          if (nodes.length < 2) {
            showPrompt("Need at least 2 nodes for autopilot!");
            addConsoleMessage('Need at least 2 nodes for autopilot.');
            return;
          }
          autopilotActive = !autopilotActive;
          const autopilotBtn = document.getElementById('autopilotBtn');
          if (autopilotBtn) autopilotBtn.classList.toggle('active', autopilotActive);
          if (autopilotActive) {
            throttle = 0;
            const throttleBtn = document.getElementById('throttleBtn');
            if (throttleBtn) throttleBtn.classList.remove('active');
            const throttleIndicator = document.getElementById('throttleIndicator');
            if (throttleIndicator) {
              throttleIndicator.textContent = '';
              throttleIndicator.classList.remove('active');
            }
            currentNodeIndex = 0;
            showPrompt("Autopilot engaged! Navigating nodes.");
            addConsoleMessage('Autopilot engaged! Navigating nodes.');
          } else {
            showPrompt("Autopilot disengaged.");
            addConsoleMessage('Autopilot disengaged.');
          }
          updateStatusOverlay();
        }

        function updateAutopilot(deltaTime) {
          if (!autopilotActive || nodes.length === 0) return;

          const targetNode = nodes[currentNodeIndex];
          const direction = targetNode.position.clone().sub(camera.position);
          const distance = direction.length();

          if (distance < 30) {
            currentNodeIndex = (currentNodeIndex + 1) % nodes.length;
            addConsoleMessage(`Reached node ${currentNodeIndex + 1}. Heading to next node.`);
          }

          // Move toward the node
          direction.normalize();
          const speed = 50;
          velocity.copy(direction.multiplyScalar(speed));
          camera.position.add(velocity.clone().multiplyScalar(deltaTime));

          // Look at the node
          const targetRotation = Math.atan2(direction.x, direction.z);
          rotation.y = targetRotation;
        }

        // Animation loop
        function animate() {
          requestAnimationFrame(animate);

          const now = performance.now();
          const deltaTime = Math.min((now - lastTime) / 1000, 0.1);
          lastTime = now;

          // Apply rotation to camera
          camera.rotation.set(rotation.x, rotation.y, 0);
          
          // Handle keyboard movement
          if (!autopilotActive) {
            const moveSpeed = throttle > 0 ? throttle : 20;
            const moveVector = new THREE.Vector3(0, 0, 0);
            
            if (keys.w || keys.arrowup) moveVector.z -= 1;
            if (keys.s || keys.arrowdown) moveVector.z += 1;
            if (keys.a || keys.arrowleft) moveVector.x -= 1;
            if (keys.d || keys.arrowright) moveVector.x += 1;
            if (keys.shift) moveVector.y -= 1; // Descend
            if (keys.space) moveVector.y += 1; // Ascend (spacebar)
            
            if (moveVector.length() > 0) {
              moveVector.normalize();
              moveVector.applyEuler(camera.rotation);
              moveVector.multiplyScalar(moveSpeed * deltaTime);
              camera.position.add(moveVector);
            }
          } else {
            updateAutopilot(deltaTime);
          }

          // Update node connections
          nodeLines.forEach((line, i) => {
            if (i < nodes.length - 1) {
              const geometry = new THREE.BufferGeometry().setFromPoints([
                nodes[i].position,
                nodes[i + 1].position
              ]);
              line.geometry.dispose();
              line.geometry = geometry;
            }
          });

          renderer.render(scene, camera);
        }

        // Controls
        try {
          const throttleBtn = document.getElementById('throttleBtn');
          const mineBtn = document.getElementById('mineBtn');
          const scanBtn = document.getElementById('scanBtn');
          const addNodeBtn = document.getElementById('addNode');
          const autopilotBtn = document.getElementById('autopilotBtn');
          const cameraBtn = document.getElementById('cameraBtn');
          const craftBtn = document.getElementById('craftBtn');
          const resetBtn = document.getElementById('resetBtn');
          const cameraLockBtn = document.getElementById('cameraLockBtn');
          const resetViewBtn = document.getElementById('resetViewBtn');
          const freeLookBtn = document.getElementById('freeLookBtn');
          const throttleIndicator = document.getElementById('throttleIndicator');
          const prompt = document.getElementById('prompt');

          if (!throttleBtn || !mineBtn || !scanBtn || !addNodeBtn || !autopilotBtn || 
              !cameraBtn || !craftBtn || !resetBtn || !cameraLockBtn || !resetViewBtn || 
              !freeLookBtn || !prompt || !throttleIndicator) {
            throw new Error('One or more control elements not found');
          }

          throttleBtn.addEventListener('click', toggleThrottle);
          mineBtn.addEventListener('click', toggleMining);
          scanBtn.addEventListener('click', scanArea);
          addNodeBtn.addEventListener('click', addNode);
          autopilotBtn.addEventListener('click', toggleAutopilot);
          cameraBtn.addEventListener('click', toggleCameraLock);
          craftBtn.addEventListener('click', () => {
            showPrompt("Crafting menu would open here");
            addConsoleMessage("TEST MODE: Crafting menu would open here");
          });
          resetBtn.addEventListener('click', reset);
          cameraLockBtn.addEventListener('click', toggleCameraLock);
          resetViewBtn.addEventListener('click', resetView);
          freeLookBtn.addEventListener('click', toggleFreeLook);

          function showPrompt(message) {
            prompt.textContent = message;
            prompt.classList.add('active');
            setTimeout(() => prompt.classList.remove('active'), 2000);
          }
        } catch (e) {
          console.error('Control setup error:', e);
        }

        // Initialize
        try {
          initializeTestResources();
          addConsoleMessage('GalaxyCraft Testing Mode initialized. Unlimited resources available.');
          addConsoleMessage('Use WASD to move, mouse to look around when camera is locked.');
          updateStatusOverlay();
          animate();
        } catch (e) {
          console.error('Initialization error:', e);
        }

        // Resize
        window.addEventListener('resize', () => {
          try {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
          } catch (e) {
            console.error('Resize error:', e);
          }
        });
      } catch (e) {
        console.error('Main script error:', e);
      }
    };
  </script>
</body>
</html>