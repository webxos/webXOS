<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GalaxyCraft: Dog Fight</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #ui {
      position: absolute;
      top: 0;
      left: 0;
      color: white;
      font-family: Arial, sans-serif;
      pointer-events: none;
      user-select: none;
    }
    #ui div { margin: 10px; }
    #score { top: 10px; left: 10px; }
    #health { top: 40px; left: 10px; }
    #armor { top: 70px; left: 10px; }
    #energy { top: 100px; left: 10px; }
    #ammo { top: 130px; left: 10px; }
    #weapon { top: 160px; left: 10px; }
    #wave { top: 190px; left: 10px; }
    #coreData { top: 220px; left: 10px; }
    #fps { top: 250px; left: 10px; }
    #lightspeed { top: 280px; left: 10px; }
    #alert {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      color: red;
      display: none;
    }
    #upgradesMenu, #settingsMenu, #mainMenu, #missionComplete {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 20px;
      display: none;
      pointer-events: auto;
      color: white;
      font-family: Arial, sans-serif;
    }
    #mainMenu { display: block; }
    button {
      display: block;
      margin: 10px auto;
      padding: 10px 20px;
      font-size: 18px;
      cursor: pointer;
    }
    #settingsMenu label, #upgradesMenu label {
      display: block;
      margin: 10px 0;
    }
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      transform: translate(-50%, -50%);
      border: 2px solid #00ff00;
      border-radius: 50%;
      box-shadow: 0 0 10px #00ff00;
      display: none;
    }
    #targetArrow {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 30px;
      height: 30px;
      transform: translate(-50%, -50%);
      border: 2px solid #00ff00;
      clip-path: polygon(50% 0%, 100% 100%, 0% 100%);
      display: none;
    }
    .glitch {
      animation: glitch 0.1s infinite alternate;
    }
    @keyframes glitch {
      0% { transform: translate(-50%, -50%) skew(0deg); }
      100% { transform: translate(-50%, -50%) skew(5deg); }
    }
  </style>
</head>
<body>
  <div id="ui">
    <div id="score">SCORE: 0</div>
    <div id="health">HEALTH: 100</div>
    <div id="armor">ARMOR: 100</div>
    <div id="energy">ENERGY: 100</div>
    <div id="ammo">AMMO: ∞/∞</div>
    <div id="weapon">WEAPON: NEURO-GATLING</div>
    <div id="wave">WAVE: 1/100 | DRONES: 0</div>
    <div id="coreData">CORE DATA: 30000</div>
    <div id="fps">FPS: 0</div>
    <div id="lightspeed">LIGHTSPEED: READY</div>
    <div id="alert">INCOMING!</div>
  </div>
  <div id="mainMenu">
    <h2>GALAXYCRAFT: DOG FIGHT</h2>
    <button onclick="startGame()">DEFEND THE CORE</button>
    <button onclick="showUpgrades()">UPGRADES</button>
    <button onclick="showSettings()">SETTINGS</button>
    <button onclick="window.close()">QUIT</button>
  </div>
  <div id="upgradesMenu">
    <h2>UPGRADES AVAILABLE</h2>
    <button onclick="upgrade('health')">INCREASE HEALTH (+20) Cost: 500</button>
    <button onclick="upgrade('armor')">INCREASE ARMOR (+20) Cost: 500</button>
    <button onclick="upgrade('damage')">INCREASE DAMAGE (+10%) Cost: 750</button>
    <button onclick="upgrade('speed')">INCREASE SPEED (+10%) Cost: 600</button>
    <button onclick="upgrade('energy')">INCREASE ENERGY (+20%) Cost: 400</button>
    <button onclick="upgrade('core')">REPAIR CORE (+5000) Cost: 1000</button>
    <button onclick="backToMenu()">CLOSE</button>
  </div>
  <div id="settingsMenu">
    <h2>GAME SETTINGS</h2>
    <label>Mouse Sensitivity: <input type="range" id="mouseSensitivity" min="0.001" max="0.005" step="0.001" value="0.002"></label>
    <label>Invert Y-Axis: <input type="checkbox" id="invertY"></label>
    <label>FOV: <input type="range" id="fov" min="60" max="120" step="1" value="75"></label>
    <label>Sound Volume: <input type="range" id="soundVolume" min="0" max="1" step="0.1" value="1"></label>
    <button onclick="backToMenu()">BACK</button>
  </div>
  <div id="missionComplete">
    <h2>MISSION COMPLETE</h2>
    <div id="finalScore">Final Score: 0</div>
    <div id="wavesSurvived">Waves Survived: 0</div>
    <div id="dronesDestroyed">Drones Destroyed: 0</div>
    <div id="accuracy">Accuracy: 0%</div>
    <div id="coreDataRemaining">Core Data Remaining: 0</div>
    <div id="creditsEarned">Total Credits Earned: 0</div>
    <button onclick="startGame()">PLAY AGAIN</button>
    <button onclick="backToMenu()">MAIN MENU</button>
  </div>
  <div id="crosshair"></div>
  <div id="targetArrow"></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
    // Performance optimization settings
    const MAX_ENTITIES = 400;
    const PERFORMANCE_MODE = true; // Reduces visual quality for better performance
    
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ 
      antialias: !PERFORMANCE_MODE,
      powerPreference: "high-performance"
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Starry background (optimized)
    const starGeometry = new THREE.BufferGeometry();
    const starMaterial = new THREE.PointsMaterial({ 
      color: 0xffffff, 
      size: PERFORMANCE_MODE ? 0.03 : 0.05,
      sizeAttenuation: true
    });
    const starVertices = [];
    const starCount = PERFORMANCE_MODE ? 2000 : 5000;
    for (let i = 0; i < starCount; i++) {
      starVertices.push((Math.random() - 0.5) * 1000, (Math.random() - 0.5) * 1000, (Math.random() - 0.5) * 1000);
    }
    starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
    const stars = new THREE.Points(starGeometry, starMaterial);
    scene.add(stars);

    // Central green planet (core) - optimized
    const coreGeometry = new THREE.SphereGeometry(10, PERFORMANCE_MODE ? 12 : 16, PERFORMANCE_MODE ? 12 : 16);
    const coreTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg');
    const coreMaterial = new THREE.MeshBasicMaterial({ map: coreTexture });
    const core = new THREE.Mesh(coreGeometry, coreMaterial);
    scene.add(core);

    // Smaller planets - optimized
    const planets = [];
    const planetCount = PERFORMANCE_MODE ? 2 : 3;
    for (let i = 0; i < planetCount; i++) {
      const size = 1 + Math.random() * 2;
      const geometry = new THREE.SphereGeometry(size, PERFORMANCE_MODE ? 12 : 16, PERFORMANCE_MODE ? 12 : 16);
      const material = new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff });
      const planet = new THREE.Mesh(geometry, material);
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      const radius = 50 + Math.random() * 30;
      planet.position.set(radius * Math.sin(phi) * Math.cos(theta), radius * Math.sin(phi) * Math.sin(theta), radius * Math.cos(phi));
      scene.add(planet);
      planets.push(planet);
    }

    // Player ship (blue fighter jet) - optimized
    const shipGeometry = new THREE.ConeGeometry(0.5, 2, PERFORMANCE_MODE ? 6 : 8);
    const shipTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/metal_rust.jpg');
    const shipMaterial = new THREE.MeshBasicMaterial({ map: shipTexture, color: 0x0000ff });
    const ship = new THREE.Mesh(shipGeometry, shipMaterial);
    ship.position.set(0, 0, 20);
    scene.add(ship);

    // Third-person camera
    camera.position.set(0, 2, 5);
    ship.add(camera);

    // Controls - optimized for flight simulator feel
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, 
        rollLeft = false, rollRight = false, spin = false, boost = false, scan = false;
    let throttle = 0; // 0 to 1 for forward, -1 to 0 for backward
    let strafeX = 0; // -1 to 1 for left/right
    let strafeY = 0; // -1 to 1 for up/down
    
    let speed = 0.2, boostSpeed = 2.0;
    let health = 100, maxHealth = 100, armor = 100, maxArmor = 100, energy = 100, maxEnergy = 100;
    let damageMultiplier = 1.0, speedMultiplier = 1.0;
    let coreData = 30000, credits = 0, score = 0, dronesDestroyed = 0, wave = 1, maxWaves = 100;
    let shotsFired = 0, shotsHit = 0;
    let pitch = 0, yaw = 0, roll = 0;
    let mouseSensitivity = 0.002, invertY = false, fov = 75;
    let isPaused = true;
    let lightspeedActive = false, lightspeedDuration = 0, lightspeedCooldown = 0;
    let fps = 0, frameCount = 0, lastFpsTime = performance.now();
    const clock = new THREE.Clock();

    // Gamepad support
    let gamepad = null;
    window.addEventListener('gamepadconnected', (e) => {
      gamepad = e.gamepad;
    });
    window.addEventListener('gamepaddisconnected', () => {
      gamepad = null;
    });

    // Enemies (red drone swarms) - optimized
    const enemies = [];
    function spawnEnemySwarm(wave) {
      const swarmSize = Math.min(3 + Math.floor(wave / 5), 20);
      if (enemies.length + swarmSize <= MAX_ENTITIES) {
        for (let i = 0; i < swarmSize; i++) {
          const geometry = new THREE.SphereGeometry(0.2, PERFORMANCE_MODE ? 6 : 8, PERFORMANCE_MODE ? 6 : 8);
          const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
          const enemy = new THREE.Mesh(geometry, material);
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const radius = 30 + Math.random() * 10;
          enemy.position.set(radius * Math.sin(phi) * Math.cos(theta), radius * Math.sin(phi) * Math.sin(theta), radius * Math.cos(phi));
          scene.add(enemy);
          enemies.push({ mesh: enemy, target: core.position });
          if (scan) {
            const dot = new THREE.Mesh(new THREE.SphereGeometry(0.1, 4, 4), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            dot.position.copy(enemy.position);
            scene.add(dot);
            enemy.scanDot = dot;
          }
        }
      }
    }

    // Projectiles (Neuro-Gatling, space/left-click) - optimized
    const projectiles = [];
    function shootProjectile() {
      if (energy >= 1) {
        energy -= 1;
        shotsFired++;
        const geometry = new THREE.SphereGeometry(0.05, 4, 4);
        const material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const projectile = new THREE.Mesh(geometry, material);
        projectile.position.copy(ship.position);
        projectile.rotation.copy(ship.rotation);
        scene.add(projectile);
        projectiles.push({ mesh: projectile, velocity: new THREE.Vector3(0, 0, -1).applyQuaternion(ship.quaternion).multiplyScalar(0.5) });
      }
    }

    // Homing Missiles (R/right-click) - optimized
    const missiles = [];
    function shootMissile() {
      if (energy >= 20 && enemies.length > 0) {
        energy -= 20;
        shotsFired++;
        const geometry = new THREE.SphereGeometry(0.05, 4, 4);
        const material = new THREE.MeshBasicMaterial({ color: 0xff00ff });
        const missile = new THREE.Mesh(geometry, material);
        missile.position.copy(ship.position);
        missile.rotation.copy(ship.rotation);
        const target = enemies[Math.floor(Math.random() * enemies.length)].mesh;
        scene.add(missile);
        missiles.push({ mesh: missile, target });
      }
    }

    // Input handling - optimized for flight controls
    document.addEventListener('keydown', (event) => {
      if (isPaused) return;
      switch (event.key.toLowerCase()) {
        case 'w': throttle = Math.min(throttle + 0.1, 1); break;
        case 's': throttle = Math.max(throttle - 0.1, -1); break;
        case 'a': strafeX = -1; break;
        case 'd': strafeX = 1; break;
        case ' ': strafeY = 1; break; // Space for up
        case 'control': strafeY = -1; break; // Ctrl for down
        case 'q': rollLeft = true; break;
        case 'e': rollRight = true; break;
        case 'z': rollLeft = true; break;
        case 'x': rollRight = true; break;
        case 'c': spin = true; break;
        case 'shift': boost = true; break;
        case ' ': shootProjectile(); break;
        case 'r': shootMissile(); break;
        case 'tab':
          if (!lightspeedActive && lightspeedCooldown <= 0) {
            lightspeedActive = true;
            lightspeedDuration = 10;
            lightspeedCooldown = 30;
            renderer.domElement.classList.add('glitch');
          }
          break;
        case 'alt': scan = !scan; toggleScan(); break;
        case 'escape': toggleMenu(); break;
      }
    });

    document.addEventListener('keyup', (event) => {
      switch (event.key.toLowerCase()) {
        case 'w': case 's': throttle = 0; break;
        case 'a': case 'd': strafeX = 0; break;
        case ' ': case 'control': strafeY = 0; break;
        case 'q': case 'z': rollLeft = false; break;
        case 'e': case 'x': rollRight = false; break;
        case 'c': spin = false; break;
        case 'shift': boost = false; break;
      }
    });

    // Mouse joystick controls
    let isMouseDown = false;
    let mouseX = 0, mouseY = 0;
    let prevMouseX = 0, prevMouseY = 0;
    
    document.addEventListener('mousedown', (event) => {
      isMouseDown = true;
      prevMouseX = event.clientX;
      prevMouseY = event.clientY;
    });
    
    document.addEventListener('mouseup', (event) => {
      isMouseDown = false;
      mouseX = 0;
      mouseY = 0;
    });
    
    document.addEventListener('mousemove', (event) => {
      if (isMouseDown && !isPaused) {
        const deltaX = event.clientX - prevMouseX;
        const deltaY = event.clientY - prevMouseY;
        mouseX = deltaX * mouseSensitivity;
        mouseY = deltaY * mouseSensitivity * (invertY ? -1 : 1);
        prevMouseX = event.clientX;
        prevMouseY = event.clientY;
      }
    });
    
    document.addEventListener('contextmenu', (event) => {
      event.preventDefault();
      shootMissile();
    });

    // Touch controls for mobile
    document.addEventListener('touchstart', (event) => {
      isMouseDown = true;
      prevMouseX = event.touches[0].clientX;
      prevMouseY = event.touches[0].clientY;
    });
    
    document.addEventListener('touchend', (event) => {
      isMouseDown = false;
      mouseX = 0;
      mouseY = 0;
    });
    
    document.addEventListener('touchmove', (event) => {
      if (isMouseDown && !isPaused) {
        const deltaX = event.touches[0].clientX - prevMouseX;
        const deltaY = event.touches[0].clientY - prevMouseY;
        mouseX = deltaX * mouseSensitivity;
        mouseY = deltaY * mouseSensitivity * (invertY ? -1 : 1);
        prevMouseX = event.touches[0].clientX;
        prevMouseY = event.touches[0].clientY;
      }
    });

    // UI functions
    function toggleMenu() {
      isPaused = !isPaused;
      document.getElementById('mainMenu').style.display = isPaused ? 'block' : 'none';
    }

    function startGame() {
      isPaused = false;
      health = maxHealth;
      armor = maxArmor;
      energy = maxEnergy;
      coreData = 30000;
      score = 0;
      dronesDestroyed = 0;
      wave = 1;
      shotsFired = 0;
      shotsHit = 0;
      document.getElementById('mainMenu').style.display = 'none';
      document.getElementById('upgradesMenu').style.display = 'none';
      document.getElementById('settingsMenu').style.display = 'none';
      document.getElementById('missionComplete').style.display = 'none';
      spawnEnemySwarm(wave);
    }

    function showUpgrades() {
      document.getElementById('mainMenu').style.display = 'none';
      document.getElementById('upgradesMenu').style.display = 'block';
    }

    function showSettings() {
      document.getElementById('mainMenu').style.display = 'none';
      document.getElementById('settingsMenu').style.display = 'block';
    }

    function backToMenu() {
      document.getElementById('mainMenu').style.display = 'block';
      document.getElementById('upgradesMenu').style.display = 'none';
      document.getElementById('settingsMenu').style.display = 'none';
    }

    function upgrade(type) {
      const costs = {
        health: 500, armor: 500, damage: 750, speed: 600, energy: 400, core: 1000
      };
      if (credits >= costs[type]) {
        credits -= costs[type];
        switch (type) {
          case 'health': maxHealth += 20; health = maxHealth; break;
          case 'armor': maxArmor += 20; armor = maxArmor; break;
          case 'damage': damageMultiplier *= 1.1; break;
          case 'speed': speedMultiplier *= 1.1; break;
          case 'energy': maxEnergy *= 1.2; energy = maxEnergy; break;
          case 'core': coreData += 5000; break;
        }
      }
    }

    function toggleScan() {
      for (const enemy of enemies) {
        if (scan && !enemy.scanDot) {
          const dot = new THREE.Mesh(new THREE.SphereGeometry(0.1, 4, 4), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
          dot.position.copy(enemy.mesh.position);
          scene.add(dot);
          enemy.scanDot = dot;
        } else if (!scan && enemy.scanDot) {
          scene.remove(enemy.scanDot);
          enemy.scanDot = null;
        }
      }
    }

    // Game loop - optimized for performance
    function animate() {
      requestAnimationFrame(animate);
      
      const delta = clock.getDelta();
      frameCount++;
      const now = performance.now();
      if (now - lastFpsTime >= 1000) {
        fps = Math.round(frameCount * 1000 / (now - lastFpsTime));
        frameCount = 0;
        lastFpsTime = now;
        document.getElementById('fps').textContent = `FPS: ${fps}`;
      }
      
      if (isPaused) return;
      
      // Update settings from UI
      mouseSensitivity = parseFloat(document.getElementById('mouseSensitivity').value);
      invertY = document.getElementById('invertY').checked;
      fov = parseFloat(document.getElementById('fov').value);
      camera.fov = fov;
      camera.updateProjectionMatrix();
      
      // Update ship movement based on controls
      const currentSpeed = boost ? boostSpeed * speedMultiplier : speed * speedMultiplier;
      
      // Apply mouse joystick controls
      if (isMouseDown) {
        yaw += mouseX;
        pitch += mouseY;
        mouseX = 0;
        mouseY = 0;
      }
      
      // Apply keyboard controls
      if (rollLeft) roll += 0.05;
      if (rollRight) roll -= 0.05;
      if (spin) roll = 0;
      
      // Apply ship rotation
      ship.rotation.x = pitch;
      ship.rotation.y = yaw;
      ship.rotation.z = roll;
      
      // Apply throttle and strafing
      const forwardVector = new THREE.Vector3(0, 0, -1).applyQuaternion(ship.quaternion);
      const rightVector = new THREE.Vector3(1, 0, 0).applyQuaternion(ship.quaternion);
      const upVector = new THREE.Vector3(0, 1, 0).applyQuaternion(ship.quaternion);
      
      ship.position.add(forwardVector.multiplyScalar(throttle * currentSpeed * delta * 60));
      ship.position.add(rightVector.multiplyScalar(strafeX * currentSpeed * delta * 60));
      ship.position.add(upVector.multiplyScalar(strafeY * currentSpeed * delta * 60));
      
      // Energy regeneration
      energy = Math.min(energy + 0.1, maxEnergy);
      
      // Lightspeed effect
      if (lightspeedActive) {
        lightspeedDuration -= delta;
        if (lightspeedDuration <= 0) {
          lightspeedActive = false;
          renderer.domElement.classList.remove('glitch');
        }
      } else if (lightspeedCooldown > 0) {
        lightspeedCooldown -= delta;
      }
      
      // Update projectiles
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const projectile = projectiles[i];
        projectile.mesh.position.add(projectile.velocity.clone().multiplyScalar(delta * 60));
        
        // Check for collisions with enemies
        let hit = false;
        for (let j = enemies.length - 1; j >= 0; j--) {
          const enemy = enemies[j];
          if (projectile.mesh.position.distanceTo(enemy.mesh.position) < 0.5) {
            scene.remove(enemy.mesh);
            if (enemy.scanDot) scene.remove(enemy.scanDot);
            enemies.splice(j, 1);
            hit = true;
            shotsHit++;
            score += 100;
            dronesDestroyed++;
            credits += 50;
            break;
          }
        }
        
        // Remove projectiles that are too far or hit something
        if (hit || projectile.mesh.position.length() > 100) {
          scene.remove(projectile.mesh);
          projectiles.splice(i, 1);
        }
      }
      
      // Update missiles
      for (let i = missiles.length - 1; i >= 0; i--) {
        const missile = missiles[i];
        if (missile.target && scene.children.includes(missile.target)) {
          const direction = missile.target.position.clone().sub(missile.mesh.position).normalize();
          missile.mesh.position.add(direction.multiplyScalar(0.3 * delta * 60));
          
          // Check for collision with target
          if (missile.mesh.position.distanceTo(missile.target.position) < 0.5) {
            scene.remove(missile.target);
            const enemyIndex = enemies.findIndex(e => e.mesh === missile.target);
            if (enemyIndex !== -1) {
              const enemy = enemies[enemyIndex];
              if (enemy.scanDot) scene.remove(enemy.scanDot);
              enemies.splice(enemyIndex, 1);
            }
            scene.remove(missile.mesh);
            missiles.splice(i, 1);
            shotsHit++;
            score += 200;
            dronesDestroyed++;
            credits += 100;
          }
        } else {
          // Target no longer exists, remove missile
          scene.remove(missile.mesh);
          missiles.splice(i, 1);
        }
      }
      
      // Update enemies
      for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        const direction = enemy.target.clone().sub(enemy.mesh.position).normalize();
        enemy.mesh.position.add(direction.multiplyScalar(0.05 * delta * 60));
        
        // Check for collision with core
        if (enemy.mesh.position.distanceTo(core.position) < 10.5) {
          scene.remove(enemy.mesh);
          if (enemy.scanDot) scene.remove(enemy.scanDot);
          enemies.splice(i, 1);
          coreData -= 100;
          if (coreData <= 0) {
            gameOver();
          }
        }
        
        // Update scan dots
        if (enemy.scanDot) {
          enemy.scanDot.position.copy(enemy.mesh.position);
        }
      }
      
      // Spawn new enemies if needed
      if (enemies.length === 0) {
        wave++;
        if (wave > maxWaves) {
          missionComplete();
          return;
        }
        spawnEnemySwarm(wave);
      }
      
      // Update UI
      document.getElementById('score').textContent = `SCORE: ${score}`;
      document.getElementById('health').textContent = `HEALTH: ${Math.round(health)}`;
      document.getElementById('armor').textContent = `ARMOR: ${Math.round(armor)}`;
      document.getElementById('energy').textContent = `ENERGY: ${Math.round(energy)}`;
      document.getElementById('wave').textContent = `WAVE: ${wave}/${maxWaves} | DRONES: ${enemies.length}`;
      document.getElementById('coreData').textContent = `CORE DATA: ${coreData}`;
      document.getElementById('lightspeed').textContent = `LIGHTSPEED: ${lightspeedCooldown > 0 ? 'COOLDOWN' : 'READY'}`;
      
      renderer.render(scene, camera);
    }

    function gameOver() {
      isPaused = true;
      document.getElementById('alert').textContent = 'MISSION FAILED';
      document.getElementById('alert').style.display = 'block';
      setTimeout(() => {
        document.getElementById('alert').style.display = 'none';
        document.getElementById('mainMenu').style.display = 'block';
      }, 3000);
    }

    function missionComplete() {
      isPaused = true;
      const accuracy = shotsFired > 0 ? Math.round((shotsHit / shotsFired) * 100) : 0;
      document.getElementById('finalScore').textContent = `Final Score: ${score}`;
      document.getElementById('wavesSurvived').textContent = `Waves Survived: ${wave}`;
      document.getElementById('dronesDestroyed').textContent = `Drones Destroyed: ${dronesDestroyed}`;
      document.getElementById('accuracy').textContent = `Accuracy: ${accuracy}%`;
      document.getElementById('coreDataRemaining').textContent = `Core Data Remaining: ${coreData}`;
      document.getElementById('creditsEarned').textContent = `Total Credits Earned: ${credits}`;
      document.getElementById('missionComplete').style.display = 'block';
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start the game loop
    animate();
  </script>
</body>
</html>