<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GALAXYCRAFT: GRAND TOUR RACING</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #ui {
            position: absolute;
            top: 8px;
            right: 8px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 12px;
            text-shadow: 0 0 4px #000;
        }
        #ui span { margin-right: 6px; }
        #buttons {
            position: absolute;
            bottom: 12px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }
        #buttons button {
            padding: 6px 14px;
            margin: 0 6px;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: 1px solid;
            border-image: linear-gradient(45deg, red, orange, yellow, green, blue) 1;
            cursor: pointer;
        }
        #menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 18px;
        }
        #menu button {
            padding: 10px 20px;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: 1px solid;
            border-image: linear-gradient(45deg, red, orange, yellow, green, blue) 1;
            cursor: pointer;
        }
        .rainbow-text {
            background: linear-gradient(45deg, red, orange, yellow, green, blue);
            background-size: 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: rainbow 8s linear infinite;
        }
        @keyframes rainbow {
            0% { background-position: 0% 50%; }
            100% { background-position: 400% 50%; }
        }
    </style>
</head>
<body>
    <div id="menu">
        <h1 class="rainbow-text">GALAXYCRAFT: GRAND TOUR RACING</h1>
        <button id="startButton">START RACE</button>
        <p>Press ESC to return to menu</p>
    </div>
    <div id="ui">
        <span id="position">POSITION: 1/4</span>
        <span id="medals">MEDALS: 0ðŸ¥‡ 0ðŸ¥ˆ 0ðŸ¥‰</span>
        <span id="webxos">$WEBXOS: 0</span>
        <span id="fps">FPS: 0</span>
    </div>
    <div id="buttons">
        <button id="shootButton">SHOOT</button>
        <button id="lightspeedButton">LIGHTSPEED</button>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
        scene.add(ambientLight);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        let gameStarted = true;
        let tunnelSegments = [];
        let ships = [];
        let neurots = [];
        let orbitingNeurots = [];
        let stars = [];
        let galaxies = [];
        let planets = [];
        let checkpointDistance = 500;
        let lastCheckpointZ = 0;
        let medals = { gold: 0, silver: 0, bronze: 0 };
        let webxos = 0;
        let boostUses = [1, 1, 1, 1];
        let boostTimes = [0, 0, 0, 0];

        // Player Ship
        function createPlayerShip() {
            const group = new THREE.Group();
            const fuselageGeometry = new THREE.CylinderGeometry(0.1, 0.3, 2, 8);
            const fuselageMaterial = new THREE.MeshPhongMaterial({ color: 0x00ffff, emissive: 0x003333 });
            const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
            group.add(fuselage);
            const wingGeometry = new THREE.BoxGeometry(2, 0.05, 0.7);
            const wingMaterial = new THREE.MeshPhongMaterial({ color: 0x00ffff, emissive: 0x003333 });
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(-1, 0, -0.5);
            leftWing.rotation.z = Math.PI / 4;
            group.add(leftWing);
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(1, 0, -0.5);
            rightWing.rotation.z = -Math.PI / 4;
            group.add(rightWing);
            const thrusterGeometry = new THREE.ConeGeometry(0.1, 0.4, 6);
            const thrusterMaterial = new THREE.MeshPhongMaterial({ color: 0x00ffff, emissive: 0x006666 });
            const thruster = new THREE.Mesh(thrusterGeometry, thrusterMaterial);
            thruster.position.set(0, 0, -1.1);
            group.add(thruster);
            group.position.set(0, 0, 0);
            scene.add(group);
            return group;
        }
        const playerShip = createPlayerShip();
        ships.push({ mesh: playerShip, speed: 0.6, neurots: 3, lane: 0, isAI: false });

        // AI Ships
        function createAIShip1() {
            const group = new THREE.Group();
            const bodyGeometry = new THREE.BoxGeometry(1.2, 0.6, 1.6);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000, emissive: 0x330000 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            group.add(body);
            const cockpitGeometry = new THREE.BoxGeometry(0.3, 0.2, 0.4);
            const cockpit = new THREE.Mesh(cockpitGeometry, bodyMaterial);
            cockpit.position.set(0, 0.4, 0.5);
            group.add(cockpit);
            const finGeometry = new THREE.BoxGeometry(0.2, 0.4, 0.8);
            const topFin = new THREE.Mesh(finGeometry, bodyMaterial);
            topFin.position.set(0, 0.5, 0);
            group.add(topFin);
            group.position.set(1.5, 0, 0);
            scene.add(group);
            return group;
        }
        function createAIShip2() {
            const group = new THREE.Group();
            const bodyGeometry = new THREE.CylinderGeometry(0.2, 0.3, 1.8, 8);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00, emissive: 0x003300 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            group.add(body);
            const wingGeometry = new THREE.BoxGeometry(1.5, 0.05, 0.6);
            const wing = new THREE.Mesh(wingGeometry, bodyMaterial);
            wing.position.set(0, 0, -0.4);
            wing.rotation.z = Math.PI / 3;
            group.add(wing);
            group.position.set(3, 0, 0);
            scene.add(group);
            return group;
        }
        function createAIShip3() {
            const group = new THREE.Group();
            const bodyGeometry = new THREE.CylinderGeometry(0.2, 0.4, 1.6, 8);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00, emissive: 0x333300 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            group.add(body);
            const spikeGeometry = new THREE.ConeGeometry(0.1, 0.4, 6);
            for (let i = 0; i < 4; i++) {
                const spike = new THREE.Mesh(spikeGeometry, bodyMaterial);
                const theta = (i / 4) * Math.PI * 2;
                spike.position.set(Math.cos(theta) * 0.5, Math.sin(theta) * 0.5, -0.4);
                spike.rotation.z = Math.PI / 2;
                group.add(spike);
            }
            group.position.set(-1.5, 0, 0);
            scene.add(group);
            return group;
        }
        ships.push({ mesh: createAIShip1(), speed: 0.55 + Math.random() * 0.05, neurots: 3, lane: 1, isAI: true });
        ships.push({ mesh: createAIShip2(), speed: 0.55 + Math.random() * 0.05, neurots: 3, lane: 2, isAI: true });
        ships.push({ mesh: createAIShip3(), speed: 0.55 + Math.random() * 0.05, neurots: 3, lane: 3, isAI: true });

        // Tunnel Generation
        function generateTunnelSegment(startZ) {
            const segmentLength = 500;
            const radius = 8;
            const sides = 12;
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];
            const indices = [];

            for (let z = 0; z <= segmentLength; z += 10) {
                const angleStep = (Math.PI * 2) / sides;
                for (let i = 0; i < sides; i++) {
                    const angle = i * angleStep;
                    const x = Math.cos(angle) * radius + Math.sin(z / 30 + startZ / 30) * 5;
                    const y = Math.sin(angle) * radius + Math.cos(z / 30 + startZ / 30) * 5;
                    vertices.push(x, y, z + startZ);
                    const hue = (z / segmentLength + startZ / 1000) % 1;
                    const rgb = new THREE.Color().setHSL(hue, 1, 0.5);
                    colors.push(rgb.r, rgb.g, rgb.b);
                }
            }

            for (let z = 0; z < segmentLength / 10; z++) {
                for (let i = 0; i < sides; i++) {
                    const nextI = (i + 1) % sides;
                    const base = z * sides;
                    const nextBase = (z + 1) * sides;
                    indices.push(base + i, base + nextI, nextBase + i);
                    indices.push(base + nextI, nextBase + nextI, nextBase + i);
                }
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(indices);
            const material = new THREE.MeshBasicMaterial({ vertexColors: true, side: THREE.BackSide, transparent: true, opacity: 0.6, wireframe: true });
            const segment = new THREE.Mesh(geometry, material);
            scene.add(segment);
            tunnelSegments.push(segment);

            // Checkpoint Ring
            if (startZ % checkpointDistance === 0) {
                const ringGeometry = new THREE.TorusGeometry(radius, 0.2, 6, sides);
                const ringMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: 0x333333 });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.z = startZ + segmentLength;
                scene.add(ring);
                setTimeout(() => scene.remove(ring), 5000);
            }
        }

        // Background Generation (Once at Start)
        function generateBackground() {
            // Stars
            for (let i = 0; i < 100; i++) {
                const starGeometry = new THREE.SphereGeometry(0.08, 6, 6);
                const starMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const star = new THREE.Mesh(starGeometry, starMaterial);
                const radius = 8 + Math.random() * 4;
                const angle = Math.random() * Math.PI * 2;
                star.position.set(
                    Math.cos(angle) * radius,
                    Math.sin(angle) * radius,
                    Math.random() * 1000
                );
                scene.add(star);
                stars.push(star);
            }
            // Galaxy Clusters
            for (let i = 0; i < 2; i++) {
                const galaxyGeometry = new THREE.PlaneGeometry(15, 15, 1);
                const galaxyMaterial = new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(Math.random(), 0.7, 0.5), transparent: true, opacity: 0.5 });
                const galaxy = new THREE.Mesh(galaxyGeometry, galaxyMaterial);
                galaxy.position.set(
                    (Math.random() - 0.5) * 50,
                    (Math.random() - 0.5) * 50,
                    Math.random() * 1000
                );
                galaxy.lookAt(camera.position);
                scene.add(galaxy);
                galaxies.push(galaxy);
            }
            // Planets
            for (let i = 0; i < 5; i++) {
                const planetGeometry = new THREE.SphereGeometry(Math.random() * 1 + 0.5, 8, 8);
                const planetMaterial = new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(Math.random(), 1, 0.5) });
                const planet = new THREE.Mesh(planetGeometry, planetMaterial);
                planet.position.set(
                    (Math.random() - 0.5) * 50,
                    (Math.random() - 0.5) * 50,
                    Math.random() * 1000
                );
                scene.add(planet);
                planets.push(planet);
            }
        }

        // Orbiting Neurots
        function updateOrbitingNeurots() {
            orbitingNeurots.forEach(neurot => scene.remove(neurot.mesh));
            orbitingNeurots = [];
            for (let i = 0; i < ships[0].neurots; i++) {
                const neurotGeometry = new THREE.SphereGeometry(0.15, 6, 6);
                const neurotMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const neurot = new THREE.Mesh(neurotGeometry, neurotMaterial);
                scene.add(neurot);
                orbitingNeurots.push({ mesh: neurot, angle: (i / 3) * Math.PI * 2 });
            }
        }

        // Initial Setup
        for (let i = 0; i < 3; i++) generateTunnelSegment(i * checkpointDistance);
        generateBackground();
        updateOrbitingNeurots();
        camera.position.set(0, 1.5, -4);
        camera.lookAt(playerShip.position);

        // Input Handling
        document.getElementById('startButton').addEventListener('click', () => {
            document.getElementById('menu').style.display = 'none';
            gameStarted = true;
        });
        document.getElementById('shootButton').addEventListener('click', () => shootNeurot(0));
        document.getElementById('lightspeedButton').addEventListener('click', () => activateLightspeed(0));
        document.addEventListener('keydown', e => {
            if (e.code === 'Space') shootNeurot(0);
            if (e.code === 'Escape') {
                gameStarted = !gameStarted;
                document.getElementById('menu').style.display = gameStarted ? 'none' : 'flex';
            }
        });

        function shootNeurot(shipIndex) {
            const ship = ships[shipIndex];
            if (ship.neurots > 0 && gameStarted) {
                ship.neurots--;
                if (shipIndex === 0) updateOrbitingNeurots();
                const neurotGeometry = new THREE.SphereGeometry(0.15, 6, 6);
                const neurotMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const neurot = new THREE.Mesh(neurotGeometry, neurotMaterial);
                neurot.position.copy(ship.mesh.position);
                scene.add(neurot);
                const targetIndex = (shipIndex + Math.floor(Math.random() * 3) + 1) % 4;
                neurots.push({ mesh: neurot, target: ships[targetIndex], source: ship });
            }
        }

        function activateLightspeed(shipIndex) {
            if (boostUses[shipIndex] > 0 && boostTimes[shipIndex] <= 0 && gameStarted) {
                boostUses[shipIndex]--;
                boostTimes[shipIndex] = 10;
                ships[shipIndex].speed = 1.2;
            }
        }

        // Game Loop
        let lastTime = 0;
        function animate(time) {
            const delta = (time - lastTime) / 1000;
            lastTime = time;

            if (!gameStarted) return requestAnimationFrame(animate);

            // Update Ships
            ships.forEach((ship, index) => {
                const laneOffset = ship.lane * 1.5 - 2.25;
                ship.mesh.position.x = laneOffset + Math.sin(ship.mesh.position.z / 30) * 5;
                ship.mesh.position.y = Math.cos(ship.mesh.position.z / 30) * 5;
                ship.mesh.position.z += ship.speed;

                // AI Behavior
                if (ship.isAI && Math.random() < 0.005) {
                    if (Math.random() < 0.5) shootNeurot(index);
                    else if (boostUses[index] > 0) activateLightspeed(index);
                }
            });

            // Update Orbiting Neurots
            orbitingNeurots.forEach(neurot => {
                neurot.angle += delta * 2;
                neurot.mesh.position.set(
                    playerShip.position.x + Math.cos(neurot.angle) * 1.2,
                    playerShip.position.y + Math.sin(neurot.angle) * 1.2,
                    playerShip.position.z
                );
            });

            // Update Neurots
            neurots.forEach((neurot, index) => {
                const target = neurot.target.mesh.position;
                const dir = target.clone().sub(neurot.mesh.position).normalize();
                neurot.mesh.position.add(dir.multiplyScalar(0.6));
                if (neurot.mesh.position.distanceTo(target) < 0.8) {
                    neurot.target.speed *= 0.5;
                    setTimeout(() => neurot.target.speed = 0.55 + Math.random() * 0.05, 2000);
                    scene.remove(neurot.mesh);
                    neurots.splice(index, 1);
                }
            });

            // Update Lightspeed
            boostTimes.forEach((time, index) => {
                if (time > 0) {
                    boostTimes[index] -= delta;
                    if (boostTimes[index] <= 0) {
                        ships[index].speed = 0.55 + (index === 0 ? 0.05 : Math.random() * 0.05);
                    }
                }
            });

            // Update Background (Seamless Wrapping)
            stars.forEach(star => {
                star.position.z -= 0.1;
                if (star.position.z < lastCheckpointZ - 100) star.position.z += 1000;
            });
            galaxies.forEach(galaxy => {
                galaxy.position.z -= 0.05;
                galaxy.lookAt(camera.position);
                if (galaxy.position.z < lastCheckpointZ - 100) galaxy.position.z += 1000;
            });
            planets.forEach(planet => {
                planet.position.z -= 0.05;
                if (planet.position.z < lastCheckpointZ - 100) planet.position.z += 1000;
            });

            // Camera Follow
            const targetPos = playerShip.position.clone().add(new THREE.Vector3(0, 1.5, -4));
            camera.position.lerp(targetPos, 0.15);
            camera.lookAt(playerShip.position);

            // Tunnel Management
            if (playerShip.position.z > lastCheckpointZ + checkpointDistance) {
                lastCheckpointZ += checkpointDistance;
                ships.forEach((ship, index) => {
                    ship.neurots = 3;
                    boostUses[index] = 1;
                });
                updateOrbitingNeurots();
                ships.sort((a, b) => b.mesh.position.z - a.mesh.position.z);
                const playerRank = ships.indexOf(ships.find(s => !s.isAI)) + 1;
                document.getElementById('position').textContent = `POSITION: ${playerRank}/4`;
                if (playerRank === 1) { medals.gold++; webxos += 1; }
                else if (playerRank === 2) { medals.silver++; webxos += 0.5; }
                else if (playerRank === 3) { medals.bronze++; webxos += 0.25; }
                document.getElementById('medals').textContent = `MEDALS: ${medals.gold}ðŸ¥‡ ${medals.silver}ðŸ¥ˆ ${medals.bronze}ðŸ¥‰`;
                document.getElementById('webxos').textContent = `$WEBXOS: ${webxos.toFixed(2)}`;
                generateTunnelSegment(lastCheckpointZ + checkpointDistance);
                if (tunnelSegments.length > 3) {
                    scene.remove(tunnelSegments.shift());
                }
            }

            // FPS Counter
            document.getElementById('fps').textContent = `FPS: ${Math.round(1 / delta)}`;

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }
        requestAnimationFrame(animate);

        // Resize Handling
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>