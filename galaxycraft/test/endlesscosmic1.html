<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GalaxyCraft - ENDLESS COSMIC EXPLORATION</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Orbitron', 'Arial', sans-serif;
    }
    body {
      background: #000;
      color: #fff;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    #cosmicCanvas {
      flex: 1;
      width: 100%;
      touch-action: none;
      position: relative;
    }
    .controls {
      position: fixed;
      bottom: 0;
      width: 100%;
      background: rgba(20, 20, 50, 0.9);
      padding: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      backdrop-filter: blur(5px);
      z-index: 10;
    }
    .control-item {
      flex: 1;
      min-width: 80px;
      text-align: center;
    }
    button {
      background: #4a90e2;
      border: none;
      padding: 10px 20px;
      color: white;
      border-radius: 20px;
      cursor: pointer;
      font-size: 16px;
      transition: transform 0.2s, background 0.2s;
    }
    button:hover {
      background: #357abd;
    }
    button.active {
      background: #ff4444;
    }
    button:active {
      transform: scale(0.95);
    }
    .prompt {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 10px;
      font-size: 14px;
      max-width: 90%;
      text-align: center;
      opacity: 0;
      transition: opacity 0.5s;
      z-index: 5;
    }
    .prompt.active {
      opacity: 1;
    }
    .hud {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      opacity: 0.4;
      z-index: 1;
    }
    .hud::before {
      content: '';
      position: absolute;
      top: 10%;
      left: 10%;
      right: 10%;
      bottom: 10%;
      border: 2px solid rgba(74, 144, 226, 0);
      border-radius: 20px;
      box-shadow: none;
    }
    .hud::after {
      content: '+';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #4a90e2;
      font-size: 24px;
    }
    .throttle-indicator {
      position: absolute;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      color: #4a90e2;
      font-size: 12px;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 5;
    }
    .throttle-indicator.active {
      opacity: 1;
    }
    .status-overlay {
      position: absolute;
      top: 0;
      width: 100%;
      background: rgba(0, 0, 0, 0.3);
      padding: 5px 10px;
      font-size: 12px;
      text-align: left;
      color: #fff;
      text-shadow: 0 0 2px #000;
      z-index: 5;
      pointer-events: none;
    }
    .console {
      position: absolute;
      bottom: 60px;
      width: 100%;
      height: 25%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      flex-direction: column;
      z-index: 5;
      padding: 5px;
    }
    .console-log {
      flex: 1;
      overflow-y: auto;
      font-size: 12px;
      color: #fff;
      text-shadow: 0 0 2px #000;
      padding: 5px;
    }
    .console-log p {
      margin: 2px 0;
    }
    .console-input {
      width: 100%;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid #4a90e2;
      color: #fff;
      padding: 5px;
      font-size: 12px;
      outline: none;
    }
    .console-input::placeholder {
      color: #aaa;
    }
    .console::-webkit-scrollbar {
      width: 8px;
    }
    .console::-webkit-scrollbar-thumb {
      background: #4a90e2;
      border-radius: 4px;
    }
    .camera-controls {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 10px;
      z-index: 10;
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    .camera-controls button {
      padding: 8px 12px;
      font-size: 14px;
    }
    .resource-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 10px;
      z-index: 10;
      display: flex;
      flex-direction: column;
      gap: 5px;
      font-size: 14px;
    }
    .resource-item {
      display: flex;
      justify-content: space-between;
      width: 200px;
    }
    .testing-banner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 0, 0, 0.7);
      padding: 10px 20px;
      border-radius: 10px;
      font-size: 24px;
      font-weight: bold;
      z-index: 100;
      pointer-events: none;
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0% { opacity: 0.7; }
      50% { opacity: 1; }
      100% { opacity: 0.7; }
    }
    .crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      border: 2px solid #0f0;
      border-radius: 50%;
      pointer-events: none;
      z-index: 5;
    }
    .light-speed {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, rgba(74, 144, 226, 0.2) 0%, transparent 70%);
      opacity: 0;
      pointer-events: none;
      z-index: 90;
      transition: opacity 1s;
    }
    .light-speed.active {
      opacity: 0.8;
    }
    .tour-info {
      position: absolute;
      bottom: 150px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 10px 20px;
      border-radius: 10px;
      font-size: 16px;
      text-align: center;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="cosmicCanvas">
    <div class="hud"></div>
    <div class="crosshair"></div>
    <div id="statusOverlay" class="status-overlay"></div>
    <div id="throttleIndicator" class="throttle-indicator"></div>
    <div id="lightSpeedEffect" class="light-speed"></div>
    <div id="console" class="console">
      <div id="consoleLog" class="console-log"></div>
      <input id="consoleInput" class="console-input" type="text" placeholder="Type /help for commands..." autocomplete="off">
    </div>
    <div class="testing-banner">ENDLESS COSMIC EXPLORATION MODE</div>
    <div id="tourInfo" class="tour-info"></div>
    <div class="camera-controls">
      <button id="cameraLockBtn">Lock Camera</button>
      <button id="resetViewBtn">Reset View</button>
      <button id="freeLookBtn">Free Look</button>
    </div>
    <div class="resource-panel">
      <div class="resource-item"><span>Credits:</span> <span id="creditsValue">∞</span></div>
      <div class="resource-item"><span>Ores:</span> <span id="oresValue">∞</span></div>
      <div class="resource-item"><span>Crystals:</span> <span id="crystalsValue">∞</span></div>
      <div class="resource-item"><span>Fuel:</span> <span id="fuelValue">∞</span></div>
      <div class="resource-item"><span>Energy:</span> <span id="energyValue">∞</span></div>
    </div>
  </div>
  <div class="controls">
    <div class="control-item">
      <button id="throttleBtn">Full Throttle</button>
    </div>
    <div class="control-item">
      <button id="mineBtn">Mine</button>
    </div>
    <div class="control-item">
      <button id="scanBtn">Scan</button>
    </div>
    <div class="control-item">
      <button id="addNode">Add Node</button>
    </div>
    <div class="control-item">
      <button id="autopilotBtn">Cosmic Tour</button>
    </div>
    <div class="control-item">
      <button id="cameraBtn">Camera</button>
    </div>
    <div class="control-item">
      <button id="teleportBtn">Teleport</button>
    </div>
    <div class="control-item">
      <button id="resetBtn">Reset</button>
    </div>
  </div>
  <div id="prompt" class="prompt"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
    window.onload = () => {
      try {
        // Scene setup
        if (!window.THREE) throw new Error('Three.js not loaded');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 1);
        const canvas = document.getElementById('cosmicCanvas');
        if (!canvas) throw new Error('Canvas element not found');
        canvas.appendChild(renderer.domElement);

        camera.position.set(0, 0, 0);
        
        // Add some stars to the background
        const starGeometry = new THREE.BufferGeometry();
        const starVertices = [];
        for (let i = 0; i < 15000; i++) {
          const x = (Math.random() - 0.5) * 3000;
          const y = (Math.random() - 0.5) * 3000;
          const z = (Math.random() - 0.5) * 3000;
          starVertices.push(x, y, z);
        }
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1.2 });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // Nebula effects
        function createNebula() {
          const nebulaGeometry = new THREE.BufferGeometry();
          const nebulaVertices = [];
          const nebulaColors = [];
          const nebulaSize = 500;
          
          for (let i = 0; i < 5000; i++) {
            const x = (Math.random() - 0.5) * nebulaSize;
            const y = (Math.random() - 0.5) * nebulaSize;
            const z = (Math.random() - 0.5) * nebulaSize;
            nebulaVertices.push(x, y, z);
            
            // Color based on position for gradient effect
            const r = 0.2 + Math.abs(x) / nebulaSize * 0.8;
            const g = 0.2 + Math.abs(y) / nebulaSize * 0.8;
            const b = 0.5 + Math.abs(z) / nebulaSize * 0.5;
            nebulaColors.push(r, g, b);
          }
          
          nebulaGeometry.setAttribute('position', new THREE.Float32BufferAttribute(nebulaVertices, 3));
          nebulaGeometry.setAttribute('color', new THREE.Float32BufferAttribute(nebulaColors, 3));
          
          const nebulaMaterial = new THREE.PointsMaterial({ 
            size: 3, 
            vertexColors: true,
            transparent: true,
            opacity: 0.7
          });
          
          const nebula = new THREE.Points(nebulaGeometry, nebulaMaterial);
          nebula.position.set(
            (Math.random() - 0.5) * 2000,
            (Math.random() - 0.5) * 2000,
            (Math.random() - 0.5) * 2000
          );
          
          nebula.userData = {
            rotationSpeed: new THREE.Vector3(
              (Math.random() - 0.5) * 0.001,
              (Math.random() - 0.5) * 0.001,
              (Math.random() - 0.5) * 0.001
            )
          };
          
          scene.add(nebula);
          return nebula;
        }
        
        // Create multiple nebulae
        const nebulae = [];
        for (let i = 0; i < 8; i++) {
          nebulae.push(createNebula());
        }

        // Shared resources
        const sharedMaterials = {
          resource: new THREE.MeshBasicMaterial({ color: 0x00ff00 }),
          ore: new THREE.MeshBasicMaterial({ color: 0xcccccc }),
          crystal: new THREE.MeshBasicMaterial({ color: 0x8844ff }),
          node: new THREE.MeshBasicMaterial({ color: 0xff33cc }),
          line: new THREE.LineBasicMaterial({ color: 0x00ff00 }),
          planet: new THREE.MeshBasicMaterial({ color: 0x44aaff })
        };
        const sharedGeometries = {
          resource: new THREE.SphereGeometry(10, 12, 12),
          node: new THREE.BoxGeometry(15, 15, 15),
          planet: new THREE.SphereGeometry(40, 32, 32)
        };

        // Game state
        let resources = [];
        let planets = [];
        let nodes = [];
        let nodeLines = [];
        let throttle = 0;
        let rotation = { x: 0, y: 0 };
        let velocity = new THREE.Vector3(0, 0, 0);
        let lastTime = performance.now();
        let entityCount = 0;
        let cosmicTourActive = false;
        let currentNodeIndex = 0;
        let cameraLocked = false;
        let freeLookActive = false;
        let isMouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let tourPoints = [];
        let currentTourPoint = 0;
        let tourMode = "explore"; // explore, cinematic, lightspeed
        
        // Testing mode - unlimited resources
        const playerResources = {
          credits: Infinity,
          ores: Infinity,
          crystals: Infinity,
          fuel: Infinity,
          energy: Infinity
        };

        // Console and status
        const statusOverlay = document.getElementById('statusOverlay');
        const consoleLog = document.getElementById('consoleLog');
        const consoleInput = document.getElementById('consoleInput');
        const tourInfo = document.getElementById('tourInfo');
        const lightSpeedEffect = document.getElementById('lightSpeedEffect');
        const maxLogMessages = 50;
        let logMessages = [];

        function addConsoleMessage(message) {
          const timestamp = new Date().toLocaleTimeString();
          logMessages.push(`[${timestamp}] ${message}`);
          if (logMessages.length > maxLogMessages) {
            logMessages.shift();
          }
          consoleLog.innerHTML = logMessages.map(msg => `<p>${msg}</p>`).join('');
          consoleLog.scrollTop = consoleLog.scrollHeight;
        }

        function updateStatusOverlay() {
          statusOverlay.textContent = `Tour Mode: ${tourMode} | Points: ${tourPoints.length} | Entities: ${entityCount}`;
        }

        function updateTourInfo(message) {
          tourInfo.textContent = message;
          setTimeout(() => {
            tourInfo.textContent = "";
          }, 5000);
        }

        // Initialize resources for testing
        function initializeTestEnvironment() {
          // Create test resources
          for (let i = 0; i < 50; i++) {
            const resource = new THREE.Mesh(
              sharedGeometries.resource, 
              Math.random() > 0.5 ? sharedMaterials.ore : sharedMaterials.crystal
            );
            
            const distance = 200 + Math.random() * 500;
            const angle = Math.random() * Math.PI * 2;
            
            resource.position.set(
              Math.cos(angle) * distance,
              (Math.random() - 0.5) * 300,
              Math.sin(angle) * distance
            );
            
            resource.userData = {
              type: Math.random() > 0.5 ? 'ore' : 'crystal',
              value: Math.floor(Math.random() * 50) + 10
            };
            
            scene.add(resource);
            resources.push(resource);
            entityCount++;
          }
          
          // Create planets
          for (let i = 0; i < 12; i++) {
            const planet = new THREE.Mesh(sharedGeometries.planet, sharedMaterials.planet);
            
            const distance = 400 + Math.random() * 800;
            const angle = Math.random() * Math.PI * 2;
            
            planet.position.set(
              Math.cos(angle) * distance,
              (Math.random() - 0.5) * 400,
              Math.sin(angle) * distance
            );
            
            planet.userData = {
              name: `Planet ${i+1}`,
              type: 'planet',
              size: 40
            };
            
            scene.add(planet);
            planets.push(planet);
            entityCount++;
            
            // Add planet to tour points
            tourPoints.push({
              position: planet.position.clone(),
              type: 'planet',
              name: `Planet ${i+1}`,
              description: `A beautiful celestial body with unique characteristics.`
            });
          }
          
          // Create some special tour points
          for (let i = 0; i < 8; i++) {
            tourPoints.push({
              position: new THREE.Vector3(
                (Math.random() - 0.5) * 1500,
                (Math.random() - 0.5) * 1000,
                (Math.random() - 0.5) * 1500
              ),
              type: 'viewpoint',
              name: `Cosmic Vista ${i+1}`,
              description: `A breathtaking view of the galaxy.`
            });
          }
          
          addConsoleMessage("Cosmic exploration environment created");
          addConsoleMessage(`${tourPoints.length} tour points available`);
        }

        // Keyboard controls - Improved FPV controls
        const keys = { 
          w: false, a: false, s: false, d: false,
          ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
          Shift: false
        };
        
        window.addEventListener('keydown', e => {
          const key = e.key.toLowerCase();
          if (keys.hasOwnProperty(key)) {
            keys[key] = true;
            e.preventDefault();
          }
          
          // Special keys
          if (key === ' ') {
            toggleMining();
          } else if (key === 'c') {
            toggleCameraLock();
          } else if (key === 'm') {
            addConsoleMessage("TEST MODE: Mining resources added to inventory");
          } else if (key === 'p') {
            toggleCosmicTour();
          } else if (key === 't') {
            teleportToRandomLocation();
          }
        });
        
        window.addEventListener('keyup', e => {
          const key = e.key.toLowerCase();
          if (keys.hasOwnProperty(key)) {
            keys[key] = false;
            e.preventDefault();
          }
        });

        // Mouse controls for camera
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        
        function onMouseMove(e) {
          if (!cameraLocked || !isMouseDown) return;
          
          const deltaX = e.clientX - lastMouseX;
          const deltaY = e.clientY - lastMouseY;
          
          // Adjust rotation based on mouse movement
          rotation.y += deltaX * 0.003;
          rotation.x += deltaY * 0.003;
          
          // Limit vertical rotation to avoid flipping
          rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotation.x));
          
          lastMouseX = e.clientX;
          lastMouseY = e.clientY;
        }
        
        function onMouseDown(e) {
          if (cameraLocked) {
            isMouseDown = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
          }
        }
        
        function onMouseUp() {
          isMouseDown = false;
        }
        
        // Add event listeners for mouse control
        renderer.domElement.addEventListener('mousemove', onMouseMove);
        renderer.domElement.addEventListener('mousedown', onMouseDown);
        renderer.domElement.addEventListener('mouseup', onMouseUp);
        
        // Touch controls for mobile
        renderer.domElement.addEventListener('touchstart', e => {
          if (cameraLocked && e.touches.length === 1) {
            isMouseDown = true;
            lastMouseX = e.touches[0].clientX;
            lastMouseY = e.touches[0].clientY;
            e.preventDefault();
          }
        });
        
        renderer.domElement.addEventListener('touchmove', e => {
          if (cameraLocked && isMouseDown && e.touches.length === 1) {
            const deltaX = e.touches[0].clientX - lastMouseX;
            const deltaY = e.touches[0].clientY - lastMouseY;
            
            rotation.y += deltaX * 0.003;
            rotation.x += deltaY * 0.003;
            rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotation.x));
            
            lastMouseX = e.touches[0].clientX;
            lastMouseY = e.touches[0].clientY;
            e.preventDefault();
          }
        });
        
        renderer.domElement.addEventListener('touchend', () => {
          isMouseDown = false;
        });

        // Console commands
        function handleCommand(input) {
          const cmd = input.trim().toLowerCase();
          if (!cmd.startsWith('/')) {
            addConsoleMessage('Commands must start with "/". Type /help for commands.');
            return;
          }
          const parts = cmd.slice(1).split(' ');
          const command = parts[0];
          const args = parts.slice(1);

          switch (command) {
            case 'help':
              addConsoleMessage('Commands: /mine, /scan, /tour, /teleport, /camera, /reset, /throttle, /mode [explore|cinematic|lightspeed]');
              break;
            case 'mine':
              toggleMining();
              break;
            case 'scan':
              scanArea();
              break;
            case 'tour':
              toggleCosmicTour();
              break;
            case 'teleport':
              teleportToRandomLocation();
              break;
            case 'camera':
              toggleCameraLock();
              break;
            case 'reset':
              reset();
              break;
            case 'throttle':
              toggleThrottle();
              break;
            case 'mode':
              if (args.length > 0) {
                setTourMode(args[0]);
              } else {
                addConsoleMessage('Current mode: ' + tourMode);
              }
              break;
            default:
              addConsoleMessage('Unknown command. Type /help for commands.');
          }
        }

        consoleInput.addEventListener('keydown', e => {
          if (e.key === 'Enter') {
            const input = consoleInput.value;
            if (input) {
              addConsoleMessage(`> ${input}`);
              handleCommand(input);
              consoleInput.value = '';
            }
          }
        });

        // Add entities
        function addNode() {
          const node = new THREE.Mesh(sharedGeometries.node, sharedMaterials.node);
          const forward = new THREE.Vector3(0, 0, -1).applyEuler(new THREE.Euler(rotation.x, rotation.y, 0));
          node.position.copy(camera.position).add(forward.multiplyScalar(100));
          node.userData = { type: 'node', created: Date.now() };
          scene.add(node);
          nodes.push(node);
          entityCount++;

          if (nodes.length > 1) {
            const prevNode = nodes[nodes.length - 2];
            const geometry = new THREE.BufferGeometry().setFromPoints([
              prevNode.position,
              node.position
            ]);
            const line = new THREE.Line(geometry, sharedMaterials.line);
            scene.add(line);
            nodeLines.push(line);
          }

          showPrompt("Satellite node deployed.");
          addConsoleMessage('Satellite node deployed.');
          updateStatusOverlay();
        }

        function toggleMining() {
          // Find closest resource
          let closestResource = null;
          let closestDistance = Infinity;
          
          resources.forEach(resource => {
            const distance = camera.position.distanceTo(resource.position);
            if (distance < 50 && distance < closestDistance) {
              closestDistance = distance;
              closestResource = resource;
            }
          });
          
          if (closestResource) {
            // In testing mode, just add resources without removing them
            const resourceType = closestResource.userData.type;
            const resourceValue = closestResource.userData.value;
            
            addConsoleMessage(`TEST MODE: Mined ${resourceValue} ${resourceType} (resource remains)`);
            showPrompt(`Mined ${resourceValue} ${resourceType}`);
            
            // Visual feedback - pulse the resource
            const originalScale = closestResource.scale.clone();
            closestResource.scale.multiplyScalar(1.5);
            setTimeout(() => {
              closestResource.scale.copy(originalScale);
            }, 200);
          } else {
            addConsoleMessage("No resources nearby to mine");
            showPrompt("No resources nearby");
          }
        }

        function scanArea() {
          // Highlight nearby resources
          resources.forEach(resource => {
            const distance = camera.position.distanceTo(resource.position);
            if (distance < 200) {
              const originalColor = resource.material.color.clone();
              resource.material.color.set(0xffff00);
              
              setTimeout(() => {
                resource.material.color.copy(originalColor);
              }, 2000);
            }
          });
          
          addConsoleMessage("Area scanned. Nearby resources highlighted.");
          showPrompt("Scanning area...");
        }

        function reset() {
          // Remove nodes and lines
          nodes.forEach(node => scene.remove(node));
          nodes = [];
          nodeLines.forEach(line => scene.remove(line));
          nodeLines = [];
          
          // Reset camera and movement
          camera.position.set(0, 0, 0);
          rotation.x = 0;
          rotation.y = 0;
          velocity.set(0, 0, 0);
          throttle = 0;
          cosmicTourActive = false;
          currentNodeIndex = 0;
          currentTourPoint = 0;
          
          const autopilotBtn = document.getElementById('autopilotBtn');
          if (autopilotBtn) autopilotBtn.classList.remove('active');
          const throttleBtn = document.getElementById('throttleBtn');
          if (throttleBtn) throttleBtn.classList.remove('active');
          const throttleIndicator = document.getElementById('throttleIndicator');
          if (throttleIndicator) {
            throttleIndicator.textContent = '';
            throttleIndicator.classList.remove('active');
          }
          
          lightSpeedEffect.classList.remove('active');
          
          showPrompt("Reset complete.");
          addConsoleMessage('Reset complete.');
          updateStatusOverlay();
        }

        // Throttle toggle for command
        function toggleThrottle() {
          throttle = throttle === 0 ? 50 : 0;
          const throttleBtn = document.getElementById('throttleBtn');
          if (throttleBtn) throttleBtn.classList.toggle('active', throttle > 0);
          const throttleIndicator = document.getElementById('throttleIndicator');
          if (throttleIndicator) {
            throttleIndicator.textContent = throttle > 0 ? `Thrust: ${throttle}` : '';
            throttleIndicator.classList.toggle('active', throttle > 0);
          }
          showPrompt(throttle > 0 ? "Throttle engaged!" : "Throttle disengaged.");
          addConsoleMessage(throttle > 0 ? 'Throttle engaged!' : 'Throttle disengaged.');
          updateStatusOverlay();
        }

        // Camera controls
        function toggleCameraLock() {
          cameraLocked = !cameraLocked;
          const cameraBtn = document.getElementById('cameraBtn');
          if (cameraBtn) cameraBtn.classList.toggle('active', cameraLocked);
          
          if (cameraLocked) {
            showPrompt("Camera control enabled - Click and drag to look around");
            addConsoleMessage("Camera control enabled");
          } else {
            showPrompt("Camera control disabled");
            addConsoleMessage("Camera control disabled");
          }
        }
        
        function resetView() {
          rotation.x = 0;
          rotation.y = 0;
          showPrompt("View reset");
          addConsoleMessage("View reset");
        }
        
        function toggleFreeLook() {
          freeLookActive = !freeLookActive;
          const freeLookBtn = document.getElementById('freeLookBtn');
          if (freeLookBtn) freeLookBtn.classList.toggle('active', freeLookActive);
          
          if (freeLookActive) {
            showPrompt("Free look mode enabled");
            addConsoleMessage("Free look mode enabled");
          } else {
            showPrompt("Free look mode disabled");
            addConsoleMessage("Free look mode disabled");
          }
        }

        // Cosmic Tour
        function toggleCosmicTour() {
          if (tourPoints.length === 0) {
            showPrompt("No tour points available!");
            addConsoleMessage('No tour points available.');
            return;
          }
          
          cosmicTourActive = !cosmicTourActive;
          const autopilotBtn = document.getElementById('autopilotBtn');
          if (autopilotBtn) autopilotBtn.classList.toggle('active', cosmicTourActive);
          
          if (cosmicTourActive) {
            throttle = 0;
            const throttleBtn = document.getElementById('throttleBtn');
            if (throttleBtn) throttleBtn.classList.remove('active');
            const throttleIndicator = document.getElementById('throttleIndicator');
            if (throttleIndicator) {
              throttleIndicator.textContent = '';
              throttleIndicator.classList.remove('active');
            }
            
            currentTourPoint = 0;
            showPrompt("Cosmic Tour engaged! Exploring the galaxy.");
            addConsoleMessage('Cosmic Tour engaged! Exploring the galaxy.');
            updateTourInfo(`Starting tour: ${tourMode} mode`);
          } else {
            lightSpeedEffect.classList.remove('active');
            showPrompt("Cosmic Tour disengaged.");
            addConsoleMessage('Cosmic Tour disengaged.');
          }
          updateStatusOverlay();
        }
        
        function setTourMode(mode) {
          const validModes = ["explore", "cinematic", "lightspeed"];
          if (validModes.includes(mode)) {
            tourMode = mode;
            addConsoleMessage(`Tour mode set to: ${mode}`);
            updateTourInfo(`Tour mode: ${mode}`);
          } else {
            addConsoleMessage(`Invalid mode. Available modes: ${validModes.join(", ")}`);
          }
        }
        
        function updateCosmicTour(deltaTime) {
          if (!cosmicTourActive || tourPoints.length === 0) return;

          const targetPoint = tourPoints[currentTourPoint];
          const direction = targetPoint.position.clone().sub(camera.position);
          const distance = direction.length();

          if (distance < 100) {
            // Reached the point, move to next
            currentTourPoint = (currentTourPoint + 1) % tourPoints.length;
            addConsoleMessage(`Reached ${targetPoint.name}. Heading to next destination.`);
            updateTourInfo(`Arrived at: ${targetPoint.name}`);
            
            // Special effects based on tour mode
            if (tourMode === "lightspeed") {
              lightSpeedEffect.classList.add('active');
              setTimeout(() => {
                lightSpeedEffect.classList.remove('active');
              }, 1000);
            }
          }

          // Move toward the point based on tour mode
          direction.normalize();
          let speed = 50;
          
          if (tourMode === "cinematic") {
            speed = 30;
            // Add cinematic camera movements
            rotation.y += Math.sin(performance.now() * 0.001) * 0.01;
            rotation.x += Math.cos(performance.now() * 0.001) * 0.005;
          } else if (tourMode === "lightspeed") {
            speed = 200;
            lightSpeedEffect.classList.add('active');
          } else {
            lightSpeedEffect.classList.remove('active');
          }
          
          velocity.copy(direction.multiplyScalar(speed));
          camera.position.add(velocity.clone().multiplyScalar(deltaTime));

          // Look at the point with smooth rotation
          const targetRotationY = Math.atan2(direction.x, direction.z);
          const targetRotationX = Math.asin(direction.y);
          
          // Smooth rotation
          rotation.y += (targetRotationY - rotation.y) * 0.05;
          rotation.x += (targetRotationX - rotation.x) * 0.05;
        }
        
        function teleportToRandomLocation() {
          if (tourPoints.length > 0) {
            const randomPoint = Math.floor(Math.random() * tourPoints.length);
            camera.position.copy(tourPoints[randomPoint].position);
            addConsoleMessage(`Teleported to: ${tourPoints[randomPoint].name}`);
            updateTourInfo(`Teleported to: ${tourPoints[randomPoint].name}`);
            
            // Visual effect for teleportation
            lightSpeedEffect.classList.add('active');
            setTimeout(() => {
              lightSpeedEffect.classList.remove('active');
            }, 1000);
          } else {
            // Random position in space
            camera.position.set(
              (Math.random() - 0.5) * 1000,
              (Math.random() - 0.5) * 1000,
              (Math.random() - 0.5) * 1000
            );
            addConsoleMessage("Teleported to random location");
            updateTourInfo("Teleported to random location");
          }
        }

        // Animation loop
        function animate() {
          requestAnimationFrame(animate);

          const now = performance.now();
          const deltaTime = Math.min((now - lastTime) / 1000, 0.1);
          lastTime = now;

          // Apply rotation to camera
          camera.rotation.set(rotation.x, rotation.y, 0);
          
          // Handle keyboard movement
          if (!cosmicTourActive) {
            const moveSpeed = throttle > 0 ? throttle : 20;
            const moveVector = new THREE.Vector3(0, 0, 0);
            
            if (keys.w || keys.arrowup) moveVector.z -= 1;
            if (keys.s || keys.arrowdown) moveVector.z += 1;
            if (keys.a || keys.arrowleft) moveVector.x -= 1;
            if (keys.d || keys.arrowright) moveVector.x += 1;
            if (keys.shift) moveVector.y -= 1; // Descend
            if (keys.space) moveVector.y += 1; // Ascend (spacebar)
            
            if (moveVector.length() > 0) {
              moveVector.normalize();
              moveVector.applyEuler(camera.rotation);
              moveVector.multiplyScalar(moveSpeed * deltaTime);
              camera.position.add(moveVector);
            }
          } else {
            updateCosmicTour(deltaTime);
          }

          // Update node connections
          nodeLines.forEach((line, i) => {
            if (i < nodes.length - 1) {
              const geometry = new THREE.BufferGeometry().setFromPoints([
                nodes[i].position,
                nodes[i + 1].position
              ]);
              line.geometry.dispose();
              line.geometry = geometry;
            }
          });
          
          // Animate nebulae
          nebulae.forEach(nebula => {
            nebula.rotation.x += nebula.userData.rotationSpeed.x;
            nebula.rotation.y += nebula.userData.rotationSpeed.y;
            nebula.rotation.z += nebula.userData.rotationSpeed.z;
          });

          renderer.render(scene, camera);
        }

        // Controls
        try {
          const throttleBtn = document.getElementById('throttleBtn');
          const mineBtn = document.getElementById('mineBtn');
          const scanBtn = document.getElementById('scanBtn');
          const addNodeBtn = document.getElementById('addNode');
          const autopilotBtn = document.getElementById('autopilotBtn');
          const cameraBtn = document.getElementById('cameraBtn');
          const teleportBtn = document.getElementById('teleportBtn');
          const resetBtn = document.getElementById('resetBtn');
          const cameraLockBtn = document.getElementById('cameraLockBtn');
          const resetViewBtn = document.getElementById('resetViewBtn');
          const freeLookBtn = document.getElementById('freeLookBtn');
          const throttleIndicator = document.getElementById('throttleIndicator');
          const prompt = document.getElementById('prompt');

          if (!throttleBtn || !mineBtn || !scanBtn || !addNodeBtn || !autopilotBtn || 
              !cameraBtn || !teleportBtn || !resetBtn || !cameraLockBtn || !resetViewBtn || 
              !freeLookBtn || !prompt || !throttleIndicator) {
            throw new Error('One or more control elements not found');
          }

          throttleBtn.addEventListener('click', toggleThrottle);
          mineBtn.addEventListener('click', toggleMining);
          scanBtn.addEventListener('click', scanArea);
          addNodeBtn.addEventListener('click', addNode);
          autopilotBtn.addEventListener('click', toggleCosmicTour);
          cameraBtn.addEventListener('click', toggleCameraLock);
          teleportBtn.addEventListener('click', teleportToRandomLocation);
          resetBtn.addEventListener('click', reset);
          cameraLockBtn.addEventListener('click', toggleCameraLock);
          resetViewBtn.addEventListener('click', resetView);
          freeLookBtn.addEventListener('click', toggleFreeLook);

          function showPrompt(message) {
            prompt.textContent = message;
            prompt.classList.add('active');
            setTimeout(() => prompt.classList.remove('active'), 2000);
          }
        } catch (e) {
          console.error('Control setup error:', e);
        }

        // Initialize
        try {
          initializeTestEnvironment();
          addConsoleMessage('ENDLESS COSMIC EXPLORATION MODE initialized.');
          addConsoleMessage('Use WASD to move, mouse to look around when camera is locked.');
          addConsoleMessage('Type /tour to start the automated cosmic tour.');
          addConsoleMessage('Type /mode [explore|cinematic|lightspeed] to change tour style.');
          updateStatusOverlay();
          animate();
        } catch (e) {
          console.error('Initialization error:', e);
        }

        // Resize
        window.addEventListener('resize', () => {
          try {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
          } catch (e) {
            console.error('Resize error:', e);
          }
        });
      } catch (e) {
        console.error('Main script error:', e);
      }
    };
  </script>
</body>
</html>