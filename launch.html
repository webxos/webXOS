<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LAUNCH SEQUENCE by webXOS 2025</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* [All CSS remains exactly the same - keeping the cyberpunk aesthetic] */
        :root {
            --cyber-black: #000000;
            --cyber-green: #00ff9d;
            --cyber-blue: #00eeff;
            --cyber-purple: #b300ff;
            --cyber-red: #ff0040;
            --cyber-orange: #ff7700;
            --dark-bg: #001a00;
            --panel-bg: rgba(0, 30, 0, 0.85);
            --terminal-text: #00ff9d;
            --glitch-color-1: #ff0040;
            --glitch-color-2: #00eeff;
            --radius: 4px;
            --spacing-sm: 4px;
            --spacing-md: 8px;
            --spacing-lg: 12px;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
            font-size: 10pt;
        }
        
        body {
            background: radial-gradient(circle at center, var(--dark-bg), var(--cyber-black));
            color: var(--terminal-text);
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        body::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 30%, rgba(0, 255, 157, 0.05) 0%, transparent 20%),
                radial-gradient(circle at 80% 70%, rgba(0, 238, 255, 0.05) 0%, transparent 20%),
                radial-gradient(circle at 40% 80%, rgba(179, 0, 255, 0.05) 0%, transparent 20%);
            pointer-events: none;
            z-index: -1;
        }

        .cyber-header {
            padding: var(--spacing-md);
            border-bottom: 1px solid var(--cyber-green);
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 50px;
            width: 100%;
            background: rgba(0, 0, 0, 0.9);
            box-shadow: 0 0 15px rgba(0, 255, 157, 0.3);
            position: fixed;
            z-index: 1000;
        }
        
        h1 {
            font-size: 12pt;
            letter-spacing: 0.5px;
            color: var(--cyber-green);
            font-weight: bold;
            text-shadow: 0 0 8px var(--cyber-green), 0 0 16px var(--cyber-green);
        }
        
        .mode-tabs {
            display: flex;
            gap: var(--spacing-sm);
        }
        
        .mode-tab {
            padding: 4px 8px;
            background: var(--panel-bg);
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            cursor: pointer;
            font-size: 9pt;
            transition: all 0.3s ease;
            box-shadow: 0 0 5px currentColor;
        }
        
        .mode-tab:hover {
            box-shadow: 0 0 10px currentColor, 0 0 15px currentColor;
        }
        
        .mode-tab.active {
            background: var(--cyber-green);
            color: #000;
            box-shadow: 0 0 10px var(--cyber-green), 0 0 20px var(--cyber-green);
        }
        
        main {
            display: flex;
            flex: 1;
            overflow: hidden;
            width: 100%;
            padding: var(--spacing-md);
            gap: var(--spacing-md);
            min-height: 0;
            margin-top: 60px;
            height: calc(100vh - 140px);
        }
        
        .cyber-panel {
            background: var(--panel-bg);
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            padding: var(--spacing-md);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 10px rgba(0, 255, 157, 0.2);
        }
        
        .left-panel, .right-panel {
            width: 280px;
        }
        
        .center-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
            min-height: 0;
        }
        
        .combat-arena-container {
            flex: 1;
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            overflow: hidden;
            position: relative;
            min-height: 0;
            background: var(--cyber-black);
            box-shadow: 0 0 15px rgba(0, 255, 157, 0.3);
        }

        #three-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .scene-controls {
            position: absolute;
            bottom: 6px;
            left: 6px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            padding: 4px;
            z-index: 10;
            font-size: 8pt;
            box-shadow: 0 0 5px var(--cyber-green);
        }
        
        .qnn-overlay {
            position: absolute;
            top: 6px;
            right: 6px;
            width: 100px;
            height: 100px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            padding: 3px;
            z-index: 10;
            box-shadow: 0 0 5px var(--cyber-green);
        }
        
        .qnn-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 1px;
            width: 100%;
            height: 100%;
        }
        
        .qnn-cell {
            background: #000;
            border: 1px solid #008800;
            transition: all 0.3s ease;
        }
        
        .qnn-cell.active {
            background: var(--cyber-green);
            box-shadow: 0 0 3px var(--cyber-green);
        }
        
        .qnn-cell.training {
            background: #ffcc00;
            animation: pulse 1s infinite;
        }
        
        .qnn-cell.learned {
            background: #00cc00;
            box-shadow: 0 0 3px #00cc00;
        }
        
        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }
        
        .console-container {
            height: 180px;
            background: var(--panel-bg);
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            padding: var(--spacing-md);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 255, 157, 0.2);
        }
        
        .console-output {
            flex: 1;
            background: #000;
            border-radius: var(--radius);
            padding: var(--spacing-md);
            overflow-y: auto;
            font-size: 9pt;
            margin-bottom: var(--spacing-sm);
            border: 1px solid var(--cyber-green);
            position: relative;
        }
        
        .console-output p {
            margin: 2px 0;
        }
        
        .ok { color: #7dff7d; }
        .warn { color: #ffea7d; }
        .err { color: #ff7d7d; }
        .sys { color: #7dd9ff; }
        .muted { color: #aaaaaa; }
        .train-log { color: #ffcc00; }
        .perf { color: #ff00ff; }
        
        .console-input {
            display: flex;
            gap: var(--spacing-sm);
            flex-shrink: 0;
            height: 32px;
        }
        
        .input-line {
            flex: 1;
            background: #000;
            border: 1px solid var(--cyber-green);
            color: var(--terminal-text);
            padding: 6px 8px;
            border-radius: var(--radius);
            font-size: 9pt;
            box-shadow: 0 0 5px var(--cyber-green);
        }
        
        .input-send {
            padding: 6px 10px;
            border-radius: var(--radius);
            background: #000;
            border: 1px solid var(--cyber-green);
            color: var(--terminal-text);
            cursor: pointer;
            flex-shrink: 0;
            font-size: 9pt;
            transition: all 0.3s ease;
            box-shadow: 0 0 5px var(--cyber-green);
        }
        
        .input-send:hover {
            background: var(--cyber-green);
            color: #000;
            box-shadow: 0 0 10px var(--cyber-green), 0 0 15px var(--cyber-green);
        }
        
        .copy-log {
            position: absolute;
            top: 5px;
            right: 5px;
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            color: var(--cyber-green);
            cursor: pointer;
            font-size: 8pt;
            z-index: 5;
        }
        
        .copy-log:hover {
            background: var(--cyber-green);
            color: #000;
        }
        
        footer {
            padding: var(--spacing-md);
            border-top: 1px solid var(--cyber-green);
            text-align: center;
            font-size: 8pt;
            color: #008800;
            height: 32px;
            width: 100%;
            background: rgba(0, 0, 0, 0.8);
            flex-shrink: 0;
        }
        
        .btn {
            padding: 6px 8px;
            border-radius: var(--radius);
            border: 1px solid var(--cyber-green);
            background: #000;
            color: var(--terminal-text);
            cursor: pointer;
            margin: 2px 0;
            transition: all 0.3s ease;
            font-size: 9pt;
            box-shadow: 0 0 5px currentColor;
        }
        
        .btn:hover {
            background: var(--cyber-green);
            color: #000;
            box-shadow: 0 0 10px var(--cyber-green), 0 0 15px var(--cyber-green);
        }
        
        .btn-primary {
            background: var(--cyber-green);
            color: #000;
            box-shadow: 0 0 10px var(--cyber-green), 0 0 15px var(--cyber-green);
        }
        
        .drone-type {
            padding: 4px 6px;
            background: #000;
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            text-align: center;
            cursor: pointer;
            margin: 1px;
            transition: all 0.3s ease;
            font-size: 8pt;
            box-shadow: 0 0 5px currentColor;
        }
        
        .drone-type:hover {
            box-shadow: 0 0 10px currentColor, 0 0 15px currentColor;
        }
        
        .drone-type.active {
            background: var(--cyber-green);
            color: #000;
            box-shadow: 0 0 10px var(--cyber-green), 0 0 15px var(--cyber-green);
        }

        .metric {
            background: #000;
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            padding: 6px;
            text-align: center;
            margin: 3px 0;
            box-shadow: 0 0 5px var(--cyber-green);
        }
        
        .metric-val {
            font-size: 10pt;
            font-weight: bold;
            color: var(--cyber-green);
        }
        
        .slider-container {
            margin: 6px 0;
        }
        
        .slider-container label {
            display: block;
            margin-bottom: 3px;
            font-size: 9pt;
        }
        
        .mode-panel {
            display: none;
        }
        
        .mode-panel.active {
            display: block;
        }
        
        .progress-bar {
            height: 8px;
            background: #000;
            border: 1px solid var(--cyber-green);
            border-radius: 4px;
            overflow: hidden;
            margin: 3px 0;
        }
        
        .progress {
            height: 100%;
            background: var(--cyber-green);
            width: 0%;
            transition: width 0.3s ease;
        }

        .memory-control {
            background: #000;
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            padding: 6px;
            margin: 3px 0;
            font-size: 8pt;
            box-shadow: 0 0 5px var(--cyber-green);
        }

        .training-stats {
            background: #000;
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            padding: 6px;
            margin: 3px 0;
            font-size: 8pt;
            box-shadow: 0 0 5px var(--cyber-green);
        }

        .panel-section {
            margin-bottom: var(--spacing-md);
        }
        
        .panel-section h2 {
            font-size: 10pt;
            margin-bottom: var(--spacing-sm);
            border-bottom: 1px solid #008800;
            padding-bottom: 2px;
            text-shadow: 0 0 5px var(--cyber-green);
        }
        
        .compact-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-sm);
        }
        
        .compact-row {
            display: flex;
            justify-content: space-between;
            margin: 2px 0;
        }
        
        .compact-row label {
            font-size: 8pt;
        }
        
        .compact-row span {
            font-size: 9pt;
            font-weight: bold;
            color: var(--cyber-green);
        }
        
        .drone-type-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-md);
        }
        
        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-sm);
        }
        
        .btn-group-vertical {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-md);
        }
        
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #000;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--cyber-green);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--cyber-blue);
        }

        /* Glitch effect for header */
        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }

        .glitch-effect {
            position: relative;
        }

        .glitch-effect::before,
        .glitch-effect::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .glitch-effect::before {
            animation: glitch-1 0.5s infinite;
            color: var(--glitch-color-1);
            z-index: -1;
        }

        .glitch-effect::after {
            animation: glitch-2 0.5s infinite;
            color: var(--glitch-color-2);
            z-index: -2;
        }

        @keyframes glitch-1 {
            0% { transform: translate(0); }
            20% { transform: translate(-1px, 1px); }
            40% { transform: translate(-1px, -1px); }
            60% { transform: translate(1px, 1px); }
            80% { transform: translate(1px, -1px); }
            100% { transform: translate(0); }
        }

        @keyframes glitch-2 {
            0% { transform: translate(0); }
            20% { transform: translate(1px, -1px); }
            40% { transform: translate(1px, 1px); }
            60% { transform: translate(-1px, -1px); }
            80% { transform: translate(-1px, 1px); }
            100% { transform: translate(0); }
        }

        /* Static effect for console */
        @keyframes static {
            0% { background-position: 0 0; }
            100% { background-position: 0 100%; }
        }

        .console-output::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(transparent 50%, rgba(0, 255, 157, 0.03) 50%);
            background-size: 100% 4px;
            animation: static 0.2s infinite;
            pointer-events: none;
            z-index: 1;
        }

        /* Modal styles for import/export */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--panel-bg);
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            padding: var(--spacing-md);
            width: 400px;
            max-width: 90%;
            box-shadow: 0 0 20px var(--cyber-green);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--cyber-green);
            padding-bottom: var(--spacing-sm);
        }

        .modal-title {
            font-size: 12pt;
            color: var(--cyber-green);
            text-shadow: 0 0 5px var(--cyber-green);
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--cyber-green);
            font-size: 14pt;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-body {
            margin-bottom: var(--spacing-md);
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: var(--spacing-sm);
        }

        .file-input {
            display: none;
        }

        .file-label {
            display: block;
            padding: var(--spacing-md);
            border: 1px dashed var(--cyber-green);
            border-radius: var(--radius);
            text-align: center;
            cursor: pointer;
            margin-bottom: var(--spacing-md);
            transition: all 0.3s ease;
        }

        .file-label:hover {
            background: rgba(0, 255, 157, 0.1);
            box-shadow: 0 0 10px var(--cyber-green);
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .status-exporting {
            background: #ffcc00;
            animation: pulse 1s infinite;
        }

        .status-importing {
            background: #00ccff;
            animation: pulse 1s infinite;
        }

        .status-success {
            background: #00cc00;
        }

        .status-error {
            background: #ff0040;
        }
    </style>
</head>
<body>
    <header class="cyber-header">
        <h1 class="glitch-effect" data-text="LAUNCH SEQUENCE - WEBXOS 2025">LAUNCH SEQUENCE - WEBXOS 2025</h1>
        <div class="mode-tabs">
            <div class="mode-tab active" data-mode="train">TRAIN</div>
            <div class="mode-tab" data-mode="test">TEST</div>
        </div>
    </header>
    
    <main>
        <div class="left-panel cyber-panel">
            <div class="mode-panel active" id="train-panel">
                <div class="panel-section">
                    <h2>Training Controls</h2>
                    <div class="drone-type-selector">
                        <div class="drone-type active" data-type="fpv">FPV</div>
                        <div class="drone-type" data-type="longrange">LONG RANGE</div>
                    </div>
                    
                    <div class="slider-container">
                        <div class="compact-row">
                            <label>Learning Rate:</label>
                            <span id="learning-rate-value">0.10</span>
                        </div>
                        <input type="range" id="learning-rate" min="0.01" max="1.0" step="0.01" value="0.1" style="width:100%">
                    </div>
                    
                    <div class="slider-container">
                        <div class="compact-row">
                            <label>Creativity:</label>
                            <span id="creativity-value">0.70</span>
                        </div>
                        <input type="range" id="creativity" min="0.0" max="1.0" step="0.01" value="0.7" style="width:100%">
                    </div>

                    <div class="memory-control">
                        <div class="compact-row">
                            <label>Training Memory:</label>
                            <span id="memory-usage">128MB</span>
                        </div>
                        <input type="range" id="memory-limit" min="64" max="1024" step="64" value="128" style="width:100%">
                    </div>
                </div>
                
                <div class="panel-section">
                    <h2>Training Actions</h2>
                    <div class="btn-group-vertical">
                        <button class="btn btn-primary" id="start-train">Start Endless Training</button>
                        <div class="btn-group">
                            <button class="btn" id="stop-train">Pause</button>
                            <button class="btn" id="reset-train">Reset</button>
                        </div>
                        <button class="btn" id="export-model">Export Training Log</button>
                        <button class="btn" id="import-model" style="display:none">Import Training Data</button>
                    </div>
                </div>
            </div>
            
            <div class="mode-panel" id="test-panel">
                <div class="panel-section">
                    <h2>Test Controls</h2>
                    <div class="btn-group-vertical">
                        <button class="btn btn-primary" id="autopilot-test">AUTO-PILOT TEST</button>
                        <button class="btn" id="test-stop">TEST STOP</button>
                        <button class="btn" id="import-json">IMPORT JSON</button>
                        <button class="btn" id="new-course">NEW COURSE</button>
                        <button class="btn" id="fpv-camera">FPV CAMERA</button>
                    </div>
                </div>
                
                <div class="panel-section">
                    <h2>Drone Configuration</h2>
                    <div class="slider-container">
                        <div class="compact-row">
                            <label>Drone Speed:</label>
                            <span id="drone-speed-value">1.0x</span>
                        </div>
                        <input type="range" id="drone-speed" min="0" max="3" step="0.1" value="1.0" style="width:100%">
                    </div>
                </div>
                
                <div class="panel-section">
                    <h2>Environment</h2>
                    <div class="btn-group">
                        <button class="btn active" data-environment="forest">FOREST</button>
                        <button class="btn" data-environment="course">COURSE</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="center-panel">
            <div class="combat-arena-container" id="scene-container">
                <canvas id="three-canvas"></canvas>
                <div class="scene-controls">
                    <div>Mouse: Drag to rotate</div>
                    <div>Wheel: Zoom in/out</div>
                </div>
                <div class="qnn-overlay">
                    <div class="qnn-grid" id="qnn-grid">
                        <!-- QNN grid will be generated by JavaScript -->
                    </div>
                </div>
            </div>
            <div class="console-container">
                <div class="console-output" id="console-output">
                    <p class="sys">[SYSTEM] LAUNCH SEQUENCE initialized</p>
                    <p class="sys">[SYSTEM] Enhanced FPV drone course ready</p>
                    <p class="sys">[SYSTEM] Type /help for available commands</p>
                </div>
                <button class="copy-log" id="copy-log">COPY LOG</button>
                <div class="console-input">
                    <input type="text" class="input-line" id="console-input" placeholder="Type /help for commands...">
                    <button class="input-send" id="console-send">SEND</button>
                </div>
            </div>
        </div>
        
        <div class="right-panel cyber-panel">
            <div class="mode-panel active" id="train-right-panel">
                <div class="panel-section">
                    <h2>Training Status</h2>
                    <div class="training-stats">
                        <div class="compact-row">
                            <label>Training Rounds:</label>
                            <span id="training-rounds">173823</span>
                        </div>
                        <div class="compact-row">
                            <label>Total Time:</label>
                            <span id="total-training-time">289h 42m</span>
                        </div>
                        <div class="compact-row">
                            <label>Best Score:</label>
                            <span id="best-score">0.0%</span>
                        </div>
                    </div>
                    
                    <div class="progress-bar">
                        <div class="progress" id="train-progress-bar" style="width: 0%"></div>
                    </div>
                    <div class="compact-row">
                        <label>Training Progress:</label>
                        <span id="train-progress">0%</span>
                    </div>
                    
                    <div class="metrics-grid">
                        <div class="metric">
                            <div class="metric-val" id="accuracy">0%</div>
                            <div>Accuracy</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="active-nodes">0</div>
                            <div>Active Nodes</div>
                        </div>
                    </div>
                </div>
                
                <div class="panel-section">
                    <h2>Training Data</h2>
                    <div class="metric">
                        <div>Model: <input type="text" id="model-name" placeholder="Model Name" style="background: #000; color: var(--cyber-green); border: 1px solid #008800; padding: 4px; width: 100%; font-size: 9pt;"></div>
                    </div>
                    
                    <div class="metrics-grid">
                        <div class="metric">
                            <div class="metric-val" id="epoch">0</div>
                            <div>Epoch</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="loss">0.00</div>
                            <div>Loss</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="complexity">Low</div>
                            <div>Complexity</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="response-time">0ms</div>
                            <div>Response Time</div>
                        </div>
                    </div>
                    
                    <div class="training-stats">
                        <div class="compact-row">
                            <label>Training Cycles:</label>
                            <span id="training-cycles">0</span>
                        </div>
                        <div class="compact-row">
                            <label>Data Points:</label>
                            <span id="data-points">0</span>
                        </div>
                        <div class="compact-row">
                            <label>Memory Used:</label>
                            <span id="memory-used">0MB</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="mode-panel" id="test-right-panel">
                <div class="panel-section">
                    <h2>Test Status</h2>
                    <div class="training-stats">
                        <div class="compact-row">
                            <label>Test Status:</label>
                            <span id="test-status">Idle</span>
                        </div>
                        <div class="compact-row">
                            <label>Test Score:</label>
                            <span id="test-score">0%</span>
                        </div>
                        <div class="compact-row">
                            <label>Environment:</label>
                            <span id="current-environment">Forest</span>
                        </div>
                        <div class="compact-row">
                            <label id="escapes-label">Gates Passed:</label>
                            <span id="escapes">0</span>
                        </div>
                    </div>
                    
                    <div class="metrics-grid">
                        <div class="metric">
                            <div class="metric-val" id="flight-time">0s</div>
                            <div>Flight Time</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="distance">0m</div>
                            <div>Distance</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="collisions">0</div>
                            <div>Collisions</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="test-speed">0 km/h</div>
                            <div>Speed</div>
                        </div>
                    </div>
                    
                    <div class="progress-bar">
                        <div class="progress" id="test-progress-bar" style="width: 0%"></div>
                    </div>
                    <div class="compact-row">
                        <label>Test Progress:</label>
                        <span id="test-progress">0%</span>
                    </div>
                </div>
            </div>
        </div>
    </main>
    
    <footer>
        WEBXOS 2025 | LAUNCH SEQUENCE v1.5.0 | FPV Drone Course | Enhanced Course Mode
    </footer>

    <!-- Import Modal -->
    <div class="modal" id="import-modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Import Training Data</div>
                <button class="modal-close" id="import-close">&times;</button>
            </div>
            <div class="modal-body">
                <div class="file-label" id="import-drop-area">
                    <span>Drop JSON file here or click to browse</span>
                    <input type="file" id="import-file" class="file-input" accept=".json">
                </div>
                <div id="import-status">
                    <span class="status-indicator" id="import-status-indicator"></span>
                    <span id="import-status-text">Ready to import</span>
                </div>
                <div id="import-preview" style="display: none; margin-top: 10px;">
                    <h3>Import Preview:</h3>
                    <div id="import-preview-content" style="max-height: 200px; overflow-y: auto; background: #000; padding: 10px; border-radius: 4px; font-size: 9pt;"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="import-cancel">Cancel</button>
                <button class="btn btn-primary" id="import-confirm" disabled>Import</button>
            </div>
        </div>
    </div>

    <!-- Export Modal -->
    <div class="modal" id="export-modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Export Training Data</div>
                <button class="modal-close" id="export-close">&times;</button>
            </div>
            <div class="modal-body">
                <div class="compact-row">
                    <label>Model Name:</label>
                    <input type="text" id="export-model-name" placeholder="Enter model name" style="background: #000; color: var(--cyber-green); border: 1px solid #008800; padding: 4px; width: 60%; font-size: 9pt;">
                </div>
                <div class="compact-row">
                    <label>Include Training Log:</label>
                    <input type="checkbox" id="export-include-log" checked style="margin-left: 10px;">
                </div>
                <div class="compact-row">
                    <label>Include QNN State:</label>
                    <input type="checkbox" id="export-include-qnn" checked style="margin-left: 10px;">
                </div>
                <div class="compact-row">
                    <label>Data Size:</label>
                    <span id="export-data-size">0 KB</span>
                </div>
                <div id="export-status">
                    <span class="status-indicator" id="export-status-indicator"></span>
                    <span id="export-status-text">Ready to export</span>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="export-cancel">Cancel</button>
                <button class="btn btn-primary" id="export-confirm">Export</button>
            </div>
        </div>
    </div>

    <script>
        // Enhanced global state with FPV drone course
        const state = {
            currentMode: 'train',
            droneType: 'fpv',
            environmentType: 'forest',
            training: {
                running: false,
                endless: false,
                progress: 0,
                epoch: 0,
                loss: 2.5,
                accuracy: 0,
                activeNodes: 0,
                responseTime: 0,
                complexity: 'Low',
                rounds: 173823,
                totalTime: 289 * 60 + 42, // in minutes
                bestScore: 0,
                cycles: 0,
                dataPoints: 0
            },
            test: {
                mode: 'autopilot',
                flightTime: 0,
                distance: 0,
                collisions: 0,
                speed: 0,
                battery: 100,
                testAccuracy: 0,
                progress: 0,
                score: 0,
                environment: 'Forest',
                escapes: 0,
                successRate: 0,
                bestRun: 0,
                status: 'Idle',
                droneSpeed: 1.0,
                startTime: 0,
                totalGates: 0,
                // New test metrics
                forestEscapeTime: 0,
                courseCompletionTime: 0,
                bestForestTime: 0,
                bestCourseTime: 0,
                attempts: 0
            },
            qnn: {
                grid: Array(10).fill().map(() => Array(10).fill('inactive')),
                learningRate: 0.1,
                creativity: 0.7,
                memoryLimit: 128,
                memoryUsed: 0
            },
            scene: null,
            camera: null,
            renderer: null,
            drone: null,
            obstacles: [],
            gates: [],
            trees: [],
            trainingEnvironments: ['A', 'B', 'C', 'D'],
            currentEnvironment: 0,
            flightControls: {
                forward: false,
                backward: false,
                left: false,
                right: false,
                up: false,
                down: false
            },
            autopilotActive: false,
            trainingInterval: null,
            testInterval: null,
            environmentInterval: null,
            trainingLog: [],
            serviceWorker: null,
            // Camera control variables
            isMouseDown: false,
            mouseX: 0,
            mouseY: 0,
            cameraDistance: 20,
            cameraAngleX: 0,
            cameraAngleY: 0.5,
            // FPV camera mode
            fpvCamera: false,
            // Test variables
            testActive: false,
            testObstacles: [],
            testGates: [],
            testStartTime: 0,
            testDuration: 60000, // 1 minute test
            reinforcementAgent: {
                learning: true,
                score: 0,
                attempts: 0,
                improvement: 0
            },
            // Import/Export state
            importData: null,
            exportData: null,
            // Drone navigation
            currentGateTarget: 0,
            gatePassed: [],
            autopilotPath: [],
            // Forest mode specific
            forestTargetDirection: null,
            forestLastDirectionChange: 0,
            forestDirectionChangeInterval: 2000, // Change direction every 2 seconds
            forestEscapeBoundary: 40, // 2x larger map (was 20)
            forestStartTime: 0,
            forestCurrentEscapeTime: 0,
            // Course mode specific
            courseStartTime: 0,
            courseCurrentTime: 0,
            // Test data storage
            testData: []
        };

        // Initialize the application with enhanced training
        function init() {
            setupEventListeners();
            generateQNNGrid();
            init3DScene();
            initServiceWorker();
            loadTrainingData();
            updateTrainingUI();
            updateTrainingStats();
            logMessage('[SYSTEM] LAUNCH SEQUENCE initialized', 'sys');
            logMessage('[SYSTEM] Enhanced FPV drone course ready', 'sys');
            logMessage('[SYSTEM] Type /help for available commands', 'sys');
            
            // Hide import button in train mode, export in test mode
            updateImportExportVisibility();
        }

        // Update import/export button visibility based on mode
        function updateImportExportVisibility() {
            const exportBtn = document.getElementById('export-model');
            const importBtn = document.getElementById('import-model');
            
            if (state.currentMode === 'train') {
                exportBtn.style.display = 'block';
                importBtn.style.display = 'none';
            } else {
                exportBtn.style.display = 'none';
                importBtn.style.display = 'block';
            }
        }

        // Initialize background service worker for continuous training
        function initServiceWorker() {
            // Simulate service worker for background training
            state.serviceWorker = {
                active: true,
                trainingData: [],
                processTrainingBatch: function() {
                    if (state.training.endless && state.training.running) {
                        // Process reinforcement learning batch
                        processReinforcementBatch();
                    }
                }
            };
            
            // Process training batches every 5 seconds
            setInterval(() => {
                state.serviceWorker.processTrainingBatch();
            }, 5000);
        }

        // Process reinforcement learning batch
        function processReinforcementBatch() {
            if (state.training.dataPoints < state.qnn.memoryLimit * 1000) {
                state.training.dataPoints += Math.floor(Math.random() * 100) + 50;
                updateTrainingStats();
                
                // Simulate reinforcement learning improvements
                if (state.training.accuracy < 95) {
                    state.training.accuracy += Math.random() * 0.5;
                    state.training.loss = Math.max(0.01, state.training.loss * 0.99);
                }
                
                // Log training progress
                if (state.training.cycles % 10 === 0) {
                    logMessage(`[TRAINING] Reinforcement batch processed: +${state.training.dataPoints} data points`, 'train-log');
                    logMessage(`[TRAINING] Model accuracy: ${state.training.accuracy.toFixed(2)}%`, 'train-log');
                }
                
                // Save training state periodically
                if (state.training.cycles % 50 === 0) {
                    saveTrainingData();
                }
            }
        }

        // Save training data to localStorage
        function saveTrainingData() {
            const trainingData = {
                timestamp: new Date().toISOString(),
                state: state,
                log: state.trainingLog.slice(-1000) // Keep last 1000 entries
            };
            
            localStorage.setItem('qnn_training_data', JSON.stringify(trainingData));
            state.qnn.memoryUsed = Math.round(JSON.stringify(trainingData).length / 1024);
            updateTrainingStats();
            
            logMessage(`[SYSTEM] Training data saved (${state.qnn.memoryUsed}MB used)`, 'sys');
        }

        // Load training data from localStorage
        function loadTrainingData() {
            const saved = localStorage.getItem('qnn_training_data');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    // Load basic training stats
                    state.training.rounds = data.state.training.rounds || 173823;
                    state.training.totalTime = data.state.training.totalTime || (289 * 60 + 42);
                    state.training.bestScore = data.state.training.bestScore || 0;
                    state.training.dataPoints = data.state.training.dataPoints || 0;
                    state.trainingLog = data.log || [];
                    
                    logMessage('[SYSTEM] Previous training data loaded', 'sys');
                    logMessage(`[SYSTEM] Resuming from ${state.training.rounds} training rounds`, 'sys');
                } catch (e) {
                    logMessage('[SYSTEM] No previous training data found', 'warn');
                }
            }
            updateTrainingStats();
        }

        // Set up event listeners
        function setupEventListeners() {
            // Mode tabs
            document.querySelectorAll('.mode-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const mode = tab.getAttribute('data-mode');
                    switchMode(mode);
                });
            });

            // Drone type selection
            document.querySelectorAll('.drone-type').forEach(type => {
                type.addEventListener('click', () => {
                    document.querySelectorAll('.drone-type').forEach(t => t.classList.remove('active'));
                    type.classList.add('active');
                    state.droneType = type.getAttribute('data-type');
                    updateDroneModel();
                    logMessage(`[SYSTEM] Drone type switched to: ${state.droneType.toUpperCase()}`, 'sys');
                });
            });

            // Environment selection
            document.querySelectorAll('[data-environment]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-environment]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.environmentType = btn.getAttribute('data-environment');
                    updateEnvironment();
                    logMessage(`[SYSTEM] Environment switched to: ${state.environmentType.toUpperCase()}`, 'sys');
                });
            });

            // Training controls
            document.getElementById('start-train').addEventListener('click', startTraining);
            document.getElementById('stop-train').addEventListener('click', stopTraining);
            document.getElementById('reset-train').addEventListener('click', resetTraining);
            document.getElementById('export-model').addEventListener('click', showExportModal);
            document.getElementById('import-model').addEventListener('click', showImportModal);

            // Test controls
            document.getElementById('autopilot-test').addEventListener('click', startAutopilotTest);
            document.getElementById('test-stop').addEventListener('click', stopTest);
            document.getElementById('import-json').addEventListener('click', showImportModal);
            document.getElementById('new-course').addEventListener('click', newCourse);
            document.getElementById('fpv-camera').addEventListener('click', toggleFPVCamera);

            // Sliders
            document.getElementById('learning-rate').addEventListener('input', updateLearningRate);
            document.getElementById('creativity').addEventListener('input', updateCreativity);
            document.getElementById('memory-limit').addEventListener('input', updateMemoryLimit);
            document.getElementById('drone-speed').addEventListener('input', updateDroneSpeed);

            // Console input
            document.getElementById('console-send').addEventListener('click', processConsoleInput);
            document.getElementById('console-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') processConsoleInput();
            });

            // Copy log button
            document.getElementById('copy-log').addEventListener('click', copyLogToClipboard);

            // Import modal events
            document.getElementById('import-close').addEventListener('click', hideImportModal);
            document.getElementById('import-cancel').addEventListener('click', hideImportModal);
            document.getElementById('import-confirm').addEventListener('click', confirmImport);
            document.getElementById('import-file').addEventListener('change', handleFileSelect);
            
            // Export modal events
            document.getElementById('export-close').addEventListener('click', hideExportModal);
            document.getElementById('export-cancel').addEventListener('click', hideExportModal);
            document.getElementById('export-confirm').addEventListener('click', confirmExport);
            document.getElementById('export-model-name').addEventListener('input', updateExportPreview);
            document.getElementById('export-include-log').addEventListener('change', updateExportPreview);
            document.getElementById('export-include-qnn').addEventListener('change', updateExportPreview);

            // Drag and drop for import
            const dropArea = document.getElementById('import-drop-area');
            dropArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropArea.style.background = 'rgba(0, 255, 157, 0.1)';
                dropArea.style.boxShadow = '0 0 10px var(--cyber-green)';
            });
            
            dropArea.addEventListener('dragleave', () => {
                dropArea.style.background = '';
                dropArea.style.boxShadow = '';
            });
            
            dropArea.addEventListener('drop', (e) => {
                e.preventDefault();
                dropArea.style.background = '';
                dropArea.style.boxShadow = '';
                
                if (e.dataTransfer.files.length) {
                    document.getElementById('import-file').files = e.dataTransfer.files;
                    handleFileSelect({ target: document.getElementById('import-file') });
                }
            });

            // Keyboard controls for drone
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);

            // Mouse controls for camera
            setupCameraControls();
        }

        // Copy console log to clipboard
        function copyLogToClipboard() {
            const text = JSON.stringify(state.trainingLog, null, 2);
            
            navigator.clipboard.writeText(text).then(() => {
                logMessage('[SYSTEM] Training log copied to clipboard as JSON', 'sys');
            }).catch(err => {
                logMessage('[ERROR] Failed to copy log: ' + err, 'err');
            });
        }

        // Show import modal
        function showImportModal() {
            document.getElementById('import-modal').classList.add('active');
            resetImportModal();
        }

        // Hide import modal
        function hideImportModal() {
            document.getElementById('import-modal').classList.remove('active');
        }

        // Reset import modal
        function resetImportModal() {
            document.getElementById('import-file').value = '';
            document.getElementById('import-preview').style.display = 'none';
            document.getElementById('import-confirm').disabled = true;
            setImportStatus('Ready to import', '');
            state.importData = null;
        }

        // Handle file selection for import
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            setImportStatus('Reading file...', 'importing');
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    state.importData = data;
                    
                    // Validate the data structure
                    if (validateImportData(data)) {
                        setImportStatus('File validated successfully', 'success');
                        document.getElementById('import-confirm').disabled = false;
                        showImportPreview(data);
                    } else {
                        setImportStatus('Invalid file format', 'error');
                        document.getElementById('import-confirm').disabled = true;
                    }
                } catch (error) {
                    setImportStatus('Error parsing JSON: ' + error.message, 'error');
                    document.getElementById('import-confirm').disabled = true;
                }
            };
            
            reader.onerror = () => {
                setImportStatus('Error reading file', 'error');
                document.getElementById('import-confirm').disabled = true;
            };
            
            reader.readAsText(file);
        }

        // Validate import data structure
        function validateImportData(data) {
            // Basic validation - check for required fields
            if (!data || typeof data !== 'object') return false;
            if (!data.timestamp || !data.state) return false;
            if (!data.state.training || !data.state.qnn) return false;
            
            return true;
        }

        // Show import preview
        function showImportPreview(data) {
            const preview = document.getElementById('import-preview-content');
            preview.innerHTML = '';
            
            // Create preview elements
            const items = [
                { label: 'Model Name', value: data.modelName || 'Unnamed' },
                { label: 'Timestamp', value: new Date(data.timestamp).toLocaleString() },
                { label: 'Training Rounds', value: data.state.training.rounds || 0 },
                { label: 'Accuracy', value: `${(data.state.training.accuracy || 0).toFixed(2)}%` },
                { label: 'Loss', value: (data.state.training.loss || 0).toFixed(4) },
                { label: 'Data Points', value: data.state.training.dataPoints || 0 }
            ];
            
            items.forEach(item => {
                const div = document.createElement('div');
                div.className = 'compact-row';
                div.innerHTML = `<label>${item.label}:</label><span>${item.value}</span>`;
                preview.appendChild(div);
            });
            
            document.getElementById('import-preview').style.display = 'block';
        }

        // Set import status
        function setImportStatus(message, status) {
            const indicator = document.getElementById('import-status-indicator');
            const text = document.getElementById('import-status-text');
            
            text.textContent = message;
            indicator.className = 'status-indicator';
            
            if (status === 'importing') {
                indicator.classList.add('status-importing');
            } else if (status === 'success') {
                indicator.classList.add('status-success');
            } else if (status === 'error') {
                indicator.classList.add('status-error');
            }
        }

        // Confirm import
        function confirmImport() {
            if (!state.importData) return;
            
            setImportStatus('Importing data...', 'importing');
            
            // Simulate import process with delay
            setTimeout(() => {
                try {
                    // Update application state with imported data
                    applyImportedData(state.importData);
                    setImportStatus('Import completed successfully', 'success');
                    
                    // Close modal after a brief delay
                    setTimeout(() => {
                        hideImportModal();
                        logMessage('[SYSTEM] Training data imported successfully', 'ok');
                    }, 1000);
                } catch (error) {
                    setImportStatus('Error during import: ' + error.message, 'error');
                }
            }, 1500);
        }

        // Apply imported data to application state
        function applyImportedData(data) {
            // Update training state
            if (data.state.training) {
                Object.assign(state.training, data.state.training);
            }
            
            // Update QNN state
            if (data.state.qnn) {
                Object.assign(state.qnn, data.state.qnn);
            }
            
            // Update training log
            if (data.log) {
                state.trainingLog = data.log;
            }
            
            // Update model name
            if (data.modelName) {
                document.getElementById('model-name').value = data.modelName;
            }
            
            // Update UI
            updateTrainingUI();
            updateTrainingStats();
            updateQNNGrid();
            
            // Save to localStorage
            saveTrainingData();
        }

        // Show export modal
        function showExportModal() {
            document.getElementById('export-modal').classList.add('active');
            resetExportModal();
            updateExportPreview();
        }

        // Hide export modal
        function hideExportModal() {
            document.getElementById('export-modal').classList.remove('active');
        }

        // Reset export modal
        function resetExportModal() {
            document.getElementById('export-model-name').value = document.getElementById('model-name').value || `qnn_model_${Date.now()}`;
            document.getElementById('export-include-log').checked = true;
            document.getElementById('export-include-qnn').checked = true;
            setExportStatus('Ready to export', '');
        }

        // Update export preview
        function updateExportPreview() {
            const modelName = document.getElementById('export-model-name').value || 'Unnamed';
            const includeLog = document.getElementById('export-include-log').checked;
            const includeQnn = document.getElementById('export-include-qnn').checked;
            
            // Prepare export data
            const exportData = {
                modelName: modelName,
                timestamp: new Date().toISOString(),
                version: '1.5.0',
                state: {
                    training: state.training,
                    qnn: includeQnn ? state.qnn : {},
                    test: state.test
                },
                log: includeLog ? state.trainingLog : []
            };
            
            // Calculate data size
            const dataSize = JSON.stringify(exportData).length;
            document.getElementById('export-data-size').textContent = `${(dataSize / 1024).toFixed(2)} KB`;
            
            state.exportData = exportData;
        }

        // Set export status
        function setExportStatus(message, status) {
            const indicator = document.getElementById('export-status-indicator');
            const text = document.getElementById('export-status-text');
            
            text.textContent = message;
            indicator.className = 'status-indicator';
            
            if (status === 'exporting') {
                indicator.classList.add('status-exporting');
            } else if (status === 'success') {
                indicator.classList.add('status-success');
            } else if (status === 'error') {
                indicator.classList.add('status-error');
            }
        }

        // Confirm export
        function confirmExport() {
            if (!state.exportData) return;
            
            setExportStatus('Exporting data...', 'exporting');
            
            // Simulate export process with delay
            setTimeout(() => {
                try {
                    // Create and download the file
                    const dataStr = JSON.stringify(state.exportData, null, 2);
                    const dataBlob = new Blob([dataStr], { type: 'application/json' });
                    
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(dataBlob);
                    link.download = `${state.exportData.modelName}_${Date.now()}.json`;
                    link.click();
                    
                    setExportStatus('Export completed successfully', 'success');
                    
                    // Close modal after a brief delay
                    setTimeout(() => {
                        hideExportModal();
                        logMessage('[SYSTEM] Training data exported successfully', 'ok');
                    }, 1000);
                } catch (error) {
                    setExportStatus('Error during export: ' + error.message, 'error');
                }
            }, 1500);
        }

        // Switch between TRAIN and TEST modes
        function switchMode(mode) {
            state.currentMode = mode;
            
            // Update tabs
            document.querySelectorAll('.mode-tab').forEach(tab => {
                tab.classList.toggle('active', tab.getAttribute('data-mode') === mode);
            });
            
            // Update panels
            document.querySelectorAll('.mode-panel').forEach(panel => {
                panel.classList.toggle('active', panel.id === `${mode}-panel` || panel.id === `${mode}-right-panel`);
            });
            
            // Update import/export button visibility
            updateImportExportVisibility();
            
            // Update scene based on mode
            updateSceneForMode();
            
            logMessage(`[SYSTEM] Mode switched to: ${mode.toUpperCase()}`, 'sys');
        }

        // Update scene based on current mode
        function updateSceneForMode() {
            if (state.currentMode === 'train') {
                // Training mode - show training environment
                updateEnvironment();
                if (state.training.running) {
                    logMessage('[TRAINING] Training environment activated', 'train-log');
                }
            } else {
                // Test mode - show test environment
                updateEnvironment();
                logMessage('[TEST] Test environment activated', 'sys');
            }
        }

        // Start training
        function startTraining() {
            state.training.running = true;
            state.training.endless = true;
            
            // Start training interval
            state.trainingInterval = setInterval(() => {
                if (state.training.running) {
                    updateTraining();
                }
            }, 100);
            
            document.getElementById('start-train').textContent = 'Training...';
            document.getElementById('start-train').classList.add('active');
            
            logMessage('[TRAINING] Endless training started', 'train-log');
        }

        // Stop training
        function stopTraining() {
            state.training.running = false;
            clearInterval(state.trainingInterval);
            
            document.getElementById('start-train').textContent = 'Start Endless Training';
            document.getElementById('start-train').classList.remove('active');
            
            logMessage('[TRAINING] Training paused', 'warn');
        }

        // Reset training
        function resetTraining() {
            state.training.running = false;
            clearInterval(state.trainingInterval);
            
            state.training.progress = 0;
            state.training.epoch = 0;
            state.training.loss = 2.5;
            state.training.accuracy = 0;
            state.training.activeNodes = 0;
            state.training.responseTime = 0;
            state.training.complexity = 'Low';
            state.training.cycles = 0;
            state.training.dataPoints = 0;
            
            document.getElementById('start-train').textContent = 'Start Endless Training';
            document.getElementById('start-train').classList.remove('active');
            
            updateTrainingUI();
            updateTrainingStats();
            
            logMessage('[TRAINING] Training reset', 'warn');
        }

        // Start autopilot test
        function startAutopilotTest() {
            if (state.testActive) {
                logMessage('[TEST] Test already running', 'warn');
                return;
            }
            
            state.testActive = true;
            state.autopilotActive = true;
            state.test.status = 'Running';
            state.testStartTime = Date.now();
            state.test.startTime = Date.now();
            state.test.collisions = 0;
            state.test.score = 0;
            state.test.flightTime = 0;
            state.test.distance = 0;
            state.test.progress = 0;
            state.test.attempts++;
            
            // Reset based on environment
            if (state.environmentType === 'forest') {
                state.test.escapes = 0;
                state.forestStartTime = Date.now();
                state.forestCurrentEscapeTime = 0;
                logMessage('[TEST] Forest escape test started - Reach the edge!', 'ok');
            } else {
                state.test.escapes = 0;
                state.courseStartTime = Date.now();
                state.courseCurrentTime = 0;
                state.currentGateTarget = 0;
                state.gatePassed = new Array(state.gates.length).fill(false);
                state.gates.forEach(gate => gate.passed = false);
                logMessage('[TEST] Course navigation test started - Complete all gates!', 'ok');
            }
            
            // Reset forest navigation
            state.forestTargetDirection = null;
            state.forestLastDirectionChange = 0;
            
            // Reset drone position to center with random rotation
            if (state.drone) {
                if (state.environmentType === 'forest') {
                    state.drone.position.set(0, 2, 0);
                    const randomRotation = Math.random() * Math.PI * 2;
                    state.drone.rotation.y = randomRotation;
                } else {
                    // For course mode, start at first gate
                    if (state.gates.length > 0) {
                        const firstGate = state.gates[0].mesh.position;
                        state.drone.position.set(firstGate.x, firstGate.y, firstGate.z - 3);
                        state.drone.rotation.y = 0;
                    } else {
                        state.drone.position.set(0, 2, 0);
                    }
                }
            }
            
            // Start test interval
            state.testInterval = setInterval(() => {
                if (state.testActive) {
                    updateTest();
                }
            }, 100);
            
            document.getElementById('autopilot-test').textContent = 'TEST RUNNING';
            document.getElementById('autopilot-test').classList.add('active');
        }

        // Stop test
        function stopTest() {
            if (!state.testActive) return;
            
            state.testActive = false;
            state.autopilotActive = false;
            clearInterval(state.testInterval);
            
            state.test.status = 'Idle';
            document.getElementById('autopilot-test').textContent = 'AUTO-PILOT TEST';
            document.getElementById('autopilot-test').classList.remove('active');
            
            // Report test results
            reportTestResults();
            
            // Reset drone position
            if (state.drone) {
                if (state.environmentType === 'forest') {
                    state.drone.position.set(0, 2, 0);
                } else {
                    // For course mode, reset to first gate
                    if (state.gates.length > 0) {
                        const firstGate = state.gates[0].mesh.position;
                        state.drone.position.set(firstGate.x, firstGate.y, firstGate.z - 3);
                    } else {
                        state.drone.position.set(0, 2, 0);
                    }
                }
            }
            
            logMessage('[TEST] Test stopped', 'warn');
        }

        // Report test results to console
        function reportTestResults() {
            const elapsed = Date.now() - state.test.startTime;
            const flightTime = (elapsed / 1000).toFixed(1);
            const score = state.test.score;
            const collisions = state.test.collisions;
            
            logMessage('[TEST] === TEST RESULTS ===', 'perf');
            logMessage(`[TEST] Total Flight Time: ${flightTime}s`, 'perf');
            logMessage(`[TEST] Collisions: ${collisions}`, 'perf');
            logMessage(`[TEST] Final Score: ${score.toFixed(1)}%`, 'perf');
            
            if (state.environmentType === 'forest') {
                const escapes = state.test.escapes;
                const bestTime = state.test.bestForestTime;
                logMessage(`[TEST] Successful Escapes: ${escapes}`, 'perf');
                if (bestTime > 0) {
                    logMessage(`[TEST] Best Escape Time: ${bestTime.toFixed(2)}s`, 'perf');
                }
            } else {
                const gatesPassed = state.test.escapes;
                const bestTime = state.test.bestCourseTime;
                logMessage(`[TEST] Gates Passed: ${gatesPassed}/${state.gates.length}`, 'perf');
                if (bestTime > 0) {
                    logMessage(`[TEST] Best Course Time: ${bestTime.toFixed(2)}s`, 'perf');
                }
            }
            
            // Save test data
            saveTestData();
            
            if (score >= 80) {
                logMessage('[TEST] EXCELLENT PERFORMANCE! Model is well optimized.', 'ok');
            } else if (score >= 60) {
                logMessage('[TEST] Good performance. Try increasing training cycles.', 'ok');
            } else {
                logMessage('[TEST] Model needs more training. Focus on obstacle avoidance.', 'warn');
            }
        }

        // Save test data for export
        function saveTestData() {
            const testData = {
                timestamp: new Date().toISOString(),
                environment: state.environmentType,
                results: {
                    score: state.test.score,
                    flightTime: state.test.flightTime,
                    collisions: state.test.collisions,
                    attempts: state.test.attempts
                }
            };
            
            if (state.environmentType === 'forest') {
                testData.results.escapes = state.test.escapes;
                testData.results.bestEscapeTime = state.test.bestForestTime;
            } else {
                testData.results.gatesPassed = state.test.escapes;
                testData.results.totalGates = state.gates.length;
                testData.results.bestCourseTime = state.test.bestCourseTime;
            }
            
            // Store in state for export
            if (!state.testData) state.testData = [];
            state.testData.push(testData);
            
            logMessage('[SYSTEM] Test data saved for export', 'sys');
        }

        // Create new course - ENHANCED WITH MORE OBSTACLES
        function newCourse() {
            // Clear existing obstacles and gates
            state.obstacles.forEach(obj => state.scene.remove(obj));
            if (state.environmentType === 'course') {
                state.gates.forEach(obj => {
                    state.scene.remove(obj.mesh);
                    state.scene.remove(obj.light);
                });
            }
            state.obstacles = [];
            state.gates = [];
            
            // Generate new course
            generateEnvironment();
            
            logMessage('[TEST] New course generated', 'ok');
        }

        // Toggle FPV camera
        function toggleFPVCamera() {
            state.fpvCamera = !state.fpvCamera;
            updateCamera();
            
            if (state.fpvCamera) {
                document.getElementById('fpv-camera').textContent = '3RD PERSON';
                logMessage('[TEST] FPV camera activated', 'ok');
            } else {
                document.getElementById('fpv-camera').textContent = 'FPV CAMERA';
                logMessage('[TEST] 3rd person camera activated', 'ok');
            }
        }

        // Update learning rate
        function updateLearningRate(e) {
            state.qnn.learningRate = parseFloat(e.target.value);
            document.getElementById('learning-rate-value').textContent = state.qnn.learningRate.toFixed(2);
            updateQNNGrid();
        }

        // Update creativity
        function updateCreativity(e) {
            state.qnn.creativity = parseFloat(e.target.value);
            document.getElementById('creativity-value').textContent = state.qnn.creativity.toFixed(2);
            updateQNNGrid();
        }

        // Update memory limit
        function updateMemoryLimit(e) {
            state.qnn.memoryLimit = parseInt(e.target.value);
            document.getElementById('memory-usage').textContent = `${state.qnn.memoryLimit}MB`;
        }

        // Update drone speed
        function updateDroneSpeed(e) {
            state.test.droneSpeed = parseFloat(e.target.value);
            document.getElementById('drone-speed-value').textContent = `${state.test.droneSpeed.toFixed(1)}x`;
        }

        // Process console input
        function processConsoleInput() {
            const input = document.getElementById('console-input');
            const command = input.value.trim();
            
            if (command) {
                logMessage(`> ${command}`, 'muted');
                handleCommand(command);
                input.value = '';
            }
        }

        // Handle console commands
        function handleCommand(command) {
            const parts = command.split(' ');
            const cmd = parts[0].toLowerCase();
            
            switch(cmd) {
                case '/help':
                    logMessage('[HELP] Available commands:', 'sys');
                    logMessage('/help - Show this help', 'sys');
                    logMessage('/status - Show system status', 'sys');
                    logMessage('/train [start|stop|reset] - Control training', 'sys');
                    logMessage('/test [start|stop] - Control testing', 'sys');
                    logMessage('/mode [train|test] - Switch mode', 'sys');
                    logMessage('/drone [fpv|longrange] - Switch drone type', 'sys');
                    logMessage('/env [forest|course] - Switch environment', 'sys');
                    logMessage('/camera [fpv|3rd] - Switch camera', 'sys');
                    logMessage('/export - Export training data', 'sys');
                    logMessage('/import - Import training data', 'sys');
                    logMessage('/copylog - Copy console log to clipboard', 'sys');
                    break;
                    
                case '/status':
                    logMessage(`[STATUS] Mode: ${state.currentMode.toUpperCase()}`, 'sys');
                    logMessage(`[STATUS] Drone: ${state.droneType.toUpperCase()}`, 'sys');
                    logMessage(`[STATUS] Environment: ${state.environmentType.toUpperCase()}`, 'sys');
                    logMessage(`[STATUS] Training: ${state.training.running ? 'RUNNING' : 'STOPPED'}`, 'sys');
                    logMessage(`[STATUS] Test: ${state.testActive ? 'RUNNING' : 'STOPPED'}`, 'sys');
                    break;
                    
                case '/train':
                    if (parts[1] === 'start') startTraining();
                    else if (parts[1] === 'stop') stopTraining();
                    else if (parts[1] === 'reset') resetTraining();
                    else logMessage('[ERROR] Invalid train command. Use: start, stop, reset', 'err');
                    break;
                    
                case '/test':
                    if (parts[1] === 'start') startAutopilotTest();
                    else if (parts[1] === 'stop') stopTest();
                    else logMessage('[ERROR] Invalid test command. Use: start, stop', 'err');
                    break;
                    
                case '/mode':
                    if (parts[1] === 'train' || parts[1] === 'test') {
                        switchMode(parts[1]);
                    } else {
                        logMessage('[ERROR] Invalid mode. Use: train, test', 'err');
                    }
                    break;
                    
                case '/drone':
                    if (parts[1] === 'fpv' || parts[1] === 'longrange') {
                        document.querySelectorAll('.drone-type').forEach(t => t.classList.remove('active'));
                        document.querySelector(`.drone-type[data-type="${parts[1]}"]`).classList.add('active');
                        state.droneType = parts[1];
                        updateDroneModel();
                        logMessage(`[SYSTEM] Drone type switched to: ${state.droneType.toUpperCase()}`, 'sys');
                    } else {
                        logMessage('[ERROR] Invalid drone type. Use: fpv, longrange', 'err');
                    }
                    break;
                    
                case '/env':
                    if (parts[1] === 'forest' || parts[1] === 'course') {
                        document.querySelectorAll('[data-environment]').forEach(b => b.classList.remove('active'));
                        document.querySelector(`[data-environment="${parts[1]}"]`).classList.add('active');
                        state.environmentType = parts[1];
                        updateEnvironment();
                        logMessage(`[SYSTEM] Environment switched to: ${state.environmentType.toUpperCase()}`, 'sys');
                    } else {
                        logMessage('[ERROR] Invalid environment. Use: forest, course', 'err');
                    }
                    break;
                    
                case '/camera':
                    if (parts[1] === 'fpv') {
                        state.fpvCamera = true;
                        updateCamera();
                        logMessage('[SYSTEM] FPV camera activated', 'sys');
                    } else if (parts[1] === '3rd') {
                        state.fpvCamera = false;
                        updateCamera();
                        logMessage('[SYSTEM] 3rd person camera activated', 'sys');
                    } else {
                        logMessage('[ERROR] Invalid camera. Use: fpv, 3rd', 'err');
                    }
                    break;
                    
                case '/export':
                    showExportModal();
                    break;
                    
                case '/import':
                    showImportModal();
                    break;
                    
                case '/copylog':
                    copyLogToClipboard();
                    break;
                    
                default:
                    logMessage(`[ERROR] Unknown command: ${cmd}`, 'err');
                    break;
            }
        }

        // Handle keyboard input for drone control
        function handleKeyDown(e) {
            switch(e.key) {
                case 'w': state.flightControls.forward = true; break;
                case 's': state.flightControls.backward = true; break;
                case 'a': state.flightControls.left = true; break;
                case 'd': state.flightControls.right = true; break;
                case 'q': state.flightControls.up = true; break;
                case 'e': state.flightControls.down = true; break;
            }
        }

        function handleKeyUp(e) {
            switch(e.key) {
                case 'w': state.flightControls.forward = false; break;
                case 's': state.flightControls.backward = false; break;
                case 'a': state.flightControls.left = false; break;
                case 'd': state.flightControls.right = false; break;
                case 'q': state.flightControls.up = false; break;
                case 'e': state.flightControls.down = false; break;
            }
        }

        // Set up camera controls
        function setupCameraControls() {
            const container = document.getElementById('scene-container');
            
            container.addEventListener('mousedown', (e) => {
                state.isMouseDown = true;
                state.mouseX = e.clientX;
                state.mouseY = e.clientY;
            });
            
            container.addEventListener('mousemove', (e) => {
                if (!state.isMouseDown) return;
                
                const deltaX = e.clientX - state.mouseX;
                const deltaY = e.clientY - state.mouseY;
                
                state.cameraAngleX += deltaX * 0.01;
                state.cameraAngleY += deltaY * 0.01;
                
                // Clamp vertical angle
                state.cameraAngleY = Math.max(-Math.PI/2, Math.min(Math.PI/2, state.cameraAngleY));
                
                state.mouseX = e.clientX;
                state.mouseY = e.clientY;
                
                updateCamera();
            });
            
            container.addEventListener('mouseup', () => {
                state.isMouseDown = false;
            });
            
            container.addEventListener('wheel', (e) => {
                state.cameraDistance += e.deltaY * 0.01;
                state.cameraDistance = Math.max(5, Math.min(50, state.cameraDistance));
                updateCamera();
            });
        }

        // Update camera position
        function updateCamera() {
            if (!state.camera || !state.drone) return;
            
            if (state.fpvCamera) {
                // FPV camera - first person view from drone
                state.camera.position.copy(state.drone.position);
                state.camera.position.y += 0.5; // Eye level
                
                // Calculate forward direction using drone's quaternion
                const forward = new THREE.Vector3(0, 0, 1);
                forward.applyQuaternion(state.drone.quaternion);
                
                state.camera.lookAt(
                    state.drone.position.x + forward.x,
                    state.drone.position.y + forward.y,
                    state.drone.position.z + forward.z
                );
            } else {
                // 3rd person camera - orbit around drone
                const x = state.drone.position.x + state.cameraDistance * Math.cos(state.cameraAngleX) * Math.cos(state.cameraAngleY);
                const y = state.drone.position.y + state.cameraDistance * Math.sin(state.cameraAngleY);
                const z = state.drone.position.z + state.cameraDistance * Math.sin(state.cameraAngleX) * Math.cos(state.cameraAngleY);
                
                state.camera.position.set(x, y, z);
                state.camera.lookAt(state.drone.position);
            }
        }

        // Initialize 3D scene
        function init3DScene() {
            const container = document.getElementById('scene-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            // Create scene
            state.scene = new THREE.Scene();
            state.scene.background = new THREE.Color(0x001100);
            
            // Create camera
            state.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            state.camera.position.set(0, 5, 10);
            
            // Create renderer
            state.renderer = new THREE.WebGLRenderer({ antialias: false });
            state.renderer.setSize(width, height);
            state.renderer.shadowMap.enabled = true;
            state.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Clear existing canvas and add new one
            const canvas = document.getElementById('three-canvas');
            if (canvas) canvas.remove();
            state.renderer.domElement.id = 'three-canvas';
            container.appendChild(state.renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            state.scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 512;
            directionalLight.shadow.mapSize.height = 512;
            state.scene.add(directionalLight);
            
            // Create ground - ENLARGED FOR FOREST MODE
            const groundGeometry = new THREE.PlaneGeometry(80, 80); // 2x larger for forest
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x004400,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            state.scene.add(ground);
            
            // Add grid helper - ENLARGED FOR FOREST MODE
            const gridHelper = new THREE.GridHelper(80, 80, 0x00ff00, 0x004400);
            gridHelper.position.y = 0.01;
            state.scene.add(gridHelper);
            
            // Create drone
            createDrone();
            
            // Generate environment
            generateEnvironment();
            
            // Start animation loop
            animate();
            
            // Handle window resize
            window.addEventListener('resize', () => {
                const width = container.clientWidth;
                const height = container.clientHeight;
                state.camera.aspect = width / height;
                state.camera.updateProjectionMatrix();
                state.renderer.setSize(width, height);
            });
        }

        // Create drone model
        function createDrone() {
            const droneGroup = new THREE.Group();
            
            // Drone body
            const bodyGeometry = new THREE.BoxGeometry(1, 0.2, 1);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            droneGroup.add(body);
            
            // Drone arms (4 arms)
            const armGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.3, 8);
            const armMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
            
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI / 2);
                const arm = new THREE.Mesh(armGeometry, armMaterial);
                arm.rotation.x = Math.PI / 2; // Horizontal arms
                arm.position.x = Math.cos(angle) * 0.6;
                arm.position.y = 0.1;
                arm.position.z = Math.sin(angle) * 0.6;
                arm.castShadow = true;
                droneGroup.add(arm);
            }
            
            // Position drone
            droneGroup.position.set(0, 2, 0);
            droneGroup.castShadow = true;
            state.scene.add(droneGroup);
            state.drone = droneGroup;
        }

        // Generate environment based on current mode and type
        function generateEnvironment() {
            // Clear existing environment
            state.obstacles.forEach(obj => state.scene.remove(obj));
            if (state.environmentType === 'course') {
                state.gates.forEach(obj => {
                    state.scene.remove(obj.mesh);
                    state.scene.remove(obj.light);
                });
            }
            state.trees.forEach(obj => state.scene.remove(obj));
            state.obstacles = [];
            state.gates = [];
            state.trees = [];
            
            if (state.environmentType === 'forest') {
                generateForest();
            } else {
                generateCourse();
                generateGates();
            }
        }

        // Generate forest environment - ENHANCED WITH 2X MORE OBSTACLES
        function generateForest() {
            // Add trees - 2x more trees
            for (let i = 0; i < 60; i++) { // Was 30
                const treeHeight = 3 + Math.random() * 4;
                const treeTrunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, treeHeight, 8);
                const treeTrunkMaterial = new THREE.MeshStandardMaterial({ color: 0x5D4037 });
                const treeTrunk = new THREE.Mesh(treeTrunkGeometry, treeTrunkMaterial);
                
                const treeTopGeometry = new THREE.ConeGeometry(1.5, treeHeight / 2, 8);
                const treeTopMaterial = new THREE.MeshStandardMaterial({ color: 0x2E7D32 });
                const treeTop = new THREE.Mesh(treeTopGeometry, treeTopMaterial);
                treeTop.position.y = treeHeight / 2 + treeHeight / 4;
                
                const tree = new THREE.Group();
                tree.add(treeTrunk);
                tree.add(treeTop);
                
                // Place trees randomly but avoid center area
                let validPosition = false;
                let attempts = 0;
                let x, z;
                
                while (!validPosition && attempts < 50) {
                    x = (Math.random() - 0.5) * 70; // 2x larger area
                    z = (Math.random() - 0.5) * 70; // 2x larger area
                    
                    // Avoid center area where drone starts
                    const distanceFromCenter = Math.sqrt(x*x + z*z);
                    if (distanceFromCenter < 3) {
                        continue;
                    }
                    
                    // Check if position is too close to other obstacles
                    let tooCloseToObstacle = false;
                    for (const obstacle of state.obstacles) {
                        const distance = Math.sqrt(
                            Math.pow(x - obstacle.position.x, 2) + 
                            Math.pow(z - obstacle.position.z, 2)
                        );
                        if (distance < 2.5) {
                            tooCloseToObstacle = true;
                            break;
                        }
                    }
                    
                    validPosition = !tooCloseToObstacle;
                    attempts++;
                }
                
                if (validPosition) {
                    tree.position.x = x;
                    tree.position.z = z;
                    tree.position.y = treeHeight / 2;
                    
                    tree.castShadow = true;
                    tree.receiveShadow = true;
                    
                    state.scene.add(tree);
                    state.trees.push(tree);
                    state.obstacles.push(tree);
                }
            }
            
            // Add large rocks - 2x more rocks
            for (let i = 0; i < 16; i++) { // Was 8
                const rockSize = 0.8 + Math.random() * 1.2; // Larger rocks
                const rockGeometry = new THREE.DodecahedronGeometry(rockSize, 0);
                const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x757575 });
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                
                rock.position.x = (Math.random() - 0.5) * 60; // 2x larger area
                rock.position.z = (Math.random() - 0.5) * 60; // 2x larger area
                rock.position.y = rockSize / 2;
                
                rock.rotation.x = Math.random() * Math.PI;
                rock.rotation.y = Math.random() * Math.PI;
                rock.rotation.z = Math.random() * Math.PI;
                
                rock.castShadow = true;
                rock.receiveShadow = true;
                
                state.scene.add(rock);
                state.obstacles.push(rock);
            }
            
            // Add rock formations (clusters of rocks)
            for (let i = 0; i < 8; i++) {
                const formationX = (Math.random() - 0.5) * 60;
                const formationZ = (Math.random() - 0.5) * 60;
                
                for (let j = 0; j < 3; j++) {
                    const rockSize = 0.5 + Math.random() * 0.8;
                    const rockGeometry = new THREE.DodecahedronGeometry(rockSize, 0);
                    const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
                    const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                    
                    rock.position.x = formationX + (Math.random() - 0.5) * 4;
                    rock.position.z = formationZ + (Math.random() - 0.5) * 4;
                    rock.position.y = rockSize / 2;
                    
                    rock.rotation.x = Math.random() * Math.PI;
                    rock.rotation.y = Math.random() * Math.PI;
                    rock.rotation.z = Math.random() * Math.PI;
                    
                    rock.castShadow = true;
                    rock.receiveShadow = true;
                    
                    state.scene.add(rock);
                    state.obstacles.push(rock);
                }
            }
        }

        // Generate obstacle course - ENHANCED WITH 3 OBSTACLES BETWEEN EACH GATE
        function generateCourse() {
            // Clear existing obstacles
            state.obstacles = [];
            
            const courseRadius = 15;
            const gateCount = 8;
            
            // Create obstacles between each gate (3 obstacles between each gate)
            for (let i = 0; i < gateCount; i++) {
                const currentGateAngle = (i / gateCount) * Math.PI * 2;
                const nextGateAngle = ((i + 1) % gateCount) / gateCount * Math.PI * 2;
                
                // Create 3 obstacles between current gate and next gate
                for (let j = 1; j <= 3; j++) {
                    const interpAngle = currentGateAngle + (nextGateAngle - currentGateAngle) * (j / 4);
                    
                    // Place obstacles at different distances from center
                    const obstacleRadius = courseRadius + (Math.random() - 0.5) * 6;
                    const x = Math.cos(interpAngle) * obstacleRadius;
                    const z = Math.sin(interpAngle) * obstacleRadius;
                    
                    // Randomly choose obstacle type
                    const obstacleType = Math.floor(Math.random() * 4);
                    
                    if (obstacleType === 0) {
                        // Pillars
                        const pillarHeight = 3 + Math.random() * 2;
                        const pillarGeometry = new THREE.CylinderGeometry(0.5, 0.5, pillarHeight, 8);
                        const pillarMaterial = new THREE.MeshStandardMaterial({ color: 0x607D8B });
                        const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                        
                        pillar.position.set(x, pillarHeight / 2, z);
                        pillar.castShadow = true;
                        pillar.receiveShadow = true;
                        
                        state.scene.add(pillar);
                        state.obstacles.push(pillar);
                    } else if (obstacleType === 1) {
                        // Walls
                        const wallLength = 3 + Math.random() * 2;
                        const wallGeometry = new THREE.BoxGeometry(1, 3, wallLength);
                        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x795548 });
                        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                        
                        wall.position.set(x, 1.5, z);
                        wall.rotation.y = interpAngle; // Face outward from center
                        
                        wall.castShadow = true;
                        wall.receiveShadow = true;
                        
                        state.scene.add(wall);
                        state.obstacles.push(wall);
                    } else if (obstacleType === 2) {
                        // Arches
                        const archHeight = 4;
                        const archGeometry = new THREE.BoxGeometry(0.3, archHeight, 2);
                        const archMaterial = new THREE.MeshStandardMaterial({ color: 0x8D6E63 });
                        
                        // Create two pillars for the arch
                        const leftPillar = new THREE.Mesh(archGeometry, archMaterial);
                        const rightPillar = new THREE.Mesh(archGeometry, archMaterial);
                        
                        leftPillar.position.set(x - 1, archHeight / 2, z);
                        rightPillar.position.set(x + 1, archHeight / 2, z);
                        
                        // Create arch top
                        const archTopGeometry = new THREE.BoxGeometry(2.5, 0.3, 0.3);
                        const archTop = new THREE.Mesh(archTopGeometry, archMaterial);
                        archTop.position.set(x, archHeight, z);
                        
                        const arch = new THREE.Group();
                        arch.add(leftPillar);
                        arch.add(rightPillar);
                        arch.add(archTop);
                        arch.rotation.y = interpAngle; // Face outward from center
                        
                        arch.castShadow = true;
                        arch.receiveShadow = true;
                        
                        state.scene.add(arch);
                        state.obstacles.push(arch);
                    } else {
                        // Hanging obstacles
                        const hangingHeight = 5 + Math.random() * 3;
                        const hangingGeometry = new THREE.BoxGeometry(1, 0.5, 1);
                        const hangingMaterial = new THREE.MeshStandardMaterial({ color: 0x9E9E9E });
                        const hanging = new THREE.Mesh(hangingGeometry, hangingMaterial);
                        
                        hanging.position.set(x, hangingHeight, z);
                        
                        // Add chains or supports
                        const chainGeometry = new THREE.CylinderGeometry(0.1, 0.1, hangingHeight - 1, 6);
                        const chainMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
                        
                        for (let k = 0; k < 4; k++) {
                            const chain = new THREE.Mesh(chainGeometry, chainMaterial);
                            const chainAngle = (k / 4) * Math.PI * 2;
                            chain.position.set(
                                x + Math.cos(chainAngle) * 0.6,
                                (hangingHeight - 1) / 2,
                                z + Math.sin(chainAngle) * 0.6
                            );
                            state.scene.add(chain);
                            state.obstacles.push(chain);
                        }
                        
                        hanging.castShadow = true;
                        hanging.receiveShadow = true;
                        
                        state.scene.add(hanging);
                        state.obstacles.push(hanging);
                    }
                }
            }
        }

        // Generate navigation gates (for course mode only)
        function generateGates() {
            // Create a circular course with vertical glowing gates
            const gateCount = 8;
            const radius = 15;
            
            for (let i = 0; i < gateCount; i++) {
                const angle = (i / gateCount) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const y = 3; // Fixed height for all gates
                
                // Create vertical ring (standing up)
                const gateGeometry = new THREE.TorusGeometry(1.5, 0.2, 8, 16);
                const gateMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x00FF00,
                    emissive: 0x00AA00,
                    emissiveIntensity: 0.5
                });
                const gate = new THREE.Mesh(gateGeometry, gateMaterial);
                
                gate.position.set(x, y, z);
                // Rotate to stand upright (vertical)
                gate.rotation.x = Math.PI / 2;
                // Face the gate toward the center of the course
                gate.rotation.y = angle + Math.PI / 2;
                
                gate.castShadow = true;
                state.scene.add(gate);
                
                // Add point light inside gate for glow effect
                const gateLight = new THREE.PointLight(0x00FF00, 0.5, 3);
                gateLight.position.set(x, y, z);
                state.scene.add(gateLight);
                
                // Add gate number indicator
                const textGeometry = new THREE.PlaneGeometry(1, 0.5);
                const textMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00FF00,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                const textPlane = new THREE.Mesh(textGeometry, textMaterial);
                textPlane.position.set(x, y + 1.5, z);
                textPlane.rotation.y = -angle; // Face outward
                state.scene.add(textPlane);
                
                state.gates.push({
                    mesh: gate,
                    light: gateLight,
                    passed: false,
                    index: i,
                    number: i + 1
                });
            }
            
            state.test.totalGates = gateCount;
        }

        // Update drone model based on type
        function updateDroneModel() {
            if (!state.drone) return;
            
            // In a real implementation, we would change the drone model
            // For this demo, we'll just log the change
            logMessage(`[SYSTEM] Drone model updated to: ${state.droneType.toUpperCase()}`, 'sys');
        }

        // Update environment based on type
        function updateEnvironment() {
            generateEnvironment();
            logMessage(`[SYSTEM] Environment updated to: ${state.environmentType.toUpperCase()}`, 'sys');
        }

        // Update training
        function updateTraining() {
            // Update training progress
            state.training.progress = Math.min(100, state.training.progress + 0.1);
            
            // Update training metrics
            state.training.epoch++;
            state.training.loss = Math.max(0.01, state.training.loss * (0.99 + Math.random() * 0.02));
            state.training.accuracy = Math.min(95, state.training.accuracy + Math.random() * 0.1);
            state.training.activeNodes = Math.floor(20 + Math.random() * 60);
            state.training.responseTime = Math.floor(5 + Math.random() * 15);
            state.training.complexity = state.training.accuracy > 50 ? 'Medium' : 'Low';
            state.training.cycles++;
            
            // Update QNN grid
            updateQNNGrid();
            
            // Update UI
            updateTrainingUI();
            updateTrainingStats();
            
            // Log progress periodically
            if (state.training.epoch % 100 === 0) {
                logMessage(`[TRAINING] Epoch: ${state.training.epoch} | Loss: ${state.training.loss.toFixed(4)} | Accuracy: ${state.training.accuracy.toFixed(2)}%`, 'train-log');
            }
        }

        // Update test
        function updateTest() {
            if (!state.testActive) return;
            
            const elapsed = Date.now() - state.testStartTime;
            state.test.progress = Math.min(100, (elapsed / state.testDuration) * 100);
            state.test.flightTime = elapsed / 1000;
            
            // Update environment-specific timing
            if (state.environmentType === 'forest') {
                state.forestCurrentEscapeTime = Date.now() - state.forestStartTime;
            } else {
                state.courseCurrentTime = Date.now() - state.courseStartTime;
            }
            
            // Update drone position with autopilot
            if (state.autopilotActive && state.drone) {
                if (state.environmentType === 'forest') {
                    navigateForest();
                } else {
                    navigateCourse();
                }
            }
            
            // Update test metrics
            state.test.distance += state.test.droneSpeed * 0.1;
            state.test.speed = 15 + Math.random() * 25 * state.test.droneSpeed;
            
            // Calculate score based on environment
            if (state.environmentType === 'forest') {
                // Forest mode: score based on escapes and time
                state.test.score = Math.min(100, 
                    (state.test.escapes * 50) + // Each escape is worth 50 points
                    Math.max(0, 50 - (state.forestCurrentEscapeTime / 1000)) // Time bonus
                );
            } else {
                // Course mode: score based on gates passed and time
                const gateProgress = state.test.escapes / state.gates.length;
                const timeBonus = Math.max(0, 50 - (state.courseCurrentTime / 1000));
                state.test.score = Math.min(100, 
                    (gateProgress * 50) + // Progress toward completion
                    timeBonus // Time bonus
                );
            }
            
            // Update UI
            updateTestUI();
            
            // End test if time is up
            if (elapsed >= state.testDuration) {
                stopTest();
            }
        }

        // Forest mode navigation - ENHANCED FOR LARGER MAP
        function navigateForest() {
            const dronePosition = state.drone.position;
            
            // Check if drone has escaped (reached the edge)
            const distanceFromCenter = Math.sqrt(
                dronePosition.x * dronePosition.x + 
                dronePosition.z * dronePosition.z
            );
            
            if (distanceFromCenter > state.forestEscapeBoundary) {
                // Drone has escaped! Record time and reset for next attempt
                const escapeTime = state.forestCurrentEscapeTime / 1000;
                state.test.escapes++;
                
                // Update best time
                if (state.test.bestForestTime === 0 || escapeTime < state.test.bestForestTime) {
                    state.test.bestForestTime = escapeTime;
                }
                
                logMessage(`[TEST] ESCAPE SUCCESS! Time: ${escapeTime.toFixed(2)}s | Best: ${state.test.bestForestTime.toFixed(2)}s`, 'ok');
                
                // Reset drone to center with new random direction
                state.drone.position.set(0, 2, 0);
                const randomRotation = Math.random() * Math.PI * 2;
                state.drone.rotation.y = randomRotation;
                state.forestStartTime = Date.now();
                state.forestCurrentEscapeTime = 0;
                
                return;
            }
            
            // Calculate direction to nearest edge (escape direction)
            let escapeDirection = new THREE.Vector3();
            
            // Find the closest boundary (x or z axis)
            const toXBoundary = state.forestEscapeBoundary - Math.abs(dronePosition.x);
            const toZBoundary = state.forestEscapeBoundary - Math.abs(dronePosition.z);
            
            if (toXBoundary < toZBoundary) {
                // Escape toward x boundary
                escapeDirection.x = dronePosition.x > 0 ? 1 : -1;
            } else {
                // Escape toward z boundary
                escapeDirection.z = dronePosition.z > 0 ? 1 : -1;
            }
            
            escapeDirection.normalize();
            
            // Check for obstacles and adjust direction
            let obstacleAvoidance = new THREE.Vector3(0, 0, 0);
            let collisionDetected = false;
            
            state.obstacles.forEach(obstacle => {
                const obstacleDistance = dronePosition.distanceTo(obstacle.position);
                if (obstacleDistance < 2.5) {
                    // Calculate avoidance vector (away from obstacle)
                    const avoidDirection = new THREE.Vector3();
                    avoidDirection.subVectors(dronePosition, obstacle.position).normalize();
                    obstacleAvoidance.add(avoidDirection.multiplyScalar(0.8));
                    
                    // If very close to obstacle, count as collision
                    if (obstacleDistance < 1.2) {
                        collisionDetected = true;
                    }
                }
            });
            
            // Handle collision
            if (collisionDetected) {
                state.test.collisions++;
                logMessage(`[TEST] Collision! Total: ${state.test.collisions}`, 'warn');
                
                // Reset drone to center with new random direction
                state.drone.position.set(0, 2, 0);
                const randomRotation = Math.random() * Math.PI * 2;
                state.drone.rotation.y = randomRotation;
                state.forestStartTime = Date.now();
                state.forestCurrentEscapeTime = 0;
                return;
            }
            
            // Combine escape direction with obstacle avoidance
            const combinedDirection = new THREE.Vector3();
            combinedDirection.addVectors(escapeDirection, obstacleAvoidance).normalize();
            
            // Move drone
            const speed = 0.12 * state.test.droneSpeed;
            state.drone.position.x += combinedDirection.x * speed;
            state.drone.position.z += combinedDirection.z * speed;
            
            // Add slight vertical variation for realism
            state.drone.position.y += (Math.random() - 0.5) * 0.05;
            
            // Keep drone at reasonable height
            state.drone.position.y = Math.max(1, Math.min(8, state.drone.position.y));
            
            // Rotate drone to face direction of movement
            state.drone.lookAt(
                dronePosition.x + combinedDirection.x,
                dronePosition.y + combinedDirection.y,
                dronePosition.z + combinedDirection.z
            );
        }

        // Course mode navigation - ENHANCED FOR MORE CHALLENGING COURSE
        function navigateCourse() {
            if (state.gates.length === 0) return;
            
            // Find the next unpassed gate
            let targetGate = null;
            for (let i = 0; i < state.gates.length; i++) {
                const gateIndex = (state.currentGateTarget + i) % state.gates.length;
                if (!state.gates[gateIndex].passed) {
                    targetGate = state.gates[gateIndex];
                    state.currentGateTarget = gateIndex;
                    break;
                }
            }
            
            // If all gates are passed, start over and record completion time
            if (!targetGate) {
                const completionTime = state.courseCurrentTime / 1000;
                state.test.escapes++; // Count as a completed course
                
                // Update best time
                if (state.test.bestCourseTime === 0 || completionTime < state.test.bestCourseTime) {
                    state.test.bestCourseTime = completionTime;
                }
                
                logMessage(`[TEST] COURSE COMPLETED! Time: ${completionTime.toFixed(2)}s | Best: ${state.test.bestCourseTime.toFixed(2)}s`, 'ok');
                
                // Reset for next attempt
                state.gatePassed = new Array(state.gates.length).fill(false);
                state.gates.forEach(gate => gate.passed = false);
                state.currentGateTarget = 0;
                state.courseStartTime = Date.now();
                state.courseCurrentTime = 0;
                targetGate = state.gates[0];
            }
            
            // Move drone toward target gate
            const targetPosition = targetGate.mesh.position;
            const dronePosition = state.drone.position;
            
            // Calculate direction to target
            const direction = new THREE.Vector3();
            direction.subVectors(targetPosition, dronePosition).normalize();
            
            // Check for obstacles in path
            let obstacleAvoidance = new THREE.Vector3(0, 0, 0);
            let collisionDetected = false;
            
            state.obstacles.forEach(obstacle => {
                const obstacleDistance = dronePosition.distanceTo(obstacle.position);
                if (obstacleDistance < 2.5) {
                    // Calculate avoidance vector
                    const avoidDirection = new THREE.Vector3();
                    avoidDirection.subVectors(dronePosition, obstacle.position).normalize();
                    avoidDirection.y += 0.3; // Prefer climbing over obstacles
                    obstacleAvoidance.add(avoidDirection.multiplyScalar(0.6));
                    
                    // If very close to obstacle, count as collision
                    if (obstacleDistance < 1.2) {
                        collisionDetected = true;
                    }
                }
            });
            
            // Handle collision
            if (collisionDetected) {
                state.test.collisions++;
                logMessage(`[TEST] Collision! Total: ${state.test.collisions}`, 'warn');
                
                // Reset drone to start position but keep gate progress
                if (state.gates.length > 0) {
                    const firstGate = state.gates[0].mesh.position;
                    state.drone.position.set(firstGate.x, firstGate.y, firstGate.z - 3);
                } else {
                    state.drone.position.set(0, 2, 0);
                }
                return;
            }
            
            // Combine target direction with obstacle avoidance
            const combinedDirection = new THREE.Vector3();
            combinedDirection.addVectors(direction, obstacleAvoidance).normalize();
            
            // Move drone
            const speed = 0.1 * state.test.droneSpeed;
            state.drone.position.x += combinedDirection.x * speed;
            state.drone.position.y += combinedDirection.y * speed;
            state.drone.position.z += combinedDirection.z * speed;
            
            // Rotate drone to face direction of movement
            state.drone.lookAt(
                dronePosition.x + combinedDirection.x,
                dronePosition.y + combinedDirection.y,
                dronePosition.z + combinedDirection.z
            );
            
            // Check if drone passed through the gate
            const distanceToGate = dronePosition.distanceTo(targetPosition);
            if (distanceToGate < 2.5 && !targetGate.passed) {
                targetGate.passed = true;
                state.test.escapes++;
                
                // Visual feedback
                targetGate.mesh.material.emissive.setHex(0xFFFFFF);
                targetGate.light.intensity = 1.5;
                
                setTimeout(() => {
                    targetGate.mesh.material.emissive.setHex(0x00AA00);
                    targetGate.light.intensity = 0.5;
                }, 500);
                
                logMessage(`[TEST] Gate ${targetGate.number} passed!`, 'ok');
            }
        }

        // Update training UI
        function updateTrainingUI() {
            document.getElementById('train-progress-bar').style.width = `${state.training.progress}%`;
            document.getElementById('train-progress').textContent = `${state.training.progress.toFixed(1)}%`;
            document.getElementById('epoch').textContent = state.training.epoch;
            document.getElementById('loss').textContent = state.training.loss.toFixed(4);
            document.getElementById('accuracy').textContent = `${state.training.accuracy.toFixed(2)}%`;
            document.getElementById('active-nodes').textContent = state.training.activeNodes;
            document.getElementById('complexity').textContent = state.training.complexity;
            document.getElementById('response-time').textContent = `${state.training.responseTime}ms`;
            document.getElementById('training-cycles').textContent = state.training.cycles;
            document.getElementById('data-points').textContent = state.training.dataPoints;
            document.getElementById('memory-used').textContent = `${state.qnn.memoryUsed}MB`;
        }

        // Update training stats
        function updateTrainingStats() {
            document.getElementById('training-rounds').textContent = state.training.rounds + state.training.cycles;
            
            const totalMinutes = state.training.totalTime + Math.floor(state.training.cycles / 10);
            const hours = Math.floor(totalMinutes / 60);
            const minutes = totalMinutes % 60;
            document.getElementById('total-training-time').textContent = `${hours}h ${minutes}m`;
            
            document.getElementById('best-score').textContent = `${Math.max(state.training.bestScore, state.training.accuracy).toFixed(2)}%`;
        }

        // Update test UI
        function updateTestUI() {
            document.getElementById('test-progress-bar').style.width = `${state.test.progress}%`;
            document.getElementById('test-progress').textContent = `${state.test.progress.toFixed(1)}%`;
            document.getElementById('flight-time').textContent = `${state.test.flightTime.toFixed(1)}s`;
            document.getElementById('distance').textContent = `${Math.round(state.test.distance)}m`;
            document.getElementById('collisions').textContent = state.test.collisions;
            document.getElementById('test-speed').textContent = `${state.test.speed.toFixed(1)} km/h`;
            document.getElementById('test-status').textContent = state.test.status;
            document.getElementById('test-score').textContent = `${state.test.score.toFixed(1)}%`;
            document.getElementById('current-environment').textContent = state.environmentType.charAt(0).toUpperCase() + state.environmentType.slice(1);
            document.getElementById('escapes').textContent = state.test.escapes;
            
            // Update environment-specific metrics
            if (state.environmentType === 'forest') {
                document.getElementById('escapes-label').textContent = 'Escapes:';
                if (state.test.bestForestTime > 0) {
                    document.getElementById('test-status').textContent = `Running - Best: ${state.test.bestForestTime.toFixed(2)}s`;
                }
            } else {
                document.getElementById('escapes-label').textContent = 'Gates Passed:';
                if (state.test.bestCourseTime > 0) {
                    document.getElementById('test-status').textContent = `Running - Best: ${state.test.bestCourseTime.toFixed(2)}s`;
                }
            }
        }

        // Generate QNN grid
        function generateQNNGrid() {
            const grid = document.getElementById('qnn-grid');
            grid.innerHTML = '';
            
            for (let i = 0; i < 100; i++) {
                const cell = document.createElement('div');
                cell.className = 'qnn-cell';
                grid.appendChild(cell);
            }
            
            updateQNNGrid();
        }

        // Update QNN grid visualization
        function updateQNNGrid() {
            const cells = document.querySelectorAll('.qnn-cell');
            
            cells.forEach((cell, i) => {
                const row = Math.floor(i / 10);
                const col = i % 10;
                
                // Determine cell state based on training progress and parameters
                let stateClass = 'inactive';
                const activation = Math.random();
                
                if (state.training.running) {
                    if (activation < state.qnn.learningRate) {
                        stateClass = 'training';
                    } else if (activation < state.qnn.creativity) {
                        stateClass = 'active';
                    } else if (activation < 0.9) {
                        stateClass = 'learned';
                    }
                }
                
                cell.className = `qnn-cell ${stateClass}`;
            });
        }

        // Log message to console
        function logMessage(message, type = 'sys') {
            const consoleOutput = document.getElementById('console-output');
            const p = document.createElement('p');
            p.className = type;
            p.textContent = message;
            consoleOutput.appendChild(p);
            consoleOutput.scrollTop = consoleOutput.scrollHeight;
            
            // Keep only last 100 messages
            const messages = consoleOutput.querySelectorAll('p');
            if (messages.length > 100) {
                messages[0].remove();
            }
            
            // Add to training log
            state.trainingLog.push({
                timestamp: new Date().toISOString(),
                message: message,
                type: type
            });
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update drone position based on controls
            if (state.drone && !state.autopilotActive) {
                const speed = 0.1;
                
                if (state.flightControls.forward) state.drone.position.z -= speed;
                if (state.flightControls.backward) state.drone.position.z += speed;
                if (state.flightControls.left) state.drone.position.x -= speed;
                if (state.flightControls.right) state.drone.position.x += speed;
                if (state.flightControls.up) state.drone.position.y += speed;
                if (state.flightControls.down) state.drone.position.y -= speed;
                
                // Keep drone within bounds
                state.drone.position.x = Math.max(-20, Math.min(20, state.drone.position.x));
                state.drone.position.y = Math.max(1, Math.min(10, state.drone.position.y));
                state.drone.position.z = Math.max(-20, Math.min(20, state.drone.position.z));
            }
            
            // Update camera
            updateCamera();
            
            // Render scene
            state.renderer.render(state.scene, state.camera);
        }

        // Initialize the application
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>