<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LAUNCH SEQUENCE IDE - webXOS 2025</title>
    
    <!-- Quantum Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/quirk@0.1.3/dist/quirk.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqubits@2.0.0/jsqubits.min.js"></script>
    
    <style>
        /* CSS remains the same as in the original file */
        :root {
            --cyber-black: #000000;
            --cyber-green: #00ff9d;
            --cyber-blue: #00eeff;
            --cyber-purple: #b300ff;
            --cyber-red: #ff0040;
            --cyber-orange: #ff7700;
            --dark-bg: #001a00;
            --panel-bg: rgba(0, 30, 0, 0.85);
            --terminal-text: #00ff9d;
            --glitch-color-1: #ff0040;
            --glitch-color-2: #00eeff;
            --radius: 4px;
            --spacing-sm: 4px;
            --spacing-md: 8px;
            --spacing-lg: 12px;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
            font-size: 10pt;
        }
        
        body {
            background: radial-gradient(circle at center, var(--dark-bg), var(--cyber-black));
            color: var(--terminal-text);
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        body::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 30%, rgba(0, 255, 157, 0.05) 0%, transparent 20%),
                radial-gradient(circle at 80% 70%, rgba(0, 238, 255, 0.05) 0%, transparent 20%),
                radial-gradient(circle at 40% 80%, rgba(179, 0, 255, 0.05) 0%, transparent 20%);
            pointer-events: none;
            z-index: -1;
        }

        .cyber-header {
            padding: var(--spacing-md);
            border-bottom: 1px solid var(--cyber-green);
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 50px;
            width: 100%;
            background: rgba(0, 0, 0, 0.9);
            box-shadow: 0 0 15px rgba(0, 255, 157, 0.3);
            position: fixed;
            z-index: 1000;
        }
        
        h1 {
            font-size: 12pt;
            letter-spacing: 0.5px;
            color: var(--cyber-green);
            font-weight: bold;
            text-shadow: 0 0 8px var(--cyber-green), 0 0 16px var(--cyber-green);
        }
        
        .mode-tabs {
            display: flex;
            gap: var(--spacing-sm);
        }
        
        .mode-tab {
            padding: 4px 8px;
            background: var(--panel-bg);
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            cursor: pointer;
            font-size: 9pt;
            transition: all 0.3s ease;
            box-shadow: 0 0 5px currentColor;
        }
        
        .mode-tab:hover {
            box-shadow: 0 0 10px currentColor, 0 0 15px currentColor;
        }
        
        .mode-tab.active {
            background: var(--cyber-green);
            color: #000;
            box-shadow: 0 0 10px var(--cyber-green), 0 0 20px var(--cyber-green);
        }
        
        .header-controls {
            display: flex;
            gap: var(--spacing-sm);
            align-items: center;
        }
        
        .export-btn, .import-btn {
            padding: 4px 8px;
            background: var(--panel-bg);
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            cursor: pointer;
            font-size: 9pt;
            transition: all 0.3s ease;
            box-shadow: 0 0 5px currentColor;
            color: var(--terminal-text);
        }
        
        .export-btn:hover, .import-btn:hover {
            background: var(--cyber-green);
            color: #000;
            box-shadow: 0 0 10px var(--cyber-green), 0 0 15px var(--cyber-green);
        }
        
        main {
            display: flex;
            flex: 1;
            overflow: hidden;
            width: 100%;
            padding: var(--spacing-md);
            gap: var(--spacing-md);
            min-height: 0;
            margin-top: 60px;
            height: calc(100vh - 140px);
        }
        
        .cyber-panel {
            background: var(--panel-bg);
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            padding: var(--spacing-md);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 10px rgba(0, 255, 157, 0.2);
        }
        
        .left-panel, .right-panel {
            width: 280px;
        }
        
        .center-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
            min-height: 0;
        }
        
        .combat-arena-container {
            flex: 1;
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            overflow: hidden;
            position: relative;
            min-height: 0;
            background: var(--cyber-black);
            box-shadow: 0 0 15px rgba(0, 255, 157, 0.3);
        }

        #three-scene {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .scene-controls {
            position: absolute;
            bottom: 6px;
            left: 6px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            padding: 4px;
            z-index: 10;
            font-size: 8pt;
            box-shadow: 0 0 5px var(--cyber-green);
        }
        
        .qnn-overlay {
            position: absolute;
            top: 6px;
            right: 6px;
            width: 100px;
            height: 100px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            padding: 3px;
            z-index: 10;
            box-shadow: 0 0 5px var(--cyber-green);
        }
        
        .antifragility-overlay {
            position: absolute;
            top: 6px;
            left: 6px;
            width: 100px;
            height: 100px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            padding: 3px;
            z-index: 10;
            box-shadow: 0 0 5px var(--cyber-green);
        }
        
        .qnn-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 1px;
            width: 100%;
            height: 100%;
        }
        
        .qnn-cell {
            background: #000;
            border: 1px solid #008800;
            transition: all 0.3s ease;
        }
        
        .qnn-cell.active {
            background: var(--cyber-green);
            box-shadow: 0 0 3px var(--cyber-green);
        }
        
        .qnn-cell.training {
            background: #ffcc00;
            animation: pulse 1s infinite;
        }
        
        .qnn-cell.learned {
            background: #00cc00;
            box-shadow: 0 0 3px #00cc00;
        }
        
        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }

        .antifragility-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 1px;
            width: 100%;
            height: 100%;
            position: relative;
        }

        .antifragility-cell {
            background: #000;
            border: 1px solid #008800;
            transition: all 0.3s ease;
        }

        .antifragility-cell.stressed {
            background: var(--cyber-red);
            box-shadow: 0 0 3px var(--cyber-red);
        }

        .antifragility-cell.stable {
            background: var(--cyber-green);
            box-shadow: 0 0 3px var(--cyber-green);
        }

        .green-dot {
            position: absolute;
            width: 8px;
            height: 8px;
            background: var(--cyber-green);
            border-radius: 50%;
            border: 1px solid var(--cyber-blue);
            box-shadow: 0 0 5px var(--cyber-green), 0 0 10px var(--cyber-green);
            transition: all 0.2s ease;
        }
        
        .console-container {
            height: 180px;
            background: var(--panel-bg);
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            padding: var(--spacing-md);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 255, 157, 0.2);
        }
        
        .console-output {
            flex: 1;
            background: #000;
            border-radius: var(--radius);
            padding: var(--spacing-md);
            overflow-y: auto;
            font-size: 9pt;
            margin-bottom: var(--spacing-sm);
            border: 1px solid var(--cyber-green);
            position: relative;
        }
        
        .console-output p {
            margin: 2px 0;
        }
        
        .ok { color: #7dff7d; }
        .warn { color: #ffea7d; }
        .err { color: #ff7d7d; }
        .sys { color: #7dd9ff; }
        .muted { color: #aaaaaa; }
        .train-log { color: #ffcc00; }
        .perf { color: #ff00ff; }
        
        .console-input {
            display: flex;
            gap: var(--spacing-sm);
            flex-shrink: 0;
            height: 32px;
        }
        
        .input-line {
            flex: 1;
            background: #000;
            border: 1px solid var(--cyber-green);
            color: var(--terminal-text);
            padding: 6px 8px;
            border-radius: var(--radius);
            font-size: 9pt;
            box-shadow: 0 0 5px var(--cyber-green);
        }
        
        .input-send {
            padding: 6px 10px;
            border-radius: var(--radius);
            background: #000;
            border: 1px solid var(--cyber-green);
            color: var(--terminal-text);
            cursor: pointer;
            flex-shrink: 0;
            font-size: 9pt;
            transition: all 0.3s ease;
            box-shadow: 0 0 5px var(--cyber-green);
        }
        
        .input-send:hover {
            background: var(--cyber-green);
            color: #000;
            box-shadow: 0 0 10px var(--cyber-green), 0 0 15px var(--cyber-green);
        }
        
        .copy-log {
            position: absolute;
            top: 5px;
            right: 5px;
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            color: var(--cyber-green);
            cursor: pointer;
            font-size: 8pt;
            z-index: 5;
        }
        
        .copy-log:hover {
            background: var(--cyber-green);
            color: #000;
        }
        
        footer {
            padding: var(--spacing-md);
            border-top: 1px solid var(--cyber-green);
            text-align: center;
            font-size: 8pt;
            color: #008800;
            height: 32px;
            width: 100%;
            background: rgba(0, 0, 0, 0.8);
            flex-shrink: 0;
        }
        
        .btn {
            padding: 6px 8px;
            border-radius: var(--radius);
            border: 1px solid var(--cyber-green);
            background: #000;
            color: var(--terminal-text);
            cursor: pointer;
            margin: 2px 0;
            transition: all 0.3s ease;
            font-size: 9pt;
            box-shadow: 0 0 5px currentColor;
        }
        
        .btn:hover {
            background: var(--cyber-green);
            color: #000;
            box-shadow: 0 0 10px var(--cyber-green), 0 0 15px var(--cyber-green);
        }
        
        .btn-primary {
            background: var(--cyber-green);
            color: #000;
            box-shadow: 0 0 10px var(--cyber-green), 0 0 15px var(--cyber-green);
        }
        
        .metric {
            background: #000;
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            padding: 6px;
            text-align: center;
            margin: 3px 0;
            box-shadow: 0 0 5px var(--cyber-green);
        }
        
        .metric-val {
            font-size: 10pt;
            font-weight: bold;
            color: var(--cyber-green);
        }
        
        .slider-container {
            margin: 6px 0;
        }
        
        .slider-container label {
            display: block;
            margin-bottom: 3px;
            font-size: 9pt;
        }
        
        .mode-panel {
            display: none;
        }
        
        .mode-panel.active {
            display: block;
        }
        
        .progress-bar {
            height: 8px;
            background: #000;
            border: 1px solid var(--cyber-green);
            border-radius: 4px;
            overflow: hidden;
            margin: 3px 0;
        }
        
        .progress {
            height: 100%;
            background: var(--cyber-green);
            width: 0%;
            transition: width 0.3s ease;
        }

        .memory-control {
            background: #000;
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            padding: 6px;
            margin: 3px 0;
            font-size: 8pt;
            box-shadow: 0 0 5px var(--cyber-green);
        }

        .training-stats {
            background: #000;
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            padding: 6px;
            margin: 3px 0;
            font-size: 8pt;
            box-shadow: 0 0 5px var(--cyber-green);
        }

        .panel-section {
            margin-bottom: var(--spacing-md);
        }
        
        .panel-section h2 {
            font-size: 10pt;
            margin-bottom: var(--spacing-sm);
            border-bottom: 1px solid #008800;
            padding-bottom: 2px;
            text-shadow: 0 0 5px var(--cyber-green);
        }
        
        .compact-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-sm);
        }
        
        .compact-row {
            display: flex;
            justify-content: space-between;
            margin: 2px 0;
        }
        
        .compact-row label {
            font-size: 8pt;
        }
        
        .compact-row span {
            font-size: 9pt;
            font-weight: bold;
            color: var(--cyber-green);
        }
        
        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-sm);
        }
        
        .btn-group-vertical {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-md);
        }
        
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #000;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--cyber-green);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--cyber-blue);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--panel-bg);
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            padding: var(--spacing-md);
            width: 400px;
            max-width: 90%;
            box-shadow: 0 0 20px var(--cyber-green);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--cyber-green);
            padding-bottom: var(--spacing-sm);
        }

        .modal-title {
            font-size: 12pt;
            color: var(--cyber-green);
            text-shadow: 0 0 5px var(--cyber-green);
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--cyber-green);
            font-size: 14pt;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-body {
            margin-bottom: var(--spacing-md);
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: var(--spacing-sm);
        }

        .file-input {
            display: none;
        }

        .file-label {
            display: block;
            padding: var(--spacing-md);
            border: 1px dashed var(--cyber-green);
            border-radius: var(--radius);
            text-align: center;
            cursor: pointer;
            margin-bottom: var(--spacing-md);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .file-label:hover {
            background: rgba(0, 255, 157, 0.1);
            box-shadow: 0 0 10px var(--cyber-green);
        }

        .file-label input[type="file"] {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .status-exporting {
            background: #ffcc00;
            animation: pulse 1s infinite;
        }

        .status-success {
            background: #00cc00;
        }

        .status-error {
            background: #ff0040;
        }
        
        .error-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: var(--radius);
            border: 2px solid var(--cyber-red);
            text-align: center;
            z-index: 100;
            font-size: 14pt;
            box-shadow: 0 0 20px var(--cyber-red);
            display: none;
        }
        
        .architecture-selector {
            margin-bottom: var(--spacing-md);
        }
        
        .architecture-selector select {
            width: 100%;
            background: #000;
            color: var(--cyber-green);
            border: 1px solid var(--cyber-green);
            padding: 6px 8px;
            border-radius: var(--radius);
            font-size: 9pt;
        }

        /* Camera mode indicator */
        .camera-mode {
            position: absolute;
            bottom: 6px;
            right: 6px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            padding: 4px 8px;
            z-index: 10;
            font-size: 8pt;
            box-shadow: 0 0 5px var(--cyber-green);
        }
    </style>
</head>
<body>
    <header class="cyber-header">
        <h1>LAUNCH SEQUENCE IDE - WEBXOS 2025</h1>
        <div class="mode-tabs">
            <div class="mode-tab active" data-mode="train">TRAIN</div>
            <div class="mode-tab" data-mode="test">TEST</div>
        </div>
        <div class="header-controls">
            <button class="export-btn" id="header-export">EXPORT</button>
            <button class="import-btn" id="header-import">IMPORT</button>
        </div>
    </header>
    
    <main>
        <div class="left-panel cyber-panel">
            <div class="mode-panel active" id="train-panel">
                <div class="panel-section">
                    <h2>Training Actions</h2>
                    <div class="btn-group-vertical">
                        <button class="btn btn-primary" id="start-train">Start Quantum Training</button>
                        <div class="btn-group">
                            <button class="btn" id="stop-train">Pause</button>
                            <button class="btn" id="reset-train">Reset</button>
                        </div>
                    </div>
                </div>
                
                <div class="panel-section">
                    <h2>QNN Architecture</h2>
                    <div class="architecture-selector">
                        <select id="network-architecture">
                            <option value="qnn">Quantum Neural Network</option>
                            <option value="hybrid">Hybrid Quantum-Classical</option>
                        </select>
                    </div>
                </div>
                
                <div class="panel-section">
                    <h2>Quantum Controls</h2>
                    
                    <div class="slider-container">
                        <div class="compact-row">
                            <label>Learning Rate:</label>
                            <span id="learning-rate-value">0.10</span>
                        </div>
                        <input type="range" id="learning-rate" min="0.01" max="1.0" step="0.01" value="0.1" style="width:100%">
                    </div>
                    
                    <div class="slider-container">
                        <div class="compact-row">
                            <label>Creativity:</label>
                            <span id="creativity-value">0.70</span>
                        </div>
                        <input type="range" id="creativity" min="0.0" max="1.0" step="0.01" value="0.7" style="width:100%">
                    </div>

                    <div class="slider-container">
                        <div class="compact-row">
                            <label>Qubits:</label>
                            <span id="qubits-value">2</span>
                        </div>
                        <input type="range" id="qubits" min="2" max="8" step="1" value="2" style="width:100%">
                    </div>

                    <div class="memory-control">
                        <div class="compact-row">
                            <label>Training Memory:</label>
                            <span id="memory-usage">128MB</span>
                        </div>
                        <input type="range" id="memory-limit" min="1" max="4096" step="1" value="128" style="width:100%">
                    </div>
                </div>
                
                <div class="panel-section">
                    <h2>Quantum Circuit</h2>
                    <div class="slider-container">
                        <div class="compact-row">
                            <label>Entanglement:</label>
                            <span id="entanglement-value">0.75</span>
                        </div>
                        <input type="range" id="entanglement" min="0.0" max="1.0" step="0.01" value="0.75" style="width:100%">
                    </div>
                    <div class="slider-container">
                        <div class="compact-row">
                            <label>Quantum Depth:</label>
                            <span id="quantum-depth-value">3</span>
                        </div>
                        <input type="range" id="quantum-depth" min="1" max="10" step="1" value="3" style="width:100%">
                    </div>
                </div>
            </div>
            
            <div class="mode-panel" id="test-panel">
                <div class="panel-section">
                    <h2>Test Actions</h2>
                    <div class="btn-group-vertical">
                        <button class="btn btn-primary" id="autopilot-test">START RESCUE TEST</button>
                        <button class="btn" id="test-stop">STOP TEST</button>
                        <button class="btn" id="new-course">NEW ENVIRONMENT</button>
                    </div>
                </div>
                
                <div class="panel-section">
                    <h2>Drone Configuration</h2>
                    <div class="slider-container">
                        <div class="compact-row">
                            <label>Drone Speed:</label>
                            <span id="drone-speed-value">1.0x</span>
                        </div>
                        <input type="range" id="drone-speed" min="0" max="3" step="0.1" value="1.0" style="width:100%">
                    </div>
                    
                    <div class="slider-container">
                        <div class="compact-row">
                            <label>Environment Complexity:</label>
                            <span id="complexity-value">0.50</span>
                        </div>
                        <input type="range" id="environment-complexity" min="0.0" max="1.0" step="0.01" value="0.5" style="width:100%">
                    </div>
                </div>

                <div class="panel-section">
                    <h2>Camera Controls</h2>
                    <div class="btn-group-vertical">
                        <button class="btn" id="camera-follow">FOLLOW DRONE</button>
                        <button class="btn" id="camera-orbit">ORBIT VIEW</button>
                        <button class="btn" id="camera-reset">RESET CAMERA</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="center-panel">
            <div class="combat-arena-container" id="scene-container">
                <div id="three-scene"></div>
                <div class="error-overlay" id="error-overlay">SCENE LOADING...</div>
                <div class="scene-controls">
                    <div>Mouse: Drag to rotate | Wheel: Zoom</div>
                </div>
                <div class="camera-mode" id="camera-mode">CAMERA: ORBIT</div>
                <div class="qnn-overlay">
                    <div class="qnn-grid" id="qnn-grid"></div>
                </div>
                <div class="antifragility-overlay">
                    <div class="antifragility-grid" id="antifragility-grid"></div>
                </div>
            </div>
            <div class="console-container">
                <div class="console-output" id="console-output">
                    <p class="sys">[SYSTEM] LAUNCH SEQUENCE IDE initialized</p>
                    <p class="sys">[SYSTEM] Quantum Training backend active</p>
                    <p class="sys">[SYSTEM] 3D Scene rendering initialized</p>
                    <p class="sys">[SYSTEM] Service Workers: Train & Test agents online</p>
                </div>
                <button class="copy-log" id="copy-log">COPY LOG</button>
                <div class="console-input">
                    <input type="text" class="input-line" id="console-input" placeholder="Type commands...">
                    <button class="input-send" id="console-send">SEND</button>
                </div>
            </div>
        </div>
        
        <div class="right-panel cyber-panel">
            <div class="mode-panel active" id="train-right-panel">
                <div class="panel-section">
                    <h2>Training Status</h2>
                    <div class="training-stats">
                        <div class="compact-row">
                            <label>Training Rounds:</label>
                            <span id="training-rounds">0</span>
                        </div>
                        <div class="compact-row">
                            <label>Total Time:</label>
                            <span id="total-training-time">0h 0m</span>
                        </div>
                        <div class="compact-row">
                            <label>Best Score:</label>
                            <span id="best-score">0.0%</span>
                        </div>
                    </div>
                    
                    <div class="progress-bar">
                        <div class="progress" id="train-progress-bar" style="width: 0%"></div>
                    </div>
                    <div class="compact-row">
                        <label>Training Progress:</label>
                        <span id="train-progress">0%</span>
                    </div>
                    
                    <div class="metrics-grid">
                        <div class="metric">
                            <div class="metric-val" id="accuracy">0%</div>
                            <div>Accuracy</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="active-nodes">0</div>
                            <div>Active Nodes</div>
                        </div>
                    </div>
                </div>
                
                <div class="panel-section">
                    <h2>Quantum State</h2>
                    <div class="metrics-grid">
                        <div class="metric">
                            <div class="metric-val" id="quantum-state">|00⟩</div>
                            <div>Qubit State</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="quantum-fidelity">0.00</div>
                            <div>Fidelity</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="quantum-entropy">0.00</div>
                            <div>Entropy</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="quantum-speed">0</div>
                            <div>Q.Ops/sec</div>
                        </div>
                    </div>
                </div>
                
                <div class="panel-section">
                    <h2>Training Metrics</h2>
                    <div class="metric">
                        <div>Model: <input type="text" id="model-name" placeholder="QNN_Model" style="background: #000; color: var(--cyber-green); border: 1px solid #008800; padding: 4px; width: 100%; font-size: 9pt;"></div>
                    </div>
                    
                    <div class="metrics-grid">
                        <div class="metric">
                            <div class="metric-val" id="epoch">0</div>
                            <div>Epoch</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="loss">0.00</div>
                            <div>Loss</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="complexity">Low</div>
                            <div>Complexity</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="response-time">0ms</div>
                            <div>Response Time</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="robustness-score">0%</div>
                            <div>Robustness</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="stress-response">0.00</div>
                            <div>Stress Response</div>
                        </div>
                    </div>
                    
                    <div class="training-stats">
                        <div class="compact-row">
                            <label>Training Cycles:</label>
                            <span id="training-cycles">0</span>
                        </div>
                        <div class="compact-row">
                            <label>Data Points:</label>
                            <span id="data-points">0</span>
                        </div>
                        <div class="compact-row">
                            <label>Memory Used:</label>
                            <span id="memory-used">0MB</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="mode-panel" id="test-right-panel">
                <div class="panel-section">
                    <h2>Rescue Test Status</h2>
                    <div class="training-stats">
                        <div class="compact-row">
                            <label>Test Status:</label>
                            <span id="test-status">Ready</span>
                        </div>
                        <div class="compact-row">
                            <label>Test Score:</label>
                            <span id="test-score">0%</span>
                        </div>
                        <div class="compact-row">
                            <label>Environment:</label>
                            <span id="current-environment">Quantum Forest</span>
                        </div>
                        <div class="compact-row">
                            <label>Objects Collected:</label>
                            <span id="objects-collected">0/3</span>
                        </div>
                    </div>
                    
                    <div class="metrics-grid">
                        <div class="metric">
                            <div class="metric-val" id="flight-time">0s</div>
                            <div>Flight Time</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="distance">0m</div>
                            <div>Distance</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="collisions">0</div>
                            <div>Collisions</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="test-speed">0 km/h</div>
                            <div>Speed</div>
                        </div>
                    </div>
                    
                    <div class="progress-bar">
                        <div class="progress" id="test-progress-bar" style="width: 0%"></div>
                    </div>
                    <div class="compact-row">
                        <label>Mission Progress:</label>
                        <span id="test-progress">0%</span>
                    </div>
                </div>
                
                <div class="panel-section">
                    <h2>Quantum Navigation</h2>
                    <div class="metrics-grid">
                        <div class="metric">
                            <div class="metric-val" id="quantum-path">Optimal</div>
                            <div>Pathfinding</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="quantum-collision">0.00</div>
                            <div>Collision Risk</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="quantum-efficiency">0%</div>
                            <div>Efficiency</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="quantum-decisions">0</div>
                            <div>Q.Decisions</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>
    
    <footer>
        WEBXOS 2025 | LAUNCH SEQUENCE IDE v2.0 | Quantum Training | 3D Simulation | Service Workers Active
    </footer>

    <!-- Modals -->
    <div class="modal" id="import-modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Import QNN Model</div>
                <button class="modal-close" id="import-close">&times;</button>
            </div>
            <div class="modal-body">
                <label class="file-label" id="import-drop-area">
                    <span>Drop JSON file here or click to browse</span>
                    <input type="file" id="import-file" class="file-input" accept=".json">
                </label>
                <div id="import-status">
                    <span class="status-indicator" id="import-status-indicator"></span>
                    <span id="import-status-text">Ready to import QNN weights</span>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="import-cancel">Cancel</button>
                <button class="btn btn-primary" id="import-confirm" disabled>Import QNN</button>
            </div>
        </div>
    </div>

    <div class="modal" id="export-modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Export QNN Model</div>
                <button class="modal-close" id="export-close">&times;</button>
            </div>
            <div class="modal-body">
                <div class="compact-row">
                    <label>Model Name:</label>
                    <input type="text" id="export-model-name" value="QNN_Model" style="background: #000; color: var(--cyber-green); border: 1px solid #008800; padding: 4px; width: 60%; font-size: 9pt;">
                </div>
                <div class="compact-row">
                    <label>Data Size:</label>
                    <span id="export-data-size">0 KB</span>
                </div>
                <div id="export-status">
                    <span class="status-indicator" id="export-status-indicator"></span>
                    <span id="export-status-text">Ready to export quantum weights</span>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="export-cancel">Cancel</button>
                <button class="btn btn-primary" id="export-confirm">Export QNN</button>
            </div>
        </div>
    </div>

    <script>
        // Enhanced global state with Q.js integration
        const state = {
            currentMode: 'train',
            training: {
                running: false,
                endless: false,
                progress: 0,
                epoch: 0,
                loss: 2.5,
                accuracy: 0,
                activeNodes: 0,
                responseTime: 0,
                complexity: 'Low',
                rounds: 0,
                totalTime: 0,
                bestScore: 0,
                cycles: 0,
                dataPoints: 0,
                networkArchitecture: 'qnn'
            },
            test: {
                mode: 'search_rescue',
                flightTime: 0,
                distance: 0,
                collisions: 0,
                speed: 0,
                progress: 0,
                score: 0,
                environment: 'Quantum Forest',
                objectsCollected: 0,
                totalObjects: 3,
                status: 'Ready',
                autopilotActive: false,
                startTime: 0,
                startPosition: null,
                missionComplete: false,
                droneSpeed: 1.0,
                environmentComplexity: 0.5
            },
            qnn: {
                learningRate: 0.1,
                creativity: 0.7,
                memoryLimit: 128,
                memoryUsed: 0,
                robustnessScore: 0,
                stressResponse: 0,
                weights: {}
            },
            quantum: {
                circuit: null,
                entanglement: 0.75,
                depth: 3,
                qubits: 2,
                state: '|00⟩',
                fidelity: 0,
                entropy: 0,
                speed: 0
            },
            // Three.js scene state
            scene: null,
            camera: null,
            renderer: null,
            controls: null,
            drone: null,
            objects: [],
            trees: [],
            collectibles: [],
            obstacles: [],
            targetDirection: null,
            lastDirectionChange: 0,
            directionChangeInterval: 2000,
            escapeBoundary: 40,
            // Camera state
            cameraMode: 'orbit', // 'orbit' or 'follow'
            cameraDistance: 15,
            cameraAngle: 0,
            cameraHeight: 5,
            // Service workers state
            serviceWorkers: {
                train: null,
                test: null
            },
            trainingInterval: null,
            testInterval: null,
            trainingLog: [],
            startTime: 0
        };

        // Service Worker for Training (Quantum Agent)
        class TrainServiceWorker {
            constructor() {
                this.initialized = false;
                this.trainingData = {};
            }

            async initialize() {
                this.initialized = true;
                return { status: 'ready', type: 'qnn_training' };
            }

            startTraining(config) {
                this.trainingData = {
                    startTime: Date.now(),
                    cycles: 0,
                    metrics: {}
                };
                return { status: 'training_started', config };
            }

            updateMetrics(quantumResult) {
                this.trainingData.cycles++;
                this.trainingData.metrics = {
                    accuracy: Math.min(95, (quantumResult.entanglement * 100)),
                    loss: Math.max(0.01, 2.5 - (quantumResult.entanglement * 2)),
                    progress: Math.min(100, quantumResult.entanglement * 100),
                    activeNodes: Math.floor(10 + quantumResult.entanglement * 90)
                };
                return this.trainingData.metrics;
            }

            getWeights() {
                return {
                    quantum_weights: this.trainingData.metrics,
                    classical_weights: {
                        learning_rate: state.qnn.learningRate,
                        creativity: state.qnn.creativity,
                        architecture: state.training.networkArchitecture
                    },
                    timestamp: Date.now()
                };
            }

            stopTraining() {
                const trainingTime = Date.now() - this.trainingData.startTime;
                return {
                    status: 'training_completed',
                    duration: trainingTime,
                    final_metrics: this.trainingData.metrics
                };
            }
        }

        // Service Worker for Test (Three.js Agent)
        class TestServiceWorker {
            constructor() {
                this.initialized = false;
                this.testData = {};
            }

            async initialize() {
                this.initialized = true;
                return { status: 'ready', type: '3d_testing' };
            }

            startTest(config) {
                this.testData = {
                    startTime: Date.now(),
                    objectsCollected: 0,
                    collisions: 0,
                    distance: 0
                };
                return { status: 'test_started', config };
            }

            updateNavigation(quantumState) {
                // Use quantum state for navigation decisions
                const efficiency = quantumState.fidelity * 100;
                const collisionRisk = Math.max(0.01, 0.1 - (quantumState.entanglement * 0.08));
                
                this.testData.efficiency = efficiency;
                this.testData.collisionRisk = collisionRisk;
                
                return {
                    efficiency: efficiency,
                    collisionRisk: collisionRisk,
                    pathfinding: quantumState.entanglement > 0.7 ? 'Optimal' : 'Standard'
                };
            }

            collectObject() {
                this.testData.objectsCollected++;
                return {
                    collected: this.testData.objectsCollected,
                    progress: (this.testData.objectsCollected / state.test.totalObjects) * 100
                };
            }

            recordCollision() {
                this.testData.collisions++;
                return this.testData.collisions;
            }

            getTestResults() {
                const testTime = Date.now() - this.testData.startTime;
                return {
                    score: Math.min(100, (this.testData.objectsCollected / state.test.totalObjects) * 100),
                    duration: testTime,
                    collisions: this.testData.collisions,
                    efficiency: this.testData.efficiency || 0
                };
            }
        }

        // Initialize the application
        function init() {
            setupEventListeners();
            initServiceWorkers();
            initThreeJSScene();
            generateQNNGrid();
            generateAntifragilityGrid();
            updateTrainingUI();
            
            logMessage('[SYSTEM] LAUNCH SEQUENCE IDE initialized', 'sys');
            logMessage('[QUANTUM] Quantum simulation ready', 'sys');
            logMessage('[Three.js] 3D scene active', 'sys');
            logMessage('[WORKERS] Train & Test agents online', 'sys');
        }

        // Initialize Service Workers
        async function initServiceWorkers() {
            state.serviceWorkers.train = new TrainServiceWorker();
            state.serviceWorkers.test = new TestServiceWorker();
            
            await state.serviceWorkers.train.initialize();
            await state.serviceWorkers.test.initialize();
            
            logMessage('[WORKER] Quantum Training Agent ready', 'ok');
            logMessage('[WORKER] Three.js Test Agent ready', 'ok');
        }

        // Initialize Three.js Scene with Forest Environment
        function initThreeJSScene() {
            try {
                const container = document.getElementById('three-scene');
                const width = container.clientWidth;
                const height = container.clientHeight;

                // Create scene
                state.scene = new THREE.Scene();
                state.scene.background = new THREE.Color(0x001100);
                state.scene.fog = new THREE.Fog(0x001100, 10, 50);

                // Create camera
                state.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
                state.camera.position.set(0, 15, 25);

                // Create renderer
                state.renderer = new THREE.WebGLRenderer({ antialias: true });
                state.renderer.setSize(width, height);
                state.renderer.shadowMap.enabled = true;
                state.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                container.appendChild(state.renderer.domElement);

                // Add lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                state.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 20, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 50;
                state.scene.add(directionalLight);

                // Create forest ground
                const groundGeometry = new THREE.PlaneGeometry(80, 80);
                const groundMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x003300,
                    shininess: 30
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                state.scene.add(ground);

                // Create grid helper
                const gridHelper = new THREE.GridHelper(80, 80, 0x00ff00, 0x004400);
                gridHelper.position.y = 0.01;
                state.scene.add(gridHelper);

                // Create drone
                createEnhancedDrone();

                // Create forest environment
                generateForest();
                
                // Create triangle drones for rescue mission
                createTriangleDrones();

                // Add OrbitControls for camera
                state.controls = new THREE.OrbitControls(state.camera, state.renderer.domElement);
                state.controls.enableDamping = true;
                state.controls.dampingFactor = 0.05;
                state.controls.target.set(0, 2, 0);

                // Handle window resize
                window.addEventListener('resize', onWindowResize);

                // Start animation loop
                animate();

                document.getElementById('error-overlay').style.display = 'none';
                logMessage('[3D] Forest scene initialized successfully', 'ok');

            } catch (error) {
                console.error('3D Scene Error:', error);
                logMessage(`[ERROR] 3D Scene: ${error.message}`, 'err');
                document.getElementById('error-overlay').style.display = 'block';
                document.getElementById('error-overlay').textContent = `3D Error: ${error.message}`;
            }
        }

        // Window resize handler
        function onWindowResize() {
            if (!state.camera || !state.renderer) return;
            
            const container = document.getElementById('three-scene');
            state.camera.aspect = container.clientWidth / container.clientHeight;
            state.camera.updateProjectionMatrix();
            state.renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // Create enhanced drone
        function createEnhancedDrone() {
            const droneGroup = new THREE.Group();
            
            // Drone body
            const bodyGeometry = new THREE.BoxGeometry(1, 0.2, 1);
            const bodyMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x00ff00,
                emissive: 0x004400
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            droneGroup.add(body);

            // Drone arms
            const armGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.8, 8);
            const armMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
            
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI / 2);
                const arm = new THREE.Mesh(armGeometry, armMaterial);
                arm.rotation.x = Math.PI / 2;
                arm.position.x = Math.cos(angle) * 0.6;
                arm.position.y = 0.1;
                arm.position.z = Math.sin(angle) * 0.6;
                arm.castShadow = true;
                droneGroup.add(arm);
                
                // Rotors
                const rotorGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.05, 16);
                const rotorMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
                const rotor = new THREE.Mesh(rotorGeometry, rotorMaterial);
                rotor.position.x = Math.cos(angle) * 0.6;
                rotor.position.y = 0.2;
                rotor.position.z = Math.sin(angle) * 0.6;
                rotor.castShadow = true;
                droneGroup.add(rotor);
            }
            
            // Position drone
            droneGroup.position.set(0, 2, 0);
            droneGroup.castShadow = true;
            state.scene.add(droneGroup);
            state.drone = droneGroup;
        }

        // Generate forest environment
        function generateForest() {
            // Clear existing trees and obstacles
            state.trees.forEach(tree => {
                if (tree && tree.parent) {
                    state.scene.remove(tree);
                }
            });
            state.trees = [];
            state.obstacles = [];

            // Generate trees based on environment complexity
            const treeCount = 30 + Math.floor(state.test.environmentComplexity * 50);
            
            for (let i = 0; i < treeCount; i++) {
                const tree = createTree();
                
                // Random position within bounds
                let validPosition = false;
                let attempts = 0;
                
                while (!validPosition && attempts < 50) {
                    tree.position.x = (Math.random() - 0.5) * 70;
                    tree.position.z = (Math.random() - 0.5) * 70;
                    
                    // Avoid center area
                    const distanceFromCenter = Math.sqrt(tree.position.x * tree.position.x + tree.position.z * tree.position.z);
                    if (distanceFromCenter < 8) {
                        attempts++;
                        continue;
                    }
                    
                    // Check distance from other trees
                    let tooClose = false;
                    for (const existingTree of state.trees) {
                        const distance = Math.sqrt(
                            Math.pow(tree.position.x - existingTree.position.x, 2) + 
                            Math.pow(tree.position.z - existingTree.position.z, 2)
                        );
                        if (distance < 3) {
                            tooClose = true;
                            break;
                        }
                    }
                    
                    validPosition = !tooClose;
                    attempts++;
                }
                
                if (validPosition) {
                    tree.position.y = 0;
                    state.scene.add(tree);
                    state.trees.push(tree);
                    state.obstacles.push(tree);
                }
            }
            
            logMessage(`[FOREST] Generated ${state.trees.length} trees`, 'ok');
        }

        // Create individual tree
        function createTree() {
            const treeGroup = new THREE.Group();
            
            const height = 3 + Math.random() * 4;
            const trunkRadius = 0.2 + Math.random() * 0.3;
            
            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(trunkRadius, trunkRadius * 1.2, height, 8);
            const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = height / 2;
            trunk.castShadow = true;
            treeGroup.add(trunk);
            
            // Canopy
            const canopySize = 1.5 + Math.random() * 1.5;
            const canopyGeometry = new THREE.ConeGeometry(canopySize, height / 1.5, 8);
            const canopyMaterial = new THREE.MeshPhongMaterial({ color: 0x228B22 });
            const canopy = new THREE.Mesh(canopyGeometry, canopyMaterial);
            canopy.position.y = height + canopySize / 2;
            canopy.castShadow = true;
            treeGroup.add(canopy);
            
            return treeGroup;
        }

        // Create triangle drones for rescue mission
        function createTriangleDrones() {
            // Clear existing collectibles
            state.collectibles.forEach(obj => {
                if (obj && obj.parent) {
                    state.scene.remove(obj);
                }
            });
            state.collectibles = [];
            
            const colors = [0xff0000, 0x00ff00, 0x0000ff];
            
            for (let i = 0; i < 3; i++) {
                const triangleGeometry = new THREE.ConeGeometry(0.8, 1.5, 3);
                const triangleMaterial = new THREE.MeshPhongMaterial({ 
                    color: colors[i],
                    emissive: colors[i],
                    emissiveIntensity: 0.3
                });
                const triangle = new THREE.Mesh(triangleGeometry, triangleMaterial);
                triangle.rotation.x = Math.PI / 2;
                
                let validPosition = false;
                let attempts = 0;
                
                while (!validPosition && attempts < 50) {
                    triangle.position.x = (Math.random() - 0.5) * 60;
                    triangle.position.z = (Math.random() - 0.5) * 60;
                    triangle.position.y = 1;
                    
                    // Avoid center area
                    const distanceFromCenter = Math.sqrt(triangle.position.x * triangle.position.x + triangle.position.z * triangle.position.z);
                    if (distanceFromCenter < 10) {
                        attempts++;
                        continue;
                    }
                    
                    // Check distance from obstacles
                    let tooClose = false;
                    for (const obstacle of state.obstacles) {
                        const distance = Math.sqrt(
                            Math.pow(triangle.position.x - obstacle.position.x, 2) + 
                            Math.pow(triangle.position.z - obstacle.position.z, 2)
                        );
                        if (distance < 4) {
                            tooClose = true;
                            break;
                        }
                    }
                    
                    // Check distance from other collectibles
                    for (const collectible of state.collectibles) {
                        const distance = Math.sqrt(
                            Math.pow(triangle.position.x - collectible.position.x, 2) + 
                            Math.pow(triangle.position.z - collectible.position.z, 2)
                        );
                        if (distance < 8) {
                            tooClose = true;
                            break;
                        }
                    }
                    
                    validPosition = !tooClose;
                    attempts++;
                }
                
                if (validPosition) {
                    triangle.castShadow = true;
                    state.scene.add(triangle);
                    state.collectibles.push(triangle);
                    
                    // Add pulsing light
                    const light = new THREE.PointLight(colors[i], 0.5, 5);
                    light.position.copy(triangle.position);
                    state.scene.add(light);
                }
            }
            
            logMessage(`[RESCUE] ${state.collectibles.length} triangle drones placed for rescue mission`, 'ok');
        }

        // Update camera to follow drone
        function updateFollowCamera() {
            if (!state.drone || state.cameraMode !== 'follow') return;
            
            const dronePosition = state.drone.position.clone();
            const droneRotation = state.drone.rotation.y;
            
            // Calculate camera position behind and above the drone
            const offset = new THREE.Vector3(
                Math.sin(droneRotation) * state.cameraDistance,
                state.cameraHeight,
                Math.cos(droneRotation) * state.cameraDistance
            );
            
            const targetPosition = dronePosition.clone().add(offset);
            
            // Smooth camera movement
            state.camera.position.lerp(targetPosition, 0.1);
            state.camera.lookAt(dronePosition);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update controls for orbit mode
            if (state.cameraMode === 'orbit' && state.controls) {
                state.controls.update();
            }
            
            // Update follow camera for follow mode
            if (state.cameraMode === 'follow') {
                updateFollowCamera();
            }
            
            // Update drone animation
            if (state.drone) {
                // Simple hover animation
                state.drone.position.y = 2 + Math.sin(Date.now() * 0.002) * 0.1;
                state.drone.rotation.y += 0.01;
                
                // Rotor animation
                state.drone.children.forEach((child, index) => {
                    if (index > 4) { // Rotors start from index 5
                        child.rotation.y += 0.2;
                    }
                });
            }
            
            // Update triangle drones animation
            state.collectibles.forEach((triangle, index) => {
                if (triangle && triangle.position) {
                    triangle.rotation.y += 0.02;
                    triangle.position.y = 1 + Math.sin(Date.now() * 0.002 + index) * 0.2;
                }
            });
            
            if (state.renderer && state.scene && state.camera) {
                state.renderer.render(state.scene, state.camera);
            }
        }

        // Set camera mode
        function setCameraMode(mode) {
            state.cameraMode = mode;
            
            if (state.controls) {
                state.controls.enabled = (mode === 'orbit');
            }
            
            document.getElementById('camera-mode').textContent = `CAMERA: ${mode.toUpperCase()}`;
            
            if (mode === 'follow' && state.drone) {
                // Set initial camera position for follow mode
                state.cameraDistance = 15;
                state.cameraHeight = 5;
                updateFollowCamera();
            }
            
            logMessage(`[CAMERA] Switched to ${mode} mode`, 'sys');
        }

        // Reset camera to default position
        function resetCamera() {
            if (state.cameraMode === 'orbit') {
                state.camera.position.set(0, 15, 25);
                if (state.controls) {
                    state.controls.target.set(0, 2, 0);
                    state.controls.update();
                }
            } else {
                setCameraMode('follow');
            }
            logMessage('[CAMERA] Camera reset', 'sys');
        }

        // Quantum Training Functions
        function startTraining() {
            if (state.training.running) return;
            
            state.training.running = true;
            state.startTime = Date.now();
            
            // Start service worker training
            state.serviceWorkers.train.startTraining({
                qubits: state.quantum.qubits,
                depth: state.quantum.depth,
                learningRate: state.qnn.learningRate
            });
            
            state.trainingInterval = setInterval(updateTraining, 100);
            
            document.getElementById('start-train').textContent = 'Training...';
            document.getElementById('start-train').classList.add('active');
            
            logMessage('[TRAINING] Quantum training started', 'train-log');
        }

        function updateTraining() {
            if (!state.training.running) return;
            
            state.training.cycles++;
            state.training.rounds++;
            state.training.epoch = Math.floor(state.training.rounds / 1000);

            try {
                // Simulate quantum circuit operations using jsqubits
                const numQubits = state.quantum.qubits;
                let qState = jsqubits("|0>").tensor(numQubits);
                
                // Apply Hadamard gates to create superposition
                for (let i = 0; i < numQubits; i++) {
                    qState = qState.hadamard(i);
                }
                
                // Apply entanglement based on depth
                for (let i = 0; i < state.quantum.depth; i++) {
                    for (let j = 0; j < numQubits - 1; j++) {
                        qState = qState.cnot(j, j + 1);
                    }
                }
                
                // Measure and get probabilities
                const probabilities = {};
                for (let i = 0; i < Math.pow(2, numQubits); i++) {
                    const basisState = i.toString(2).padStart(numQubits, '0');
                    probabilities[basisState] = Math.pow(qState.measure(basisState).magnitude, 2);
                }
                
                // Calculate entanglement probability (probability of |00...0⟩ and |11...1⟩)
                const allZeros = '0'.repeat(numQubits);
                const allOnes = '1'.repeat(numQubits);
                const entanglementProb = (probabilities[allZeros] || 0) + (probabilities[allOnes] || 0);
                
                // Update training metrics using service worker
                const metrics = state.serviceWorkers.train.updateMetrics({
                    entanglement: entanglementProb,
                    depth: state.quantum.depth,
                    qubits: state.quantum.qubits
                });
                
                state.training.progress = metrics.progress;
                state.training.accuracy = metrics.accuracy;
                state.training.loss = metrics.loss;
                state.training.activeNodes = metrics.activeNodes;
                state.training.responseTime = Math.max(5, 100 - state.training.accuracy);
                
                // Update quantum state
                const maxProbState = Object.keys(probabilities).reduce((a, b) => 
                    probabilities[a] > probabilities[b] ? a : b
                );
                state.quantum.state = `|${maxProbState}⟩`;
                state.quantum.fidelity = entanglementProb;
                state.quantum.entropy = 1 - entanglementProb;
                state.quantum.speed = state.training.cycles % 100;

            } catch (error) {
                // Fallback to simple simulation if quantum library fails
                state.training.progress = Math.min(100, state.training.progress + 0.5);
                state.training.accuracy = Math.min(95, state.training.accuracy + 0.3);
                state.training.loss = Math.max(0.01, state.training.loss * 0.995);
                state.training.activeNodes = Math.floor(10 + state.qnn.creativity * 90);
                state.training.responseTime = Math.max(5, 100 - state.training.accuracy);
                
                state.quantum.fidelity = Math.min(1, state.quantum.fidelity + 0.01);
                state.quantum.entropy = Math.max(0, state.quantum.entropy - 0.005);
                state.quantum.speed = state.training.cycles % 100;
                
                if (state.training.cycles % 10 === 0) {
                    logMessage('[TRAINING] Using simulation mode - quantum libraries not available', 'warn');
                }
            }

            updateQNNGrid();
            updateTrainingUI();
            updateQuantumUI();

            if (state.training.cycles % 50 === 0) {
                saveTrainingData();
            }
        }

        function stopTraining() {
            state.training.running = false;
            clearInterval(state.trainingInterval);
            
            const results = state.serviceWorkers.train.stopTraining();
            document.getElementById('start-train').textContent = 'Start Quantum Training';
            document.getElementById('start-train').classList.remove('active');
            
            logMessage(`[TRAINING] Paused - ${state.training.cycles} cycles completed`, 'warn');
        }

        function resetTraining() {
            stopTraining();
            
            state.training.progress = 0;
            state.training.epoch = 0;
            state.training.loss = 2.5;
            state.training.accuracy = 0;
            state.training.activeNodes = 0;
            state.training.responseTime = 0;
            state.training.complexity = 'Low';
            state.training.cycles = 0;
            state.training.dataPoints = 0;
            state.training.rounds = 0;
            
            state.quantum.circuit = null;
            state.quantum.fidelity = 0;
            state.quantum.entropy = 0;
            state.quantum.speed = 0;
            
            updateTrainingUI();
            updateQuantumUI();
            updateQNNGrid();
            
            logMessage('[TRAINING] Reset complete', 'warn');
        }

        // Test Functions - Search and Rescue Mission
        function startAutopilotTest() {
            if (state.testInterval) {
                logMessage('[TEST] Test already running', 'warn');
                return;
            }
            
            state.test.status = 'Running';
            state.test.objectsCollected = 0;
            state.test.collisions = 0;
            state.test.score = 0;
            state.test.progress = 0;
            state.test.autopilotActive = true;
            state.test.missionComplete = false;
            
            // Position drone at random corner
            const corners = [
                { x: -35, z: -35 },
                { x: 35, z: -35 },
                { x: 35, z: 35 },
                { x: -35, z: 35 }
            ];
            const startCorner = corners[Math.floor(Math.random() * corners.length)];
            state.test.startPosition = startCorner;
            
            if (state.drone) {
                state.drone.position.set(startCorner.x, 2, startCorner.z);
                state.drone.lookAt(0, 2, 0);
            }
            
            // Switch to follow camera mode when test starts
            setCameraMode('follow');
            
            state.serviceWorkers.test.startTest({
                environment: state.test.environment,
                totalObjects: state.test.totalObjects
            });
            
            state.testInterval = setInterval(updateTest, 100);
            state.test.startTime = Date.now();
            
            logMessage('[TEST] Search and rescue mission started', 'ok');
            logMessage('[TEST] Mission: Find and collect 3 triangle drones', 'ok');
            updateTestUI();
        }

        function updateTest() {
            if (!state.testInterval) return;
            
            // Update test metrics
            state.test.flightTime = (Date.now() - state.test.startTime) / 1000;
            state.test.progress = Math.min(100, (state.test.flightTime / 180) * 100);
            
            // Autopilot navigation
            if (state.test.autopilotActive && state.drone) {
                updateAutopilot();
            }
            
            // Check for collectible objects
            checkCollectibles();
            
            // Check for collisions
            checkCollisions();
            
            // Calculate test score
            calculateTestScore();
            
            updateTestUI();
            
            // Check for mission completion
            if (state.test.objectsCollected >= state.test.totalObjects && !state.test.missionComplete) {
                completeMission();
            }
        }

        function updateAutopilot() {
            if (!state.drone) return;
            
            const drone = state.drone;
            const speed = 0.1 * state.test.droneSpeed;
            const now = Date.now();
            
            // Initialize target direction if not set
            if (!state.targetDirection) {
                state.targetDirection = {
                    x: (Math.random() - 0.5) * 2,
                    z: (Math.random() - 0.5) * 2
                };
                state.lastDirectionChange = now;
            }
            
            // Change direction periodically or when hitting boundaries
            if (now - state.lastDirectionChange > state.directionChangeInterval || 
                Math.abs(drone.position.x) > state.escapeBoundary - 5 ||
                Math.abs(drone.position.z) > state.escapeBoundary - 5) {
                
                const angle = Math.random() * Math.PI * 2;
                state.targetDirection = {
                    x: Math.cos(angle),
                    z: Math.sin(angle)
                };
                state.lastDirectionChange = now;
            }
            
            // Apply movement with collision avoidance
            let newX = drone.position.x + state.targetDirection.x * speed;
            let newZ = drone.position.z + state.targetDirection.z * speed;
            
            // Simple collision prediction
            let collisionRisk = false;
            for (const obstacle of state.obstacles) {
                const distance = Math.sqrt(
                    Math.pow(newX - obstacle.position.x, 2) + 
                    Math.pow(newZ - obstacle.position.z, 2)
                );
                if (distance < 2.5) {
                    collisionRisk = true;
                    break;
                }
            }
            
            if (!collisionRisk) {
                drone.position.x = newX;
                drone.position.z = newZ;
                state.test.distance += Math.sqrt(
                    Math.pow(state.targetDirection.x * speed, 2) + 
                    Math.pow(state.targetDirection.z * speed, 2)
                );
            } else {
                // Change direction immediately if collision risk
                state.lastDirectionChange = 0;
            }
            
            // Keep within bounds
            const boundary = state.escapeBoundary - 2;
            if (Math.abs(drone.position.x) > boundary) {
                drone.position.x = Math.sign(drone.position.x) * boundary;
                state.targetDirection.x *= -1;
            }
            if (Math.abs(drone.position.z) > boundary) {
                drone.position.z = Math.sign(drone.position.z) * boundary;
                state.targetDirection.z *= -1;
            }
            
            // Point drone in direction of movement
            if (state.targetDirection.x !== 0 || state.targetDirection.z !== 0) {
                drone.lookAt(
                    drone.position.x + state.targetDirection.x,
                    drone.position.y,
                    drone.position.z + state.targetDirection.z
                );
            }
        }

        function checkCollectibles() {
            if (!state.drone) return;
            
            const dronePos = state.drone.position;
            
            state.collectibles.forEach((collectible, index) => {
                if (collectible && collectible.position && !collectible.collected) {
                    const distance = dronePos.distanceTo(collectible.position);
                    
                    if (distance < 2.5) {
                        // Mark as collected
                        collectible.collected = true;
                        collectible.visible = false;
                        
                        // Remove associated light
                        const lights = state.scene.children.filter(child => 
                            child instanceof THREE.PointLight && 
                            child.position.distanceTo(collectible.position) < 0.1
                        );
                        lights.forEach(light => state.scene.remove(light));
                        
                        state.test.objectsCollected++;
                        const collectionResult = state.serviceWorkers.test.collectObject();
                        logMessage(`[TEST] Triangle drone ${state.test.objectsCollected} collected!`, 'ok');
                    }
                }
            });
        }

        function checkCollisions() {
            if (!state.drone) return;
            
            const dronePos = state.drone.position;
            
            for (const obstacle of state.obstacles) {
                const distance = dronePos.distanceTo(obstacle.position);
                if (distance < 2) {
                    state.test.collisions++;
                    state.serviceWorkers.test.recordCollision();
                    
                    // Small bounce back
                    if (state.targetDirection) {
                        state.targetDirection.x *= -0.5;
                        state.targetDirection.z *= -0.5;
                    }
                    
                    if (state.test.collisions % 5 === 0) {
                        logMessage(`[TEST] Collision detected! Total: ${state.test.collisions}`, 'warn');
                    }
                    break;
                }
            }
        }

        function calculateTestScore() {
            // Base score from collected objects
            let score = state.test.objectsCollected * 25;
            
            // Penalty for collisions
            score = Math.max(0, score - state.test.collisions * 2);
            
            // Time bonus (faster is better)
            const timeBonus = Math.max(0, 25 - (state.test.flightTime / 10));
            score += timeBonus;
            
            state.test.score = Math.min(100, score);
        }

        function completeMission() {
            state.test.missionComplete = true;
            state.test.status = 'Mission Complete';
            
            logMessage('[TEST] MISSION COMPLETE! All triangle drones rescued!', 'ok');
            logMessage(`[TEST] Mission time: ${state.test.flightTime.toFixed(2)}s`, 'ok');
            logMessage(`[TEST] Final score: ${state.test.score.toFixed(1)}%`, 'ok');
            
            // Stop the test after a delay
            setTimeout(() => {
                stopTest();
            }, 3000);
        }

        function stopTest() {
            clearInterval(state.testInterval);
            state.testInterval = null;
            state.test.autopilotActive = false;
            
            state.test.status = 'Ready';
            document.getElementById('autopilot-test').textContent = 'START RESCUE TEST';
            
            logMessage('[TEST] Mission stopped', 'warn');
            updateTestUI();
        }

        function newCourse() {
            stopTest();
            
            // Clear existing environment
            state.trees.forEach(tree => state.scene.remove(tree));
            state.collectibles.forEach(collectible => state.scene.remove(collectible));
            state.trees = [];
            state.collectibles = [];
            state.obstacles = [];
            
            // Generate new environment
            generateForest();
            createTriangleDrones();
            
            // Reset drone position
            if (state.drone) {
                state.drone.position.set(0, 2, 0);
            }
            
            state.test.environment = 'Quantum Forest ' + (Math.floor(Math.random() * 1000));
            logMessage(`[TEST] New environment: ${state.test.environment}`, 'sys');
            updateTestUI();
        }

        // UI Update Functions
        function updateTrainingUI() {
            document.getElementById('training-rounds').textContent = state.training.rounds;
            document.getElementById('total-training-time').textContent = 
                `${Math.floor(state.training.cycles / 60)}m ${state.training.cycles % 60}s`;
            document.getElementById('train-progress').textContent = state.training.progress.toFixed(1) + '%';
            document.getElementById('train-progress-bar').style.width = state.training.progress + '%';
            document.getElementById('accuracy').textContent = state.training.accuracy.toFixed(1) + '%';
            document.getElementById('active-nodes').textContent = state.training.activeNodes;
            document.getElementById('loss').textContent = state.training.loss.toFixed(3);
            document.getElementById('epoch').textContent = state.training.epoch;
            document.getElementById('response-time').textContent = state.training.responseTime.toFixed(1) + 'ms';
            document.getElementById('complexity').textContent = state.training.complexity;
            document.getElementById('training-cycles').textContent = state.training.cycles;
            document.getElementById('data-points').textContent = state.training.dataPoints;
            document.getElementById('memory-used').textContent = Math.floor(state.training.cycles * 0.1) + 'MB';
            document.getElementById('robustness-score').textContent = Math.floor(state.training.accuracy * 0.8) + '%';
            document.getElementById('stress-response').textContent = (2.5 - state.training.loss).toFixed(2);
        }

        function updateTestUI() {
            document.getElementById('test-status').textContent = state.test.status;
            document.getElementById('test-score').textContent = state.test.score.toFixed(1) + '%';
            document.getElementById('current-environment').textContent = state.test.environment;
            document.getElementById('objects-collected').textContent = 
                `${state.test.objectsCollected}/${state.test.totalObjects}`;
            document.getElementById('flight-time').textContent = state.test.flightTime.toFixed(1) + 's';
            document.getElementById('distance').textContent = Math.floor(state.test.distance) + 'm';
            document.getElementById('collisions').textContent = state.test.collisions;
            document.getElementById('test-speed').textContent = Math.floor(state.test.distance / state.test.flightTime * 3.6) + ' km/h';
            document.getElementById('test-progress').textContent = state.test.progress.toFixed(1) + '%';
            document.getElementById('test-progress-bar').style.width = state.test.progress + '%';
        }

        function updateQuantumUI() {
            document.getElementById('quantum-state').textContent = state.quantum.state;
            document.getElementById('quantum-fidelity').textContent = state.quantum.fidelity.toFixed(3);
            document.getElementById('quantum-entropy').textContent = state.quantum.entropy.toFixed(3);
            document.getElementById('quantum-speed').textContent = state.quantum.speed;
            
            if (state.currentMode === 'test') {
                const navUpdate = state.serviceWorkers.test.updateNavigation({
                    fidelity: state.quantum.fidelity,
                    entanglement: state.quantum.entanglement
                });
                document.getElementById('quantum-path').textContent = navUpdate.pathfinding;
                document.getElementById('quantum-collision').textContent = navUpdate.collisionRisk.toFixed(3);
                document.getElementById('quantum-efficiency').textContent = Math.floor(navUpdate.efficiency) + '%';
                document.getElementById('quantum-decisions').textContent = state.training.cycles;
            }
        }

        function updateQNNGrid() {
            const cells = document.querySelectorAll('.qnn-cell');
            const activeProbability = state.training.progress / 100;
            
            cells.forEach((cell, i) => {
                const isActive = Math.random() < activeProbability;
                const isTraining = state.training.running && Math.random() < 0.2;
                const isLearned = state.training.accuracy > 50 && Math.random() < (state.training.accuracy / 100);

                cell.className = 'qnn-cell';
                if (isLearned) {
                    cell.classList.add('learned');
                } else if (isTraining) {
                    cell.classList.add('training');
                } else if (isActive) {
                    cell.classList.add('active');
                }
            });
        }

        function generateQNNGrid() {
            const grid = document.getElementById('qnn-grid');
            grid.innerHTML = '';
            for (let i = 0; i < 100; i++) {
                const cell = document.createElement('div');
                cell.className = 'qnn-cell';
                grid.appendChild(cell);
            }
        }

        function generateAntifragilityGrid() {
            const grid = document.getElementById('antifragility-grid');
            grid.innerHTML = '';
            for (let i = 0; i < 25; i++) {
                const cell = document.createElement('div');
                cell.className = 'antifragility-cell';
                if (Math.random() > 0.7) {
                    cell.classList.add('stressed');
                } else if (Math.random() > 0.5) {
                    cell.classList.add('stable');
                }
                grid.appendChild(cell);
            }
        }

        // Export/Import Functions
        function showExportModal() {
            const modal = document.getElementById('export-modal');
            updateExportPreview();
            modal.classList.add('active');
        }

        function updateExportPreview() {
            const modelName = document.getElementById('export-model-name').value || 'QNN_Model';
            
            state.exportData = {
                modelName: modelName,
                timestamp: new Date().toISOString(),
                version: '2.0',
                quantumWeights: state.serviceWorkers.train.getWeights(),
                trainingMetrics: {
                    progress: state.training.progress,
                    accuracy: state.training.accuracy,
                    loss: state.training.loss,
                    activeNodes: state.training.activeNodes,
                    epochs: state.training.epoch,
                    cycles: state.training.cycles
                },
                quantumState: {
                    qubits: state.quantum.qubits,
                    depth: state.quantum.depth,
                    entanglement: state.quantum.entanglement,
                    fidelity: state.quantum.fidelity
                },
                testResults: state.serviceWorkers.test.getTestResults()
            };
            
            const dataSize = JSON.stringify(state.exportData).length;
            document.getElementById('export-data-size').textContent = `${(dataSize / 1024).toFixed(1)} KB`;
        }

        function confirmExport() {
            const dataStr = JSON.stringify(state.exportData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `QNN_${state.exportData.modelName}_${Date.now()}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            logMessage(`[EXPORT] QNN model '${state.exportData.modelName}' exported`, 'ok');
            hideExportModal();
        }

        function showImportModal() {
            const modal = document.getElementById('import-modal');
            modal.classList.add('active');
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file && file.type === 'application/json') {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        state.importData = JSON.parse(e.target.result);
                        document.getElementById('import-status-text').textContent = 
                            `Ready to import: ${state.importData.modelName}`;
                        document.getElementById('import-status-indicator').className = 'status-indicator status-success';
                        document.getElementById('import-confirm').disabled = false;
                    } catch (error) {
                        document.getElementById('import-status-text').textContent = 'Invalid JSON file';
                        document.getElementById('import-status-indicator').className = 'status-indicator status-error';
                    }
                };
                reader.readAsText(file);
            }
        }

        function confirmImport() {
            if (!state.importData) return;
            
            // Import training data
            if (state.importData.trainingMetrics) {
                state.training.progress = state.importData.trainingMetrics.progress || 0;
                state.training.accuracy = state.importData.trainingMetrics.accuracy || 0;
                state.training.loss = state.importData.trainingMetrics.loss || 2.5;
                state.training.activeNodes = state.importData.trainingMetrics.activeNodes || 0;
                state.training.epoch = state.importData.trainingMetrics.epochs || 0;
                state.training.cycles = state.importData.trainingMetrics.cycles || 0;
            }
            
            // Import quantum state
            if (state.importData.quantumState) {
                state.quantum.qubits = state.importData.quantumState.qubits || 2;
                state.quantum.depth = state.importData.quantumState.depth || 3;
                state.quantum.entanglement = state.importData.quantumState.entanglement || 0;
                state.quantum.fidelity = state.importData.quantumState.fidelity || 0;
            }
            
            updateTrainingUI();
            updateQuantumUI();
            updateQNNGrid();
            
            logMessage(`[IMPORT] QNN model '${state.importData.modelName}' loaded`, 'ok');
            hideImportModal();
        }

        function hideExportModal() {
            document.getElementById('export-modal').classList.remove('active');
        }

        function hideImportModal() {
            document.getElementById('import-modal').classList.remove('active');
            // Reset import form
            document.getElementById('import-file').value = '';
            document.getElementById('import-status-text').textContent = 'Ready to import QNN weights';
            document.getElementById('import-status-indicator').className = 'status-indicator';
            document.getElementById('import-confirm').disabled = true;
        }

        function saveTrainingData() {
            const logEntry = {
                timestamp: new Date().toISOString(),
                progress: state.training.progress,
                accuracy: state.training.accuracy,
                loss: state.training.loss,
                epoch: state.training.epoch,
                quantumState: state.quantum.state
            };
            state.trainingLog.push(logEntry);
            state.training.dataPoints++;
            
            if (state.training.cycles % 100 === 0) {
                logMessage(`[TRAINING] Epoch ${state.training.epoch} - Accuracy: ${state.training.accuracy.toFixed(1)}%`, 'train-log');
            }
        }

        function switchMode(mode) {
            state.currentMode = mode;
            
            // Update UI
            document.querySelectorAll('.mode-tab').forEach(tab => {
                tab.classList.toggle('active', tab.getAttribute('data-mode') === mode);
            });
            
            document.querySelectorAll('.mode-panel').forEach(panel => {
                panel.classList.toggle('active', panel.id.includes(mode));
            });
            
            // Reset camera to orbit mode when switching to train
            if (mode === 'train') {
                setCameraMode('orbit');
            }
            
            logMessage(`[SYSTEM] Switched to ${mode.toUpperCase()} mode`, 'sys');
        }

        function logMessage(message, type = 'info') {
            const console = document.getElementById('console-output');
            const line = document.createElement('p');
            line.className = type;
            line.textContent = message;
            console.appendChild(line);
            console.scrollTop = console.scrollHeight;
        }

        // Event Listeners
        function setupEventListeners() {
            // Mode tabs
            document.querySelectorAll('.mode-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    switchMode(tab.getAttribute('data-mode'));
                });
            });

            // Header controls
            document.getElementById('header-export').addEventListener('click', showExportModal);
            document.getElementById('header-import').addEventListener('click', showImportModal);

            // Training controls
            document.getElementById('start-train').addEventListener('click', startTraining);
            document.getElementById('stop-train').addEventListener('click', stopTraining);
            document.getElementById('reset-train').addEventListener('click', resetTraining);

            // Test controls
            document.getElementById('autopilot-test').addEventListener('click', startAutopilotTest);
            document.getElementById('test-stop').addEventListener('click', stopTest);
            document.getElementById('new-course').addEventListener('click', newCourse);

            // Camera controls
            document.getElementById('camera-follow').addEventListener('click', () => setCameraMode('follow'));
            document.getElementById('camera-orbit').addEventListener('click', () => setCameraMode('orbit'));
            document.getElementById('camera-reset').addEventListener('click', resetCamera);

            // Sliders
            document.getElementById('learning-rate').addEventListener('input', (e) => {
                state.qnn.learningRate = parseFloat(e.target.value);
                document.getElementById('learning-rate-value').textContent = state.qnn.learningRate.toFixed(2);
            });
            
            document.getElementById('creativity').addEventListener('input', (e) => {
                state.qnn.creativity = parseFloat(e.target.value);
                document.getElementById('creativity-value').textContent = state.qnn.creativity.toFixed(2);
            });
            
            document.getElementById('qubits').addEventListener('input', (e) => {
                state.quantum.qubits = parseInt(e.target.value);
                document.getElementById('qubits-value').textContent = state.quantum.qubits;
            });
            
            document.getElementById('quantum-depth').addEventListener('input', (e) => {
                state.quantum.depth = parseInt(e.target.value);
                document.getElementById('quantum-depth-value').textContent = state.quantum.depth;
            });
            
            document.getElementById('drone-speed').addEventListener('input', (e) => {
                state.test.droneSpeed = parseFloat(e.target.value);
                document.getElementById('drone-speed-value').textContent = state.test.droneSpeed.toFixed(1) + 'x';
            });
            
            document.getElementById('environment-complexity').addEventListener('input', (e) => {
                state.test.environmentComplexity = parseFloat(e.target.value);
                document.getElementById('complexity-value').textContent = state.test.environmentComplexity.toFixed(2);
            });

            // Modal controls
            document.getElementById('export-close').addEventListener('click', hideExportModal);
            document.getElementById('export-cancel').addEventListener('click', hideExportModal);
            document.getElementById('export-confirm').addEventListener('click', confirmExport);
            
            document.getElementById('import-close').addEventListener('click', hideImportModal);
            document.getElementById('import-cancel').addEventListener('click', hideImportModal);
            document.getElementById('import-confirm').addEventListener('click', confirmImport);
            document.getElementById('import-file').addEventListener('change', handleFileSelect);

            // Console
            document.getElementById('console-send').addEventListener('click', processConsoleInput);
            document.getElementById('console-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') processConsoleInput();
            });

            document.getElementById('copy-log').addEventListener('click', () => {
                const text = document.getElementById('console-output').innerText;
                navigator.clipboard.writeText(text);
                logMessage('[SYSTEM] Log copied to clipboard', 'ok');
            });
        }

        function processConsoleInput() {
            const input = document.getElementById('console-input');
            const command = input.value.trim();
            
            if (command) {
                logMessage(`> ${command}`, 'muted');
                
                switch(command.toLowerCase()) {
                    case '/help':
                        logMessage('[HELP] Available commands: /help, /status, /reset, /export', 'sys');
                        break;
                    case '/status':
                        logMessage(`[STATUS] Training: ${state.training.running ? 'RUNNING' : 'STOPPED'}, Progress: ${state.training.progress.toFixed(1)}%`, 'sys');
                        break;
                    case '/reset':
                        resetTraining();
                        break;
                    case '/export':
                        showExportModal();
                        break;
                    default:
                        logMessage('[ERROR] Unknown command. Type /help for available commands.', 'err');
                }
                
                input.value = '';
            }
        }

        // Initialize when page loads
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>