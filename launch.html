<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LAUNCH SEQUENCE by webXOS 2025</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --primary: #00ff00;
            --secondary: #00ffcc;
            --background: #000000;
            --panel: rgba(0, 20, 0, 0.7);
            --text: #00FF00;
            --muted: #008800;
            --radius: 5px;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
            font-size: 12pt; /* Set base font size to 12pt */
        }
        
        body {
            background-color: var(--background);
            color: var(--text);
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            padding: 10px;
            border-bottom: 2px solid var(--primary);
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 60px;
            width: 100%;
            background: rgba(0, 0, 0, 0.8);
        }
        
        h1 {
            font-size: 15pt; /* Set header to 15pt */
            letter-spacing: 0.5px;
            color: var(--primary);
            font-weight: bold;
            text-shadow: 0 0 10px var(--primary), 0 0 20px var(--primary); /* Neural glow effect */
        }
        
        .mode-tabs {
            display: flex;
            gap: 5px;
        }
        
        .mode-tab {
            padding: 6px 12px;
            background: var(--panel);
            border: 2px solid var(--primary);
            border-radius: var(--radius);
            cursor: pointer;
            font-size: 0.85rem;
        }
        
        .mode-tab.active {
            background: var(--primary);
            color: #000;
        }
        
        main {
            display: flex;
            flex: 1;
            overflow: hidden;
            width: 100%;
            padding: 10px;
            gap: 10px;
            min-height: 0;
        }
        
        .left-panel, .right-panel {
            width: 300px;
            background: var(--panel);
            border: 2px solid var(--primary);
            border-radius: var(--radius);
            padding: 15px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        .center-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-height: 0;
        }
        
        .scene-container {
            flex: 1;
            border: 2px solid var(--primary);
            border-radius: var(--radius);
            overflow: hidden;
            position: relative;
            min-height: 0;
            background: #001122;
        }

        #three-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .scene-controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--primary);
            border-radius: var(--radius);
            padding: 5px;
            z-index: 10;
            font-size: 0.8rem;
        }
        
        .qnn-overlay {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 120px;
            height: 120px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--primary);
            border-radius: var(--radius);
            padding: 5px;
            z-index: 10;
        }
        
        .qnn-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 1px;
            width: 100%;
            height: 100%;
        }
        
        .qnn-cell {
            background: #000;
            border: 1px solid var(--muted);
            transition: all 0.3s ease;
        }
        
        .qnn-cell.active {
            background: var(--primary);
            box-shadow: 0 0 5px var(--primary);
        }
        
        .qnn-cell.training {
            background: #ffcc00;
            animation: pulse 1s infinite;
        }
        
        .qnn-cell.learned {
            background: #00cc00;
            box-shadow: 0 0 5px #00cc00;
        }
        
        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }
        
        .console-container {
            flex: 1;
            min-height: 200px;
            background: var(--panel);
            border: 2px solid var(--primary);
            border-radius: var(--radius);
            padding: 10px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .console-output {
            flex: 1;
            background: #000;
            border-radius: var(--radius);
            padding: 10px;
            overflow-y: auto;
            font-size: 1rem; /* Larger text */
            margin-bottom: 8px;
            border: 1px solid var(--primary);
            min-height: 150px;
        }
        
        .console-output p {
            margin: 4px 0; /* Slightly more spacing */
        }
        
        .ok { color: #7dff7d; }
        .warn { color: #ffea7d; }
        .err { color: #ff7d7d; }
        .sys { color: #7dd9ff; }
        .muted { color: #aaaaaa; }
        .train-log { color: #ffcc00; }
        .perf { color: #ff00ff; }
        
        .console-input {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
            height: 45px; /* Slightly taller for better visibility */
        }
        
        .input-line {
            flex: 1;
            background: #000;
            border: 2px solid var(--primary);
            color: var(--text);
            padding: 12px;
            border-radius: var(--radius);
            font-size: 1rem; /* Larger text */
        }
        
        .input-send {
            padding: 12px 16px;
            border-radius: var(--radius);
            background: #000;
            border: 2px solid var(--primary);
            color: var(--text);
            cursor: pointer;
            flex-shrink: 0;
            font-size: 1rem; /* Larger text */
        }
        
        footer {
            padding: 10px;
            border-top: 2px solid var(--primary);
            text-align: center;
            font-size: 0.8rem;
            color: var(--muted);
            height: 40px;
            width: 100%;
            background: rgba(0, 0, 0, 0.8);
            flex-shrink: 0;
        }
        
        .btn {
            padding: 10px;
            border-radius: var(--radius);
            border: 2px solid var(--primary);
            background: #000;
            color: var(--text);
            cursor: pointer;
            margin: 5px 0;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }
        
        .btn:hover {
            background: var(--primary);
            color: #000;
        }
        
        .btn-primary {
            background: var(--primary);
            color: #000;
        }
        
        .drone-type {
            padding: 8px;
            background: #000;
            border: 2px solid var(--primary);
            border-radius: var(--radius);
            text-align: center;
            cursor: pointer;
            margin: 2px;
            transition: all 0.3s ease;
            font-size: 0.85rem;
        }
        
        .drone-type.active {
            background: var(--primary);
            color: #000;
        }

        .metric {
            background: #000;
            border: 2px solid var(--primary);
            border-radius: var(--radius);
            padding: 10px;
            text-align: center;
            margin: 5px 0;
        }
        
        .metric-val {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--primary);
        }
        
        .slider-container {
            margin: 10px 0;
        }
        
        .slider-container label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }
        
        .mode-panel {
            display: none;
        }
        
        .mode-panel.active {
            display: block;
        }
        
        .progress-bar {
            height: 10px;
            background: #000;
            border: 1px solid var(--primary);
            border-radius: 5px;
            overflow: hidden;
            margin: 5px 0;
        }
        
        .progress {
            height: 100%;
            background: var(--primary);
            width: 0%;
            transition: width 0.3s ease;
        }

        .memory-control {
            background: #000;
            border: 1px solid var(--primary);
            border-radius: var(--radius);
            padding: 8px;
            margin: 5px 0;
            font-size: 0.8rem;
        }

        .training-stats {
            background: #000;
            border: 1px solid var(--primary);
            border-radius: var(--radius);
            padding: 8px;
            margin: 5px 0;
            font-size: 0.8rem;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #000;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--secondary);
        }
    </style>
</head>
<body>
    <header>
        <h1>LAUNCH SEQUENCE - WEBXOS 2025</h1>
        <div class="mode-tabs">
            <div class="mode-tab active" data-mode="train">TRAIN</div>
            <div class="mode-tab" data-mode="test">TEST</div>
        </div>
    </header>
    
    <main>
        <div class="left-panel">
            <div class="mode-panel active" id="train-panel">
                <h2>Training Controls</h2>
                <div class="drone-type-selector">
                    <div class="drone-type active" data-type="tinywhoop">Tiny Whoop</div>
                    <div class="drone-type" data-type="longrange">Long Range</div>
                    <div class="drone-type" data-type="fpv">FPV</div>
                </div>
                
                <div class="slider-container">
                    <label>Learning Rate: <span id="learning-rate-value">0.10</span></label>
                    <input type="range" id="learning-rate" min="0.01" max="1.0" step="0.01" value="0.1" style="width:100%">
                </div>
                
                <div class="slider-container">
                    <label>Creativity: <span id="creativity-value">0.70</span></label>
                    <input type="range" id="creativity" min="0.0" max="1.0" step="0.01" value="0.7" style="width:100%">
                </div>

                <div class="memory-control">
                    <label>Training Memory: <span id="memory-usage">128MB</span></label>
                    <input type="range" id="memory-limit" min="64" max="1024" step="64" value="128" style="width:100%">
                </div>

                <div class="training-stats">
                    <div>Training Rounds: <span id="training-rounds">0</span></div>
                    <div>Total Training Time: <span id="total-training-time">0h 0m</span></div>
                    <div>Best Score: <span id="best-score">0%</span></div>
                </div>
                
                <button class="btn btn-primary" id="start-train">Start Endless Training</button>
                <button class="btn" id="stop-train">Pause Training</button>
                <button class="btn" id="export-model">Export Training Log</button>
                <button class="btn" id="reset-train">Reset Training</button>
                
                <div class="progress-bar">
                    <div class="progress" id="train-progress-bar" style="width: 0%"></div>
                </div>
                <div class="metric">
                    <div class="metric-val" id="train-progress">0%</div>
                    <div>Training Progress</div>
                </div>
                
                <div class="metric">
                    <div class="metric-val" id="accuracy">0%</div>
                    <div>Accuracy</div>
                </div>
                <div class="metric">
                    <div class="metric-val" id="active-nodes">0</div>
                    <div>Active Nodes</div>
                </div>
            </div>
            
            <div class="mode-panel" id="test-panel">
                <h2>Test Controls</h2>
                <button class="btn" id="import-model">IMPORT QNN</button>
                <button class="btn" id="manual-test">MANUAL TEST</button>
                <button class="btn" id="autopilot-test">AUTO PILOT</button>
                <button class="btn" id="full-test">FULL TEST ROUND</button>

                <div class="training-stats">
                    <div>Test Score: <span id="test-score">0%</span></div>
                    <div>Environment: <span id="current-environment">A</span></div>
                    <div>Obstacles Passed: <span id="obstacles-passed">0</span></div>
                </div>
                
                <div class="metric">
                    <div class="metric-val" id="flight-time">0s</div>
                    <div>Flight Time</div>
                </div>
                <div class="metric">
                    <div class="metric-val" id="distance">0m</div>
                    <div>Distance</div>
                </div>
                <div class="metric">
                    <div class="metric-val" id="collisions">0</div>
                    <div>Collisions</div>
                </div>
            </div>
        </div>
        
        <div class="center-panel">
            <div class="scene-container" id="scene-container">
                <canvas id="three-canvas"></canvas>
                <div class="scene-controls">
                    <div>Mouse: Drag to rotate</div>
                    <div>Wheel: Zoom in/out</div>
                </div>
                <div class="qnn-overlay">
                    <div class="qnn-grid" id="qnn-grid">
                        <!-- QNN grid will be generated by JavaScript -->
                    </div>
                </div>
            </div>
            <div class="console-container">
                <div class="console-output" id="console-output">
                    <p class="sys">[SYSTEM] LAUNCH SEQUENCE initialized</p>
                    <p class="sys">[SYSTEM] Endless training mode available</p>
                    <p class="sys">[SYSTEM] Type /help for available commands</p>
                </div>
                <div class="console-input">
                    <input type="text" class="input-line" id="console-input" placeholder="Type /help for commands...">
                    <button class="input-send" id="console-send">SEND</button>
                </div>
            </div>
        </div>
        
        <div class="right-panel">
            <div class="mode-panel active" id="train-right-panel">
                <h2>Training Data</h2>
                <div class="metric">
                    <div>Model: <input type="text" id="model-name" placeholder="Model Name" style="background: #000; color: #00ff00; border: 1px solid #008800; padding: 5px; width: 100%; font-size: 0.9rem;"></div>
                </div>
                <div class="metric">
                    <div class="metric-val" id="epoch">0</div>
                    <div>Epoch</div>
                </div>
                <div class="metric">
                    <div class="metric-val" id="loss">0.00</div>
                    <div>Loss</div>
                </div>
                <div class="metric">
                    <div class="metric-val" id="complexity">Low</div>
                    <div>Complexity</div>
                </div>
                <div class="metric">
                    <div class="metric-val" id="response-time">0ms</div>
                    <div>Response Time</div>
                </div>
                <div class="training-stats">
                    <div>Training Cycles: <span id="training-cycles">0</span></div>
                    <div>Data Points: <span id="data-points">0</span></div>
                    <div>Memory Used: <span id="memory-used">0MB</span></div>
                </div>
            </div>
            
            <div class="mode-panel" id="test-right-panel">
                <h2>Test Metrics</h2>
                <div class="metric">
                    <div class="metric-val" id="test-accuracy">0%</div>
                    <div>Accuracy</div>
                </div>
                <div class="metric">
                    <div class="metric-val" id="test-speed">0 km/h</div>
                    <div>Speed</div>
                </div>
                <div class="metric">
                    <div class="metric-val" id="test-battery">100%</div>
                    <div>Battery</div>
                </div>
                <div class="progress-bar">
                    <div class="progress" id="test-progress-bar" style="width: 0%"></div>
                </div>
                <div class="metric">
                    <div class="metric-val" id="test-progress">0%</div>
                    <div>Test Progress</div>
                </div>
                <div class="training-stats">
                    <div>Best Run: <span id="best-run">0%</span></div>
                    <div>Success Rate: <span id="success-rate">0%</span></div>
                    <div>Learning Rate: <span id="current-learning-rate">0.10</span></div>
                </div>
            </div>
        </div>
    </main>
    
    <footer>
        WEBXOS 2025 | LAUNCH SEQUENCE v1.1.0 | Lattice OS Compatible | Endless Training Active
    </footer>

    <script>
        // Enhanced global state with 24/7 training capabilities
        const state = {
            currentMode: 'train',
            droneType: 'tinywhoop',
            training: {
                running: false,
                endless: false,
                progress: 0,
                epoch: 0,
                loss: 2.5,
                accuracy: 0,
                activeNodes: 0,
                responseTime: 0,
                complexity: 'Low',
                rounds: 0,
                totalTime: 0,
                bestScore: 0,
                cycles: 0,
                dataPoints: 0
            },
            test: {
                mode: 'manual',
                flightTime: 0,
                distance: 0,
                collisions: 0,
                speed: 0,
                battery: 100,
                testAccuracy: 0,
                progress: 0,
                score: 0,
                environment: 'A',
                obstaclesPassed: 0,
                successRate: 0,
                bestRun: 0
            },
            qnn: {
                grid: Array(10).fill().map(() => Array(10).fill('inactive')),
                learningRate: 0.1,
                creativity: 0.7,
                memoryLimit: 128,
                memoryUsed: 0
            },
            scene: null,
            camera: null,
            renderer: null,
            drone: null,
            obstacles: [],
            gates: [],
            trainingEnvironments: ['A', 'B', 'C', 'D'],
            currentEnvironment: 0,
            flightControls: {
                forward: false,
                backward: false,
                left: false,
                right: false,
                up: false,
                down: false
            },
            autopilotActive: false,
            trainingInterval: null,
            testInterval: null,
            environmentInterval: null,
            trainingLog: [],
            serviceWorker: null,
            // Camera control variables
            isMouseDown: false,
            mouseX: 0,
            mouseY: 0,
            cameraDistance: 20,
            cameraAngleX: 0,
            cameraAngleY: 0.5,
            // Full test variables
            fullTestActive: false,
            testObstacles: []
        };

        // Initialize the application with enhanced training
        function init() {
            setupEventListeners();
            generateQNNGrid();
            init3DScene();
            initServiceWorker();
            loadTrainingData();
            logMessage('[SYSTEM] LAUNCH SEQUENCE initialized', 'sys');
            logMessage('[SYSTEM] Endless 24/7 training mode ready', 'sys');
            logMessage('[SYSTEM] Advanced recursive reinforcement learning active', 'sys');
            logMessage('[SYSTEM] Type /help for available commands', 'sys');
        }

        // Initialize background service worker for continuous training
        function initServiceWorker() {
            // Simulate service worker for background training
            state.serviceWorker = {
                active: true,
                trainingData: [],
                processTrainingBatch: function() {
                    if (state.training.endless && state.training.running) {
                        // Process reinforcement learning batch
                        processReinforcementBatch();
                    }
                }
            };
            
            // Process training batches every 5 seconds
            setInterval(() => {
                state.serviceWorker.processTrainingBatch();
            }, 5000);
        }

        // Process reinforcement learning batch
        function processReinforcementBatch() {
            if (state.training.dataPoints < state.qnn.memoryLimit * 1000) {
                state.training.dataPoints += Math.floor(Math.random() * 100) + 50;
                updateTrainingStats();
                
                // Simulate reinforcement learning improvements
                if (state.training.accuracy < 95) {
                    state.training.accuracy += Math.random() * 0.5;
                    state.training.loss = Math.max(0.01, state.training.loss * 0.99);
                }
                
                // Log training progress
                if (state.training.cycles % 10 === 0) {
                    logMessage(`[TRAINING] Reinforcement batch processed: +${state.training.dataPoints} data points`, 'train-log');
                    logMessage(`[TRAINING] Model accuracy: ${state.training.accuracy.toFixed(2)}%`, 'train-log');
                }
                
                // Save training state periodically
                if (state.training.cycles % 50 === 0) {
                    saveTrainingData();
                }
            }
        }

        // Save training data to localStorage
        function saveTrainingData() {
            const trainingData = {
                timestamp: new Date().toISOString(),
                state: state,
                log: state.trainingLog.slice(-1000) // Keep last 1000 entries
            };
            
            localStorage.setItem('qnn_training_data', JSON.stringify(trainingData));
            state.qnn.memoryUsed = Math.round(JSON.stringify(trainingData).length / 1024);
            updateTrainingStats();
            
            logMessage(`[SYSTEM] Training data saved (${state.qnn.memoryUsed}MB used)`, 'sys');
        }

        // Load training data from localStorage
        function loadTrainingData() {
            const saved = localStorage.getItem('qnn_training_data');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    // Load basic training stats
                    state.training.rounds = data.state.training.rounds || 0;
                    state.training.totalTime = data.state.training.totalTime || 0;
                    state.training.bestScore = data.state.training.bestScore || 0;
                    state.training.dataPoints = data.state.training.dataPoints || 0;
                    state.trainingLog = data.log || [];
                    
                    logMessage('[SYSTEM] Previous training data loaded', 'sys');
                    logMessage(`[SYSTEM] Resuming from ${state.training.rounds} training rounds`, 'sys');
                } catch (e) {
                    logMessage('[SYSTEM] No previous training data found', 'warn');
                }
            }
            updateTrainingStats();
        }

        // Set up event listeners
        function setupEventListeners() {
            // Mode tabs
            document.querySelectorAll('.mode-tab').forEach(tab => {
                tab.addEventListener('click', () => switchMode(tab.dataset.mode));
            });

            // Drone type selector
            document.querySelectorAll('.drone-type').forEach(type => {
                type.addEventListener('click', () => {
                    document.querySelectorAll('.drone-type').forEach(t => t.classList.remove('active'));
                    type.classList.add('active');
                    state.droneType = type.dataset.type;
                    logMessage(`[TRAIN] Drone type set to: ${type.textContent}`, 'ok');
                });
            });

            // Training controls
            document.getElementById('start-train').addEventListener('click', startTraining);
            document.getElementById('stop-train').addEventListener('click', stopTraining);
            document.getElementById('export-model').addEventListener('click', exportModel);
            document.getElementById('reset-train').addEventListener('click', resetTraining);

            // Test controls
            document.getElementById('import-model').addEventListener('click', importModel);
            document.getElementById('manual-test').addEventListener('click', () => setTestMode('manual'));
            document.getElementById('autopilot-test').addEventListener('click', () => setTestMode('autopilot'));
            document.getElementById('full-test').addEventListener('click', startFullTest);

            // Sliders
            document.getElementById('learning-rate').addEventListener('input', (e) => {
                state.qnn.learningRate = parseFloat(e.target.value);
                document.getElementById('learning-rate-value').textContent = state.qnn.learningRate.toFixed(2);
                document.getElementById('current-learning-rate').textContent = state.qnn.learningRate.toFixed(2);
            });

            document.getElementById('creativity').addEventListener('input', (e) => {
                state.qnn.creativity = parseFloat(e.target.value);
                document.getElementById('creativity-value').textContent = state.qnn.creativity.toFixed(2);
            });

            document.getElementById('memory-limit').addEventListener('input', (e) => {
                state.qnn.memoryLimit = parseInt(e.target.value);
                document.getElementById('memory-usage').textContent = state.qnn.memoryLimit + 'MB';
            });

            // Console
            document.getElementById('console-send').addEventListener('click', processConsoleCommand);
            document.getElementById('console-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') processConsoleCommand();
            });

            // Keyboard controls for manual flight
            document.addEventListener('keydown', (e) => {
                if (state.currentMode !== 'test') return;
                
                switch(e.code) {
                    case 'KeyW': state.flightControls.forward = true; break;
                    case 'KeyS': state.flightControls.backward = true; break;
                    case 'KeyA': state.flightControls.left = true; break;
                    case 'KeyD': state.flightControls.right = true; break;
                    case 'KeyR': state.flightControls.up = true; break;
                    case 'KeyF': state.flightControls.down = true; break;
                }
            });

            document.addEventListener('keyup', (e) => {
                if (state.currentMode !== 'test') return;
                
                switch(e.code) {
                    case 'KeyW': state.flightControls.forward = false; break;
                    case 'KeyS': state.flightControls.backward = false; break;
                    case 'KeyA': state.flightControls.left = false; break;
                    case 'KeyD': state.flightControls.right = false; break;
                    case 'KeyR': state.flightControls.up = false; break;
                    case 'KeyF': state.flightControls.down = false; break;
                }
            });
        }

        // Generate QNN grid
        function generateQNNGrid() {
            const grid = document.getElementById('qnn-grid');
            grid.innerHTML = '';
            for (let y = 0; y < 10; y++) {
                for (let x = 0; x < 10; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'qnn-cell inactive';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    grid.appendChild(cell);
                }
            }
        }

        // Update QNN grid based on state
        function updateQNNGrid() {
            for (let y = 0; y < 10; y++) {
                for (let x = 0; x < 10; x++) {
                    const cell = document.querySelector(`.qnn-cell[data-x="${x}"][data-y="${y}"]`);
                    if (cell) {
                        cell.className = `qnn-cell ${state.qnn.grid[y][x]}`;
                    }
                }
            }
        }

        // Switch between modes
        function switchMode(mode) {
            state.currentMode = mode;
            
            // Update active tab
            document.querySelectorAll('.mode-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.mode === mode);
            });
            
            // Show/hide panels
            document.querySelectorAll('.mode-panel').forEach(panel => {
                panel.classList.toggle('active', panel.id.includes(mode));
            });
            
            logMessage(`[SYSTEM] Switched to ${mode.toUpperCase()} mode`, 'sys');
            
            // Reset test state when switching to test mode
            if (mode === 'test') {
                resetTest();
            }
        }

        // Enhanced training functions for 24/7 operation
        function startTraining() {
            if (state.training.running) {
                logMessage('[TRAIN] Training already in progress', 'warn');
                return;
            }
            
            state.training.running = true;
            state.training.endless = true;
            state.training.progress = 0;
            state.training.epoch = 0;
            state.training.loss = 2.5;
            state.training.accuracy = 0;
            state.training.activeNodes = 0;
            
            logMessage('[TRAIN] Endless training started - 24/7 mode active', 'ok');
            logMessage('[TRAIN] Background service worker processing reinforcement learning', 'ok');
            
            // Clear any existing interval
            if (state.trainingInterval) clearInterval(state.trainingInterval);
            
            // Enhanced training simulation with reinforcement learning
            state.trainingInterval = setInterval(() => {
                if (!state.training.running) {
                    clearInterval(state.trainingInterval);
                    return;
                }
                
                state.training.epoch++;
                state.training.rounds++;
                state.training.cycles++;
                state.training.totalTime += 0.1;
                
                // Progressive learning algorithm
                state.training.progress = Math.min(99.9, state.training.progress + 0.1);
                state.training.loss = Math.max(0.01, state.training.loss * (0.995 + Math.random() * 0.005));
                state.training.accuracy = Math.min(99.5, state.training.accuracy + (Math.random() * 0.3));
                state.training.activeNodes = Math.min(100, state.training.activeNodes + Math.floor(Math.random() * 3));
                state.training.responseTime = Math.max(1, state.training.responseTime - Math.random() * 0.5);
                state.training.complexity = state.training.activeNodes > 80 ? 'Very High' : 
                                           state.training.activeNodes > 60 ? 'High' : 
                                           state.training.activeNodes > 30 ? 'Medium' : 'Low';
                
                // Update QNN grid with progressive learning patterns
                for (let y = 0; y < 10; y++) {
                    for (let x = 0; x < 10; x++) {
                        const learningFactor = state.training.accuracy / 100;
                        const rand = Math.random();
                        if (rand > 0.9 - (learningFactor * 0.3)) {
                            state.qnn.grid[y][x] = 'active';
                        } else if (rand > 0.7 - (learningFactor * 0.2)) {
                            state.qnn.grid[y][x] = 'training';
                        } else if (rand > 0.5 - (learningFactor * 0.1)) {
                            state.qnn.grid[y][x] = 'learned';
                        } else {
                            state.qnn.grid[y][x] = 'inactive';
                        }
                    }
                }
                updateQNNGrid();
                
                // Log training progress periodically
                if (state.training.epoch % 100 === 0) {
                    const logEntry = {
                        timestamp: new Date().toISOString(),
                        epoch: state.training.epoch,
                        accuracy: state.training.accuracy,
                        loss: state.training.loss,
                        activeNodes: state.training.activeNodes,
                        droneType: state.droneType
                    };
                    state.trainingLog.push(logEntry);
                    
                    logMessage(`[TRAINING] Epoch ${state.training.epoch}: Accuracy ${state.training.accuracy.toFixed(2)}%, Loss ${state.training.loss.toFixed(4)}`, 'train-log');
                }
                
                updateTrainingUI();
                updateTrainingStats();
                
            }, 100);
        }

        function stopTraining() {
            state.training.running = false;
            state.training.endless = false;
            if (state.trainingInterval) clearInterval(state.trainingInterval);
            saveTrainingData();
            logMessage('[TRAIN] Training paused - data saved', 'warn');
        }

        function resetTraining() {
            stopTraining();
            state.training.progress = 0;
            state.training.epoch = 0;
            state.training.loss = 2.5;
            state.training.accuracy = 0;
            state.training.activeNodes = 0;
            state.training.responseTime = 0;
            state.training.complexity = 'Low';
            state.training.rounds = 0;
            state.training.totalTime = 0;
            state.training.cycles = 0;
            state.training.dataPoints = 0;
            
            // Reset QNN grid
            for (let y = 0; y < 10; y++) {
                for (let x = 0; x < 10; x++) {
                    state.qnn.grid[y][x] = 'inactive';
                }
            }
            updateQNNGrid();
            
            // Clear training log
            state.trainingLog = [];
            localStorage.removeItem('qnn_training_data');
            
            updateTrainingUI();
            updateTrainingStats();
            logMessage('[TRAIN] Training completely reset', 'sys');
        }

        function updateTrainingStats() {
            document.getElementById('training-rounds').textContent = state.training.rounds;
            document.getElementById('total-training-time').textContent = 
                Math.floor(state.training.totalTime / 60) + 'h ' + Math.floor(state.training.totalTime % 60) + 'm';
            document.getElementById('best-score').textContent = state.training.bestScore.toFixed(1) + '%';
            document.getElementById('training-cycles').textContent = state.training.cycles;
            document.getElementById('data-points').textContent = state.training.dataPoints;
            document.getElementById('memory-used').textContent = state.qnn.memoryUsed + 'MB';
        }

        function exportModel() {
            const modelName = document.getElementById('model-name').value || `qnn_model_${Date.now()}`;
            const exportData = {
                name: modelName,
                type: state.droneType,
                grid: state.qnn.grid,
                parameters: {
                    learningRate: state.qnn.learningRate,
                    creativity: state.qnn.creativity,
                    memoryLimit: state.qnn.memoryLimit
                },
                training: state.training,
                test: state.test,
                trainingLog: state.trainingLog,
                timestamp: new Date().toISOString(),
                totalRounds: state.training.rounds,
                totalTime: state.training.totalTime,
                bestAccuracy: state.training.accuracy
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${modelName}_full_training_log.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            logMessage(`[TRAIN] Complete training log "${modelName}" exported`, 'ok');
            logMessage(`[TRAIN] ${state.trainingLog.length} training entries included`, 'ok');
        }

        function importModel() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const model = JSON.parse(event.target.result);
                        document.getElementById('model-name').value = model.name;
                        
                        // Update QNN grid with imported model
                        for (let y = 0; y < 10; y++) {
                            for (let x = 0; x < 10; x++) {
                                state.qnn.grid[y][x] = model.grid[y][x];
                            }
                        }
                        updateQNNGrid();
                        
                        // Load training data if available
                        if (model.trainingLog) {
                            state.trainingLog = model.trainingLog;
                            logMessage(`[TEST] Model "${model.name}" imported with ${model.trainingLog.length} training entries`, 'ok');
                        } else {
                            logMessage(`[TEST] Model "${model.name}" imported`, 'ok');
                        }
                    } catch (err) {
                        logMessage('[TEST] Error importing model: Invalid format', 'err');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function setTestMode(mode) {
            state.test.mode = mode;
            state.autopilotActive = (mode === 'autopilot');
            
            if (mode === 'autopilot' && document.getElementById('model-name').value === '') {
                logMessage('[TEST] No model loaded for autopilot. Import a model first.', 'warn');
                state.autopilotActive = false;
                return;
            }
            
            resetTest();
            logMessage(`[TEST] Mode set to: ${mode.toUpperCase()}`, 'ok');
            
            // Enhanced autopilot with environment switching
            if (mode === 'autopilot') {
                if (state.testInterval) clearInterval(state.testInterval);
                if (state.environmentInterval) clearInterval(state.environmentInterval);
                
                // Switch environments every 15 seconds
                state.environmentInterval = setInterval(() => {
                    state.currentEnvironment = (state.currentEnvironment + 1) % state.trainingEnvironments.length;
                    state.test.environment = state.trainingEnvironments[state.currentEnvironment];
                    createEnhancedArena();
                    logMessage(`[TEST] Environment switched to: ${state.test.environment}`, 'ok');
                    updateTestUI();
                }, 15000);
                
                state.testInterval = setInterval(() => {
                    state.test.flightTime += 0.1;
                    state.test.distance += 1;
                    state.test.speed = 15 + Math.random() * 25;
                    state.test.battery = Math.max(0, state.test.battery - 0.1);
                    state.test.testAccuracy = Math.min(100, state.test.testAccuracy + 0.8);
                    state.test.progress = Math.min(100, state.test.progress + 1.5);
                    state.test.obstaclesPassed = Math.min(20, state.test.obstaclesPassed + Math.random());
                    
                    // Calculate score
                    state.test.score = Math.min(100, 
                        (state.test.testAccuracy * 0.4) + 
                        (state.test.progress * 0.3) + 
                        ((20 - state.test.collisions) * 2.5)
                    );
                    
                    // Update best run
                    if (state.test.score > state.test.bestRun) {
                        state.test.bestRun = state.test.score;
                    }
                    
                    // Calculate success rate
                    state.test.successRate = Math.min(100, (state.test.obstaclesPassed / 20) * 100);
                    
                    updateTestUI();
                    
                    if (state.test.progress >= 100) {
                        clearInterval(state.testInterval);
                        clearInterval(state.environmentInterval);
                        logMessage('[TEST] Autopilot test completed!', 'ok');
                        logMessage(`[TEST] Final Score: ${state.test.score.toFixed(1)}%`, 'perf');
                        logMessage(`[TEST] Best Run: ${state.test.bestRun.toFixed(1)}%`, 'perf');
                        logMessage(`[TEST] Success Rate: ${state.test.successRate.toFixed(1)}%`, 'perf');
                        
                        // Provide performance feedback
                        if (state.test.score < 60) {
                            logMessage('[FEEDBACK] Model needs more training. Focus on obstacle avoidance.', 'warn');
                        } else if (state.test.score < 80) {
                            logMessage('[FEEDBACK] Good performance. Try increasing creativity parameter.', 'ok');
                        } else {
                            logMessage('[FEEDBACK] Excellent performance! Model is well optimized.', 'ok');
                        }
                    }
                }, 100);
            }
        }

        function startFullTest() {
            if (document.getElementById('model-name').value === '') {
                logMessage('[TEST] No model loaded for full test. Import a model first.', 'warn');
                return;
            }
            
            state.fullTestActive = true;
            state.autopilotActive = true;
            resetTest();
            
            // Create additional random obstacles for full test
            createFullTestObstacles();
            
            logMessage('[TEST] Starting full test round with random obstacles', 'ok');
            logMessage('[TEST] Drone will test all paths and angles', 'ok');
            
            if (state.testInterval) clearInterval(state.testInterval);
            if (state.environmentInterval) clearInterval(state.environmentInterval);
            
            state.testInterval = setInterval(() => {
                state.test.flightTime += 0.1;
                state.test.distance += 1.5;
                state.test.speed = 20 + Math.random() * 30;
                state.test.battery = Math.max(0, state.test.battery - 0.15);
                state.test.testAccuracy = Math.min(100, state.test.testAccuracy + 1);
                state.test.progress = Math.min(100, state.test.progress + 2);
                state.test.obstaclesPassed = Math.min(50, state.test.obstaclesPassed + Math.random() * 1.5);
                
                // Calculate score
                state.test.score = Math.min(100, 
                    (state.test.testAccuracy * 0.3) + 
                    (state.test.progress * 0.4) + 
                    ((50 - state.test.collisions) * 0.6)
                );
                
                // Update best run
                if (state.test.score > state.test.bestRun) {
                    state.test.bestRun = state.test.score;
                }
                
                // Calculate success rate
                state.test.successRate = Math.min(100, (state.test.obstaclesPassed / 50) * 100);
                
                updateTestUI();
                
                if (state.test.progress >= 100) {
                    clearInterval(state.testInterval);
                    clearInterval(state.environmentInterval);
                    state.fullTestActive = false;
                    logMessage('[TEST] Full test round completed!', 'ok');
                    logMessage(`[TEST] Final Score: ${state.test.score.toFixed(1)}%`, 'perf');
                    logMessage(`[TEST] Best Run: ${state.test.bestRun.toFixed(1)}%`, 'perf');
                    logMessage(`[TEST] Success Rate: ${state.test.successRate.toFixed(1)}%`, 'perf');
                    logMessage(`[TEST] Total Distance: ${Math.round(state.test.distance)}m`, 'perf');
                    logMessage(`[TEST] Flight Time: ${state.test.flightTime.toFixed(1)}s`, 'perf');
                    
                    // Provide detailed performance feedback
                    if (state.test.score < 60) {
                        logMessage('[FEEDBACK] Model needs significant improvement in obstacle navigation.', 'warn');
                    } else if (state.test.score < 80) {
                        logMessage('[FEEDBACK] Good performance. Consider fine-tuning learning parameters.', 'ok');
                    } else {
                        logMessage('[FEEDBACK] Excellent performance! Model demonstrates strong navigation skills.', 'ok');
                    }
                }
            }, 100);
        }

        function createFullTestObstacles() {
            // Clear any existing test obstacles
            state.testObstacles.forEach(obj => state.scene.remove(obj));
            state.testObstacles = [];
            
            const obstacleMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xff0000,
                emissive: 0x440000
            });
            
            // Create random obstacles for full test
            for (let i = 0; i < 30; i++) {
                const x = (Math.random() - 0.5) * 24;
                const z = (Math.random() - 0.5) * 24;
                const y = Math.random() * 3 + 1;
                
                let geometry;
                if (Math.random() > 0.5) {
                    geometry = new THREE.BoxGeometry(
                        Math.random() * 1.5 + 0.5,
                        Math.random() * 2 + 1,
                        Math.random() * 1.5 + 0.5
                    );
                } else {
                    geometry = new THREE.CylinderGeometry(
                        Math.random() * 0.8 + 0.3,
                        Math.random() * 0.8 + 0.3,
                        Math.random() * 3 + 1,
                        8
                    );
                }
                
                const obstacle = new THREE.Mesh(geometry, obstacleMaterial);
                obstacle.position.set(x, y, z);
                obstacle.castShadow = true;
                state.scene.add(obstacle);
                state.testObstacles.push(obstacle);
            }
        }

        function resetTest() {
            state.test.flightTime = 0;
            state.test.distance = 0;
            state.test.collisions = 0;
            state.test.speed = 0;
            state.test.battery = 100;
            state.test.testAccuracy = 0;
            state.test.progress = 0;
            state.test.score = 0;
            state.test.obstaclesPassed = 0;
            state.test.environment = 'A';
            state.currentEnvironment = 0;
            state.fullTestActive = false;
            
            // Clear test obstacles
            state.testObstacles.forEach(obj => state.scene.remove(obj));
            state.testObstacles = [];
            
            if (state.testInterval) clearInterval(state.testInterval);
            if (state.environmentInterval) clearInterval(state.environmentInterval);
            
            createEnhancedArena();
            updateTestUI();
        }

        function updateTrainingUI() {
            document.getElementById('train-progress-bar').style.width = `${state.training.progress}%`;
            document.getElementById('train-progress').textContent = `${state.training.progress.toFixed(1)}%`;
            document.getElementById('accuracy').textContent = `${state.training.accuracy.toFixed(1)}%`;
            document.getElementById('active-nodes').textContent = state.training.activeNodes;
            document.getElementById('epoch').textContent = state.training.epoch;
            document.getElementById('response-time').textContent = `${state.training.responseTime.toFixed(1)}ms`;
            document.getElementById('loss').textContent = state.training.loss.toFixed(4);
            document.getElementById('complexity').textContent = state.training.complexity;
        }

        function updateTestUI() {
            document.getElementById('flight-time').textContent = state.test.flightTime.toFixed(1) + 's';
            document.getElementById('distance').textContent = Math.round(state.test.distance) + 'm';
            document.getElementById('collisions').textContent = state.test.collisions;
            document.getElementById('test-speed').textContent = state.test.speed.toFixed(1) + 'km/h';
            document.getElementById('test-battery').textContent = state.test.battery.toFixed(0) + '%';
            document.getElementById('test-accuracy').textContent = state.test.testAccuracy.toFixed(1) + '%';
            document.getElementById('test-progress-bar').style.width = `${state.test.progress}%`;
            document.getElementById('test-progress').textContent = `${state.test.progress.toFixed(1)}%`;
            document.getElementById('test-score').textContent = state.test.score.toFixed(1) + '%';
            document.getElementById('current-environment').textContent = state.test.environment;
            document.getElementById('obstacles-passed').textContent = state.test.obstaclesPassed;
            document.getElementById('best-run').textContent = state.test.bestRun.toFixed(1) + '%';
            document.getElementById('success-rate').textContent = state.test.successRate.toFixed(1) + '%';
            document.getElementById('current-learning-rate').textContent = state.qnn.learningRate.toFixed(2);
        }

        // Enhanced console command processing
        function processConsoleCommand() {
            const command = document.getElementById('console-input').value.trim();
            if (!command) return;
            
            logMessage(`> ${command}`, 'muted');
            document.getElementById('console-input').value = '';
            
            const parts = command.split(' ');
            const cmd = parts[0].toLowerCase();
            
            switch(cmd) {
                case '/help':
                    logMessage('[HELP] Available commands:', 'sys');
                    logMessage('  /help - Show this help message', 'sys');
                    logMessage('  /status - Show system status', 'sys');
                    logMessage('  /export - Export complete training log', 'sys');
                    logMessage('  /import - Import model for testing', 'sys');
                    logMessage('  /train [start|stop|reset] - Control endless training', 'sys');
                    logMessage('  /test [manual|autopilot|full] - Set test mode', 'sys');
                    logMessage('  /memory [size] - Set memory limit (64-1024MB)', 'sys');
                    logMessage('  /clear - Clear console', 'sys');
                    logMessage('  /log - Show recent training log', 'sys');
                    logMessage('[HELP] Flight Controls (TEST mode):', 'sys');
                    logMessage('  W/S - Forward/Backward', 'sys');
                    logMessage('  A/D - Left/Right', 'sys');
                    logMessage('  R/F - Up/Down', 'sys');
                    logMessage('[HELP] 3D Scene Controls:', 'sys');
                    logMessage('  Mouse Drag - Rotate camera', 'sys');
                    logMessage('  Mouse Wheel - Zoom in/out', 'sys');
                    break;
                    
                case '/status':
                    logMessage('[STATUS] Current mode: ' + state.currentMode.toUpperCase(), 'sys');
                    logMessage(`[STATUS] Training: ${state.training.running ? 'Running (24/7)' : 'Stopped'}`, 'sys');
                    logMessage(`[STATUS] Test mode: ${state.test.mode}`, 'sys');
                    logMessage(`[STATUS] Drone type: ${state.droneType}`, 'sys');
                    logMessage(`[STATUS] Memory: ${state.qnn.memoryUsed}MB/${state.qnn.memoryLimit}MB used`, 'sys');
                    logMessage(`[STATUS] Training rounds: ${state.training.rounds}`, 'sys');
                    break;
                    
                case '/export':
                    if (state.currentMode === 'train') {
                        exportModel();
                    } else {
                        logMessage('[ERROR] Export only available in TRAIN mode', 'err');
                    }
                    break;
                    
                case '/import':
                    if (state.currentMode === 'test') {
                        importModel();
                    } else {
                        logMessage('[ERROR] Import only available in TEST mode', 'err');
                    }
                    break;
                    
                case '/train':
                    const action = parts[1];
                    if (action === 'start') startTraining();
                    else if (action === 'stop') stopTraining();
                    else if (action === 'reset') resetTraining();
                    else logMessage('[ERROR] Usage: /train [start|stop|reset]', 'err');
                    break;
                    
                case '/test':
                    const mode = parts[1];
                    if (mode === 'manual' || mode === 'autopilot') {
                        setTestMode(mode);
                    } else if (mode === 'full') {
                        startFullTest();
                    } else {
                        logMessage('[ERROR] Usage: /test [manual|autopilot|full]', 'err');
                    }
                    break;
                    
                case '/memory':
                    const size = parseInt(parts[1]);
                    if (size >= 64 && size <= 1024) {
                        state.qnn.memoryLimit = size;
                        document.getElementById('memory-limit').value = size;
                        document.getElementById('memory-usage').textContent = size + 'MB';
                        logMessage(`[SYSTEM] Memory limit set to ${size}MB`, 'ok');
                    } else {
                        logMessage('[ERROR] Memory size must be between 64-1024MB', 'err');
                    }
                    break;
                    
                case '/log':
                    logMessage('[TRAINING LOG] Recent entries:', 'sys');
                    const recentLogs = state.trainingLog.slice(-5);
                    recentLogs.forEach(entry => {
                        logMessage(`  Epoch ${entry.epoch}: ${entry.accuracy.toFixed(2)}% accuracy, ${entry.loss.toFixed(4)} loss`, 'train-log');
                    });
                    break;
                    
                case '/clear':
                    document.getElementById('console-output').innerHTML = '';
                    break;
                    
                default:
                    logMessage(`[ERROR] Unknown command: ${cmd}. Type /help for available commands.`, 'err');
            }
        }

        // Log message to console
        function logMessage(message, type = 'muted') {
            const p = document.createElement('p');
            p.className = type;
            p.textContent = message;
            document.getElementById('console-output').appendChild(p);
            document.getElementById('console-output').scrollTop = document.getElementById('console-output').scrollHeight;
        }

        // Enhanced 3D Scene with multiple environments and camera controls
        function init3DScene() {
            try {
                const canvas = document.getElementById('three-canvas');
                const container = document.getElementById('scene-container');
                
                // Create scene
                state.scene = new THREE.Scene();
                state.scene.background = new THREE.Color(0x001122);
                
                // Create camera
                state.camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
                updateCameraPosition();
                
                // Create renderer
                state.renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
                state.renderer.setSize(container.clientWidth, container.clientHeight);
                state.renderer.shadowMap.enabled = true;
                state.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // Add enhanced lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                state.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 20, 10);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 50;
                directionalLight.shadow.camera.left = -20;
                directionalLight.shadow.camera.right = 20;
                directionalLight.shadow.camera.top = 20;
                directionalLight.shadow.camera.bottom = -20;
                state.scene.add(directionalLight);
                
                // Create enhanced arena
                createEnhancedArena();
                
                // Add camera controls
                setupCameraControls();
                
                // Start animation loop
                animate3D();
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    state.camera.aspect = container.clientWidth / container.clientHeight;
                    state.camera.updateProjectionMatrix();
                    state.renderer.setSize(container.clientWidth, container.clientHeight);
                });
                
                logMessage('[3D] Enhanced training environment initialized', 'ok');
                logMessage('[3D] 4 training environments ready for auto-pilot testing', 'ok');
                logMessage('[3D] Camera controls: Drag to rotate, Wheel to zoom', 'ok');
                
            } catch (error) {
                console.error('3D Scene initialization error:', error);
                logMessage(`[3D ERROR] ${error.message}`, 'err');
            }
        }

        // Set up camera controls for rotation and zoom
        function setupCameraControls() {
            const canvas = document.getElementById('three-canvas');
            
            // Mouse down event
            canvas.addEventListener('mousedown', (e) => {
                state.isMouseDown = true;
                state.mouseX = e.clientX;
                state.mouseY = e.clientY;
            });
            
            // Mouse move event
            canvas.addEventListener('mousemove', (e) => {
                if (!state.isMouseDown) return;
                
                const deltaX = e.clientX - state.mouseX;
                const deltaY = e.clientY - state.mouseY;
                
                state.cameraAngleX += deltaX * 0.01;
                state.cameraAngleY += deltaY * 0.01;
                
                // Limit vertical rotation
                state.cameraAngleY = Math.max(-Math.PI/2, Math.min(Math.PI/2, state.cameraAngleY));
                
                state.mouseX = e.clientX;
                state.mouseY = e.clientY;
                
                updateCameraPosition();
            });
            
            // Mouse up event
            canvas.addEventListener('mouseup', () => {
                state.isMouseDown = false;
            });
            
            // Mouse wheel event for zoom
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                state.cameraDistance += e.deltaY * 0.01;
                state.cameraDistance = Math.max(5, Math.min(50, state.cameraDistance));
                updateCameraPosition();
            });
        }

        // Update camera position based on current angles and distance
        function updateCameraPosition() {
            const x = state.cameraDistance * Math.cos(state.cameraAngleX) * Math.cos(state.cameraAngleY);
            const y = state.cameraDistance * Math.sin(state.cameraAngleY);
            const z = state.cameraDistance * Math.sin(state.cameraAngleX) * Math.cos(state.cameraAngleY);
            
            state.camera.position.set(x, y, z);
            state.camera.lookAt(0, 0, 0);
        }

        // Create enhanced arena with multiple environment layouts
        function createEnhancedArena() {
            // Clear previous objects
            if (state.drone) state.scene.remove(state.drone);
            state.obstacles.forEach(obj => state.scene.remove(obj));
            state.gates.forEach(obj => state.scene.remove(obj));
            state.obstacles = [];
            state.gates = [];
            
            // Add a detailed grid floor
            const gridSize = 30;
            const gridDivisions = 30;
            const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0x00ff00, 0x004400);
            gridHelper.position.y = 0;
            state.scene.add(gridHelper);
            
            // Add ground plane
            const groundGeometry = new THREE.PlaneGeometry(gridSize, gridSize);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x003300,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            state.scene.add(ground);
            
            // Create enhanced drone
            const droneGroup = new THREE.Group();
            
            // Drone body
            const bodyGeo = new THREE.BoxGeometry(0.8, 0.15, 0.8);
            const bodyMat = new THREE.MeshPhongMaterial({ color: 0x00ff00, emissive: 0x004400 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.castShadow = true;
            droneGroup.add(body);
            
            // Arms and propellers
            const armPositions = [[0.5, 0, 0.5], [-0.5, 0, 0.5], [0.5, 0, -0.5], [-0.5, 0, -0.5]];
            armPositions.forEach(([x, y, z]) => {
                const arm = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.03, 0.03, 1, 8),
                    new THREE.MeshPhongMaterial({ color: 0x333333 })
                );
                arm.rotation.z = Math.PI / 2;
                arm.position.set(x/2, y, z/2);
                arm.castShadow = true;
                droneGroup.add(arm);
                
                const propeller = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2, 0.2, 0.02, 16),
                    new THREE.MeshPhongMaterial({ color: 0x00ffff, transparent: true, opacity: 0.7 })
                );
                propeller.position.set(x, 0.1, z);
                propeller.castShadow = true;
                droneGroup.add(propeller);
            });
            
            // Central light
            const centralLight = new THREE.PointLight(0x00ff00, 1, 3);
            centralLight.position.set(0, 0.2, 0);
            droneGroup.add(centralLight);
            
            droneGroup.position.set(0, 3, 0);
            state.scene.add(droneGroup);
            state.drone = droneGroup;
            
            // Create obstacles based on current environment
            createEnvironmentObstacles();
            
            // Create training gates
            createTrainingGates();
        }

        // Create environment-specific obstacles
        function createEnvironmentObstacles() {
            const obstacleMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xff0000,
                emissive: 0x440000
            });
            
            // Different obstacle layouts for each environment
            const layouts = {
                A: [
                    { type: 'box', pos: [5, 1.5, 5], size: [2, 3, 2] },
                    { type: 'box', pos: [-5, 1.5, -5], size: [2, 3, 2] },
                    { type: 'cylinder', pos: [0, 1.5, 8], size: [1.5, 3, 1.5] },
                    { type: 'box', pos: [8, 1.5, -2], size: [1, 4, 1] },
                    { type: 'cylinder', pos: [-8, 1.5, 2], size: [1, 4, 1] }
                ],
                B: [
                    { type: 'box', pos: [3, 1.5, 3], size: [1, 3, 1] },
                    { type: 'box', pos: [-3, 1.5, -3], size: [1, 3, 1] },
                    { type: 'box', pos: [6, 1.5, -6], size: [1, 3, 1] },
                    { type: 'box', pos: [-6, 1.5, 6], size: [1, 3, 1] },
                    { type: 'cylinder', pos: [0, 1.5, 0], size: [2, 4, 2] }
                ],
                C: [
                    { type: 'cylinder', pos: [4, 1.5, 4], size: [1, 3, 1] },
                    { type: 'cylinder', pos: [-4, 1.5, -4], size: [1, 3, 1] },
                    { type: 'box', pos: [7, 1.5, 0], size: [1.5, 3, 1.5] },
                    { type: 'box', pos: [-7, 1.5, 0], size: [1.5, 3, 1.5] },
                    { type: 'cylinder', pos: [0, 1.5, 7], size: [1, 3, 1] },
                    { type: 'cylinder', pos: [0, 1.5, -7], size: [1, 3, 1] }
                ],
                D: [
                    { type: 'box', pos: [2, 1.5, 2], size: [1, 3, 1] },
                    { type: 'box', pos: [5, 1.5, 5], size: [1, 3, 1] },
                    { type: 'box', pos: [-2, 1.5, -2], size: [1, 3, 1] },
                    { type: 'box', pos: [-5, 1.5, -5], size: [1, 3, 1] },
                    { type: 'cylinder', pos: [8, 1.5, 0], size: [1, 4, 1] },
                    { type: 'cylinder', pos: [-8, 1.5, 0], size: [1, 4, 1] }
                ]
            };
            
            const currentLayout = layouts[state.test.environment] || layouts.A;
            
            currentLayout.forEach(obs => {
                let geometry;
                if (obs.type === 'cylinder') {
                    geometry = new THREE.CylinderGeometry(obs.size[0], obs.size[0], obs.size[1], 16);
                } else {
                    geometry = new THREE.BoxGeometry(obs.size[0], obs.size[1], obs.size[2]);
                }
                
                const obstacle = new THREE.Mesh(geometry, obstacleMaterial);
                obstacle.position.set(obs.pos[0], obs.pos[1], obs.pos[2]);
                obstacle.castShadow = true;
                state.scene.add(obstacle);
                state.obstacles.push(obstacle);
            });
        }

        // Create training gates
        function createTrainingGates() {
            const gateGeometry = new THREE.BoxGeometry(6, 4, 0.5);
            const gateMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x000000,
                emissive: 0x00ff00,
                transparent: true,
                opacity: 0.8
            });
            
            const gatePositions = [
                { x: 0, y: 2, z: -12 },
                { x: 8, y: 2, z: -8 },
                { x: 12, y: 2, z: 0 },
                { x: 8, y: 2, z: 8 },
                { x: 0, y: 2, z: 12 },
                { x: -8, y: 2, z: 8 },
                { x: -12, y: 2, z: 0 },
                { x: -8, y: 2, z: -8 }
            ];
            
            gatePositions.forEach((pos, index) => {
                const gate = new THREE.Mesh(gateGeometry, gateMaterial);
                gate.position.set(pos.x, pos.y, pos.z);
                gate.rotation.y = Math.atan2(pos.x, pos.z);
                gate.castShadow = true;
                state.scene.add(gate);
                state.gates.push({ mesh: gate, passed: false, index: index });
            });
        }

        // Enhanced 3D animation loop
        function animate3D() {
            requestAnimationFrame(animate3D);
            
            // Rotate drone propellers
            if (state.drone) {
                state.drone.children.forEach((child, index) => {
                    // Rotate propellers (they are at indices 5-8 after body and arms)
                    if (index >= 5 && index <= 8) {
                        child.rotation.y += 0.3;
                    }
                });
                
                // Move drone based on controls or autopilot
                if (state.currentMode === 'test') {
                    const speed = 0.15;
                    if (state.autopilotActive) {
                        // Enhanced autopilot with obstacle avoidance
                        simulateEnhancedAutopilot();
                    } else {
                        // Manual control
                        if (state.flightControls.forward) state.drone.position.z -= speed;
                        if (state.flightControls.backward) state.drone.position.z += speed;
                        if (state.flightControls.left) state.drone.position.x -= speed;
                        if (state.flightControls.right) state.drone.position.x += speed;
                        if (state.flightControls.up) state.drone.position.y += speed;
                        if (state.flightControls.down) state.drone.position.y -= speed;
                    }
                    
                    // Check gate passes and collisions
                    checkGatePasses();
                    checkCollisions();
                }
            }
            
            // Render the scene
            if (state.renderer && state.scene && state.camera) {
                state.renderer.render(state.scene, state.camera);
            }
        }

        // Enhanced autopilot with obstacle avoidance
        function simulateEnhancedAutopilot() {
            if (!state.drone || state.gates.length === 0) return;
            
            // Find the next unpassed gate
            const targetGate = state.gates.find(gate => !gate.passed);
            if (targetGate) {
                const targetPosition = targetGate.mesh.position;
                const direction = new THREE.Vector3();
                direction.subVectors(targetPosition, state.drone.position).normalize();
                
                // Basic obstacle avoidance
                let avoidVector = new THREE.Vector3();
                state.obstacles.forEach(obstacle => {
                    const obstacleDistance = state.drone.position.distanceTo(obstacle.position);
                    if (obstacleDistance < 4) {
                        const avoidDirection = new THREE.Vector3();
                        avoidDirection.subVectors(state.drone.position, obstacle.position).normalize();
                        avoidVector.add(avoidDirection.multiplyScalar(1 / obstacleDistance));
                    }
                });
                
                // Also avoid test obstacles in full test mode
                if (state.fullTestActive) {
                    state.testObstacles.forEach(obstacle => {
                        const obstacleDistance = state.drone.position.distanceTo(obstacle.position);
                        if (obstacleDistance < 3) {
                            const avoidDirection = new THREE.Vector3();
                            avoidDirection.subVectors(state.drone.position, obstacle.position).normalize();
                            avoidVector.add(avoidDirection.multiplyScalar(1.5 / obstacleDistance));
                        }
                    });
                }
                
                // Combine target direction and avoidance
                const combinedDirection = new THREE.Vector3();
                combinedDirection.addVectors(direction, avoidVector.multiplyScalar(2)).normalize();
                
                const speed = state.fullTestActive ? 0.18 : 0.12;
                state.drone.position.x += combinedDirection.x * speed;
                state.drone.position.y += combinedDirection.y * speed;
                state.drone.position.z += combinedDirection.z * speed;
                
                // Rotate drone towards target
                state.drone.lookAt(targetPosition);
            }
        }

        // Check if drone has passed through gates
        function checkGatePasses() {
            state.gates.forEach(gate => {
                if (!gate.passed) {
                    const distance = state.drone.position.distanceTo(gate.mesh.position);
                    if (distance < 3) {
                        gate.passed = true;
                        state.test.obstaclesPassed++;
                        logMessage(`[TEST] Gate ${gate.index + 1} passed`, 'ok');
                    }
                }
            });
        }

        // Check for collisions with obstacles
        function checkCollisions() {
            state.obstacles.forEach(obstacle => {
                const distance = state.drone.position.distanceTo(obstacle.position);
                if (distance < 1.8) {
                    state.test.collisions++;
                    updateTestUI();
                    
                    // Visual collision feedback
                    const originalEmissive = obstacle.material.emissive.getHex();
                    obstacle.material.emissive.setHex(0xffff00);
                    setTimeout(() => {
                        obstacle.material.emissive.setHex(originalEmissive);
                    }, 300);
                    
                    // Brief pause and reposition in autopilot
                    if (state.autopilotActive) {
                        state.drone.position.x += (Math.random() - 0.5) * 3;
                        state.drone.position.z += (Math.random() - 0.5) * 3;
                    }
                }
            });
            
            // Also check collisions with test obstacles in full test mode
            if (state.fullTestActive) {
                state.testObstacles.forEach(obstacle => {
                    const distance = state.drone.position.distanceTo(obstacle.position);
                    if (distance < 1.5) {
                        state.test.collisions++;
                        updateTestUI();
                        
                        // Visual collision feedback
                        const originalEmissive = obstacle.material.emissive.getHex();
                        obstacle.material.emissive.setHex(0xffff00);
                        setTimeout(() => {
                            obstacle.material.emissive.setHex(originalEmissive);
                        }, 300);
                        
                        // Brief pause and reposition in autopilot
                        if (state.autopilotActive) {
                            state.drone.position.x += (Math.random() - 0.5) * 2;
                            state.drone.position.z += (Math.random() - 0.5) * 2;
                        }
                    }
                });
            }
        }

        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>