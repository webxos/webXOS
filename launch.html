<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LAUNCH SEQUENCE by webXOS 2025</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* [All existing CSS remains exactly the same - no changes] */
        :root {
            --cyber-black: #000000;
            --cyber-green: #00ff9d;
            --cyber-blue: #00eeff;
            --cyber-purple: #b300ff;
            --cyber-red: #ff0040;
            --cyber-orange: #ff7700;
            --dark-bg: #001a00;
            --panel-bg: rgba(0, 30, 0, 0.85);
            --terminal-text: #00ff9d;
            --glitch-color-1: #ff0040;
            --glitch-color-2: #00eeff;
            --radius: 4px;
            --spacing-sm: 4px;
            --spacing-md: 8px;
            --spacing-lg: 12px;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
            font-size: 10pt;
        }
        
        body {
            background: radial-gradient(circle at center, var(--dark-bg), var(--cyber-black));
            color: var(--terminal-text);
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        body::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 30%, rgba(0, 255, 157, 0.05) 0%, transparent 20%),
                radial-gradient(circle at 80% 70%, rgba(0, 238, 255, 0.05) 0%, transparent 20%),
                radial-gradient(circle at 40% 80%, rgba(179, 0, 255, 0.05) 0%, transparent 20%);
            pointer-events: none;
            z-index: -1;
        }

        .cyber-header {
            padding: var(--spacing-md);
            border-bottom: 1px solid var(--cyber-green);
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 50px;
            width: 100%;
            background: rgba(0, 0, 0, 0.9);
            box-shadow: 0 0 15px rgba(0, 255, 157, 0.3);
            position: fixed;
            z-index: 1000;
        }
        
        h1 {
            font-size: 12pt;
            letter-spacing: 0.5px;
            color: var(--cyber-green);
            font-weight: bold;
            text-shadow: 0 0 8px var(--cyber-green), 0 0 16px var(--cyber-green);
        }
        
        .mode-tabs {
            display: flex;
            gap: var(--spacing-sm);
        }
        
        .mode-tab {
            padding: 4px 8px;
            background: var(--panel-bg);
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            cursor: pointer;
            font-size: 9pt;
            transition: all 0.3s ease;
            box-shadow: 0 0 5px currentColor;
        }
        
        .mode-tab:hover {
            box-shadow: 0 0 10px currentColor, 0 0 15px currentColor;
        }
        
        .mode-tab.active {
            background: var(--cyber-green);
            color: #000;
            box-shadow: 0 0 10px var(--cyber-green), 0 0 20px var(--cyber-green);
        }
        
        main {
            display: flex;
            flex: 1;
            overflow: hidden;
            width: 100%;
            padding: var(--spacing-md);
            gap: var(--spacing-md);
            min-height: 0;
            margin-top: 60px;
            height: calc(100vh - 140px);
        }
        
        .cyber-panel {
            background: var(--panel-bg);
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            padding: var(--spacing-md);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 10px rgba(0, 255, 157, 0.2);
        }
        
        .left-panel, .right-panel {
            width: 280px;
        }
        
        .center-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
            min-height: 0;
        }
        
        .combat-arena-container {
            flex: 1;
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            overflow: hidden;
            position: relative;
            min-height: 0;
            background: var(--cyber-black);
            box-shadow: 0 0 15px rgba(0, 255, 157, 0.3);
        }

        #three-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .scene-controls {
            position: absolute;
            bottom: 6px;
            left: 6px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            padding: 4px;
            z-index: 10;
            font-size: 8pt;
            box-shadow: 0 0 5px var(--cyber-green);
        }
        
        .qnn-overlay {
            position: absolute;
            top: 6px;
            right: 6px;
            width: 100px;
            height: 100px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            padding: 3px;
            z-index: 10;
            box-shadow: 0 0 5px var(--cyber-green);
        }
        
        .antifragility-overlay {
            position: absolute;
            top: 6px;
            left: 6px;
            width: 100px;
            height: 100px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            padding: 3px;
            z-index: 10;
            box-shadow: 0 0 5px var(--cyber-green);
        }
        
        .qnn-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 1px;
            width: 100%;
            height: 100%;
        }
        
        .qnn-cell {
            background: #000;
            border: 1px solid #008800;
            transition: all 0.3s ease;
        }
        
        .qnn-cell.active {
            background: var(--cyber-green);
            box-shadow: 0 0 3px var(--cyber-green);
        }
        
        .qnn-cell.training {
            background: #ffcc00;
            animation: pulse 1s infinite;
        }
        
        .qnn-cell.learned {
            background: #00cc00;
            box-shadow: 0 0 3px #00cc00;
        }
        
        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }

        .antifragility-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 1px;
            width: 100%;
            height: 100%;
            position: relative;
        }

        .antifragility-cell {
            background: #000;
            border: 1px solid #008800;
            transition: all 0.3s ease;
        }

        .antifragility-cell.stressed {
            background: var(--cyber-red);
            box-shadow: 0 0 3px var(--cyber-red);
        }

        .antifragility-cell.stable {
            background: var(--cyber-green);
            box-shadow: 0 0 3px var(--cyber-green);
        }

        .green-dot {
            position: absolute;
            width: 8px;
            height: 8px;
            background: var(--cyber-green);
            border-radius: 50%;
            border: 1px solid var(--cyber-blue);
            box-shadow: 0 0 5px var(--cyber-green), 0 0 10px var(--cyber-green);
            transition: all 0.2s ease;
        }
        
        .console-container {
            height: 180px;
            background: var(--panel-bg);
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            padding: var(--spacing-md);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 255, 157, 0.2);
        }
        
        .console-output {
            flex: 1;
            background: #000;
            border-radius: var(--radius);
            padding: var(--spacing-md);
            overflow-y: auto;
            font-size: 9pt;
            margin-bottom: var(--spacing-sm);
            border: 1px solid var(--cyber-green);
            position: relative;
        }
        
        .console-output p {
            margin: 2px 0;
        }
        
        .ok { color: #7dff7d; }
        .warn { color: #ffea7d; }
        .err { color: #ff7d7d; }
        .sys { color: #7dd9ff; }
        .muted { color: #aaaaaa; }
        .train-log { color: #ffcc00; }
        .perf { color: #ff00ff; }
        
        .console-input {
            display: flex;
            gap: var(--spacing-sm);
            flex-shrink: 0;
            height: 32px;
        }
        
        .input-line {
            flex: 1;
            background: #000;
            border: 1px solid var(--cyber-green);
            color: var(--terminal-text);
            padding: 6px 8px;
            border-radius: var(--radius);
            font-size: 9pt;
            box-shadow: 0 0 5px var(--cyber-green);
        }
        
        .input-send {
            padding: 6px 10px;
            border-radius: var(--radius);
            background: #000;
            border: 1px solid var(--cyber-green);
            color: var(--terminal-text);
            cursor: pointer;
            flex-shrink: 0;
            font-size: 9pt;
            transition: all 0.3s ease;
            box-shadow: 0 0 5px var(--cyber-green);
        }
        
        .input-send:hover {
            background: var(--cyber-green);
            color: #000;
            box-shadow: 0 0 10px var(--cyber-green), 0 0 15px var(--cyber-green);
        }
        
        .copy-log {
            position: absolute;
            top: 5px;
            right: 5px;
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            color: var(--cyber-green);
            cursor: pointer;
            font-size: 8pt;
            z-index: 5;
        }
        
        .copy-log:hover {
            background: var(--cyber-green);
            color: #000;
        }
        
        footer {
            padding: var(--spacing-md);
            border-top: 1px solid var(--cyber-green);
            text-align: center;
            font-size: 8pt;
            color: #008800;
            height: 32px;
            width: 100%;
            background: rgba(0, 0, 0, 0.8);
            flex-shrink: 0;
        }
        
        .btn {
            padding: 6px 8px;
            border-radius: var(--radius);
            border: 1px solid var(--cyber-green);
            background: #000;
            color: var(--terminal-text);
            cursor: pointer;
            margin: 2px 0;
            transition: all 0.3s ease;
            font-size: 9pt;
            box-shadow: 0 0 5px currentColor;
        }
        
        .btn:hover {
            background: var(--cyber-green);
            color: #000;
            box-shadow: 0 0 10px var(--cyber-green), 0 0 15px var(--cyber-green);
        }
        
        .btn-primary {
            background: var(--cyber-green);
            color: #000;
            box-shadow: 0 0 10px var(--cyber-green), 0 0 15px var(--cyber-green);
        }
        
        .drone-type {
            padding: 4px 6px;
            background: #000;
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            text-align: center;
            cursor: pointer;
            margin: 1px;
            transition: all 0.3s ease;
            font-size: 8pt;
            box-shadow: 0 0 5px currentColor;
        }
        
        .drone-type:hover {
            box-shadow: 0 0 10px currentColor, 0 0 15px currentColor;
        }
        
        .drone-type.active {
            background: var(--cyber-green);
            color: #000;
            box-shadow: 0 0 10px var(--cyber-green), 0 0 15px var(--cyber-green);
        }

        .metric {
            background: #000;
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            padding: 6px;
            text-align: center;
            margin: 3px 0;
            box-shadow: 0 0 5px var(--cyber-green);
        }
        
        .metric-val {
            font-size: 10pt;
            font-weight: bold;
            color: var(--cyber-green);
        }
        
        .slider-container {
            margin: 6px 0;
        }
        
        .slider-container label {
            display: block;
            margin-bottom: 3px;
            font-size: 9pt;
        }
        
        .mode-panel {
            display: none;
        }
        
        .mode-panel.active {
            display: block;
        }
        
        .progress-bar {
            height: 8px;
            background: #000;
            border: 1px solid var(--cyber-green);
            border-radius: 4px;
            overflow: hidden;
            margin: 3px 0;
        }
        
        .progress {
            height: 100%;
            background: var(--cyber-green);
            width: 0%;
            transition: width 0.3s ease;
        }

        .memory-control {
            background: #000;
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            padding: 6px;
            margin: 3px 0;
            font-size: 8pt;
            box-shadow: 0 0 5px var(--cyber-green);
        }

        .training-stats {
            background: #000;
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            padding: 6px;
            margin: 3px 0;
            font-size: 8pt;
            box-shadow: 0 0 5px var(--cyber-green);
        }

        .panel-section {
            margin-bottom: var(--spacing-md);
        }
        
        .panel-section h2 {
            font-size: 10pt;
            margin-bottom: var(--spacing-sm);
            border-bottom: 1px solid #008800;
            padding-bottom: 2px;
            text-shadow: 0 0 5px var(--cyber-green);
        }
        
        .compact-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-sm);
        }
        
        .compact-row {
            display: flex;
            justify-content: space-between;
            margin: 2px 0;
        }
        
        .compact-row label {
            font-size: 8pt;
        }
        
        .compact-row span {
            font-size: 9pt;
            font-weight: bold;
            color: var(--cyber-green);
        }
        
        .drone-type-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-md);
        }
        
        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-sm);
        }
        
        .btn-group-vertical {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-md);
        }
        
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #000;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--cyber-green);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--cyber-blue);
        }

        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }

        .glitch-effect {
            position: relative;
        }

        .glitch-effect::before,
        .glitch-effect::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .glitch-effect::before {
            animation: glitch-1 0.5s infinite;
            color: var(--glitch-color-1);
            z-index: -1;
        }

        .glitch-effect::after {
            animation: glitch-2 0.5s infinite;
            color: var(--glitch-color-2);
            z-index: -2;
        }

        @keyframes glitch-1 {
            0% { transform: translate(0); }
            20% { transform: translate(-1px, 1px); }
            40% { transform: translate(-1px, -1px); }
            60% { transform: translate(1px, 1px); }
            80% { transform: translate(1px, -1px); }
            100% { transform: translate(0); }
        }

        @keyframes glitch-2 {
            0% { transform: translate(0); }
            20% { transform: translate(1px, -1px); }
            40% { transform: translate(1px, 1px); }
            60% { transform: translate(-1px, -1px); }
            80% { transform: translate(-1px, 1px); }
            100% { transform: translate(0); }
        }

        @keyframes static {
            0% { background-position: 0 0; }
            100% { background-position: 0 100%; }
        }

        .console-output::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(transparent 50%, rgba(0, 255, 157, 0.03) 50%);
            background-size: 100% 4px;
            animation: static 0.2s infinite;
            pointer-events: none;
            z-index: 1;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--panel-bg);
            border: 1px solid var(--cyber-green);
            border-radius: var(--radius);
            padding: var(--spacing-md);
            width: 400px;
            max-width: 90%;
            box-shadow: 0 0 20px var(--cyber-green);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--cyber-green);
            padding-bottom: var(--spacing-sm);
        }

        .modal-title {
            font-size: 12pt;
            color: var(--cyber-green);
            text-shadow: 0 0 5px var(--cyber-green);
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--cyber-green);
            font-size: 14pt;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-body {
            margin-bottom: var(--spacing-md);
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: var(--spacing-sm);
        }

        .file-input {
            display: none;
        }

        .file-label {
            display: block;
            padding: var(--spacing-md);
            border: 1px dashed var(--cyber-green);
            border-radius: var(--radius);
            text-align: center;
            cursor: pointer;
            margin-bottom: var(--spacing-md);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .file-label:hover {
            background: rgba(0, 255, 157, 0.1);
            box-shadow: 0 0 10px var(--cyber-green);
        }

        .file-label input[type="file"] {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .status-exporting {
            background: #ffcc00;
            animation: pulse 1s infinite;
        }

        .status-importing {
            background: #00ccff;
            animation: pulse 1s infinite;
        }

        .status-success {
            background: #00cc00;
        }

        .status-error {
            background: #ff0040;
        }
    </style>
</head>
<body>
    <header class="cyber-header">
        <h1 class="glitch-effect" data-text="LAUNCH SEQUENCE - WEBXOS 2025">LAUNCH SEQUENCE - WEBXOS 2025</h1>
        <div class="mode-tabs">
            <div class="mode-tab active" data-mode="train">TRAIN</div>
            <div class="mode-tab" data-mode="test">TEST</div>
        </div>
    </header>
    
    <main>
        <div class="left-panel cyber-panel">
            <div class="mode-panel active" id="train-panel">
                <div class="panel-section">
                    <h2>Training Controls</h2>
                    <!-- REMOVED: Drone type selector -->
                    
                    <div class="slider-container">
                        <div class="compact-row">
                            <label>Learning Rate:</label>
                            <span id="learning-rate-value">0.10</span>
                        </div>
                        <input type="range" id="learning-rate" min="0.01" max="1.0" step="0.01" value="0.1" style="width:100%">
                    </div>
                    
                    <div class="slider-container">
                        <div class="compact-row">
                            <label>Creativity:</label>
                            <span id="creativity-value">0.70</span>
                        </div>
                        <input type="range" id="creativity" min="0.0" max="1.0" step="0.01" value="0.7" style="width:100%">
                    </div>

                    <div class="memory-control">
                        <div class="compact-row">
                            <label>Training Memory:</label>
                            <span id="memory-usage">128MB</span>
                        </div>
                        <input type="range" id="memory-limit" min="1" max="4096" step="1" value="128" style="width:100%">
                    </div>
                </div>
                
                <div class="panel-section">
                    <h2>Antifragility Controls</h2>
                    <div class="slider-container">
                        <div class="compact-row">
                            <label>X-Antifragility (Stability):</label>
                            <span id="x-antifragility-value">0.50</span>
                        </div>
                        <input type="range" id="x-antifragility" min="0.0" max="1.0" step="0.01" value="0.5" style="width:100%">
                    </div>
                    <div class="slider-container">
                        <div class="compact-row">
                            <label>Y-Antifragility (Adaptability):</label>
                            <span id="y-antifragility-value">0.50</span>
                        </div>
                        <input type="range" id="y-antifragility" min="0.0" max="1.0" step="0.01" value="0.5" style="width:100%">
                    </div>
                </div>
                
                <div class="panel-section">
                    <h2>Training Actions</h2>
                    <div class="btn-group-vertical">
                        <button class="btn btn-primary" id="start-train">Start Endless Training</button>
                        <div class="btn-group">
                            <button class="btn" id="stop-train">Pause</button>
                            <button class="btn" id="reset-train">Reset</button>
                        </div>
                        <button class="btn" id="export-model">Export Training Log</button>
                        <button class="btn" id="import-model" style="display:none">Import Training Data</button>
                    </div>
                </div>
            </div>
            
            <div class="mode-panel" id="test-panel">
                <div class="panel-section">
                    <h2>Test Controls</h2>
                    <div class="btn-group-vertical">
                        <button class="btn btn-primary" id="autopilot-test">SEARCH & RESCUE TEST</button>
                        <button class="btn" id="test-stop">TEST STOP</button>
                        <button class="btn" id="import-json">IMPORT JSON</button>
                        <button class="btn" id="new-course">NEW FOREST</button>
                        <button class="btn" id="fpv-camera">FPV CAMERA</button>
                    </div>
                </div>
                
                <div class="panel-section">
                    <h2>Drone Configuration</h2>
                    <div class="slider-container">
                        <div class="compact-row">
                            <label>Drone Speed:</label>
                            <span id="drone-speed-value">1.0x</span>
                        </div>
                        <input type="range" id="drone-speed" min="0" max="3" step="0.1" value="1.0" style="width:100%">
                    </div>
                    
                    <div class="slider-container">
                        <div class="compact-row">
                            <label>Environment Complexity:</label>
                            <span id="complexity-value">0.50</span>
                        </div>
                        <input type="range" id="environment-complexity" min="0.0" max="1.0" step="0.01" value="0.5" style="width:100%">
                    </div>
                </div>
                
                <!-- REMOVED: Environment selection (only forest mode now) -->
            </div>
        </div>
        
        <div class="center-panel">
            <div class="combat-arena-container" id="scene-container">
                <canvas id="three-canvas"></canvas>
                <div class="scene-controls">
                    <div>Mouse: Drag to rotate</div>
                    <div>Wheel: Zoom in/out</div>
                </div>
                <div class="qnn-overlay">
                    <div class="qnn-grid" id="qnn-grid">
                    </div>
                </div>
                <div class="antifragility-overlay">
                    <div class="antifragility-grid" id="antifragility-grid">
                    </div>
                </div>
            </div>
            <div class="console-container">
                <div class="console-output" id="console-output">
                    <p class="sys">[SYSTEM] LAUNCH SEQUENCE initialized</p>
                    <p class="sys">[SYSTEM] Search & Rescue Forest ready</p>
                    <p class="sys">[SYSTEM] Type /help for available commands</p>
                </div>
                <button class="copy-log" id="copy-log">COPY LOG</button>
                <div class="console-input">
                    <input type="text" class="input-line" id="console-input" placeholder="Type /help for commands...">
                    <button class="input-send" id="console-send">SEND</button>
                </div>
            </div>
        </div>
        
        <div class="right-panel cyber-panel">
            <div class="mode-panel active" id="train-right-panel">
                <div class="panel-section">
                    <h2>Training Status</h2>
                    <div class="training-stats">
                        <div class="compact-row">
                            <label>Training Rounds:</label>
                            <span id="training-rounds">173823</span>
                        </div>
                        <div class="compact-row">
                            <label>Total Time:</label>
                            <span id="total-training-time">289h 42m</span>
                        </div>
                        <div class="compact-row">
                            <label>Best Score:</label>
                            <span id="best-score">0.0%</span>
                        </div>
                    </div>
                    
                    <div class="progress-bar">
                        <div class="progress" id="train-progress-bar" style="width: 0%"></div>
                    </div>
                    <div class="compact-row">
                        <label>Training Progress:</label>
                        <span id="train-progress">0%</span>
                    </div>
                    
                    <div class="metrics-grid">
                        <div class="metric">
                            <div class="metric-val" id="accuracy">0%</div>
                            <div>Accuracy</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="active-nodes">0</div>
                            <div>Active Nodes</div>
                        </div>
                    </div>
                </div>
                
                <div class="panel-section">
                    <h2>Training Data</h2>
                    <div class="metric">
                        <div>Model: <input type="text" id="model-name" placeholder="Model Name" style="background: #000; color: var(--cyber-green); border: 1px solid #008800; padding: 4px; width: 100%; font-size: 9pt;"></div>
                    </div>
                    
                    <div class="metrics-grid">
                        <div class="metric">
                            <div class="metric-val" id="epoch">0</div>
                            <div>Epoch</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="loss">0.00</div>
                            <div>Loss</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="complexity">Low</div>
                            <div>Complexity</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="response-time">0ms</div>
                            <div>Response Time</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="robustness-score">0%</div>
                            <div>Robustness</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="stress-response">0.00</div>
                            <div>Stress Response</div>
                        </div>
                    </div>
                    
                    <div class="training-stats">
                        <div class="compact-row">
                            <label>Training Cycles:</label>
                            <span id="training-cycles">0</span>
                        </div>
                        <div class="compact-row">
                            <label>Data Points:</label>
                            <span id="data-points">0</span>
                        </div>
                        <div class="compact-row">
                            <label>Memory Used:</label>
                            <span id="memory-used">0MB</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="mode-panel" id="test-right-panel">
                <div class="panel-section">
                    <h2>Search & Rescue Status</h2>
                    <div class="training-stats">
                        <div class="compact-row">
                            <label>Test Status:</label>
                            <span id="test-status">Idle</span>
                        </div>
                        <div class="compact-row">
                            <label>Test Score:</label>
                            <span id="test-score">0%</span>
                        </div>
                        <div class="compact-row">
                            <label>Environment:</label>
                            <span id="current-environment">Forest</span>
                        </div>
                        <div class="compact-row">
                            <label id="escapes-label">Objects Collected:</label>
                            <span id="escapes">0/3</span>
                        </div>
                    </div>
                    
                    <div class="metrics-grid">
                        <div class="metric">
                            <div class="metric-val" id="flight-time">0s</div>
                            <div>Flight Time</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="distance">0m</div>
                            <div>Distance</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="collisions">0</div>
                            <div>Collisions</div>
                        </div>
                        <div class="metric">
                            <div class="metric-val" id="test-speed">0 km/h</div>
                            <div>Speed</div>
                        </div>
                    </div>
                    
                    <div class="progress-bar">
                        <div class="progress" id="test-progress-bar" style="width: 0%"></div>
                    </div>
                    <div class="compact-row">
                        <label>Mission Progress:</label>
                        <span id="test-progress">0%</span>
                    </div>
                </div>
            </div>
        </div>
    </main>
    
    <footer>
        WEBXOS 2025 | LAUNCH SEQUENCE v1.5.0 | Search & Rescue Forest | Lattice Integration
    </footer>

    <div class="modal" id="import-modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Import Training Data</div>
                <button class="modal-close" id="import-close">&times;</button>
            </div>
            <div class="modal-body">
                <label class="file-label" id="import-drop-area">
                    <span>Drop JSON file here or click to browse</span>
                    <input type="file" id="import-file" class="file-input" accept=".json">
                </label>
                <div id="import-status">
                    <span class="status-indicator" id="import-status-indicator"></span>
                    <span id="import-status-text">Ready to import</span>
                </div>
                <div id="import-preview" style="display: none; margin-top: 10px;">
                    <h3>Import Preview:</h3>
                    <div id="import-preview-content" style="max-height: 200px; overflow-y: auto; background: #000; padding: 10px; border-radius: 4px; font-size: 9pt;"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="import-cancel">Cancel</button>
                <button class="btn btn-primary" id="import-confirm" disabled>Import</button>
            </div>
        </div>
    </div>

    <div class="modal" id="export-modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Export Training Data</div>
                <button class="modal-close" id="export-close">&times;</button>
            </div>
            <div class="modal-body">
                <div class="compact-row">
                    <label>Model Name:</label>
                    <input type="text" id="export-model-name" placeholder="Enter model name" style="background: #000; color: var(--cyber-green); border: 1px solid #008800; padding: 4px; width: 60%; font-size: 9pt;">
                </div>
                <div class="compact-row">
                    <label>Include Training Log:</label>
                    <input type="checkbox" id="export-include-log" checked style="margin-left: 10px;">
                </div>
                <div class="compact-row">
                    <label>Include QNN State:</label>
                    <input type="checkbox" id="export-include-qnn" checked style="margin-left: 10px;">
                </div>
                <div class="compact-row">
                    <label>Data Size:</label>
                    <span id="export-data-size">0 KB</span>
                </div>
                <div id="export-status">
                    <span class="status-indicator" id="export-status-indicator"></span>
                    <span id="export-status-text">Ready to export</span>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" id="export-cancel">Cancel</button>
                <button class="btn btn-primary" id="export-confirm">Export</button>
            </div>
        </div>
    </div>

    <script>
        // Enhanced global state with Search & Rescue Forest
        const state = {
            currentMode: 'train',
            droneType: 'unified', // Unified drone type
            environmentType: 'forest', // Only forest mode now
            training: {
                running: false,
                endless: false,
                progress: 0,
                epoch: 0,
                loss: 2.5,
                accuracy: 0,
                activeNodes: 0,
                responseTime: 0,
                complexity: 'Low',
                rounds: 173823,
                totalTime: 289 * 60 + 42, // in minutes
                bestScore: 0,
                cycles: 0,
                dataPoints: 0
            },
            test: {
                mode: 'search_rescue',
                flightTime: 0,
                distance: 0,
                collisions: 0,
                speed: 0,
                battery: 100,
                testAccuracy: 0,
                progress: 0,
                score: 0,
                environment: 'Forest',
                objectsCollected: 0,
                totalObjects: 3,
                successRate: 0,
                bestRun: 0,
                status: 'Idle',
                droneSpeed: 1.0,
                startTime: 0,
                startPosition: null,
                missionComplete: false,
                returnHome: false,
                searchAndRescueTime: 0,
                bestSearchTime: 0,
                attempts: 0
            },
            qnn: {
                grid: Array(10).fill().map(() => Array(10).fill('inactive')),
                learningRate: 0.1,
                creativity: 0.7,
                memoryLimit: 128,
                memoryUsed: 0,
                antifragilityX: 0.5,
                antifragilityY: 0.5,
                robustnessScore: 0,
                stressResponse: 0
            },
            environmentComplexity: 0.5,
            scene: null,
            camera: null,
            renderer: null,
            drone: null,
            obstacles: [],
            collectibles: [], // Red triangle objects to collect
            trees: [],
            trainingEnvironments: ['A', 'B', 'C', 'D'],
            currentEnvironment: 0,
            flightControls: {
                forward: false,
                backward: false,
                left: false,
                right: false,
                up: false,
                down: false
            },
            autopilotActive: false,
            trainingInterval: null,
            testInterval: null,
            environmentInterval: null,
            trainingLog: [],
            serviceWorker: null,
            isMouseDown: false,
            mouseX: 0,
            mouseY: 0,
            cameraDistance: 20,
            cameraAngleX: 0,
            cameraAngleY: 0.5,
            fpvCamera: false,
            testActive: false,
            testObstacles: [],
            testStartTime: 0,
            testDuration: 180000, // 3 minutes for search and rescue
            reinforcementAgent: {
                learning: true,
                score: 0,
                attempts: 0,
                improvement: 0
            },
            importData: null,
            exportData: null,
            forestTargetDirection: null,
            forestLastDirectionChange: 0,
            forestDirectionChangeInterval: 2000,
            forestEscapeBoundary: 40,
            forestStartTime: 0,
            forestCurrentSearchTime: 0,
            testData: [],
            // NEW: Enhanced scene state
            sceneStats: {
                fps: 60,
                treeCount: 0,
                objectCount: 0,
                performanceWarnings: []
            },
            // NEW: Lattice export state
            latticeExport: {
                entityId: '',
                lastExport: null,
                format: 'lattice_v1'
            }
        };

        // Initialize the application with enhanced training
        function init() {
            setupEventListeners();
            generateQNNGrid();
            generateAntifragilityGrid();
            initEnhanced3DScene(); // Enhanced 3D scene
            initServiceWorker();
            loadTrainingData();
            updateTrainingUI();
            updateTrainingStats();
            setupPerformanceMonitoring(); // NEW: Performance monitoring
            logMessage('[SYSTEM] LAUNCH SEQUENCE initialized with Enhanced 3D Scene', 'sys');
            logMessage('[SYSTEM] Search & Rescue Forest with Lattice JSON ready', 'sys');
            logMessage('[SYSTEM] Type /help for available commands', 'sys');
            
            // Hide import button in train mode, export in test mode
            updateImportExportVisibility();
        }

        // NEW: Enhanced 3D scene initialization with error handling
        function initEnhanced3DScene() {
            try {
                const container = document.getElementById('scene-container');
                if (!container) {
                    throw new Error('Scene container not found');
                }

                const width = container.clientWidth;
                const height = container.clientHeight;
                
                // Create scene with cyberpunk background
                state.scene = new THREE.Scene();
                state.scene.background = new THREE.Color(0x001100);
                state.scene.fog = new THREE.Fog(0x001100, 20, 80);
                
                // Enhanced camera setup
                state.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
                state.camera.position.set(15, 15, 15);
                state.camera.lookAt(0, 0, 0);
                
                // Robust renderer with error handling
                try {
                    state.renderer = new THREE.WebGLRenderer({ 
                        antialias: true,
                        powerPreference: "high-performance"
                    });
                    state.renderer.setSize(width, height);
                    state.renderer.shadowMap.enabled = true;
                    state.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                    state.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                    
                    const canvas = document.getElementById('three-canvas');
                    if (canvas) canvas.remove();
                    state.renderer.domElement.id = 'three-canvas';
                    container.appendChild(state.renderer.domElement);
                } catch (error) {
                    logMessage(`[ERROR] WebGL not supported: ${error.message}`, 'err');
                    return;
                }
                
                // Enhanced lighting
                setupEnhancedLighting();
                
                // Create optimized ground
                createOptimizedGround();
                
                // Create drone
                createEnhancedDrone();
                
                // Generate optimized forest
                generateOptimizedForest();
                
                // Start animation loop
                animate();
                
                // Handle window resize
                setupWindowResizeHandler();
                
                logMessage('[3D] Enhanced scene initialized successfully', 'ok');
                
            } catch (error) {
                logMessage(`[ERROR] 3D Scene initialization failed: ${error.message}`, 'err');
            }
        }

        // NEW: Enhanced lighting setup
        function setupEnhancedLighting() {
            // Ambient light for base illumination
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            state.scene.add(ambientLight);
            
            // Main directional light (sun)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -25;
            directionalLight.shadow.camera.right = 25;
            directionalLight.shadow.camera.top = 25;
            directionalLight.shadow.camera.bottom = -25;
            state.scene.add(directionalLight);
            
            // Fill light for softer shadows
            const fillLight = new THREE.DirectionalLight(0x5577aa, 0.3);
            fillLight.position.set(-10, 10, -5);
            state.scene.add(fillLight);
            
            // Cyberpunk accent lights
            const accentLight1 = new THREE.PointLight(0x00ff9d, 0.3, 15);
            accentLight1.position.set(15, 5, 15);
            state.scene.add(accentLight1);
            
            const accentLight2 = new THREE.PointLight(0x00eeff, 0.2, 15);
            accentLight2.position.set(-15, 5, -15);
            state.scene.add(accentLight2);
        }

        // NEW: Optimized ground creation
        function createOptimizedGround() {
            // Main ground plane - ENLARGED FOR FOREST
            const groundGeometry = new THREE.PlaneGeometry(80, 80);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x004400,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            state.scene.add(ground);
            
            // Enhanced grid helper
            const gridHelper = new THREE.GridHelper(80, 80, 0x00ff00, 0x004400);
            gridHelper.position.y = 0.01;
            state.scene.add(gridHelper);
            
            // Boundary markers
            createBoundaryMarkers();
        }

        // NEW: Create boundary markers for the forest
        function createBoundaryMarkers() {
            const boundarySize = 80;
            const markerGeometry = new THREE.BoxGeometry(0.5, 2, 0.5);
            const markerMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00ff00,
                emissive: 0x004400,
                emissiveIntensity: 0.3
            });
            
            // Create corner markers
            const corners = [
                { x: -boundarySize/2, z: -boundarySize/2 },
                { x: boundarySize/2, z: -boundarySize/2 },
                { x: boundarySize/2, z: boundarySize/2 },
                { x: -boundarySize/2, z: boundarySize/2 }
            ];
            
            corners.forEach(corner => {
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.set(corner.x, 1, corner.z);
                marker.castShadow = true;
                state.scene.add(marker);
            });
        }

        // NEW: Enhanced drone creation
        function createEnhancedDrone() {
            const droneGroup = new THREE.Group();
            
            // Enhanced drone body
            const bodyGeometry = new THREE.BoxGeometry(1, 0.2, 1);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x222222,
                metalness: 0.8,
                roughness: 0.2
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            droneGroup.add(body);
            
            // Enhanced drone arms
            const armGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.3, 8);
            const armMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x444444,
                metalness: 0.6,
                roughness: 0.3
            });
            
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI / 2);
                const arm = new THREE.Mesh(armGeometry, armMaterial);
                arm.rotation.x = Math.PI / 2;
                arm.position.x = Math.cos(angle) * 0.6;
                arm.position.y = 0.1;
                arm.position.z = Math.sin(angle) * 0.6;
                arm.castShadow = true;
                droneGroup.add(arm);
                
                // Add rotors
                const rotorGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.05, 16);
                const rotorMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x888888,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const rotor = new THREE.Mesh(rotorGeometry, rotorMaterial);
                rotor.position.x = Math.cos(angle) * 0.6;
                rotor.position.y = 0.2;
                rotor.position.z = Math.sin(angle) * 0.6;
                rotor.castShadow = true;
                droneGroup.add(rotor);
            }
            
            // Navigation lights
            const frontLight = new THREE.PointLight(0x00eeff, 0.5, 2);
            frontLight.position.set(0, 0.1, -0.5);
            droneGroup.add(frontLight);
            
            const rearLight = new THREE.PointLight(0xff0040, 0.3, 2);
            rearLight.position.set(0, 0.1, 0.5);
            droneGroup.add(rearLight);
            
            // Position drone
            droneGroup.position.set(0, 2, 0);
            droneGroup.castShadow = true;
            state.scene.add(droneGroup);
            state.drone = droneGroup;
            
            // Store drone data for JSON export
            state.drone.userData = {
                type: 'drone',
                model: 'unified_search_rescue',
                status: 'active'
            };
        }

        // NEW: Optimized forest generation with varied trees
        function generateOptimizedForest() {
            // Clear existing trees
            state.trees.forEach(tree => state.scene.remove(tree));
            state.trees = [];
            state.obstacles = state.obstacles.filter(obs => !state.trees.includes(obs));
            
            // Calculate tree count based on complexity with performance limits
            const baseTreeCount = 20;
            const maxTreeCount = 100; // Performance limit
            const treeCount = Math.min(maxTreeCount, 
                baseTreeCount + Math.floor(state.environmentComplexity * 80));
            
            // Performance optimization warning
            if (treeCount > 80) {
                state.sceneStats.performanceWarnings.push('High tree count may affect performance');
                logMessage(`[PERF] High tree count: ${treeCount}. Consider reducing complexity.`, 'warn');
            }
            
            let placedTrees = 0;
            let placementAttempts = 0;
            const maxPlacementAttempts = treeCount * 3; // Prevent infinite loops
            
            while (placedTrees < treeCount && placementAttempts < maxPlacementAttempts) {
                const tree = createVariedTree();
                
                // Smart placement to avoid overlap and create navigable paths
                const x = (Math.random() - 0.5) * 70;
                const z = (Math.random() - 0.5) * 70;
                
                // Avoid center area where drone starts
                const distanceFromCenter = Math.sqrt(x*x + z*z);
                if (distanceFromCenter < 8) {
                    placementAttempts++;
                    continue;
                }
                
                // Check minimum distance from other trees (2.5 units)
                let tooClose = false;
                for (const existingTree of state.trees) {
                    const distance = Math.sqrt(
                        Math.pow(x - existingTree.position.x, 2) + 
                        Math.pow(z - existingTree.position.z, 2)
                    );
                    if (distance < 2.5) {
                        tooClose = true;
                        break;
                    }
                }
                
                if (!tooClose) {
                    tree.position.set(x, tree.userData.height / 2, z);
                    state.scene.add(tree);
                    state.trees.push(tree);
                    state.obstacles.push(tree);
                    placedTrees++;
                }
                
                placementAttempts++;
            }
            
            // Add rocks and other obstacles
            generateAdditionalObstacles();
            
            // Update scene statistics
            state.sceneStats.treeCount = state.trees.length;
            state.sceneStats.objectCount = state.obstacles.length;
            
            logMessage(`[FOREST] Generated ${state.trees.length} trees with varied sizes`, 'ok');
            logMessage(`[SCENE] Total objects: ${state.sceneStats.objectCount}`, 'sys');
        }

        // NEW: Create trees with varied appearance
        function createVariedTree() {
            const treeGroup = new THREE.Group();
            
            // Varied tree properties for natural look
            const height = 2 + Math.random() * 5;
            const trunkRadius = 0.2 + Math.random() * 0.3;
            const canopySize = 1 + Math.random() * 1.5;
            const trunkColor = new THREE.Color().setHSL(0.07, 0.5, 0.2 + Math.random() * 0.2);
            const canopyColor = new THREE.Color().setHSL(0.3, 0.6 + Math.random() * 0.2, 0.3 + Math.random() * 0.2);
            
            // Trunk with varied color
            const trunkGeometry = new THREE.CylinderGeometry(trunkRadius, trunkRadius * 1.2, height, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ 
                color: trunkColor,
                roughness: 0.9,
                metalness: 0.1
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            treeGroup.add(trunk);
            
            // Canopy with varied color and shape
            const canopyGeometry = new THREE.ConeGeometry(canopySize, height / 2, 8);
            const canopyMaterial = new THREE.MeshStandardMaterial({ 
                color: canopyColor,
                roughness: 0.8,
                metalness: 0.1
            });
            const canopy = new THREE.Mesh(canopyGeometry, canopyMaterial);
            canopy.position.y = height / 2 + height / 4;
            treeGroup.add(canopy);
            
            // Random rotation for natural look
            treeGroup.rotation.y = Math.random() * Math.PI * 2;
            
            // Store tree data for JSON export
            treeGroup.userData = {
                type: 'tree',
                height: height,
                trunkRadius: trunkRadius,
                canopySize: canopySize,
                position: treeGroup.position.clone()
            };
            
            treeGroup.castShadow = true;
            treeGroup.receiveShadow = true;
            
            return treeGroup;
        }

        // NEW: Generate additional obstacles (rocks, formations)
        function generateAdditionalObstacles() {
            // Add large rocks
            const rockCount = 10 + Math.floor(state.environmentComplexity * 10);
            
            for (let i = 0; i < rockCount; i++) {
                const rockSize = 0.8 + Math.random() * 1.2;
                const rockGeometry = new THREE.DodecahedronGeometry(rockSize, 1);
                const rockMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x555555 + Math.random() * 0x222222,
                    roughness: 0.8,
                    metalness: 0.2
                });
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                
                // Place rocks away from center and other objects
                let validPosition = false;
                let attempts = 0;
                
                while (!validPosition && attempts < 50) {
                    rock.position.x = (Math.random() - 0.5) * 60;
                    rock.position.z = (Math.random() - 0.5) * 60;
                    rock.position.y = rockSize / 2;
                    
                    const distanceFromCenter = Math.sqrt(
                        rock.position.x * rock.position.x + 
                        rock.position.z * rock.position.z
                    );
                    
                    if (distanceFromCenter < 5) {
                        attempts++;
                        continue;
                    }
                    
                    // Check distance from other obstacles
                    let tooClose = false;
                    for (const obstacle of state.obstacles) {
                        const distance = Math.sqrt(
                            Math.pow(rock.position.x - obstacle.position.x, 2) + 
                            Math.pow(rock.position.z - obstacle.position.z, 2)
                        );
                        if (distance < 2) {
                            tooClose = true;
                            break;
                        }
                    }
                    
                    if (!tooClose) {
                        validPosition = true;
                    }
                    attempts++;
                }
                
                if (validPosition) {
                    rock.rotation.x = Math.random() * Math.PI;
                    rock.rotation.y = Math.random() * Math.PI;
                    rock.rotation.z = Math.random() * Math.PI;
                    
                    rock.castShadow = true;
                    rock.receiveShadow = true;
                    
                    rock.userData = {
                        type: 'rock',
                        size: rockSize
                    };
                    
                    state.scene.add(rock);
                    state.obstacles.push(rock);
                }
            }
        }

        // NEW: Enhanced Lattice-compatible JSON export
        function exportLatticeJSON() {
            try {
                const now = new Date().toISOString();
                
                // Collect SLAM data from scene
                const slamData = {
                    poses: getDronePathPoses(),
                    map: getForestMapData(),
                    sensors: getSensorData(),
                    timestamp: now
                };
                
                // Collect QNN data
                const qnnData = {
                    superpositionStates: getQNNSuperpositionStates(),
                    trainingDataset: getTrainingDataset(),
                    antifragilityGrid: getAntifragilityGridData(),
                    metrics: {
                        accuracy: state.training.accuracy,
                        robustness: state.qnn.robustnessScore,
                        stressResponse: state.qnn.stressResponse
                    }
                };
                
                // Unified Lattice entity
                const latticeEntity = {
                    // Lattice core fields
                    entityId: `QNN_DRONE_${Date.now()}`,
                    description: 'QNN-Enhanced Autonomous Drone from LAUNCH SEQUENCE',
                    isLive: state.training.running || state.testActive,
                    expiryTime: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(), // 24 hours
                    aliases: { 
                        name: document.getElementById('model-name').value || 'Unnamed QNN Drone'
                    },
                    milView: {
                        disposition: "DISPOSITION_FRIENDLY",
                        environment: "ENVIRONMENT_AIR"
                    },
                    location: {
                        position: {
                            latitudeDegrees: 33.69447852698943, // Default coordinates
                            longitudeDegrees: -117.9173785693163,
                            altitudeHaeMeters: state.drone ? state.drone.position.y : 0
                        }
                    },
                    ontology: {
                        template: "TEMPLATE_TRACK",
                        platformType: "Drone",
                        specificType: "QNN_Enhanced_Autonomous"
                    },
                    provenance: {
                        integrationName: "launch_sequence_v1.5",
                        dataType: "qnn_slam_hybrid",
                        sourceUpdateTime: now
                    },
                    
                    // SLAM data for robotics integration
                    slamData: slamData,
                    
                    // QNN data for neural network state
                    qnnData: qnnData,
                    
                    // Training and test data
                    trainingMetrics: {
                        epochs: state.training.epoch,
                        loss: state.training.loss,
                        accuracy: state.training.accuracy,
                        activeNodes: state.training.activeNodes
                    },
                    
                    testResults: state.testData.length > 0 ? state.testData[state.testData.length - 1] : null,
                    
                    // Scene configuration
                    sceneConfig: {
                        environmentType: state.environmentType,
                        complexity: state.environmentComplexity,
                        treeCount: state.trees.length,
                        objectCount: state.obstacles.length
                    },
                    
                    // Metadata
                    version: "1.5.0",
                    exportFormat: "lattice_slam_qnn_hybrid",
                    timestamp: now
                };
                
                // Store for later use
                state.latticeExport.entityId = latticeEntity.entityId;
                state.latticeExport.lastExport = now;
                
                // Create downloadable file
                const jsonString = JSON.stringify(latticeEntity, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `lattice_drone_${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                logMessage('[EXPORT] Lattice JSON exported successfully', 'ok');
                logMessage(`[EXPORT] Entity ID: ${latticeEntity.entityId}`, 'sys');
                logMessage(`[EXPORT] Format: ${latticeEntity.exportFormat}`, 'sys');
                
                return latticeEntity;
                
            } catch (error) {
                logMessage(`[ERROR] Lattice export failed: ${error.message}`, 'err');
                return null;
            }
        }

        // NEW: Helper functions for Lattice JSON data collection
        function getDronePathPoses() {
            const poses = [];
            const currentTime = new Date().toISOString();
            
            if (state.drone) {
                poses.push({
                    timestamp: currentTime,
                    position: {
                        x: state.drone.position.x,
                        y: state.drone.position.y,
                        z: state.drone.position.z
                    },
                    orientation: {
                        roll: state.drone.rotation.x,
                        pitch: state.drone.rotation.y,
                        yaw: state.drone.rotation.z
                    },
                    covariance: [1.0, 0, 0, 0, 1.0, 0, 0, 0, 1.0] // Identity covariance
                });
            }
            
            // Add historical test data if available
            if (state.testData && state.testData.length > 0) {
                state.testData.forEach((data, index) => {
                    if (data.position) {
                        poses.push({
                            timestamp: data.timestamp || currentTime,
                            position: data.position,
                            orientation: data.orientation || { roll: 0, pitch: 0, yaw: 0 },
                            covariance: [1.0, 0, 0, 0, 1.0, 0, 0, 0, 1.0]
                        });
                    }
                });
            }
            
            return poses;
        }

        function getForestMapData() {
            const treeData = state.trees.map(tree => ({
                type: 'tree',
                position: {
                    x: tree.position.x,
                    y: tree.position.y,
                    z: tree.position.z
                },
                properties: tree.userData
            }));
            
            const obstacleData = state.obstacles
                .filter(obs => !state.trees.includes(obs))
                .map(obs => ({
                    type: 'obstacle',
                    position: {
                        x: obs.position.x,
                        y: obs.position.y,
                        z: obs.position.z
                    },
                    properties: obs.userData || { type: 'unknown' }
                }));
            
            return {
                type: "occupancy_grid",
                resolution: 0.5,
                width: 80,
                height: 80,
                origin: { x: -40, y: -40, z: 0 },
                objects: [...treeData, ...obstacleData],
                timestamp: new Date().toISOString()
            };
        }

        function getSensorData() {
            return {
                simulatedLidar: {
                    ranges: Array(360).fill(0).map(() => 5 + Math.random() * 20),
                    angles: Array(360).fill(0).map((_, i) => i * (Math.PI / 180)),
                    maxRange: 25,
                    minRange: 0.1
                },
                camera: {
                    resolution: { width: 640, height: 480 },
                    fov: 60,
                    detectedObjects: state.collectibles.filter(c => !c.collected).length
                },
                imu: {
                    acceleration: { x: 0, y: 0, z: 0 },
                    gyroscope: { x: 0, y: 0, z: 0 }
                }
            };
        }

        function getQNNSuperpositionStates() {
            const states = [];
            const qnnCells = document.querySelectorAll('.qnn-cell');
            
            qnnCells.forEach((cell, index) => {
                let amplitudes = [1.0, 0.0]; // Default |0 state
                
                if (cell.classList.contains('active')) {
                    amplitudes = [0.707, 0.707]; // |0 + |1 / sqrt(2)
                } else if (cell.classList.contains('training')) {
                    amplitudes = [0.866, 0.5]; // Different training state
                } else if (cell.classList.contains('learned')) {
                    amplitudes = [0.5, 0.866]; // Learned state
                }
                
                states.push({
                    qubitId: index + 1,
                    amplitudes: amplitudes,
                    basis: "computational",
                    timestamp: new Date().toISOString()
                });
            });
            
            return states;
        }

        function getTrainingDataset() {
            return {
                inputs: state.training.dataPoints > 0 ? 
                    Array(Math.min(1000, state.training.dataPoints)).fill([0.1, 0.2]) : [],
                outputs: state.training.dataPoints > 0 ? 
                    Array(Math.min(1000, state.training.dataPoints)).fill([1]) : [],
                epochs: state.training.epoch,
                loss: state.training.loss,
                accuracy: state.training.accuracy,
                timestamp: new Date().toISOString()
            };
        }

        function getAntifragilityGridData() {
            const gridData = [];
            const cells = document.querySelectorAll('.antifragility-cell');
            
            cells.forEach((cell, index) => {
                gridData.push({
                    cellId: index + 1,
                    state: cell.classList.contains('stressed') ? 'stressed' : 'stable',
                    stressLevel: cell.classList.contains('stressed') ? 0.8 : 0.2,
                    position: {
                        row: Math.floor(index / 5),
                        col: index % 5
                    }
                });
            });
            
            return gridData;
        }

        // NEW: Enhanced JSON import with Lattice compatibility
        function importLatticeJSON(file) {
            const reader = new FileReader();
            
            reader.onload = (event) => {
                try {
                    const entity = JSON.parse(event.target.result);
                    
                    // Validate Lattice entity structure
                    if (!validateLatticeEntity(entity)) {
                        throw new Error('Invalid Lattice entity format');
                    }
                    
                    // Update scene from imported data
                    updateSceneFromLatticeEntity(entity);
                    
                    logMessage('[IMPORT] Lattice JSON imported successfully', 'ok');
                    logMessage(`[IMPORT] Loaded entity: ${entity.entityId}`, 'sys');
                    logMessage(`[IMPORT] Format: ${entity.exportFormat || 'unknown'}`, 'sys');
                    
                } catch (error) {
                    logMessage(`[ERROR] Lattice import failed: ${error.message}`, 'err');
                }
            };
            
            reader.onerror = () => {
                logMessage('[ERROR] Failed to read Lattice JSON file', 'err');
            };
            
            reader.readAsText(file);
        }

        // NEW: Validate Lattice entity structure
        function validateLatticeEntity(entity) {
            if (!entity.entityId || !entity.description) {
                return false;
            }
            
            // Check for required Lattice fields
            if (!entity.ontology || !entity.provenance) {
                return false;
            }
            
            return true;
        }

        // NEW: Update scene from Lattice entity data
        function updateSceneFromLatticeEntity(entity) {
            try {
                // Update drone position if available
                if (entity.location && entity.location.position && state.drone) {
                    // Convert latitude/longitude back to scene coordinates
                    const sceneX = entity.location.position.longitudeDegrees || 0;
                    const sceneY = entity.location.position.altitudeHaeMeters || 2;
                    const sceneZ = entity.location.position.latitudeDegrees || 0;
                    
                    state.drone.position.set(sceneX, sceneY, sceneZ);
                    logMessage(`[IMPORT] Drone position updated to (${sceneX.toFixed(1)}, ${sceneY.toFixed(1)}, ${sceneZ.toFixed(1)})`, 'sys');
                }
                
                // Update training metrics if available
                if (entity.trainingMetrics) {
                    state.training.epoch = entity.trainingMetrics.epochs || state.training.epoch;
                    state.training.loss = entity.trainingMetrics.loss || state.training.loss;
                    state.training.accuracy = entity.trainingMetrics.accuracy || state.training.accuracy;
                    state.training.activeNodes = entity.trainingMetrics.activeNodes || state.training.activeNodes;
                    updateTrainingUI();
                    logMessage('[IMPORT] Training metrics updated', 'sys');
                }
                
                // Update QNN data if available
                if (entity.qnnData) {
                    updateQNNFromImportedData(entity.qnnData);
                }
                
                // Update scene configuration if available
                if (entity.sceneConfig) {
                    state.environmentComplexity = entity.sceneConfig.complexity || state.environmentComplexity;
                    document.getElementById('environment-complexity').value = state.environmentComplexity;
                    document.getElementById('complexity-value').textContent = state.environmentComplexity.toFixed(2);
                    logMessage(`[IMPORT] Scene complexity set to ${state.environmentComplexity}`, 'sys');
                }
                
                // Store entity ID for reference
                state.latticeExport.entityId = entity.entityId;
                
            } catch (error) {
                logMessage(`[ERROR] Failed to update scene from Lattice data: ${error.message}`, 'err');
            }
        }

        // NEW: Update QNN from imported data
        function updateQNNFromImportedData(qnnData) {
            if (qnnData.superpositionStates) {
                const qnnCells = document.querySelectorAll('.qnn-cell');
                qnnData.superpositionStates.forEach((state, index) => {
                    if (qnnCells[index]) {
                        qnnCells[index].classList.remove('active', 'training', 'learned');
                        if (state.amplitudes[0] === 0.707 && state.amplitudes[1] === 0.707) {
                            qnnCells[index].classList.add('active');
                        }
                    }
                });
            }
            
            if (qnnData.antifragilityGrid) {
                const antifragilityCells = document.querySelectorAll('.antifragility-cell');
                qnnData.antifragilityGrid.forEach((cell, index) => {
                    if (antifragilityCells[index]) {
                        antifragilityCells[index].classList.remove('stressed', 'stable');
                        antifragilityCells[index].classList.add(cell.state);
                    }
                });
            }
            
            if (qnnData.metrics) {
                state.qnn.robustnessScore = qnnData.metrics.robustness || state.qnn.robustnessScore;
                state.qnn.stressResponse = qnnData.metrics.stressResponse || state.qnn.stressResponse;
            }
            
            logMessage('[IMPORT] QNN state updated from imported data', 'sys');
        }

        // NEW: Trigger Lattice import via file input
        function triggerLatticeImport() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                if (e.target.files[0]) {
                    importLatticeJSON(e.target.files[0]);
                }
            };
            input.click();
        }

        // NEW: Enhanced camera controls
        function setupEnhancedCameraControls() {
            const container = document.getElementById('scene-container');
            
            // Mouse state
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            // Camera constraints
            const cameraConstraints = {
                minDistance: 5,
                maxDistance: 50,
                minPolarAngle: 0.1, // Avoid going under the ground
                maxPolarAngle: Math.PI - 0.1 // Avoid flipping over
            };
            
            container.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
                container.style.cursor = 'grabbing';
            });
            
            container.addEventListener('mousemove', (e) => {
                if (!isDragging || !state.drone) return;
                
                const deltaMove = {
                    x: e.clientX - previousMousePosition.x,
                    y: e.clientY - previousMousePosition.y
                };
                
                // Update camera angles with smoothing
                state.cameraAngleX += deltaMove.x * 0.01;
                state.cameraAngleY += deltaMove.y * 0.01;
                
                // Apply constraints
                state.cameraAngleY = Math.max(
                    cameraConstraints.minPolarAngle,
                    Math.min(cameraConstraints.maxPolarAngle, state.cameraAngleY)
                );
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
                updateEnhancedCamera();
            });
            
            container.addEventListener('mouseup', () => {
                isDragging = false;
                container.style.cursor = 'grab';
            });
            
            container.addEventListener('mouseleave', () => {
                isDragging = false;
                container.style.cursor = 'default';
            });
            
            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                
                // Smooth zoom with acceleration
                const zoomSpeed = 0.005;
                const zoomAcceleration = Math.abs(e.deltaY) > 50 ? 1.5 : 1.0;
                state.cameraDistance += e.deltaY * zoomSpeed * zoomAcceleration;
                
                // Apply constraints
                state.cameraDistance = Math.max(
                    cameraConstraints.minDistance,
                    Math.min(cameraConstraints.maxDistance, state.cameraDistance)
                );
                
                updateEnhancedCamera();
            });
            
            // Add hover effect
            container.addEventListener('mouseenter', () => {
                if (!isDragging) {
                    container.style.cursor = 'grab';
                }
            });
        }

        // NEW: Enhanced camera update
        function updateEnhancedCamera() {
            if (!state.camera || !state.drone) return;
            
            if (state.fpvCamera) {
                // First-person view from drone
                state.camera.position.copy(state.drone.position);
                state.camera.position.y += 0.3; // Eye level
                
                // Use drone's forward direction
                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyQuaternion(state.drone.quaternion);
                
                const lookAtPoint = new THREE.Vector3(
                    state.drone.position.x + forward.x,
                    state.drone.position.y + forward.y,
                    state.drone.position.z + forward.z
                );
                
                state.camera.lookAt(lookAtPoint);
            } else {
                // Third-person orbit camera
                const cameraOffset = new THREE.Vector3(
                    Math.sin(state.cameraAngleX) * Math.cos(state.cameraAngleY),
                    Math.sin(state.cameraAngleY),
                    Math.cos(state.cameraAngleX) * Math.cos(state.cameraAngleY)
                ).multiplyScalar(state.cameraDistance);
                
                state.camera.position.copy(state.drone.position).add(cameraOffset);
                state.camera.lookAt(state.drone.position);
            }
        }

        // NEW: Performance monitoring
        function setupPerformanceMonitoring() {
            let frameCount = 0;
            let lastTime = performance.now();
            let fps = 60;
            
            function monitorPerformance() {
                frameCount++;
                const currentTime = performance.now();
                
                if (currentTime >= lastTime + 1000) {
                    fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                    frameCount = 0;
                    lastTime = currentTime;
                    
                    state.sceneStats.fps = fps;
                    
                    // Log performance issues
                    if (fps < 30 && !state.sceneStats.performanceWarnings.includes('low_fps')) {
                        state.sceneStats.performanceWarnings.push('low_fps');
                        logMessage(`[PERF] Low FPS: ${fps}. Consider reducing environment complexity.`, 'warn');
                    } else if (fps >= 45 && state.sceneStats.performanceWarnings.includes('low_fps')) {
                        state.sceneStats.performanceWarnings = state.sceneStats.performanceWarnings.filter(w => w !== 'low_fps');
                    }
                    
                    // Update performance metric in UI
                    const responseTimeElement = document.getElementById('response-time');
                    if (responseTimeElement) {
                        responseTimeElement.textContent = `${fps} FPS`;
                    }
                }
                
                requestAnimationFrame(monitorPerformance);
            }
            
            monitorPerformance();
        }

        // NEW: Window resize handler
        function setupWindowResizeHandler() {
            window.addEventListener('resize', () => {
                const container = document.getElementById('scene-container');
                if (!container || !state.camera || !state.renderer) return;
                
                const width = container.clientWidth;
                const height = container.clientHeight;
                
                state.camera.aspect = width / height;
                state.camera.updateProjectionMatrix();
                state.renderer.setSize(width, height);
                
                logMessage(`[SCENE] Resized to ${width}x${height}`, 'sys');
            });
        }

        // Generate antifragility grid
        function generateAntifragilityGrid() {
            const grid = document.getElementById('antifragility-grid');
            grid.innerHTML = '';
            
            // Create 5x5 grid
            for (let i = 0; i < 25; i++) {
                const cell = document.createElement('div');
                cell.className = 'antifragility-cell';
                grid.appendChild(cell);
            }
            
            // Add green dot
            const dot = document.createElement('div');
            dot.className = 'green-dot';
            grid.appendChild(dot);
            
            updateAntifragilityGrid();
        }

        // Update antifragility grid visualization
        function updateAntifragilityGrid() {
            const cells = document.querySelectorAll('.antifragility-cell');
            const dot = document.querySelector('.green-dot');
            
            if (!cells.length || !dot) return;
            
            // Update cell states based on antifragility metrics
            cells.forEach((cell, i) => {
                const row = Math.floor(i / 5);
                const col = i % 5;
                const stressLevel = Math.random() * state.qnn.stressResponse;
                cell.className = `antifragility-cell ${stressLevel > 0.5 ? 'stressed' : 'stable'}`;
            });
            
            // Position green dot based on X/Y antifragility
            const xPos = state.qnn.antifragilityX * 92;
            const yPos = (1 - state.qnn.antifragilityY) * 92;
            dot.style.left = `${xPos}px`;
            dot.style.top = `${yPos}px`;
        }

        // Update training with antifragility
        function updateTrainingAntifragility() {
            // Update robustness score based on antifragility parameters
            state.qnn.robustnessScore = Math.min(100, (state.qnn.antifragilityX * 50 + state.qnn.antifragilityY * 50));
            
            // Simulate stress response based on antifragility settings
            state.qnn.stressResponse = Math.max(0, 1 - (state.qnn.antifragilityX + state.qnn.antifragilityY) / 2);
            
            // Adjust training metrics for antifragility
            if (state.qnn.antifragilityX > 0.7) {
                // High stability reduces hallucinations, improves accuracy
                state.training.accuracy = Math.min(95, state.training.accuracy + 0.2);
                state.training.loss = Math.max(0.01, state.training.loss * 0.98);
            }
            if (state.qnn.antifragilityY > 0.7) {
                // High adaptability improves response to stressors
                state.training.responseTime = Math.max(5, state.training.responseTime * 0.95);
            }
            
            // Log antifragility updates
            if (state.training.cycles % 10 === 0) {
                logMessage(`[ANTIFRAGILITY] Robustness: ${state.qnn.robustnessScore.toFixed(2)}% | Stress: ${state.qnn.stressResponse.toFixed(2)}`, 'train-log');
            }
            
            updateTrainingUI();
        }

        // Update import/export button visibility based on mode
        function updateImportExportVisibility() {
            const exportBtn = document.getElementById('export-model');
            const importBtn = document.getElementById('import-model');
            
            if (state.currentMode === 'train') {
                exportBtn.style.display = 'block';
                importBtn.style.display = 'none';
            } else {
                exportBtn.style.display = 'none';
                importBtn.style.display = 'block';
            }
        }

        // Initialize background service worker for continuous training
        function initServiceWorker() {
            // Simulate service worker for background training
            state.serviceWorker = {
                active: true,
                trainingData: [],
                processTrainingBatch: function() {
                    if (state.training.endless && state.training.running) {
                        // Process reinforcement learning batch
                        processReinforcementBatch();
                    }
                }
            };
            
            // Process training batches every 5 seconds
            setInterval(() => {
                state.serviceWorker.processTrainingBatch();
            }, 5000);
        }

        // Process reinforcement learning batch
        function processReinforcementBatch() {
            if (state.training.dataPoints < state.qnn.memoryLimit * 1000) {
                state.training.dataPoints += Math.floor(Math.random() * 100) + 50;
                updateTrainingStats();
                
                // Simulate reinforcement learning improvements
                if (state.training.accuracy < 95) {
                    state.training.accuracy += Math.random() * 0.5;
                    state.training.loss = Math.max(0.01, state.training.loss * 0.99);
                }
                
                // Log training progress
                if (state.training.cycles % 10 === 0) {
                    logMessage(`[TRAINING] Reinforcement batch processed: +${state.training.dataPoints} data points`, 'train-log');
                    logMessage(`[TRAINING] Model accuracy: ${state.training.accuracy.toFixed(2)}%`, 'train-log');
                }
                
                // Save training state periodically
                if (state.training.cycles % 50 === 0) {
                    saveTrainingData();
                }
            }
        }

        // Save training data to localStorage
        function saveTrainingData() {
            const trainingData = {
                timestamp: new Date().toISOString(),
                state: state,
                log: state.trainingLog.slice(-1000) // Keep last 1000 entries
            };
            
            localStorage.setItem('qnn_training_data', JSON.stringify(trainingData));
            state.qnn.memoryUsed = Math.round(JSON.stringify(trainingData).length / 1024);
            updateTrainingStats();
            
            logMessage(`[SYSTEM] Training data saved (${state.qnn.memoryUsed}MB used)`, 'sys');
        }

        // Load training data from localStorage
        function loadTrainingData() {
            const saved = localStorage.getItem('qnn_training_data');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    // Load basic training stats
                    state.training.rounds = data.state.training.rounds || 173823;
                    state.training.totalTime = data.state.training.totalTime || (289 * 60 + 42);
                    state.training.bestScore = data.state.training.bestScore || 0;
                    state.training.dataPoints = data.state.training.dataPoints || 0;
                    state.trainingLog = data.log || [];
                    
                    logMessage('[SYSTEM] Previous training data loaded', 'sys');
                    logMessage(`[SYSTEM] Resuming from ${state.training.rounds} training rounds`, 'sys');
                } catch (e) {
                    logMessage('[SYSTEM] No previous training data found', 'warn');
                }
            }
            updateTrainingStats();
        }

        // Set up event listeners
        function setupEventListeners() {
            // Mode tabs
            document.querySelectorAll('.mode-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const mode = tab.getAttribute('data-mode');
                    switchMode(mode);
                });
            });

            // REMOVED: Drone type selection

            // Training controls
            document.getElementById('start-train').addEventListener('click', startTraining);
            document.getElementById('stop-train').addEventListener('click', stopTraining);
            document.getElementById('reset-train').addEventListener('click', resetTraining);
            document.getElementById('export-model').addEventListener('click', showExportModal);
            document.getElementById('import-model').addEventListener('click', showImportModal);

            // Test controls
            document.getElementById('autopilot-test').addEventListener('click', startAutopilotTest);
            document.getElementById('test-stop').addEventListener('click', stopTest);
            document.getElementById('import-json').addEventListener('click', showImportModal);
            document.getElementById('new-course').addEventListener('click', newCourse);
            document.getElementById('fpv-camera').addEventListener('click', toggleFPVCamera);

            // Sliders
            document.getElementById('learning-rate').addEventListener('input', updateLearningRate);
            document.getElementById('creativity').addEventListener('input', updateCreativity);
            document.getElementById('memory-limit').addEventListener('input', updateMemoryLimit);
            document.getElementById('drone-speed').addEventListener('input', updateDroneSpeed);

            // Antifragility and complexity sliders
            document.getElementById('x-antifragility').addEventListener('input', updateAntifragilityX);
            document.getElementById('y-antifragility').addEventListener('input', updateAntifragilityY);
            document.getElementById('environment-complexity').addEventListener('input', updateEnvironmentComplexity);

            // Console input
            document.getElementById('console-send').addEventListener('click', processConsoleInput);
            document.getElementById('console-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') processConsoleInput();
            });

            // Copy log button
            document.getElementById('copy-log').addEventListener('click', copyLogToClipboard);

            // Import modal events
            document.getElementById('import-close').addEventListener('click', hideImportModal);
            document.getElementById('import-cancel').addEventListener('click', hideImportModal);
            document.getElementById('import-confirm').addEventListener('click', confirmImport);
            
            // File input change event listener
            document.getElementById('import-file').addEventListener('change', handleFileSelect);
            
            // Export modal events
            document.getElementById('export-close').addEventListener('click', hideExportModal);
            document.getElementById('export-cancel').addEventListener('click', hideExportModal);
            document.getElementById('export-confirm').addEventListener('click', confirmExport);
            document.getElementById('export-model-name').addEventListener('input', updateExportPreview);
            document.getElementById('export-include-log').addEventListener('change', updateExportPreview);
            document.getElementById('export-include-qnn').addEventListener('change', updateExportPreview);

            // Drag and drop for import
            const dropArea = document.getElementById('import-drop-area');
            dropArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropArea.style.background = 'rgba(0, 255, 157, 0.1)';
                dropArea.style.boxShadow = '0 0 10px var(--cyber-green)';
            });
            
            dropArea.addEventListener('dragleave', () => {
                dropArea.style.background = '';
                dropArea.style.boxShadow = '';
            });
            
            dropArea.addEventListener('drop', (e) => {
                e.preventDefault();
                dropArea.style.background = '';
                dropArea.style.boxShadow = '';
                
                if (e.dataTransfer.files.length) {
                    document.getElementById('import-file').files = e.dataTransfer.files;
                    handleFileSelect({ target: document.getElementById('import-file') });
                }
            });

            // Keyboard controls for drone
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);

            // NEW: Enhanced camera controls
            setupEnhancedCameraControls();
        }

        // Update antifragility X
        function updateAntifragilityX(e) {
            state.qnn.antifragilityX = parseFloat(e.target.value);
            document.getElementById('x-antifragility-value').textContent = state.qnn.antifragilityX.toFixed(2);
            updateAntifragilityGrid();
            updateTrainingAntifragility();
        }

        // Update antifragility Y
        function updateAntifragilityY(e) {
            state.qnn.antifragilityY = parseFloat(e.target.value);
            document.getElementById('y-antifragility-value').textContent = state.qnn.antifragilityY.toFixed(2);
            updateAntifragilityGrid();
            updateTrainingAntifragility();
        }

        // Update environment complexity
        function updateEnvironmentComplexity(e) {
            state.environmentComplexity = parseFloat(e.target.value);
            document.getElementById('complexity-value').textContent = state.environmentComplexity.toFixed(2);
            
            // Regenerate forest with new complexity
            generateOptimizedForest();
            generateCollectibles();
            
            logMessage(`[SCENE] Environment complexity set to ${state.environmentComplexity}`, 'sys');
        }

        // Copy console log to clipboard
        function copyLogToClipboard() {
            const text = JSON.stringify(state.trainingLog, null, 2);
            
            navigator.clipboard.writeText(text).then(() => {
                logMessage('[SYSTEM] Training log copied to clipboard as JSON', 'sys');
            }).catch(err => {
                logMessage('[ERROR] Failed to copy log: ' + err, 'err');
            });
        }

        // Show import modal
        function showImportModal() {
            document.getElementById('import-modal').classList.add('active');
            resetImportModal();
        }

        // Hide import modal
        function hideImportModal() {
            document.getElementById('import-modal').classList.remove('active');
        }

        // Reset import modal
        function resetImportModal() {
            document.getElementById('import-file').value = '';
            document.getElementById('import-preview').style.display = 'none';
            document.getElementById('import-confirm').disabled = true;
            setImportStatus('Ready to import', '');
            state.importData = null;
        }

        // Handle file selection for import
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            setImportStatus('Reading file...', 'importing');
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    state.importData = data;
                    
                    if (validateImportData(data)) {
                        let formatType = 'LAUNCH SEQUENCE';
                        if (data.latticeEntity && data.modelName) {
                            formatType = 'LAUNCH SEQUENCE + Lattice';
                        } else if (data.entityId && data.ontology) {
                            formatType = 'Lattice Entity';
                        }
                        
                        setImportStatus(`${formatType} format detected`, 'success');
                        document.getElementById('import-confirm').disabled = false;
                        showImportPreview(data);
                    } else {
                        setImportStatus('Invalid file format', 'error');
                        document.getElementById('import-confirm').disabled = true;
                    }
                } catch (error) {
                    setImportStatus('Error parsing JSON: ' + error.message, 'error');
                    document.getElementById('import-confirm').disabled = true;
                }
            };
            
            reader.onerror = () => {
                setImportStatus('Error reading file', 'error');
                document.getElementById('import-confirm').disabled = true;
            };
            
            reader.readAsText(file);
        }

        // Validate import data structure
        function validateImportData(data) {
            // Check for LAUNCH SEQUENCE format
            if (data && data.timestamp && data.state) {
                return true;
            }
            
            // Check for Lattice format with QNN data
            if (data && data.latticeEntity && data.modelName) {
                return true;
            }
            
            // Check for pure Lattice format (we can extract basic info)
            if (data && data.entityId && data.ontology) {
                return true;
            }
            
            return false;
        }

        // Show import preview
        function showImportPreview(data) {
            const preview = document.getElementById('import-preview-content');
            preview.innerHTML = '';
            
            let items = [];
            
            if (data.latticeEntity && data.modelName) {
                // Dual format (LAUNCH SEQUENCE + Lattice)
                items = [
                    { label: 'Model Name', value: data.modelName },
                    { label: 'Lattice Entity ID', value: data.latticeEntity.entityId },
                    { label: 'Platform Type', value: data.latticeEntity.ontology.platformType },
                    { label: 'Timestamp', value: new Date(data.timestamp).toLocaleString() },
                    { label: 'Accuracy', value: `${(data.state?.training?.accuracy || 0).toFixed(2)}%` },
                    { label: 'Training Rounds', value: data.state?.training?.rounds || 0 }
                ];
                
                // Add format indicator
                const formatInfo = document.createElement('div');
                formatInfo.className = 'compact-row';
                formatInfo.innerHTML = `<label style="color: var(--cyber-blue)">Format:</label><span style="color: var(--cyber-blue)">LAUNCH SEQUENCE + Lattice</span>`;
                preview.appendChild(formatInfo);
                
            } else if (data.entityId && data.ontology) {
                // Pure Lattice format
                items = [
                    { label: 'Entity ID', value: data.entityId },
                    { label: 'Description', value: data.description },
                    { label: 'Platform Type', value: data.ontology.platformType },
                    { label: 'Specific Type', value: data.ontology.specificType },
                    { label: 'Environment', value: data.milView?.environment || 'Unknown' }
                ];
                
                // Add format indicator
                const formatInfo = document.createElement('div');
                formatInfo.className = 'compact-row';
                formatInfo.innerHTML = `<label style="color: var(--cyber-orange)">Format:</label><span style="color: var(--cyber-orange)">Lattice Entity</span>`;
                preview.appendChild(formatInfo);
                
            } else {
                // Original LAUNCH SEQUENCE format
                items = [
                    { label: 'Model Name', value: data.modelName || 'Unnamed' },
                    { label: 'Timestamp', value: new Date(data.timestamp).toLocaleString() },
                    { label: 'Training Rounds', value: data.state.training.rounds || 0 },
                    { label: 'Accuracy', value: `${(data.state.training.accuracy || 0).toFixed(2)}%` },
                    { label: 'Loss', value: (data.state.training.loss || 0).toFixed(4) },
                    { label: 'Data Points', value: data.state.training.dataPoints || 0 }
                ];
            }
            
            items.forEach(item => {
                const div = document.createElement('div');
                div.className = 'compact-row';
                div.innerHTML = `<label>${item.label}:</label><span>${item.value}</span>`;
                preview.appendChild(div);
            });
            
            document.getElementById('import-preview').style.display = 'block';
        }

        // Set import status
        function setImportStatus(message, status) {
            const indicator = document.getElementById('import-status-indicator');
            const text = document.getElementById('import-status-text');
            
            text.textContent = message;
            indicator.className = 'status-indicator';
            
            if (status === 'importing') {
                indicator.classList.add('status-importing');
            } else if (status === 'success') {
                indicator.classList.add('status-success');
            } else if (status === 'error') {
                indicator.classList.add('status-error');
            }
        }

        // Confirm import
        function confirmImport() {
            if (!state.importData) return;
            
            setImportStatus('Importing data...', 'importing');
            
            // Simulate import process with delay
            setTimeout(() => {
                try {
                    // Update application state with imported data
                    applyImportedData(state.importData);
                    setImportStatus('Import completed successfully', 'success');
                    
                    // Close modal after a brief delay
                    setTimeout(() => {
                        hideImportModal();
                        logMessage('[SYSTEM] Training data imported successfully', 'ok');
                    }, 1000);
                } catch (error) {
                    setImportStatus('Error during import: ' + error.message, 'error');
                }
            }, 1500);
        }

        // Apply imported data to application state
        function applyImportedData(data) {
            if (data.latticeEntity && data.modelName) {
                // Dual format - use LAUNCH SEQUENCE data
                if (data.state.training) {
                    Object.assign(state.training, data.state.training);
                }
                if (data.state.qnn) {
                    Object.assign(state.qnn, data.state.qnn);
                }
                if (data.state.test) {
                    Object.assign(state.test, data.state.test);
                }
                if (data.log) {
                    state.trainingLog = data.log;
                }
                if (data.modelName) {
                    document.getElementById('model-name').value = data.modelName;
                }
                
                logMessage(`[SYSTEM] Imported LAUNCH SEQUENCE + Lattice data: ${data.latticeEntity.entityId}`, 'sys');
                
            } else if (data.entityId && data.ontology) {
                // Pure Lattice format - create basic training state
                state.training.rounds = data.qnnMetrics?.trainingRounds || 1000;
                state.training.accuracy = data.qnnMetrics?.accuracy || 0;
                state.qnn.robustnessScore = data.qnnMetrics?.robustnessScore || 0;
                state.qnn.antifragilityX = data.qnnMetrics?.antifragilityX || 0.5;
                state.qnn.antifragilityY = data.qnnMetrics?.antifragilityY || 0.5;
                
                document.getElementById('model-name').value = data.aliases?.name || data.entityId;
                
                logMessage(`[LATTICE] Imported Lattice entity: ${data.entityId}`, 'sys');
                
            } else {
                // Original LAUNCH SEQUENCE format
                if (data.state.training) {
                    Object.assign(state.training, data.state.training);
                }
                if (data.state.qnn) {
                    Object.assign(state.qnn, data.state.qnn);
                }
                if (data.log) {
                    state.trainingLog = data.log;
                }
                if (data.modelName) {
                    document.getElementById('model-name').value = data.modelName;
                }
            }
            
            // Update UI
            updateTrainingUI();
            updateTrainingStats();
            updateQNNGrid();
            updateAntifragilityGrid();
            
            // Save to localStorage
            saveTrainingData();
        }

        // Show export modal
        function showExportModal() {
            document.getElementById('export-modal').classList.add('active');
            resetExportModal();
            updateExportPreview();
        }

        // Hide export modal
        function hideExportModal() {
            document.getElementById('export-modal').classList.remove('active');
        }

        // Reset export modal
        function resetExportModal() {
            document.getElementById('export-model-name').value = document.getElementById('model-name').value || `qnn_model_${Date.now()}`;
            document.getElementById('export-include-log').checked = true;
            document.getElementById('export-include-qnn').checked = true;
            setExportStatus('Ready to export', '');
        }

        // Update export preview
        function updateExportPreview() {
            const modelName = document.getElementById('export-model-name').value || 'Unnamed';
            const includeLog = document.getElementById('export-include-log').checked;
            const includeQnn = document.getElementById('export-include-qnn').checked;
            
            // Prepare the export data in dual format
            const exportData = {
                // LAUNCH SEQUENCE format (for backward compatibility)
                modelName: modelName,
                timestamp: new Date().toISOString(),
                version: '1.5.0',
                state: {
                    training: state.training,
                    qnn: includeQnn ? state.qnn : {},
                    test: state.test
                },
                log: includeLog ? state.trainingLog : [],
                
                // Lattice-compatible format
                latticeEntity: {
                    entityId: `QNN_${modelName.toUpperCase().replace(/\s+/g, '_')}_${Date.now()}`,
                    description: `QNN Trained Drone Model: ${modelName}`,
                    isLive: true,
                    expiryTime: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),
                    aliases: {
                        name: modelName
                    },
                    milView: {
                        disposition: "DISPOSITION_FRIENDLY",
                        environment: "ENVIRONMENT_AIR"
                    },
                    location: {
                        position: {
                            latitudeDegrees: 33.69447852698943,
                            longitudeDegrees: -117.9173785693163,
                            altitudeHaeMeters: state.drone ? state.drone.position.y : 0
                        }
                    },
                    ontology: {
                        template: "TEMPLATE_TRACK",
                        platformType: "Unified_Search_Rescue_Drone",
                        specificType: "QNN_Autonomous_System"
                    },
                    provenance: {
                        integrationName: "launch_sequence_qnn",
                        dataType: "qnn_drone_data",
                        sourceUpdateTime: new Date().toISOString()
                    },
                    // Include QNN performance metrics in Lattice format
                    qnnMetrics: {
                        accuracy: state.training.accuracy,
                        trainingRounds: state.training.rounds,
                        robustnessScore: state.qnn.robustnessScore,
                        antifragilityX: state.qnn.antifragilityX,
                        antifragilityY: state.qnn.antifragilityY,
                        activeNodes: state.training.activeNodes,
                        responseTime: state.training.responseTime
                    }
                }
            };
            
            // Calculate data size
            const dataSize = JSON.stringify(exportData).length;
            document.getElementById('export-data-size').textContent = `${(dataSize / 1024).toFixed(2)} KB`;
            
            state.exportData = exportData;
        }

        // Set export status
        function setExportStatus(message, status) {
            const indicator = document.getElementById('export-status-indicator');
            const text = document.getElementById('export-status-text');
            
            text.textContent = message;
            indicator.className = 'status-indicator';
            
            if (status === 'exporting') {
                indicator.classList.add('status-exporting');
            } else if (status === 'success') {
                indicator.classList.add('status-success');
            } else if (status === 'error') {
                indicator.classList.add('status-error');
            }
        }

        // Confirm export
        function confirmExport() {
            if (!state.exportData) return;
            
            setExportStatus('Exporting data...', 'exporting');
            
            setTimeout(() => {
                try {
                    const dataStr = JSON.stringify(state.exportData, null, 2);
                    const dataBlob = new Blob([dataStr], { type: 'application/json' });
                    
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(dataBlob);
                    
                    // Use Lattice entity ID for filename if available
                    const fileName = state.exportData.latticeEntity 
                        ? state.exportData.latticeEntity.entityId 
                        : `${state.exportData.modelName}_${Date.now()}`;
                        
                    link.download = `${fileName}.json`;
                    link.click();
                    
                    setExportStatus('Export completed successfully', 'success');
                    
                    // Log appropriate format message
                    if (state.exportData.latticeEntity) {
                        logMessage(`[SYSTEM] Data exported in LAUNCH SEQUENCE + Lattice format: ${state.exportData.latticeEntity.entityId}`, 'ok');
                    } else {
                        logMessage('[SYSTEM] Training data exported in LAUNCH SEQUENCE format', 'ok');
                    }
                    
                    setTimeout(() => {
                        hideExportModal();
                    }, 1000);
                } catch (error) {
                    setExportStatus('Error during export: ' + error.message, 'error');
                }
            }, 1500);
        }

        // Switch between TRAIN and TEST modes
        function switchMode(mode) {
            state.currentMode = mode;
            
            // Update tabs
            document.querySelectorAll('.mode-tab').forEach(tab => {
                tab.classList.toggle('active', tab.getAttribute('data-mode') === mode);
            });
            
            // Update panels
            document.querySelectorAll('.mode-panel').forEach(panel => {
                panel.classList.toggle('active', panel.id === `${mode}-panel` || panel.id === `${mode}-right-panel`);
            });
            
            // Update import/export button visibility
            updateImportExportVisibility();
            
            // Update scene based on mode
            updateSceneForMode();
            
            logMessage(`[SYSTEM] Mode switched to: ${mode.toUpperCase()}`, 'sys');
        }

        // Update scene based on current mode
        function updateSceneForMode() {
            if (state.currentMode === 'train') {
                // Training mode - show training environment
                updateEnvironment();
                if (state.training.running) {
                    logMessage('[TRAINING] Training environment activated', 'train-log');
                }
            } else {
                // Test mode - show test environment
                updateEnvironment();
                logMessage('[TEST] Search & Rescue Forest activated', 'sys');
            }
        }

        // Start training
        function startTraining() {
            state.training.running = true;
            state.training.endless = true;
            
            // Start training interval
            state.trainingInterval = setInterval(() => {
                if (state.training.running) {
                    updateTraining();
                }
            }, 100);
            
            document.getElementById('start-train').textContent = 'Training...';
            document.getElementById('start-train').classList.add('active');
            
            logMessage('[TRAINING] Endless training started', 'train-log');
        }

        // Stop training
        function stopTraining() {
            state.training.running = false;
            clearInterval(state.trainingInterval);
            
            document.getElementById('start-train').textContent = 'Start Endless Training';
            document.getElementById('start-train').classList.remove('active');
            
            logMessage('[TRAINING] Training paused', 'warn');
        }

        // Reset training
        function resetTraining() {
            state.training.running = false;
            clearInterval(state.trainingInterval);
            
            state.training.progress = 0;
            state.training.epoch = 0;
            state.training.loss = 2.5;
            state.training.accuracy = 0;
            state.training.activeNodes = 0;
            state.training.responseTime = 0;
            state.training.complexity = 'Low';
            state.training.cycles = 0;
            state.training.dataPoints = 0;
            
            document.getElementById('start-train').textContent = 'Start Endless Training';
            document.getElementById('start-train').classList.remove('active');
            
            updateTrainingUI();
            updateTrainingStats();
            
            logMessage('[TRAINING] Training reset', 'warn');
        }

        // NEW: Search and Rescue test start
        function startAutopilotTest() {
            if (state.testActive) {
                logMessage('[TEST] Test already running', 'warn');
                return;
            }
            
            state.testActive = true;
            state.autopilotActive = true;
            state.test.status = 'Searching';
            state.testStartTime = Date.now();
            state.test.startTime = Date.now();
            state.test.collisions = 0;
            state.test.score = 0;
            state.test.flightTime = 0;
            state.test.distance = 0;
            state.test.progress = 0;
            state.test.objectsCollected = 0;
            state.test.missionComplete = false;
            state.test.returnHome = false;
            state.test.attempts++;
            
            // Choose a random corner to start from
            const corners = [
                { x: -35, z: -35 }, // Bottom-left
                { x: 35, z: -35 },  // Bottom-right
                { x: 35, z: 35 },   // Top-right
                { x: -35, z: 35 }   // Top-left
            ];
            const startCorner = corners[Math.floor(Math.random() * corners.length)];
            state.test.startPosition = startCorner;
            
            // Position drone at start corner
            if (state.drone) {
                state.drone.position.set(startCorner.x, 2, startCorner.z);
                // Point drone toward center
                state.drone.lookAt(0, 2, 0);
            }
            
            logMessage(`[TEST] Search & Rescue started from corner (${startCorner.x}, ${startCorner.z})`, 'ok');
            logMessage('[TEST] Mission: Find 3 red objects and return to start', 'ok');
            
            // Start test interval
            state.testInterval = setInterval(() => {
                if (state.testActive) {
                    updateTest();
                }
            }, 100);
            
            document.getElementById('autopilot-test').textContent = 'MISSION RUNNING';
            document.getElementById('autopilot-test').classList.add('active');
        }

        // Stop test
        function stopTest() {
            if (!state.testActive) return;
            
            state.testActive = false;
            state.autopilotActive = false;
            clearInterval(state.testInterval);
            
            state.test.status = 'Idle';
            document.getElementById('autopilot-test').textContent = 'SEARCH & RESCUE TEST';
            document.getElementById('autopilot-test').classList.remove('active');
            
            // Report test results
            reportTestResults();
            
            // Reset drone position
            if (state.drone) {
                state.drone.position.set(0, 2, 0);
            }
            
            logMessage('[TEST] Mission aborted', 'warn');
        }

        // Report test results to console
        function reportTestResults() {
            const elapsed = Date.now() - state.test.startTime;
            const flightTime = (elapsed / 1000).toFixed(1);
            const score = state.test.score;
            const collisions = state.test.collisions;
            const objectsCollected = state.test.objectsCollected;
            
            logMessage('[TEST] === MISSION RESULTS ===', 'perf');
            logMessage(`[TEST] Total Flight Time: ${flightTime}s`, 'perf');
            logMessage(`[TEST] Collisions: ${collisions}`, 'perf');
            logMessage(`[TEST] Objects Collected: ${objectsCollected}/3`, 'perf');
            logMessage(`[TEST] Final Score: ${score.toFixed(1)}%`, 'perf');
            
            if (state.test.missionComplete) {
                const missionTime = state.test.searchAndRescueTime / 1000;
                logMessage(`[TEST] MISSION SUCCESS! Time: ${missionTime.toFixed(2)}s`, 'ok');
                
                // Update best time
                if (state.test.bestSearchTime === 0 || missionTime < state.test.bestSearchTime) {
                    state.test.bestSearchTime = missionTime;
                    logMessage(`[TEST] NEW BEST TIME: ${missionTime.toFixed(2)}s`, 'ok');
                }
            } else {
                logMessage('[TEST] Mission incomplete', 'warn');
            }
            
            // Save test data
            saveTestData();
            
            if (score >= 80) {
                logMessage('[TEST] EXCELLENT PERFORMANCE! Model is well optimized.', 'ok');
            } else if (score >= 60) {
                logMessage('[TEST] Good performance. Try increasing training cycles.', 'ok');
            } else {
                logMessage('[TEST] Model needs more training. Focus on object detection.', 'warn');
            }
        }

        // Save test data for export
        function saveTestData() {
            const testData = {
                timestamp: new Date().toISOString(),
                environment: state.environmentType,
                results: {
                    score: state.test.score,
                    flightTime: state.test.flightTime,
                    collisions: state.test.collisions,
                    objectsCollected: state.test.objectsCollected,
                    missionComplete: state.test.missionComplete,
                    attempts: state.test.attempts
                }
            };
            
            if (state.test.missionComplete) {
                testData.results.missionTime = state.test.searchAndRescueTime;
                testData.results.bestMissionTime = state.test.bestSearchTime;
            }
            
            // Store in state for export
            if (!state.testData) state.testData = [];
            state.testData.push(testData);
            
            logMessage('[SYSTEM] Test data saved for export', 'sys');
        }

        // Create new forest
        function newCourse() {
            // Clear existing obstacles and collectibles
            state.obstacles.forEach(obj => state.scene.remove(obj));
            state.collectibles.forEach(obj => state.scene.remove(obj.mesh));
            state.obstacles = [];
            state.collectibles = [];
            
            // Generate new optimized forest
            generateOptimizedForest();
            generateCollectibles();
            
            logMessage('[TEST] New Search & Rescue Forest generated', 'ok');
        }

        // Generate collectible objects (red triangles)
        function generateCollectibles() {
            // Clear existing collectibles
            state.collectibles.forEach(collectible => {
                state.scene.remove(collectible.mesh);
                if (collectible.light) {
                    state.scene.remove(collectible.light);
                }
            });
            state.collectibles = [];
            
            // Create 3 red triangle collectibles
            for (let i = 0; i < 3; i++) {
                const triangleGeometry = new THREE.ConeGeometry(0.8, 1.5, 3);
                const triangleMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff0000,
                    emissive: 0x990000,
                    emissiveIntensity: 0.5
                });
                const triangle = new THREE.Mesh(triangleGeometry, triangleMaterial);
                
                // Place triangles randomly in the forest
                let validPosition = false;
                let attempts = 0;
                let x, z;
                
                while (!validPosition && attempts < 50) {
                    x = (Math.random() - 0.5) * 60;
                    z = (Math.random() - 0.5) * 60;
                    
                    // Avoid center area
                    const distanceFromCenter = Math.sqrt(x*x + z*z);
                    if (distanceFromCenter < 5) {
                        attempts++;
                        continue;
                    }
                    
                    // Check if position is too close to other obstacles or collectibles
                    let tooClose = false;
                    for (const obstacle of state.obstacles) {
                        const distance = Math.sqrt(
                            Math.pow(x - obstacle.position.x, 2) + 
                            Math.pow(z - obstacle.position.z, 2)
                        );
                        if (distance < 3) {
                            tooClose = true;
                            break;
                        }
                    }
                    
                    for (const collectible of state.collectibles) {
                        const distance = Math.sqrt(
                            Math.pow(x - collectible.mesh.position.x, 2) + 
                            Math.pow(z - collectible.mesh.position.z, 2)
                        );
                        if (distance < 5) {
                            tooClose = true;
                            break;
                        }
                    }
                    
                    validPosition = !tooClose;
                    attempts++;
                }
                
                if (validPosition) {
                    triangle.position.set(x, 0.8, z);
                    triangle.rotation.x = Math.PI / 2; // Lay flat on the ground
                    triangle.castShadow = true;
                    state.scene.add(triangle);
                    
                    // Add point light for glow effect
                    const triangleLight = new THREE.PointLight(0xff0000, 0.3, 2);
                    triangleLight.position.set(x, 1, z);
                    state.scene.add(triangleLight);
                    
                    state.collectibles.push({
                        mesh: triangle,
                        light: triangleLight,
                        collected: false,
                        index: i
                    });
                }
            }
            
            logMessage(`[SYSTEM] ${state.collectibles.length} collectible objects placed in forest`, 'sys');
        }

        // Toggle FPV camera
        function toggleFPVCamera() {
            state.fpvCamera = !state.fpvCamera;
            updateEnhancedCamera();
            
            if (state.fpvCamera) {
                document.getElementById('fpv-camera').textContent = '3RD PERSON';
                logMessage('[TEST] FPV camera activated', 'ok');
            } else {
                document.getElementById('fpv-camera').textContent = 'FPV CAMERA';
                logMessage('[TEST] 3rd person camera activated', 'ok');
            }
        }

        // Update learning rate
        function updateLearningRate(e) {
            state.qnn.learningRate = parseFloat(e.target.value);
            document.getElementById('learning-rate-value').textContent = state.qnn.learningRate.toFixed(2);
            updateQNNGrid();
        }

        // Update creativity
        function updateCreativity(e) {
            state.qnn.creativity = parseFloat(e.target.value);
            document.getElementById('creativity-value').textContent = state.qnn.creativity.toFixed(2);
            updateQNNGrid();
        }

        // Update memory limit
        function updateMemoryLimit(e) {
            state.qnn.memoryLimit = parseInt(e.target.value);
            document.getElementById('memory-usage').textContent = `${state.qnn.memoryLimit}MB`;
        }

        // Update drone speed
        function updateDroneSpeed(e) {
            state.test.droneSpeed = parseFloat(e.target.value);
            document.getElementById('drone-speed-value').textContent = `${state.test.droneSpeed.toFixed(1)}x`;
        }

        // Process console input
        function processConsoleInput() {
            const input = document.getElementById('console-input');
            const command = input.value.trim();
            
            if (command) {
                logMessage(`> ${command}`, 'muted');
                handleCommand(command);
                input.value = '';
            }
        }

        // Handle console commands
        function handleCommand(command) {
            const parts = command.split(' ');
            const cmd = parts[0].toLowerCase();
            
            switch(cmd) {
                case '/help':
                    logMessage('[HELP] Available commands:', 'sys');
                    logMessage('/help - Show this help', 'sys');
                    logMessage('/status - Show system status', 'sys');
                    logMessage('/train [start|stop|reset] - Control training', 'sys');
                    logMessage('/test [start|stop] - Control testing', 'sys');
                    logMessage('/mode [train|test] - Switch mode', 'sys');
                    logMessage('/camera [fpv|3rd] - Switch camera', 'sys');
                    logMessage('/antifragility [x] [y] - Set antifragility parameters', 'sys');
                    logMessage('/complexity [value] - Set environment complexity', 'sys');
                    logMessage('/export - Export training data', 'sys');
                    logMessage('/import - Import training data', 'sys');
                    logMessage('/copylog - Copy console log to clipboard', 'sys');
                    logMessage('/lattice-status - Show Lattice entity status', 'sys');
                    logMessage('/lattice-update - Update Lattice entity with current state', 'sys');
                    logMessage('/export-lattice - Export in Lattice format', 'sys');
                    logMessage('/import-lattice - Import Lattice JSON', 'sys');
                    logMessage('/scene-info - Show scene statistics', 'sys');
                    logMessage('/performance - Show performance metrics', 'sys');
                    break;
                    
                case '/status':
                    logMessage(`[STATUS] Mode: ${state.currentMode.toUpperCase()}`, 'sys');
                    logMessage(`[STATUS] Drone: ${state.droneType.toUpperCase()}`, 'sys');
                    logMessage(`[STATUS] Environment: ${state.environmentType.toUpperCase()}`, 'sys');
                    logMessage(`[STATUS] Training: ${state.training.running ? 'RUNNING' : 'STOPPED'}`, 'sys');
                    logMessage(`[STATUS] Test: ${state.testActive ? 'RUNNING' : 'STOPPED'}`, 'sys');
                    logMessage(`[STATUS] FPS: ${state.sceneStats.fps}`, 'sys');
                    break;
                    
                case '/train':
                    if (parts[1] === 'start') startTraining();
                    else if (parts[1] === 'stop') stopTraining();
                    else if (parts[1] === 'reset') resetTraining();
                    else logMessage('[ERROR] Invalid train command. Use: start, stop, reset', 'err');
                    break;
                    
                case '/test':
                    if (parts[1] === 'start') startAutopilotTest();
                    else if (parts[1] === 'stop') stopTest();
                    else logMessage('[ERROR] Invalid test command. Use: start, stop', 'err');
                    break;
                    
                case '/mode':
                    if (parts[1] === 'train' || parts[1] === 'test') {
                        switchMode(parts[1]);
                    } else {
                        logMessage('[ERROR] Invalid mode. Use: train, test', 'err');
                    }
                    break;
                    
                case '/camera':
                    if (parts[1] === 'fpv') {
                        state.fpvCamera = true;
                        updateEnhancedCamera();
                        logMessage('[SYSTEM] FPV camera activated', 'sys');
                    } else if (parts[1] === '3rd') {
                        state.fpvCamera = false;
                        updateEnhancedCamera();
                        logMessage('[SYSTEM] 3rd person camera activated', 'sys');
                    } else {
                        logMessage('[ERROR] Invalid camera. Use: fpv, 3rd', 'err');
                    }
                    break;
                    
                case '/antifragility':
                    if (parts[1] && parts[2]) {
                        const x = parseFloat(parts[1]);
                        const y = parseFloat(parts[2]);
                        if (!isNaN(x) && !isNaN(y) && x >= 0 && x <= 1 && y >= 0 && y <= 1) {
                            state.qnn.antifragilityX = x;
                            state.qnn.antifragilityY = y;
                            document.getElementById('x-antifragility').value = x;
                            document.getElementById('y-antifragility').value = y;
                            document.getElementById('x-antifragility-value').textContent = x.toFixed(2);
                            document.getElementById('y-antifragility-value').textContent = y.toFixed(2);
                            updateAntifragilityGrid();
                            updateTrainingAntifragility();
                            logMessage(`[ANTIFRAGILITY] Set X=${x.toFixed(2)}, Y=${y.toFixed(2)}`, 'sys');
                        } else {
                            logMessage('[ERROR] Invalid antifragility values. Use: /antifragility [0-1] [0-1]', 'err');
                        }
                    } else {
                        logMessage('[ERROR] Invalid antifragility command. Use: /antifragility [x] [y]', 'err');
                    }
                    break;

                case '/complexity':
                    if (parts[1]) {
                        const complexity = parseFloat(parts[1]);
                        if (!isNaN(complexity) && complexity >= 0 && complexity <= 1) {
                            state.environmentComplexity = complexity;
                            document.getElementById('environment-complexity').value = complexity;
                            document.getElementById('complexity-value').textContent = complexity.toFixed(2);
                            generateOptimizedForest();
                            generateCollectibles();
                            logMessage(`[SYSTEM] Environment complexity set to ${complexity.toFixed(2)}`, 'sys');
                        } else {
                            logMessage('[ERROR] Invalid complexity value. Use: /complexity [0-1]', 'err');
                        }
                    } else {
                        logMessage('[ERROR] Invalid complexity command. Use: /complexity [value]', 'err');
                    }
                    break;
                    
                case '/export':
                    showExportModal();
                    break;
                    
                case '/import':
                    showImportModal();
                    break;
                    
                case '/export-lattice':
                    exportLatticeJSON();
                    break;
                    
                case '/import-lattice':
                    triggerLatticeImport();
                    break;
                    
                case '/copylog':
                    copyLogToClipboard();
                    break;
                    
                case '/lattice':
                case '/lattice-status':
                    logMessage('[LATTICE] Entity Status:', 'sys');
                    if (state.latticeExport.entityId) {
                        logMessage(`  ID: ${state.latticeExport.entityId}`, 'sys');
                    } else {
                        logMessage(`  ID: QNN_${(document.getElementById('model-name').value || 'unnamed').toUpperCase().replace(/\s+/g, '_')}`, 'sys');
                    }
                    logMessage(`  Description: QNN Trained Drone Model`, 'sys');
                    logMessage(`  Platform: Unified_Search_Rescue_Drone`, 'sys');
                    logMessage(`  Live: ${state.training.running || state.testActive}`, 'sys');
                    logMessage(`  Export Format: Lattice + SLAM + QNN Hybrid`, 'sys');
                    if (state.latticeExport.lastExport) {
                        logMessage(`  Last Export: ${new Date(state.latticeExport.lastExport).toLocaleString()}`, 'sys');
                    }
                    break;
                    
                case '/lattice-update':
                    exportLatticeJSON();
                    logMessage('[LATTICE] Entity updated with current QNN state', 'sys');
                    break;
                    
                case '/scene-info':
                    logMessage('[SCENE] Scene Statistics:', 'sys');
                    logMessage(`  Trees: ${state.sceneStats.treeCount}`, 'sys');
                    logMessage(`  Objects: ${state.sceneStats.objectCount}`, 'sys');
                    logMessage(`  Collectibles: ${state.collectibles.length}`, 'sys');
                    logMessage(`  FPS: ${state.sceneStats.fps}`, 'sys');
                    if (state.sceneStats.performanceWarnings.length > 0) {
                        logMessage(`  Warnings: ${state.sceneStats.performanceWarnings.join(', ')}`, 'warn');
                    }
                    break;
                    
                case '/performance':
                    logMessage('[PERFORMANCE] System Metrics:', 'perf');
                    logMessage(`  FPS: ${state.sceneStats.fps}`, 'perf');
                    logMessage(`  Memory Used: ${state.qnn.memoryUsed}MB / ${state.qnn.memoryLimit}MB`, 'perf');
                    logMessage(`  Training Data Points: ${state.training.dataPoints}`, 'perf');
                    logMessage(`  Scene Objects: ${state.sceneStats.objectCount}`, 'perf');
                    if (state.sceneStats.fps < 30) {
                        logMessage(`  PERFORMANCE: Low FPS detected. Reduce environment complexity.`, 'warn');
                    } else if (state.sceneStats.fps > 50) {
                        logMessage(`  PERFORMANCE: Excellent frame rate`, 'ok');
                    }
                    break;
                    
                default:
                    logMessage(`[ERROR] Unknown command: ${cmd}`, 'err');
                    break;
            }
        }

        // Handle keyboard input for drone control
        function handleKeyDown(e) {
            switch(e.key) {
                case 'w': state.flightControls.forward = true; break;
                case 's': state.flightControls.backward = true; break;
                case 'a': state.flightControls.left = true; break;
                case 'd': state.flightControls.right = true; break;
                case 'q': state.flightControls.up = true; break;
                case 'e': state.flightControls.down = true; break;
            }
        }

        function handleKeyUp(e) {
            switch(e.key) {
                case 'w': state.flightControls.forward = false; break;
                case 's': state.flightControls.backward = false; break;
                case 'a': state.flightControls.left = false; break;
                case 'd': state.flightControls.right = false; break;
                case 'q': state.flightControls.up = false; break;
                case 'e': state.flightControls.down = false; break;
            }
        }

        // Update environment based on type
        function updateEnvironment() {
            generateOptimizedForest();
            generateCollectibles();
            logMessage(`[SYSTEM] Environment updated to: ${state.environmentType.toUpperCase()}`, 'sys');
        }

        // Update training with antifragility integration
        function updateTraining() {
            // Update training progress
            state.training.progress = Math.min(100, state.training.progress + 0.1);
            
            // Update training metrics
            state.training.epoch++;
            state.training.loss = Math.max(0.01, state.training.loss * (0.99 + Math.random() * 0.02));
            state.training.accuracy = Math.min(95, state.training.accuracy + Math.random() * 0.1);
            state.training.activeNodes = Math.floor(20 + Math.random() * 60);
            state.training.responseTime = Math.floor(5 + Math.random() * 15);
            state.training.complexity = state.training.accuracy > 50 ? 'Medium' : 'Low';
            state.training.cycles++;
            
            // Apply antifragility to training
            updateTrainingAntifragility();
            
            // Update QNN grid
            updateQNNGrid();
            
            // Update UI
            updateTrainingUI();
            updateTrainingStats();
            
            // Log progress periodically
            if (state.training.epoch % 100 === 0) {
                logMessage(`[TRAINING] Epoch: ${state.training.epoch} | Loss: ${state.training.loss.toFixed(4)} | Accuracy: ${state.training.accuracy.toFixed(2)}%`, 'train-log');
            }
        }

        // NEW: Search and Rescue test update
        function updateTest() {
            if (!state.testActive) return;
            
            const elapsed = Date.now() - state.testStartTime;
            state.test.progress = Math.min(100, (elapsed / state.testDuration) * 100);
            state.test.flightTime = elapsed / 1000;
            state.test.searchAndRescueTime = elapsed;
            
            // Update drone position with autopilot
            if (state.autopilotActive && state.drone) {
                navigateSearchAndRescue();
            }
            
            // Update test metrics
            state.test.distance += state.test.droneSpeed * 0.1;
            state.test.speed = 15 + Math.random() * 25 * state.test.droneSpeed;
            
            // Calculate score based on mission progress
            const collectionProgress = state.test.objectsCollected / state.test.totalObjects;
            const timePenalty = Math.max(0, (elapsed / 1000) / 60); // 1 point per minute
            state.test.score = Math.min(100, 
                (collectionProgress * 70) + // 70% for collection
                (state.test.missionComplete ? 30 : 0) - // 30% for return home
                timePenalty // Time penalty
            );
            
            // Update UI
            updateTestUI();
            
            // End test if time is up or mission complete
            if (elapsed >= state.testDuration || state.test.missionComplete) {
                stopTest();
            }
        }

        // NEW: Search and Rescue navigation
        function navigateSearchAndRescue() {
            const dronePosition = state.drone.position;
            
            // If mission is complete, do nothing
            if (state.test.missionComplete) return;
            
            // If all objects collected, return to start
            if (state.test.objectsCollected >= state.test.totalObjects && !state.test.returnHome) {
                state.test.returnHome = true;
                state.test.status = 'Returning Home';
                logMessage('[TEST] All objects collected! Returning to start position.', 'ok');
            }
            
            let targetPosition;
            
            if (state.test.returnHome) {
                // Return to start position
                targetPosition = state.test.startPosition;
                
                // Check if drone has returned to start
                const distanceToStart = Math.sqrt(
                    Math.pow(dronePosition.x - targetPosition.x, 2) + 
                    Math.pow(dronePosition.z - targetPosition.z, 2)
                );
                
                if (distanceToStart < 3) {
                    // Mission complete!
                    state.test.missionComplete = true;
                    state.test.status = 'Mission Complete';
                    logMessage('[TEST] MISSION ACCOMPLISHED! Returned to start position.', 'ok');
                    return;
                }
            } else {
                // Search for collectibles
                let nearestCollectible = null;
                let minDistance = Infinity;
                
                // Find the nearest uncollected collectible
                state.collectibles.forEach(collectible => {
                    if (!collectible.collected) {
                        const distance = dronePosition.distanceTo(collectible.mesh.position);
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestCollectible = collectible;
                        }
                    }
                });
                
                if (nearestCollectible) {
                    targetPosition = nearestCollectible.mesh.position;
                    
                    // Check if drone is close enough to collect
                    if (minDistance < 2) {
                        // Collect the object
                        nearestCollectible.collected = true;
                        state.test.objectsCollected++;
                        
                        // Visual feedback
                        state.scene.remove(nearestCollectible.mesh);
                        state.scene.remove(nearestCollectible.light);
                        
                        logMessage(`[TEST] Object collected! ${state.test.objectsCollected}/3`, 'ok');
                        
                        // Update status
                        if (state.test.objectsCollected < state.test.totalObjects) {
                            state.test.status = `Searching (${state.test.objectsCollected}/3)`;
                        }
                    }
                } else {
                    // No collectibles found, wander randomly
                    if (Date.now() - state.forestLastDirectionChange > state.forestDirectionChangeInterval) {
                        state.forestTargetDirection = new THREE.Vector3(
                            (Math.random() - 0.5) * 2,
                            0,
                            (Math.random() - 0.5) * 2
                        ).normalize();
                        state.forestLastDirectionChange = Date.now();
                    }
                    targetPosition = new THREE.Vector3(
                        dronePosition.x + state.forestTargetDirection.x * 10,
                        2,
                        dronePosition.z + state.forestTargetDirection.z * 10
                    );
                }
            }
            
            // Calculate direction to target
            const direction = new THREE.Vector3();
            direction.subVectors(targetPosition, dronePosition).normalize();
            
            // Check for obstacles and adjust direction
            let obstacleAvoidance = new THREE.Vector3(0, 0, 0);
            let collisionDetected = false;
            
            state.obstacles.forEach(obstacle => {
                const obstacleDistance = dronePosition.distanceTo(obstacle.position);
                if (obstacleDistance < 2.5) {
                    // Calculate avoidance vector (away from obstacle)
                    const avoidDirection = new THREE.Vector3();
                    avoidDirection.subVectors(dronePosition, obstacle.position).normalize();
                    obstacleAvoidance.add(avoidDirection.multiplyScalar(0.8));
                    
                    // If very close to obstacle, count as collision
                    if (obstacleDistance < 1.2) {
                        collisionDetected = true;
                    }
                }
            });
            
            // Handle collision
            if (collisionDetected) {
                state.test.collisions++;
                logMessage(`[TEST] Collision! Total: ${state.test.collisions}`, 'warn');
            }
            
            // Combine target direction with obstacle avoidance
            const combinedDirection = new THREE.Vector3();
            combinedDirection.addVectors(direction, obstacleAvoidance).normalize();
            
            // Move drone
            const speed = 0.1 * state.test.droneSpeed;
            state.drone.position.x += combinedDirection.x * speed;
            state.drone.position.z += combinedDirection.z * speed;
            
            // Add slight vertical variation for realism
            state.drone.position.y += (Math.random() - 0.5) * 0.05;
            
            // Keep drone at reasonable height
            state.drone.position.y = Math.max(1, Math.min(8, state.drone.position.y));
            
            // Rotate drone to face direction of movement
            state.drone.lookAt(
                dronePosition.x + combinedDirection.x,
                dronePosition.y + combinedDirection.y,
                dronePosition.z + combinedDirection.z
            );
        }

        // Update training UI with antifragility metrics
        function updateTrainingUI() {
            document.getElementById('train-progress-bar').style.width = `${state.training.progress}%`;
            document.getElementById('train-progress').textContent = `${state.training.progress.toFixed(1)}%`;
            document.getElementById('epoch').textContent = state.training.epoch;
            document.getElementById('loss').textContent = state.training.loss.toFixed(4);
            document.getElementById('accuracy').textContent = `${state.training.accuracy.toFixed(2)}%`;
            document.getElementById('active-nodes').textContent = state.training.activeNodes;
            document.getElementById('complexity').textContent = state.training.complexity;
            document.getElementById('response-time').textContent = `${state.training.responseTime}ms`;
            document.getElementById('training-cycles').textContent = state.training.cycles;
            document.getElementById('data-points').textContent = state.training.dataPoints;
            document.getElementById('memory-used').textContent = `${state.qnn.memoryUsed}MB`;
            document.getElementById('robustness-score').textContent = `${state.qnn.robustnessScore.toFixed(2)}%`;
            document.getElementById('stress-response').textContent = state.qnn.stressResponse.toFixed(2);
        }

        // Update training stats
        function updateTrainingStats() {
            document.getElementById('training-rounds').textContent = state.training.rounds + state.training.cycles;
            
            const totalMinutes = state.training.totalTime + Math.floor(state.training.cycles / 10);
            const hours = Math.floor(totalMinutes / 60);
            const minutes = totalMinutes % 60;
            document.getElementById('total-training-time').textContent = `${hours}h ${minutes}m`;
            
            document.getElementById('best-score').textContent = `${Math.max(state.training.bestScore, state.training.accuracy).toFixed(2)}%`;
        }

        // Update test UI
        function updateTestUI() {
            document.getElementById('test-progress-bar').style.width = `${state.test.progress}%`;
            document.getElementById('test-progress').textContent = `${state.test.progress.toFixed(1)}%`;
            document.getElementById('flight-time').textContent = `${state.test.flightTime.toFixed(1)}s`;
            document.getElementById('distance').textContent = `${Math.round(state.test.distance)}m`;
            document.getElementById('collisions').textContent = state.test.collisions;
            document.getElementById('test-speed').textContent = `${state.test.speed.toFixed(1)} km/h`;
            document.getElementById('test-status').textContent = state.test.status;
            document.getElementById('test-score').textContent = `${state.test.score.toFixed(1)}%`;
            document.getElementById('current-environment').textContent = state.environmentType.charAt(0).toUpperCase() + state.environmentType.slice(1);
            document.getElementById('escapes').textContent = `${state.test.objectsCollected}/${state.test.totalObjects}`;
            
            // Update best time if available
            if (state.test.bestSearchTime > 0) {
                document.getElementById('test-status').textContent = `${state.test.status} - Best: ${state.test.bestSearchTime.toFixed(2)}s`;
            }
        }

        // Generate QNN grid
        function generateQNNGrid() {
            const grid = document.getElementById('qnn-grid');
            grid.innerHTML = '';
            
            for (let i = 0; i < 100; i++) {
                const cell = document.createElement('div');
                cell.className = 'qnn-cell';
                grid.appendChild(cell);
            }
            
            updateQNNGrid();
        }

        // Update QNN grid visualization
        function updateQNNGrid() {
            const cells = document.querySelectorAll('.qnn-cell');
            
            cells.forEach((cell, i) => {
                const row = Math.floor(i / 10);
                const col = i % 10;
                
                // Determine cell state based on training progress and parameters
                let stateClass = 'inactive';
                const activation = Math.random();
                
                if (state.training.running) {
                    if (activation < state.qnn.learningRate) {
                        stateClass = 'training';
                    } else if (activation < state.qnn.creativity) {
                        stateClass = 'active';
                    } else if (activation < 0.9) {
                        stateClass = 'learned';
                    }
                }
                
                cell.className = `qnn-cell ${stateClass}`;
            });
        }

        // Log message to console
        function logMessage(message, type = 'sys') {
            const consoleOutput = document.getElementById('console-output');
            const p = document.createElement('p');
            p.className = type;
            p.textContent = message;
            consoleOutput.appendChild(p);
            consoleOutput.scrollTop = consoleOutput.scrollHeight;
            
            // Keep only last 100 messages
            const messages = consoleOutput.querySelectorAll('p');
            if (messages.length > 100) {
                messages[0].remove();
            }
            
            // Add to training log
            state.trainingLog.push({
                timestamp: new Date().toISOString(),
                message: message,
                type: type
            });
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update drone position based on controls
            if (state.drone && !state.autopilotActive) {
                const speed = 0.1;
                
                if (state.flightControls.forward) state.drone.position.z -= speed;
                if (state.flightControls.backward) state.drone.position.z += speed;
                if (state.flightControls.left) state.drone.position.x -= speed;
                if (state.flightControls.right) state.drone.position.x += speed;
                if (state.flightControls.up) state.drone.position.y += speed;
                if (state.flightControls.down) state.drone.position.y -= speed;
                
                // Keep drone within bounds
                state.drone.position.x = Math.max(-35, Math.min(35, state.drone.position.x));
                state.drone.position.y = Math.max(1, Math.min(10, state.drone.position.y));
                state.drone.position.z = Math.max(-35, Math.min(35, state.drone.position.z));
            }
            
            // Update camera
            updateEnhancedCamera();
            
            // Render scene
            state.renderer.render(state.scene, state.camera);
        }

        // Initialize the application
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>