<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>edTV: INFRARED CLONER</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: #0a0a0a;
            color: #fff;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        
        #container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        #threeCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        .control-panel {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 12px;
            z-index: 3;
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 95%;
            max-width: 400px;
            border: 1px solid rgba(255, 0, 0, 0.5);
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.3);
        }
        
        .title {
            text-align: center;
            font-size: 1rem;
            margin-bottom: 3px;
            color: #ff3333;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.7);
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
        }
        
        .btn {
            background: rgba(255, 50, 50, 0.3);
            border: 1px solid #ff3333;
            color: #fff;
            padding: 8px 12px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s;
            flex: 1;
            min-width: 100px;
            text-align: center;
        }
        
        .btn:hover {
            background: rgba(255, 50, 50, 0.5);
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.7);
        }
        
        .btn.active {
            background: rgba(255, 50, 50, 0.7);
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.9);
        }
        
        .btn:disabled {
            background: rgba(100, 100, 100, 0.3);
            border: 1px solid #666;
            color: #888;
            box-shadow: none;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 3px;
        }
        
        .slider-container span {
            font-size: 0.75rem;
            color: #ccc;
            min-width: 100px;
        }
        
        input[type="range"] {
            flex: 1;
            -webkit-appearance: none;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #ff3333;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
        }
        
        .status {
            text-align: center;
            font-size: 0.7rem;
            color: #aaa;
            margin-top: 3px;
        }
        
        .instructions {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 12px;
            z-index: 3;
            max-width: 250px;
            border: 1px solid rgba(255, 0, 0, 0.5);
            font-size: 0.8rem;
            line-height: 1.3;
        }
        
        .instructions h3 {
            color: #ff3333;
            margin-bottom: 6px;
            font-size: 0.9rem;
        }
        
        .instructions p {
            margin-bottom: 6px;
        }
        
        .instructions ul {
            padding-left: 15px;
        }
        
        .instructions li {
            margin-bottom: 4px;
            font-size: 0.75rem;
        }
        
        .mode-selector {
            display: flex;
            gap: 5px;
            justify-content: center;
            margin-top: 5px;
        }
        
        .mode-btn {
            flex: 1;
            padding: 6px 10px;
            font-size: 0.7rem;
        }
        
        @media (max-width: 768px) {
            .instructions {
                display: none;
            }
            
            .control-panel {
                width: 98%;
                padding: 10px;
            }
            
            .btn {
                padding: 7px 10px;
                font-size: 0.75rem;
                min-width: 90px;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="threeCanvas"></canvas>
        
        <div class="instructions">
            <h3>edTV: INFRARED CLONER</h3>
            <p>Real-time infrared simulation with thermal imaging and night vision.</p>
            <ul>
                <li>Allow camera access when prompted</li>
                <li>Click and drag to rotate view</li>
                <li>Scroll to zoom in/out</li>
                <li>Switch between thermal and night vision modes</li>
                <li>Toggle camera (mobile) to switch between front/back</li>
            </ul>
        </div>
        
        <div class="control-panel">
            <div class="title">INFRARED CLONER - THERMAL/NIGHT VISION</div>
            
            <div class="controls">
                <button id="startBtn" class="btn">START</button>
                <button id="stopBtn" class="btn" disabled>STOP</button>
                <button id="switchCameraBtn" class="btn">SWITCH CAM</button>
            </div>
            
            <div class="mode-selector">
                <button id="thermalMode" class="btn mode-btn active">THERMAL</button>
                <button id="nightMode" class="btn mode-btn">NIGHT VISION</button>
            </div>
            
            <div class="slider-container">
                <span>Point Size:</span>
                <input type="range" id="pointSize" min="0.1" max="2" step="0.1" value="0.8">
            </div>
            
            <div class="slider-container">
                <span>Glow Intensity:</span>
                <input type="range" id="glowIntensity" min="1" max="20" step="1" value="10">
            </div>
            
            <div class="slider-container">
                <span>Bloom Effect:</span>
                <input type="range" id="bloomEffect" min="0" max="2" step="0.1" value="1.2">
            </div>
            
            <div class="status" id="status">Ready - Click START to begin</div>
        </div>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // Main application
        document.addEventListener('DOMContentLoaded', function() {
            // Scene setup
            let scene, camera, renderer, pointCloud, pointMaterial;
            let video, canvas2D, ctx2D;
            let isWebcamActive = false;
            let stream = null;
            let currentFacingMode = 'user'; // 'user' for front, 'environment' for back
            
            // Mode variables
            let currentMode = 'thermal'; // 'thermal' or 'night'
            let previousFrameData = null;
            
            // Mouse controls
            let isMouseDown = false;
            let mouseX = 0, mouseY = 0;
            let targetRotationX = 0, targetRotationY = 0;
            let targetZoom = 15;
            
            // Initialize Three.js
            function initThreeJS() {
                // Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x050505);
                
                // Camera
                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 0, 15);
                
                // Renderer
                renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('threeCanvas'),
                    antialias: true,
                    alpha: true
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(1, 1, 1);
                scene.add(directionalLight);
                
                // Add a grid for room size estimation
                const gridHelper = new THREE.GridHelper(20, 20, 0xff0000, 0x330000);
                gridHelper.position.y = -5;
                scene.add(gridHelper);
                
                // Create initial point cloud (will be updated with webcam data)
                createPointCloud();
                
                // Handle window resize
                window.addEventListener('resize', onWindowResize);
                
                // Mouse controls
                setupMouseControls();
                
                // Start animation loop
                animate();
            }
            
            // Set up mouse controls for camera rotation and zoom
            function setupMouseControls() {
                const canvas = document.getElementById('threeCanvas');
                
                // Mouse down event
                canvas.addEventListener('mousedown', function(event) {
                    isMouseDown = true;
                    mouseX = event.clientX;
                    mouseY = event.clientY;
                });
                
                // Mouse move event
                canvas.addEventListener('mousemove', function(event) {
                    if (!isMouseDown) return;
                    
                    const deltaX = event.clientX - mouseX;
                    const deltaY = event.clientY - mouseY;
                    
                    targetRotationY += deltaX * 0.01;
                    targetRotationX += deltaY * 0.01;
                    
                    mouseX = event.clientX;
                    mouseY = event.clientY;
                });
                
                // Mouse up event
                canvas.addEventListener('mouseup', function() {
                    isMouseDown = false;
                });
                
                // Mouse wheel for zoom
                canvas.addEventListener('wheel', function(event) {
                    event.preventDefault();
                    targetZoom += event.deltaY * 0.01;
                    targetZoom = Math.max(5, Math.min(30, targetZoom));
                });
            }
            
            // Create point cloud geometry
            function createPointCloud() {
                // Create a simple geometry with a grid of points
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(720 * 720 * 3);
                const colors = new Float32Array(720 * 720 * 3);
                
                let index = 0;
                for (let i = 0; i < 720; i++) {
                    for (let j = 0; j < 720; j++) {
                        positions[index] = (i - 360) * 0.01;
                        positions[index + 1] = (j - 360) * 0.01;
                        positions[index + 2] = 0;
                        
                        // Set initial color to dark red
                        colors[index] = 0.3;
                        colors[index + 1] = 0.0;
                        colors[index + 2] = 0.0;
                        
                        index += 3;
                    }
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                // Material with glowing effect
                pointMaterial = new THREE.PointsMaterial({
                    size: parseFloat(document.getElementById('pointSize').value),
                    vertexColors: true,
                    sizeAttenuation: true,
                    transparent: true,
                    opacity: 0.9
                });
                
                // Points
                pointCloud = new THREE.Points(geometry, pointMaterial);
                scene.add(pointCloud);
            }
            
            // Apply thermal color mapping
            function thermalColorMapping(brightness, motion = 0) {
                // Thermal color scale: black -> dark red -> red -> yellow -> white
                let r, g, b;
                
                if (brightness < 0.2) {
                    // Black to dark red
                    r = brightness * 2.5;
                    g = 0;
                    b = 0;
                } else if (brightness < 0.5) {
                    // Dark red to red
                    r = 0.5 + (brightness - 0.2) * 1.67;
                    g = 0;
                    b = 0;
                } else if (brightness < 0.8) {
                    // Red to yellow
                    r = 1.0;
                    g = (brightness - 0.5) * 3.33;
                    b = 0;
                } else {
                    // Yellow to white
                    r = 1.0;
                    g = 1.0;
                    b = (brightness - 0.8) * 5;
                }
                
                // Add motion glow (neon green for moving objects)
                if (motion > 0.1) {
                    g = Math.min(1, g + motion * 2);
                }
                
                return { r, g, b };
            }
            
            // Apply night vision color mapping
            function nightVisionColorMapping(brightness, motion = 0) {
                // Night vision: black -> dark green -> green -> bright green
                let r, g, b;
                
                if (brightness < 0.3) {
                    // Black to dark green
                    r = 0;
                    g = brightness * 1.67;
                    b = 0;
                } else if (brightness < 0.7) {
                    // Dark green to green
                    r = 0;
                    g = 0.5 + (brightness - 0.3) * 1.25;
                    b = 0;
                } else {
                    // Green to bright green
                    r = (brightness - 0.7) * 3.33;
                    g = 1.0;
                    b = (brightness - 0.7) * 1.67;
                }
                
                // Add motion glow (red for moving objects)
                if (motion > 0.1) {
                    r = Math.min(1, r + motion * 3);
                }
                
                return { r, g, b };
            }
            
            // Detect motion between frames
            function detectMotion(currentData, width, height) {
                if (!previousFrameData) {
                    previousFrameData = new Uint8ClampedArray(currentData.length);
                    return new Float32Array(width * height).fill(0);
                }
                
                const motionMap = new Float32Array(width * height);
                const threshold = 30; // Sensitivity to change
                
                for (let i = 0; i < currentData.length; i += 4) {
                    const pixelIndex = i / 4;
                    
                    // Calculate brightness for current and previous frame
                    const currentBrightness = (currentData[i] + currentData[i+1] + currentData[i+2]) / 3;
                    const prevBrightness = (previousFrameData[i] + previousFrameData[i+1] + previousFrameData[i+2]) / 3;
                    
                    // Calculate difference
                    const diff = Math.abs(currentBrightness - prevBrightness);
                    
                    // Normalize to 0-1 range
                    motionMap[pixelIndex] = Math.min(1, diff / threshold);
                }
                
                // Store current frame for next comparison
                previousFrameData.set(currentData);
                
                return motionMap;
            }
            
            // Update point cloud with webcam data
            function updatePointCloud() {
                if (!isWebcamActive || !video || video.readyState !== video.HAVE_ENOUGH_DATA) return;
                
                // Get video dimensions
                const srcW = video.videoWidth;
                const srcH = video.videoHeight;
                
                // Calculate crop area to get center 720x720
                const sx = Math.max(0, (srcW - 720) / 2);
                const sy = Math.max(0, (srcH - 720) / 2);
                const cropSize = Math.min(720, srcW, srcH);
                
                // Draw cropped video to 2D canvas for processing
                ctx2D.clearRect(0, 0, canvas2D.width, canvas2D.height);
                ctx2D.drawImage(video, sx, sy, cropSize, cropSize, 0, 0, canvas2D.width, canvas2D.height);
                
                const imageData = ctx2D.getImageData(0, 0, canvas2D.width, canvas2D.height);
                const data = imageData.data;
                
                // Detect motion
                const motionMap = detectMotion(data, canvas2D.width, canvas2D.height);
                
                // Get point cloud geometry
                const positions = pointCloud.geometry.attributes.position.array;
                const colors = pointCloud.geometry.attributes.color.array;
                
                const glowIntensity = parseFloat(document.getElementById('glowIntensity').value);
                const bloomEffect = parseFloat(document.getElementById('bloomEffect').value);
                const width = canvas2D.width;
                const height = canvas2D.height;
                
                // Update point positions based on video data
                let pointIndex = 0;
                for (let i = 0; i < height; i += 1) {
                    for (let j = 0; j < width; j += 1) {
                        const pixelIndex = (i * width + j) * 4;
                        const r = data[pixelIndex] / 255;
                        const g = data[pixelIndex + 1] / 255;
                        const b = data[pixelIndex + 2] / 255;
                        
                        // Calculate brightness and apply bloom effect
                        let brightness = (r + g + b) / 3;
                        brightness = Math.min(1, brightness * bloomEffect);
                        
                        // Get motion value for this pixel
                        const motion = motionMap[i * width + j];
                        
                        // Apply color mapping based on current mode
                        let color;
                        if (currentMode === 'thermal') {
                            color = thermalColorMapping(brightness, motion);
                        } else {
                            color = nightVisionColorMapping(brightness, motion);
                        }
                        
                        // Map to 3D space (centered, scaled)
                        const x = (j / width - 0.5) * 10;
                        const y = (0.5 - i / height) * 10;
                        const z = (brightness - 0.5) * glowIntensity;
                        
                        // Update position
                        positions[pointIndex * 3] = x;
                        positions[pointIndex * 3 + 1] = y;
                        positions[pointIndex * 3 + 2] = z;
                        
                        // Apply color with glow effect
                        colors[pointIndex * 3] = color.r;
                        colors[pointIndex * 3 + 1] = color.g;
                        colors[pointIndex * 3 + 2] = color.b;
                        
                        pointIndex++;
                        
                        // Safety check - don't exceed point cloud size
                        if (pointIndex * 3 >= positions.length) break;
                    }
                    // Safety check - don't exceed point cloud size
                    if (pointIndex * 3 >= positions.length) break;
                }
                
                // Mark attributes as needing update
                pointCloud.geometry.attributes.position.needsUpdate = true;
                pointCloud.geometry.attributes.color.needsUpdate = true;
            }
            
            // Start webcam
            async function startWebcam() {
                try {
                    updateStatus('Accessing camera...');
                    
                    stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            width: { ideal: 1280 },
                            height: { ideal: 720 },
                            facingMode: currentFacingMode
                        }, 
                        audio: false 
                    });
                    
                    video = document.createElement('video');
                    video.srcObject = stream;
                    video.play();
                    
                    // Create 2D canvas for processing video frames
                    canvas2D = document.createElement('canvas');
                    canvas2D.width = 720;
                    canvas2D.height = 720;
                    ctx2D = canvas2D.getContext('2d');
                    
                    // Wait for video to be ready
                    video.addEventListener('loadeddata', function() {
                        isWebcamActive = true;
                        updateStatus(`${currentMode.toUpperCase()} mode active - Drag to rotate, scroll to zoom`);
                        document.getElementById('startBtn').disabled = true;
                        document.getElementById('stopBtn').disabled = false;
                    });
                    
                } catch (error) {
                    console.error('Error accessing webcam:', error);
                    updateStatus('Error: Could not access webcam. Please check permissions.');
                }
            }
            
            // Stop webcam
            function stopWebcam() {
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                    stream = null;
                }
                
                isWebcamActive = false;
                video = null;
                canvas2D = null;
                ctx2D = null;
                previousFrameData = null;
                
                updateStatus('Webcam stopped - Click START to begin');
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
            }
            
            // Switch camera (front/back)
            async function switchCamera() {
                if (!isWebcamActive) return;
                
                // Stop current stream
                stopWebcam();
                
                // Toggle facing mode
                currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
                
                // Restart with new camera
                await startWebcam();
            }
            
            // Switch mode (thermal/night vision)
            function switchMode(mode) {
                currentMode = mode;
                
                // Update UI
                document.getElementById('thermalMode').classList.toggle('active', mode === 'thermal');
                document.getElementById('nightMode').classList.toggle('active', mode === 'night');
                
                if (isWebcamActive) {
                    updateStatus(`${mode.toUpperCase()} mode active - Drag to rotate, scroll to zoom`);
                }
            }
            
            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                
                if (isWebcamActive) {
                    updatePointCloud();
                }
                
                // Smooth camera rotation
                camera.rotation.x += (targetRotationX - camera.rotation.x) * 0.05;
                camera.rotation.y += (targetRotationY - camera.rotation.y) * 0.05;
                
                // Smooth camera zoom
                camera.position.z += (targetZoom - camera.position.z) * 0.1;
                
                renderer.render(scene, camera);
            }
            
            // Handle window resize
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            // Update status message
            function updateStatus(message) {
                document.getElementById('status').textContent = message;
            }
            
            // Initialize event listeners
            function initEventListeners() {
                // Webcam buttons
                document.getElementById('startBtn').addEventListener('click', startWebcam);
                document.getElementById('stopBtn').addEventListener('click', stopWebcam);
                document.getElementById('switchCameraBtn').addEventListener('click', switchCamera);
                
                // Mode buttons
                document.getElementById('thermalMode').addEventListener('click', () => switchMode('thermal'));
                document.getElementById('nightMode').addEventListener('click', () => switchMode('night'));
                
                // Sliders
                document.getElementById('pointSize').addEventListener('input', function() {
                    pointMaterial.size = parseFloat(this.value);
                });
            }
            
            // Initialize the application
            function init() {
                initThreeJS();
                initEventListeners();
            }
            
            // Start the app
            init();
        });
    </script>
</body>
</html>