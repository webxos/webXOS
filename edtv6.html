<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>edTV6</title>
<style>
  body,html{margin:0;height:100%;overflow:hidden;background:#000;color:#39ff14;font-family:monospace;}
  canvas{display:block;width:100vw;height:100vh;}
  #hud{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:10;}
  .corner{padding:12px;background:rgba(0,15,0,0.85);border:1px solid #39ff14;}
  #tl{top:0;left:0;}
  #tr{top:0;right:0;text-align:right;}
  #bl{bottom:0;left:0;}
  #br{bottom:0;right:0;text-align:right;}
  .btn{pointer-events:all;background:rgba(0,25,0,0.95);border:2px solid #39ff14;padding:14px 24px;font-size:16px;cursor:pointer;box-shadow:0 0 20px #39ff14;}
  #calibrate{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);z-index:20;padding:20px 40px;font-size:20px;}
  @keyframes neon{0%{box-shadow:0 0 20px #39ff14;}100%{box-shadow:0 0 50px #39ff14;}}
</style>
</head>
<body>

<canvas id="c"></canvas>

<div id="hud">
  <div class="corner" id="tl"><h2>edTV6</h2><div id="status">OFFLINE</div></div>
  <div class="corner" id="tr">SCAN ACTIVE</div>
  <div class="corner btn" id="bl" onclick="toggleDensity()">DENSITY: LOW</div>
  <div class="corner btn" id="br" onclick="resetView()">RESET VIEW</div>
</div>

<button id="calibrate" class="btn" style="animation:neon 1.5s infinite alternate;">CALIBRATE WEBCAM</button>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js';
import {OrbitControls} from 'https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/controls/OrbitControls.js';

const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100);
camera.position.set(0, 0, 6);

const controls = new OrbitControls(camera, canvas);
controls.enableDamping = true;

const grid = new THREE.GridHelper(12, 30, 0x39ff14, 0x003300);
grid.position.z = -2;
scene.add(grid);

let points, video, offscreen, ctx, density = 90;

function createPoints() {
  if (points) scene.remove(points), points.geometry.dispose(), points.material.dispose();
  const count = density * density;
  const geom = new THREE.BufferGeometry();
  const pos = new Float32Array(count * 3);
  const col = new Float32Array(count * 3);
  geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  geom.setAttribute('color', new THREE.BufferAttribute(col, 3));
  geom.boundingSphere = new THREE.Sphere(new THREE.Vector3(0,0,0), 10);
  const mat = new THREE.PointsMaterial({size: 0.09, vertexColors: true, sizeAttenuation: true});
  points = new THREE.Points(geom, mat);
  scene.add(points);
}
createPoints();

async function startWebcam() {
  document.getElementById('calibrate').style.display = 'none';
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: 'environment', width: {ideal: 640}, height: {ideal: 480} }
    });
    video = document.createElement('video');
    video.srcObject = stream;
    video.playsInline = true;
    video.muted = true;
    video.play();

    video.onloadedmetadata = () => {
      offscreen = document.createElement('canvas');
      offscreen.width = video.videoWidth;
      offscreen.height = video.videoHeight;
      ctx = offscreen.getContext('2d');
      document.getElementById('status').textContent = 'WEBCAM ONLINE';
      requestAnimationFrame(animate);
    };
  } catch (err) {
    document.getElementById('status').textContent = 'WEBCAM DENIED';
    document.getElementById('calibrate').style.display = 'block';
    console.error(err);
  }
}

document.getElementById('calibrate').onclick = startWebcam;

function updatePoints() {
  if (!video || video.readyState < 2 || !ctx) return;
  ctx.drawImage(video, 0, 0, offscreen.width, offscreen.height);
  const data = ctx.getImageData(0, 0, offscreen.width, offscreen.height).data;

  const pos = points.geometry.attributes.position.array;
  const col = points.geometry.attributes.color.array;

  let i = 0;
  for (let y = 0; y < density; y++) {
    for (let x = 0; x < density; x++) {
      const sx = (x / density) * offscreen.width | 0;
      const sy = (y / density) * offscreen.height | 0;
      const idx = (sy * offscreen.width + sx) * 4;

      const r = data[idx], g = data[idx+1], b = data[idx+2];
      const brightness = (r + g + b) / 765;

      pos[i*3]   = (x / density - 0.5) * 8;
      pos[i*3+1] = (0.5 - y / density) * 8;
      pos[i*3+2] = (brightness - 0.3) * 6;  // less jumpy

      col[i*3]   = r/255;
      col[i*3+1] = g/255;
      col[i*3+2] = b/255;
      i++;
    }
  }
  points.geometry.attributes.position.needsUpdate = true;
  points.geometry.attributes.color.needsUpdate = true;
}

window.toggleDensity = () => {
  density = density === 90 ? 140 : 90;
  document.getElementById('bl').textContent = `DENSITY: ${density === 90 ? 'LOW' : 'HIGH'}`;
  createPoints();
};

window.resetView = () => {
  camera.position.set(0, 0, 6);
  controls.target.set(0, 0, 0);
  controls.update();
};

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  updatePoints();
  renderer.render(scene, camera);
}

addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
