<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>edTV: CHANNEL 6</title>
    <meta name="theme-color" content="#000000">
    <link rel="manifest" href="data:application/manifest+json,{
        \"name\": \"NeuroTS AR Mirror\",
        \"short_name\": \"NeuroTS Mirror\",
        \"description\": \"NeuroTS-based 3D scene reconstruction with real-time object detection\",
        \"start_url\": \"./\",
        \"display\": \"fullscreen\",
        \"background_color\": \"#000000\",
        \"theme_color\": \"#000000\",
        \"icons\": [
            {
                \"src\": \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkyIiBoZWlnaHQ9IjE5MiIgdmlld0JveD0iMCAwIDE5MiAxOTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxOTIiIGhlaWdodD0iMTkyIiBmaWxsPSIjMDAwMDAwIi8+CjxwYXRoIGQ9Ik05NiAxMjhMMTI4IDk2SDY0TDEyOCA2NEw5NiAzMkw2NCA2NEgxMjhMNjQgOTZIMTI4TDk2IDEyOFoiIGZpbGw9IiMwMGZmMDAiLz4KPC9zdmc+Cg==\",
                \"sizes\": \"192x192\",
                \"type\": \"image/svg+xml\"
            }
        ]
    }">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.19.2/dist/ort.min.js"></script>
    <style>
        *{margin:0;padding:0;box-sizing:border-box;font-family:'Press Start 2P',cursive;image-rendering:pixelated}
        body{background:#000;color:#0f0;overflow:hidden;height:100vh;user-select:none;-webkit-tap-highlight-color:transparent}
        #appContainer{position:relative;width:100%;height:100vh;overflow:hidden}
        .matrix-grid{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(rgba(0,255,0,0.1)1px,transparent 1px),linear-gradient(90deg,rgba(0,255,0,0.1)1px,transparent 1px);background-size:16px 16px;opacity:0.3}
        .crt-overlay{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(to bottom,transparent 50%,rgba(0,20,0,0.1)50%);background-size:100% 4px;z-index:5;pointer-events:none;animation:scanline 8s linear infinite}
        @keyframes scanline{0%{background-position:0 0}100%{background-position:0 100%}}
        #visualizationContainer{position:absolute;top:0;left:0;width:100%;height:100%;z-index:2}
        #ideInterface{position:absolute;top:0;left:0;width:100%;height:100%;z-index:10}
        
        /* Top Banner with Glitch Effect */
        .top-banner {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 40px;
            background: rgba(255, 0, 255, 0.9);
            border-bottom: 2px solid #f0f;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 12;
            overflow: hidden;
            animation: glitch 3s infinite;
        }
        
        @keyframes glitch {
            0%, 100% { transform: translateX(0); }
            5% { transform: translateX(-2px); }
            10% { transform: translateX(2px); }
            15% { transform: translateX(-1px); }
            20% { transform: translateX(1px); }
            25% { transform: translateX(0); }
            50% { transform: translateX(0); }
            55% { transform: translateX(-1px) skewX(-2deg); }
            60% { transform: translateX(1px) skewX(2deg); }
            65% { transform: translateX(-1px) skewX(-1deg); }
            70% { transform: translateX(1px) skewX(1deg); }
            75% { transform: translateX(0); }
        }
        
        .top-banner::before {
            content: '';
            position: absolute;
            top: 0;
            left: -10%;
            width: 120%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            animation: shimmer 2s infinite;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .top-banner-text {
            font-size: 12px;
            color: #000;
            text-shadow: 1px 1px 0 #fff;
            letter-spacing: 1px;
        }
        
        /* Single Mirror Button - Moved Up */
        .mirror-btn{
            width:120px;height:52px;background:#000;border:3px solid #0ff;color:#0ff;
            font-size:10px;display:flex;align-items:center;justify-content:center;cursor:pointer;
            box-shadow:3px 3px 0 #000;transform:skew(-2deg);transition:background 0.1s,color 0.1s;
            touch-action:none;
            position:absolute;top:60px;left:50%;transform:translateX(-50%);z-index:11
        }
        .mirror-btn:hover,.mirror-btn:active{background:#0ff;color:#000}
        .mirror-btn.active{background:#0ff;color:#000}
        
        /* PPV Face View */
        .ppv-face-view {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 120px;
            height: 90px;
            background: #000;
            border: 2px solid #0ff;
            z-index: 15;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .ppv-face-view.expanded {
            width: 300px;
            height: 225px;
            z-index: 20;
        }
        
        .ppv-canvas {
            width: 100%;
            height: 100%;
        }
        
        /* Mirror Popup - Lightweight Window */
        .mirror-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 10, 0, 0.95);
            border: 3px solid #0ff;
            padding: 8px;
            z-index: 100;
            box-shadow: 6px 6px 0 #000, inset 2px 2px 0 #0ff;
            width: 320px;
            height: 400px;
            resize: both;
            overflow: hidden;
            font-size: 8px;
            color: #0ff;
            border-radius: 4px;
        }
        
        .mirror-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 8px;
            background: rgba(0, 255, 255, 0.2);
            border-bottom: 2px solid #0ff;
            margin-bottom: 8px;
            cursor: move;
            user-select: none;
        }
        
        .mirror-title {
            font-size: 10px;
            color: #0ff;
            text-shadow: 1px 1px 0 #000;
        }
        
        .mirror-close {
            width: 24px;
            height: 24px;
            background: #000;
            border: 2px solid #f00;
            color: #f00;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
        }
        
        .mirror-close:hover,.mirror-close:active{background:#f00;color:#000}
        
        .mirror-content {
            width: 100%;
            height: calc(100% - 40px);
            position: relative;
        }
        
        /* Webcam Mesh Styles */
        .webcam-mesh-container {
            width: 100%;
            height: 200px;
            background: #000;
            border: 2px solid #0f0;
            position: relative;
            overflow: hidden;
        }
        
        .webcam-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                linear-gradient(rgba(0, 255, 0, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 0, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
            z-index: 1;
        }
        
        .face-direction-arrow {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            transform-origin: center;
            z-index: 3;
            transition: transform 0.1s ease;
        }
        
        .face-direction-arrow::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 20px solid #f00;
        }
        
        .face-direction-arrow::after {
            content: '';
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 4px;
            height: 20px;
            background: #f00;
        }
        
        .user-position-marker {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #0ff;
            border-radius: 50%;
            z-index: 2;
            box-shadow: 0 0 10px #0ff;
        }
        
        #calibStatus{font-size:6px;color:#ff0;margin:4px 0;text-align:center}
        
        /* Radar Canvas Styles */
        #radarCanvas {
            width: 100%;
            height: 100px;
            border: 2px solid #0f0;
            background: #000;
            display: block;
            margin-top: 8px;
        }
        
        .radar-container {
            position: relative;
            width: 100%;
            height: 100px;
        }
        
        /* HUD Warning */
        #hudWarning{position:absolute;top:20%;left:50%;transform:translate(-50%,-50%);color:#f00;font-size:12px;text-shadow:1px 1px 0 #000;z-index:11;display:none}
        
        /* Scene Controls */
        .scene-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 11;
        }
        
        .scene-btn {
            width: 80px;
            height: 40px;
            background: #000;
            border: 2px solid #0f0;
            color: #0f0;
            font-size: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
        }
        
        .scene-btn:hover,.scene-btn:active{background:#0f0;color:#000}
        
        /* NeuroTS Status */
        .neurots-status {
            position: absolute;
            top: 50px;
            left: 10px;
            font-size: 8px;
            color: #0ff;
            z-index: 11;
            background: rgba(0,0,0,0.7);
            padding: 5px;
            border: 1px solid #0ff;
        }
        
        /* Desktop Override */
        @media (min-width:768px){
            .mirror-btn{width:140px;height:56px;font-size:12px}
        }
        
        /* Mobile Optimization */
        @media (max-width:767px){
            .mirror-popup{width:300px;height:380px}
            .scene-controls{flex-direction:column;align-items:center}
            .ppv-face-view{width:100px;height:75px}
            .ppv-face-view.expanded{width:280px;height:210px}
        }
        
        /* Accessibility improvements */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        
        /* Focus styles for accessibility */
        .mirror-btn:focus, .mirror-close:focus, .scene-btn:focus {
            outline: 2px solid #0ff;
            outline-offset: 2px;
        }
        
        /* Webcam Canvas */
        #webcamCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }
        
        /* Scene Click Area */
        #sceneClickArea {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: calc(100% - 80px);
            z-index: 3;
            cursor: pointer;
        }
    </style>
</head>
<body>
<div id="appContainer">
    <div class="matrix-grid"></div>
    <div class="crt-overlay"></div>
    
    <!-- Top Banner with Glitch Effect -->
    <div class="top-banner">
        <div class="top-banner-text">edTV: CHANNEL 6</div>
    </div>
    
    <!-- PPV Face View -->
    <div class="ppv-face-view" id="ppvFaceView">
        <canvas class="ppv-canvas" id="ppvCanvas"></canvas>
    </div>
    
    <!-- NeuroTS Status -->
    <div class="neurots-status" id="neurotsStatus">
        LIVE: CALIBRATING...
    </div>
    
    <!-- 3D SCENE -->
    <div id="visualizationContainer">
        <canvas id="visualizationCanvas"></canvas>
        <div id="sceneClickArea" title="Click to center view"></div>
    </div>
    
    <div id="ideInterface">
        <!-- SINGLE MIRROR BUTTON -->
        <button id="mirrorBtn" class="mirror-btn" aria-label="Open AR Mirror">edTV: CHANNEL 6</button>
        
        <!-- SCENE CONTROLS -->
        <div class="scene-controls">
            <button id="zoomInBtn" class="scene-btn" aria-label="Zoom In">ZOOM +</button>
            <button id="zoomOutBtn" class="scene-btn" aria-label="Zoom Out">ZOOM -</button>
            <button id="resetViewBtn" class="scene-btn" aria-label="Reset View">RESET</button>
        </div>
        
        <!-- HUD -->
        <div id="hudWarning">USER MISSING</div>
    </div>

    <!-- MIRROR POPUP -->
    <div class="mirror-popup" id="mirrorPopup">
        <div class="mirror-header">
            <div class="mirror-title">edTV</div>
            <div class="mirror-close" id="emergencyClose" aria-label="Emergency Close">X</div>
        </div>
        <div class="mirror-content">
            <div class="webcam-mesh-container" id="webcamMeshContainer">
                <canvas id="webcamCanvas"></canvas>
                <div class="webcam-grid"></div>
                <div class="face-direction-arrow" id="faceDirectionArrow"></div>
                <div class="user-position-marker" id="userPositionMarker" style="top: 50%; left: 50%;"></div>
            </div>
            <div id="calibStatus">AR CALIBRATING...</div>
            <div class="radar-container">
                <canvas id="radarCanvas"></canvas>
            </div>
        </div>
    </div>
</div>

<script>
    // Main Application Variables
    let scene, cam, ren, clock;
    let userObj, neurotsObjects = [], neurotsWalls = [];
    let faceDirection = 0, userDetected = false;
    let stream, faceMesh, camera;
    let isFrontCam = true;
    const user = new THREE.Vector3(0, 1, 0);
    let animationId = null;
    let serviceWorkerUrl = null;
    let mirrorDragging = false;
    let mirrorOffset = { x: 0, y: 0 };
    let depthSession = null;
    let neurotsReconstructionActive = false;
    let neurotsReconstructionData = [];
    let sceneScale = 1.0;
    let isZooming = false;

    // DOM utility functions
    const $ = s => document.querySelector(s);
    const $$ = s => document.querySelectorAll(s);

    function init() {
        try {
            init3D();
            setupFaceDetection();
            setupDepthModel();
            setupServiceWorker();
            setupEventListeners();
            autoStartMirror();
            animate();
            
            console.log("NeuroTS AR Mirror initialized successfully");
        } catch (error) {
            console.error('Initialization error:', error);
        }
    }

    function init3D() {
        try {
            // Initialize Three.js scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            cam.position.set(0, 2, 5);
            
            const canvas = $('#visualizationCanvas');
            ren = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                antialias: false, 
                powerPreference: "high-performance" 
            });
            ren.setSize(window.innerWidth, window.innerHeight);
            ren.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            clock = new THREE.Clock();

            // Lighting
            scene.add(new THREE.AmbientLight(0x003300));
            const dir = new THREE.DirectionalLight(0x00ff00, 0.4);
            dir.position.set(5, 10, 5);
            scene.add(dir);

            // Grid
            const gridSize = 20, gridDiv = 20;
            const gridMat = new THREE.LineBasicMaterial({ color: 0x004400 });
            const gridGeo = new THREE.BufferGeometry();
            const positions = [];
            for (let i = -gridSize / 2; i <= gridSize / 2; i += gridSize / gridDiv) {
                positions.push(i, 0, -gridSize / 2, i, 0, gridSize / 2);
                positions.push(-gridSize / 2, 0, i, gridSize / 2, 0, i);
            }
            gridGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            scene.add(new THREE.LineSegments(gridGeo, gridMat));

            // User object (NeuroTS organic representation)
            userObj = createNeurotsUser();
            userObj.position.copy(user);
            scene.add(userObj);

            cam.lookAt(user);
            ren.render(scene, cam);
            
        } catch (error) {
            console.error('3D initialization error:', error);
            throw new Error(`3D setup failed: ${error.message}`);
        }
    }

    function createNeurotsUser() {
        // Create organic neurots representation of user
        const group = new THREE.Group();
        
        // Head (organic sphere with neurots pattern)
        const headGeometry = new THREE.SphereGeometry(0.3, 8, 6);
        const headMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x00ffff, 
            wireframe: true 
        });
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.y = 0.3;
        group.add(head);
        
        // Body (organic cylinder)
        const bodyGeometry = new THREE.CylinderGeometry(0.2, 0.15, 0.6, 8);
        const bodyMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x00aaff, 
            wireframe: true 
        });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.y = -0.3;
        group.add(body);
        
        // Shoulders (organic representation)
        const shoulderGeometry = new THREE.SphereGeometry(0.1, 6, 4);
        const shoulderMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x0088ff, 
            wireframe: true 
        });
        
        const leftShoulder = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
        leftShoulder.position.set(-0.25, 0, 0);
        group.add(leftShoulder);
        
        const rightShoulder = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
        rightShoulder.position.set(0.25, 0, 0);
        group.add(rightShoulder);
        
        return group;
    }

    function setupFaceDetection() {
        try {
            faceMesh = new FaceMesh({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
                }
            });
            
            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            faceMesh.onResults(onFaceMeshResults);
            
            console.log("Face Mesh detection initialized");
        } catch (error) {
            console.error('Face detection setup error:', error);
        }
    }

    async function setupDepthModel() {
        try {
            // In a real implementation, we would load the Depth Anything V2 model here
            // For this demo, we'll simulate depth estimation
            console.log("Depth model setup (simulated)");
            
            // Simulate loading delay
            setTimeout(() => {
                $('#neurotsStatus').textContent = 'NEUROTS: READY';
                neurotsReconstructionActive = true;
            }, 2000);
            
        } catch (error) {
            console.error('Depth model setup error:', error);
        }
    }

    function onFaceMeshResults(results) {
        userDetected = results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0;
        $('#hudWarning').style.display = userDetected ? 'none' : 'block';
        
        const canvas = $('#webcamCanvas');
        const ppvCanvas = $('#ppvCanvas');
        const ctx = canvas.getContext('2d');
        const ppvCtx = ppvCanvas.getContext('2d');
        
        // Clear and draw the video frame
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ppvCtx.clearRect(0, 0, ppvCanvas.width, ppvCanvas.height);
        
        if (results.image) {
            ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
            ppvCtx.drawImage(results.image, 0, 0, ppvCanvas.width, ppvCanvas.height);
        }

        if (userDetected) {
            const landmarks = results.multiFaceLandmarks[0];
            
            // Draw face mesh
            drawConnectors(ctx, landmarks, FACEMESH_TESSELATION, { color: '#C0C0C070', lineWidth: 1 });
            drawConnectors(ctx, landmarks, FACEMESH_RIGHT_EYE, { color: '#FF3030', lineWidth: 1 });
            drawConnectors(ctx, landmarks, FACEMESH_LEFT_EYE, { color: '#30FF30', lineWidth: 1 });
            drawConnectors(ctx, landmarks, FACEMESH_FACE_OVAL, { color: '#E0E0E0', lineWidth: 2 });
            
            // Calculate face direction (yaw) using cheek landmarks
            const leftCheek = landmarks[234];
            const rightCheek = landmarks[454];
            const yaw = Math.atan2(
                (rightCheek.x - leftCheek.x) * canvas.width,
                (rightCheek.z - leftCheek.z) * 1000 // Approximate depth
            ) * 180 / Math.PI;
            
            faceDirection = yaw;
            $('#calibStatus').textContent = `NEUROTS CALIBRATED - FACING: ${yaw.toFixed(0)}Â°`;
            $('#faceDirectionArrow').style.transform = `translate(-50%, -50%) rotate(${yaw}deg)`;
            
            // Update NeuroTS reconstruction based on face direction
            updateNeurotsReconstruction(landmarks);
            
            // Update radar display
            updateRadar();
            
            // Send data to service worker if available
            if (navigator.serviceWorker?.controller) {
                navigator.serviceWorker.controller.postMessage({ 
                    type: 'face_data', 
                    landmarks: landmarks,
                    direction: yaw, 
                    detected: userDetected 
                });
            }
        } else {
            $('#calibStatus').textContent = 'NEUROTS CALIBRATING - FACE NOT DETECTED';
            $('#faceDirectionArrow').style.transform = `translate(-50%, -50%) rotate(0deg)`;
        }
    }

    function updateNeurotsReconstruction(landmarks) {
        if (!neurotsReconstructionActive) return;
        
        // Clear existing neurots objects periodically for dynamic reconstruction
        if (Math.random() < 0.05) {
            neurotsObjects.forEach(obj => {
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
                scene.remove(obj);
            });
            neurotsObjects = [];
        }
        
        // Create neurots-based organic objects based on face direction
        const numObjects = Math.floor(Math.random() * 3) + 2; // 2-4 objects
        
        for (let i = 0; i < numObjects; i++) {
            const isWall = Math.random() > 0.7; // 30% chance of being a wall
            
            // Position objects in a semi-circle in front of the user
            const angle = (Math.random() * 120 - 60 + faceDirection) * Math.PI / 180;
            const distance = 2 + Math.random() * 5; // 2-7 units away
            
            const pos = new THREE.Vector3(
                user.x + Math.sin(angle) * distance,
                user.y + (Math.random() * 2), // Vary height
                user.z + Math.cos(angle) * distance
            );
            
            // Create neurots organic geometry
            let geometry;
            const neurotsType = Math.floor(Math.random() * 4);
            
            switch(neurotsType) {
                case 0:
                    // Organic blob
                    geometry = new THREE.SphereGeometry(0.2 + Math.random() * 0.3, 6, 4);
                    break;
                case 1:
                    // Organic tube
                    geometry = new THREE.CylinderGeometry(
                        0.1 + Math.random() * 0.2, 
                        0.05 + Math.random() * 0.15, 
                        0.5 + Math.random(), 
                        6
                    );
                    break;
                case 2:
                    // Organic irregular shape
                    geometry = new THREE.DodecahedronGeometry(0.2 + Math.random() * 0.3, 0);
                    break;
                case 3:
                    // Organic cluster
                    geometry = new THREE.OctahedronGeometry(0.15 + Math.random() * 0.25, 0);
                    break;
            }
            
            const material = new THREE.MeshBasicMaterial({ 
                color: isWall ? 0x00ff00 : 0xff0000, // Green for walls, red for objects
                wireframe: true,
                transparent: true,
                opacity: 0.7
            });
            
            const obj = new THREE.Mesh(geometry, material);
            obj.position.copy(pos);
            
            // Add organic rotation and scale variation
            obj.rotation.x = Math.random() * Math.PI;
            obj.rotation.y = Math.random() * Math.PI;
            obj.rotation.z = Math.random() * Math.PI;
            
            obj.scale.x = 0.8 + Math.random() * 0.4;
            obj.scale.y = 0.8 + Math.random() * 0.4;
            obj.scale.z = 0.8 + Math.random() * 0.4;
            
            // Add user data for tracking
            obj.userData = {
                type: isWall ? 'wall' : 'object',
                id: i,
                distance: distance,
                neurots: true
            };
            
            scene.add(obj);
            neurotsObjects.push(obj);
            
            // Store reconstruction data for reinforcement learning
            neurotsReconstructionData.push({
                position: { x: pos.x, y: pos.y, z: pos.z },
                type: isWall ? 'wall' : 'object',
                timestamp: Date.now()
            });
        }
        
        // Limit reconstruction data to prevent memory issues
        if (neurotsReconstructionData.length > 100) {
            neurotsReconstructionData = neurotsReconstructionData.slice(-50);
        }
        
        // Update status
        $('#neurotsStatus').textContent = `NEUROTS: ${neurotsObjects.length} OBJECTS`;
    }

    function updateRadar() {
        const canvas = $('#radarCanvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        
        // Clear radar
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, width, height);
        
        // Draw radar circles
        ctx.strokeStyle = '#0f0';
        ctx.lineWidth = 1;
        
        // Outer circle
        ctx.beginPath();
        ctx.arc(width/2, height/2, 40, 0, Math.PI * 2);
        ctx.stroke();
        
        // Middle circle
        ctx.beginPath();
        ctx.arc(width/2, height/2, 25, 0, Math.PI * 2);
        ctx.stroke();
        
        // Inner circle
        ctx.beginPath();
        ctx.arc(width/2, height/2, 10, 0, Math.PI * 2);
        ctx.stroke();
        
        // Draw crosshairs
        ctx.beginPath();
        ctx.moveTo(width/2, 10);
        ctx.lineTo(width/2, height - 10);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(10, height/2);
        ctx.lineTo(width - 10, height/2);
        ctx.stroke();
        
        // Draw neurots objects on radar
        neurotsObjects.forEach(obj => {
            const dx = obj.position.x - user.x;
            const dz = (isFrontCam ? 1 : -1) * (obj.position.z - user.z);
            const angle = Math.atan2(dx, dz) - (faceDirection * Math.PI / 180);
            const distance = Math.hypot(dx, dz);
            
            if (distance < 7) { // Only show objects within radar range
                const radarX = width/2 + Math.sin(angle) * (distance / 7) * 40;
                const radarY = height/2 - Math.cos(angle) * (distance / 7) * 40;
                
                ctx.fillStyle = obj.userData.type === 'wall' ? '#0f0' : '#f00';
                ctx.beginPath();
                ctx.arc(radarX, radarY, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Add organic glow effect
                ctx.fillStyle = obj.userData.type === 'wall' ? 'rgba(0, 255, 0, 0.3)' : 'rgba(255, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(radarX, radarY, 6, 0, Math.PI * 2);
                ctx.fill();
            }
        });
        
        // Draw user position (center)
        ctx.fillStyle = '#0ff';
        ctx.beginPath();
        ctx.arc(width/2, height/2, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw direction indicator
        ctx.strokeStyle = '#ff0';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(width/2, height/2);
        ctx.lineTo(
            width/2 + Math.sin(faceDirection * Math.PI / 180) * 15,
            height/2 - Math.cos(faceDirection * Math.PI / 180) * 15
        );
        ctx.stroke();
    }

    function autoStartMirror() {
        // Automatically start the mirror when the app loads
        setTimeout(() => {
            openMirror();
            startWebcam();
        }, 1000);
    }

    function openMirror() {
        $('#mirrorPopup').style.display = 'block';
        $('#mirrorBtn').classList.add('active');
        
        // Setup PPV canvas size
        const ppvCanvas = $('#ppvCanvas');
        ppvCanvas.width = $('#ppvFaceView').clientWidth;
        ppvCanvas.height = $('#ppvFaceView').clientHeight;
    }

    function closeMirror() {
        $('#mirrorPopup').style.display = 'none';
        $('#mirrorBtn').classList.remove('active');
        stopWebcam();
    }

    function emergencyClose() {
        // Emergency close - kill webcam and close everything
        stopWebcam();
        closeMirror();
        $('#neurotsStatus').textContent = 'NEUROTS: EMERGENCY STOP';
        
        console.log("Emergency close activated");
    }

    function startWebcam() {
        if (stream) {
            return; // Webcam already running
        }
        
        const status = $('#calibStatus');
        status.textContent = 'NEUROTS CALIBRATING...';
        
        try {
            // Auto-detect camera direction based on device
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            isFrontCam = isMobile; // Use front camera on mobile, back on desktop
            
            // Request camera access
            navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: isFrontCam ? 'user' : 'environment',
                    width: { ideal: 640 },
                    height: { ideal: 480 }
                } 
            })
            .then(s => {
                stream = s;
                
                // Create video element for face detection
                const video = document.createElement('video');
                video.id = 'webcamVideo';
                video.srcObject = stream;
                video.autoplay = true;
                video.playsInline = true;
                video.style.display = 'none';
                document.body.appendChild(video);
                
                // Setup camera for face detection
                camera = new Camera(video, {
                    onFrame: async () => {
                        await faceMesh.send({ image: video });
                    },
                    width: 640,
                    height: 480
                });
                
                camera.start();
                
                // Setup webcam canvas
                const canvas = $('#webcamCanvas');
                canvas.width = 300;
                canvas.height = 200;
                
                status.textContent = 'NEUROTS CALIBRATING - FACE DETECTION ACTIVE';
                
                console.log("Webcam started successfully");
            })
            .catch(error => {
                console.error('Webcam error:', error);
                
                let errorMessage = 'CAMERA ACCESS DENIED';
                if (error.name === 'NotAllowedError') {
                    errorMessage = 'CAMERA ACCESS DENIED BY USER';
                } else if (error.name === 'NotFoundError') {
                    errorMessage = 'NO CAMERA FOUND';
                } else if (error.name === 'NotSupportedError') {
                    errorMessage = 'CAMERA NOT SUPPORTED';
                }
                
                status.textContent = errorMessage;
                stream = null;
            });
            
        } catch (error) {
            console.error('Webcam setup error:', error);
            status.textContent = 'WEBCAM SETUP FAILED';
        }
    }

    function stopWebcam() {
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            stream = null;
            
            if (camera) {
                camera.stop();
            }
            
            // Remove hidden video element
            const video = $('#webcamVideo');
            if (video) video.remove();
            
            $('#calibStatus').textContent = 'WEBCAM STOPPED';
            
            console.log("Webcam stopped");
        }
    }

    function centerView() {
        // Reset camera to center on user
        cam.position.set(0, 2, 5);
        cam.lookAt(user);
        
        console.log("View centered on user");
    }

    function zoomIn() {
        if (isZooming) return;
        
        isZooming = true;
        sceneScale = Math.min(sceneScale * 1.2, 3.0);
        
        // Apply scale to neurots objects
        neurotsObjects.forEach(obj => {
            const originalScale = obj.userData.originalScale || 1;
            obj.scale.setScalar(originalScale * sceneScale);
        });
        
        setTimeout(() => { isZooming = false; }, 300);
        console.log("Zoomed in");
    }

    function zoomOut() {
        if (isZooming) return;
        
        isZooming = true;
        sceneScale = Math.max(sceneScale / 1.2, 0.5);
        
        // Apply scale to neurots objects
        neurotsObjects.forEach(obj => {
            const originalScale = obj.userData.originalScale || 1;
            obj.scale.setScalar(originalScale * sceneScale);
        });
        
        setTimeout(() => { isZooming = false; }, 300);
        console.log("Zoomed out");
    }

    function setupEventListeners() {
        // Mirror button event listener
        $('#mirrorBtn').addEventListener('click', () => {
            if ($('#mirrorPopup').style.display === 'block') {
                closeMirror();
            } else {
                openMirror();
                startWebcam();
            }
        });
        
        // Emergency close button
        $('#emergencyClose').addEventListener('click', emergencyClose);
        
        // Scene click area for centering view
        $('#sceneClickArea').addEventListener('click', centerView);
        
        // Zoom controls
        $('#zoomInBtn').addEventListener('click', zoomIn);
        $('#zoomOutBtn').addEventListener('click', zoomOut);
        $('#resetViewBtn').addEventListener('click', centerView);
        
        // PPV face view toggle
        $('#ppvFaceView').addEventListener('click', () => {
            $('#ppvFaceView').classList.toggle('expanded');
        });
        
        // Mirror dragging functionality
        const mirrorHeader = $('.mirror-header');
        const mirrorPopup = $('#mirrorPopup');
        
        mirrorHeader.addEventListener('mousedown', startDrag);
        mirrorHeader.addEventListener('touchstart', startDrag);
        
        function startDrag(e) {
            e.preventDefault();
            mirrorDragging = true;
            
            const rect = mirrorPopup.getBoundingClientRect();
            if (e.type === 'mousedown') {
                mirrorOffset.x = e.clientX - rect.left;
                mirrorOffset.y = e.clientY - rect.top;
            } else if (e.type === 'touchstart') {
                mirrorOffset.x = e.touches[0].clientX - rect.left;
                mirrorOffset.y = e.touches[0].clientY - rect.top;
            }
            
            document.addEventListener('mousemove', dragMirror);
            document.addEventListener('touchmove', dragMirror);
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchend', stopDrag);
        }
        
        function dragMirror(e) {
            if (!mirrorDragging) return;
            e.preventDefault();
            
            let clientX, clientY;
            if (e.type === 'mousemove') {
                clientX = e.clientX;
                clientY = e.clientY;
            } else if (e.type === 'touchmove') {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            }
            
            mirrorPopup.style.left = (clientX - mirrorOffset.x) + 'px';
            mirrorPopup.style.top = (clientY - mirrorOffset.y) + 'px';
            mirrorPopup.style.transform = 'none';
        }
        
        function stopDrag() {
            mirrorDragging = false;
            document.removeEventListener('mousemove', dragMirror);
            document.removeEventListener('touchmove', dragMirror);
            document.removeEventListener('mouseup', stopDrag);
            document.removeEventListener('touchend', stopDrag);
        }
        
        // Window resize handler
        window.addEventListener('resize', () => {
            cam.aspect = window.innerWidth / window.innerHeight;
            cam.updateProjectionMatrix();
            ren.setSize(window.innerWidth, window.innerHeight);
            
            // Update PPV canvas size
            const ppvCanvas = $('#ppvCanvas');
            const ppvView = $('#ppvFaceView');
            ppvCanvas.width = ppvView.clientWidth;
            ppvCanvas.height = ppvView.clientHeight;
        }, { passive: true });
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', cleanup);
        
        console.log("Event listeners setup complete");
    }

    function cleanup() {
        // Stop animation loop
        if (animationId) {
            cancelAnimationFrame(animationId);
        }
        
        // Stop webcam
        if (stream) {
            stopWebcam();
        }
        
        // Clean up Three.js resources
        if (scene) {
            scene.traverse(object => {
                if (object.geometry) object.geometry.dispose();
                if (object.material) {
                    if (Array.isArray(object.material)) {
                        object.material.forEach(material => material.dispose());
                    } else {
                        object.material.dispose();
                    }
                }
            });
        }
        
        // Revoke service worker URL
        if (serviceWorkerUrl) {
            URL.revokeObjectURL(serviceWorkerUrl);
        }
        
        console.log("Cleanup completed");
    }

    function setupServiceWorker() {
        if ('serviceWorker' in navigator) {
            try {
                const swScript = `
                    const CACHE_NAME = 'neurots-mirror-cache-v1';
                    const urlsToCache = [
                        '/',
                        '/index.html',
                        'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js',
                        'https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js',
                        'https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js',
                        'https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js',
                        'https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js',
                        'https://cdn.jsdelivr.net/npm/onnxruntime-web@1.19.2/dist/ort.min.js',
                        'https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap'
                    ];
                    
                    self.addEventListener('install', (event) => {
                        self.skipWaiting();
                        event.waitUntil(
                            caches.open(CACHE_NAME).then((cache) => {
                                return cache.addAll(urlsToCache);
                            })
                        );
                        console.log('Service Worker: Installed');
                    });
                    
                    self.addEventListener('activate', (event) => {
                        self.clients.claim();
                        console.log('Service Worker: Activated');
                    });
                    
                    self.addEventListener('fetch', (event) => {
                        event.respondWith(
                            caches.match(event.request).then(response => {
                                return response || fetch(event.request);
                            })
                        );
                    });
                    
                    // NeuroTS reinforcement learning data collection
                    self.addEventListener('message', (event) => {
                        if (event.data && event.data.type === 'neurots_data') {
                            // Store neurots reconstruction data for reinforcement learning
                            console.log('NeuroTS data received:', event.data);
                            
                            // In a real implementation, this would send data to a reinforcement learning model
                            // For this demo, we'll just log it
                        }
                    });
                `;
                
                const swBlob = new Blob([swScript], { type: 'application/javascript' });
                serviceWorkerUrl = URL.createObjectURL(swBlob);
                
                navigator.serviceWorker.register(serviceWorkerUrl)
                    .then((registration) => {
                        console.log('Service Worker registered successfully');
                    })
                    .catch((error) => {
                        console.error('Service Worker registration failed:', error);
                    });
                
            } catch (error) {
                console.error('Service Worker setup error:', error);
            }
        } else {
            console.log("Service Worker not supported");
        }
    }

    function animate() {
        animationId = requestAnimationFrame(animate);
        const deltaTime = clock.getDelta();
        
        // Update user rotation based on face direction
        if (userObj) {
            userObj.rotation.y = -faceDirection * Math.PI / 180;
        }
        
        // Animate neurots objects with organic movement
        neurotsObjects.forEach((obj, index) => {
            // Gentle organic pulsing
            const pulse = Math.sin(Date.now() * 0.002 + index) * 0.1;
            obj.scale.x = (obj.userData.originalScaleX || 1) * (1 + pulse) * sceneScale;
            obj.scale.y = (obj.userData.originalScaleY || 1) * (1 + pulse) * sceneScale;
            obj.scale.z = (obj.userData.originalScaleZ || 1) * (1 + pulse) * sceneScale;
            
            // Store original scale if not already stored
            if (!obj.userData.originalScaleX) {
                obj.userData.originalScaleX = obj.scale.x / sceneScale;
                obj.userData.originalScaleY = obj.scale.y / sceneScale;
                obj.userData.originalScaleZ = obj.scale.z / sceneScale;
            }
            
            // Gentle organic rotation
            obj.rotation.x += deltaTime * 0.1;
            obj.rotation.y += deltaTime * 0.15;
            obj.rotation.z += deltaTime * 0.05;
        });
        
        // Update camera to follow user with organic movement
        const camX = user.x + Math.sin(faceDirection * Math.PI / 180) * 5;
        const camY = user.y + 2 + Math.sin(Date.now() * 0.001) * 0.1; // Gentle bobbing
        const camZ = user.z + Math.cos(faceDirection * Math.PI / 180) * 5;
        
        cam.position.lerp(new THREE.Vector3(camX, camY, camZ), 0.1);
        cam.lookAt(user);
        
        // Render scene
        ren.render(scene, cam);
        
        // Send NeuroTS data to service worker periodically
        if (neurotsReconstructionData.length > 0 && Math.random() < 0.01) {
            navigator.serviceWorker?.controller?.postMessage({
                type: 'neurots_data',
                data: neurotsReconstructionData.slice(-10) // Send recent data
            });
        }
    }

    // Initialize the application when the window loads
    window.addEventListener('load', init);
</script>
</body>
</html>
