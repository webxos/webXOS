<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Server MCP Controller</title>
    <link rel="icon" href="/static/icon.png">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=stylesheet">
    <link rel="stylesheet" href="/static/style.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: monospace, sans-serif;
        }

        html, body {
            height: 100vh;
            overflow: hidden;
            background: #000;
            color: #0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: background 0.3s, box-shadow 0.3s;
            -webkit-tap-highlight-color: transparent;
        }

        body.glow {
            background: rgba(255, 0, 0, 0.1);
            box-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000 inset;
        }

        h1 {
            font-size: 1.6rem;
            text-align: center;
            margin: 0.8rem 0;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 0 5px #0f0;
        }

        #console {
            width: 90%;
            max-width: 900px;
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #0f0;
            padding: 0.6rem;
            flex: 1;
            max-height: calc(100vh - 240px);
            overflow-y: auto;
            margin: 0.5rem 0;
            border-radius: 5px;
            font-size: 0.8rem;
            -webkit-overflow-scrolling: touch;
            transition: border-color 0.3s, box-shadow 0.3s;
        }

        #console.active-monitor {
            border-color: #ff0000;
            box-shadow: 0 0 10px #ff0000;
        }

        #console p {
            margin: 0.2rem 0;
        }

        #console .command {
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            text-shadow: 0 0 3px #0f0;
        }

        .button-group {
            display: flex;
            gap: 0.5rem;
            margin: 0.5rem 0;
            padding: 0.5rem;
            flex-wrap: wrap;
            justify-content: center;
            width: 90%;
            max-width: 900px;
        }

        button {
            background: #0f0;
            color: #000;
            border: none;
            padding: 0.6rem 1.2rem;
            font-size: 0.9rem;
            cursor: pointer;
            border-radius: 3px;
            min-width: 90px;
            text-align: center;
            touch-action: manipulation;
            transition: background 0.3s, box-shadow 0.3s;
        }

        button:hover, button:focus {
            background: #0c0;
            outline: 2px solid #0f0;
        }

        button.active-monitor {
            background: #ff0000;
            box-shadow: 0 0 10px #ff0000;
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
        }

        #server-stats {
            width: 90%;
            max-width: 900px;
            margin: 0.5rem 0;
            display: flex;
            flex-direction: column;
            gap: 0.2rem;
        }

        .progress-container {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .progress-label {
            width: 90px;
            font-size: 0.75rem;
        }

        .progress-bar {
            flex: 1;
            height: 8px;
            background: #333;
            border: 1px solid #0f0;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #0f0;
            transition: width 0.5s;
        }

        footer {
            width: 100%;
            padding: 0.4rem;
            font-size: 9pt;
            text-align: center;
            color: #0f0;
            background: rgba(0, 0, 0, 0.8);
            line-height: 1.2;
        }

        @media (max-width: 600px) {
            h1 { font-size: 1.1rem; margin: 0.5rem 0; }
            #console { 
                font-size: 0.75rem; 
                padding: 0.5rem; 
                max-height: calc(100vh - 220px); 
            }
            button { 
                padding: 0.5rem 1rem; 
                font-size: 0.85rem; 
                min-width: 80px; 
            }
            footer { padding: 0.3rem; }
            .progress-label { width: 70px; font-size: 0.7rem; }
            .progress-bar { height: 7px; }
        }

        @media (max-width: 400px) {
            .button-group { flex-direction: column; align-items: center; }
            button { width: 100%; max-width: 160px; }
            #console { max-height: calc(100vh - 200px); }
            #server-stats { gap: 0.15rem; }
        }
    </style>
</head>
<body>
    <h1 role="heading" aria-level="1">Server MCP Controller</h1>
    <div id="console" role="log" aria-live="polite">
        <p>Server MCP Controller: Check: Run server health checks | Monitor: Toggle real-time latency monitoring | Clear: Reset console</p>
    </div>
    <div id="server-stats">
        <div class="progress-container">
            <span class="progress-label">Agent 1:</span>
            <div class="progress-bar"><div class="progress-fill" id="agent1-bar" style="width: 0%"></div></div>
            <span id="agent1-value">0 ms</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">Agent 2:</span>
            <div class="progress-bar"><div class="progress-fill" id="agent2-bar" style="width: 0%"></div></div>
            <span id="agent2-value">0 ms</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">Agent 3:</span>
            <div class="progress-bar"><div class="progress-fill" id="agent3-bar" style="width: 0%"></div></div>
            <span id="agent3-value">0 ms</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">Agent 4:</span>
            <div class="progress-bar"><div class="progress-fill" id="agent4-bar" style="width: 0%"></div></div>
            <span id="agent4-value">0 ms</span>
        </div>
    </div>
    <div class="button-group">
        <button id="check-btn" aria-label="Run server health checks">Check</button>
        <button id="monitor-btn" aria-label="Toggle real-time latency monitoring">Monitor</button>
        <button id="clear-btn" aria-label="Clear console output">Clear</button>
    </div>
    <footer>
        © 2025 WebXOS - Server MCP Controller<br>
        Check: Run server health checks | Monitor: Toggle real-time latency monitoring | Clear: Reset console
    </footer>

    <script>
        function serverLog(message) {
            console.log(`[SERVER] ${message}`);
        }

        const consoleDiv = document.getElementById('console');
        let logQueue = [];
        function logMessage(message, isCommand = false) {
            const formattedMessage = isCommand 
                ? `<span class="command">${message}</span>`
                : message;
            logQueue.push(`[${new Date().toLocaleTimeString()}] ${formattedMessage}`);
            if (logQueue.length > 50) logQueue.shift();
            throttleConsoleUpdate();
        }

        const throttleConsoleUpdate = (() => {
            let timeout;
            return () => {
                if (!timeout) {
                    timeout = setTimeout(() => {
                        consoleDiv.innerHTML = logQueue.map(msg => `<p>${msg}</p>`).join('');
                        consoleDiv.scrollTop = consoleDiv.scrollHeight;
                        timeout = null;
                    }, 100);
                }
            };
        })();

        function triggerGlow() {
            document.body.classList.add('glow');
            setTimeout(() => document.body.classList.remove('glow'), 1000);
        }

        function flashRedGlow() {
            consoleDiv.classList.add('active-monitor');
            setTimeout(() => consoleDiv.classList.remove('active-monitor'), 500);
            setTimeout(() => {
                consoleDiv.classList.add('active-monitor');
                setTimeout(() => consoleDiv.classList.remove('active-monitor'), 500);
            }, 1000);
        }

        function clearConsole() {
            serverLog('Clear button clicked');
            try {
                logQueue = ['Server MCP Controller: Check: Run server health checks | Monitor: Toggle real-time latency monitoring | Clear: Reset console'];
                document.getElementById('agent1-bar').style.width = '0%';
                document.getElementById('agent1-value').textContent = '0 ms';
                document.getElementById('agent2-bar').style.width = '0%';
                document.getElementById('agent2-value').textContent = '0 ms';
                document.getElementById('agent3-bar').style.width = '0%';
                document.getElementById('agent3-value').textContent = '0 ms';
                document.getElementById('agent4-bar').style.width = '0%';
                document.getElementById('agent4-value').textContent = '0 ms';
                throttleConsoleUpdate();
                logMessage('Console and stats cleared.', true);
            } catch (err) {
                logMessage(`Clear Error: ${err.message}`, true);
                serverLog(`Clear Error: ${err.stack}`);
            }
        }

        async function fetchWithErrorHandling(url, options = {}) {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                const response = await fetch(url, { ...options, signal: controller.signal });
                clearTimeout(timeoutId);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    const text = await response.text();
                    throw new Error(`Expected JSON, got ${contentType}: ${text.slice(0, 50)}...`);
                }
                return await response.json();
            } catch (error) {
                const stack = error.stack || 'No stack trace available';
                const analysis = analyzeServerError(error.message, stack, url);
                logMessage(`Error fetching ${url}: ${error.message}\nAnalysis: ${analysis}`);
                return { error: error.message, analysis };
            }
        }

        function analyzeServerError(message, stack, url) {
            const analysis = [];
            if (message.includes('HTTP 404')) {
                analysis.push('404 Error: Endpoint not found.');
                analysis.push(`Verify Netlify Function deployment in netlify.toml. Ensure functions directory is set to 'server'.`);
                analysis.push(`Check if ${url} is defined in server/${url.split('/')[2]}/index.js and deployed to /.netlify/functions/${url.split('/')[2]}.`);
                analysis.push('Suggestion: Run `netlify deploy --prod` and check Netlify Functions dashboard.');
                analysis.push('Local Test: Run `netlify dev` and curl `http://localhost:8888/.netlify/functions/${url.split('/')[2]}`.');
            }
            if (message.includes('Expected JSON')) {
                analysis.push('Server returned non-JSON response. Ensure endpoint returns Content-Type: application/json.');
                analysis.push('Suggestion: Verify agent index.js returns valid JSON with `module.exports.handler`.');
            }
            if (message.includes('AbortError') || stack.includes('Timeout')) {
                analysis.push('Request timed out. Check server availability or increase timeout.');
                analysis.push('Suggestion: Test with `netlify dev` locally to diagnose network issues.');
            }
            return analysis.length ? analysis.join('\n') : 'No specific issues identified. Check Netlify logs for details.';
        }

        class ServerAgent {
            constructor(name) {
                this.name = name;
                this.latencyHistory = [];
            }

            async checkLatency() {
                const start = performance.now();
                const response = await fetchWithErrorHandling(`/.netlify/functions/${this.name}/health`);
                const latency = performance.now() - start;
                this.latencyHistory.push(latency);
                if (this.latencyHistory.length > 20) this.latencyHistory.shift();
                return { 
                    latency, 
                    status: response.error ? 'Error' : response.status || 'Healthy',
                    error: response.error || null,
                    analysis: response.analysis || null
                };
            }
        }

        const agents = [
            new ServerAgent('server-agent1'),
            new ServerAgent('server-agent2'),
            new ServerAgent('server-agent3'),
            new ServerAgent('server-agent4')
        ];

        async function checkServers() {
            serverLog('Check button clicked');
            triggerGlow();
            flashRedGlow();
            try {
                const checkBtn = document.getElementById('check-btn');
                checkBtn.disabled = true;
                logMessage('Running server health checks...', true);

                const results = [];
                for (const [index, agent] of agents.entries()) {
                    const { latency, status, error, analysis } = await agent.checkLatency();
                    results.push({ name: agent.name, latency, status, error, analysis });
                    logMessage(`${agent.name}: ${status} (Latency: ${latency.toFixed(2)}ms)${error ? `\nError: ${error}\nAnalysis: ${analysis}` : ''}`);
                    document.getElementById(`agent${index + 1}-bar`).style.width = `${Math.min(100, latency / 2)}%`;
                    document.getElementById(`agent${index + 1}-value`).textContent = `${latency.toFixed(2)} ms`;
                }

                const checkDate = new Date().toLocaleString();
                const avgLatency = results.reduce((sum, res) => sum + res.latency, 0) / results.length;
                const worstAgent = results.reduce((worst, res) => res.latency > worst.latency ? res : worst, results[0]);
                const errorCount = results.filter(res => res.error).length;

                let report = `Server MCP Controller Diagnostic Report\n\n`;
                report += `Check Date: ${checkDate}\n`;
                report += `Agents: ${agents.length}\n`;
                report += `Errors Detected: ${errorCount}\n\n`;
                report += `Agent Status:\n`;
                results.forEach(res => {
                    report += `${res.name}: ${res.status} (Latency: ${res.latency.toFixed(2)}ms)${res.error ? `\n  Error: ${res.error}\n  Analysis: ${res.analysis}` : ''}\n`;
                });
                report += `\nAverage Latency: ${avgLatency.toFixed(2)}ms\n`;
                report += `Highest Latency: ${worstAgent.name} (${worstAgent.latency.toFixed(2)}ms)\n`;
                report += `\nRecommendations:\n`;
                report += errorCount > 0 
                    ? '- Review error analysis for affected agents.\n- Check Netlify Functions logs.\n- Redeploy with `netlify deploy --prod`.\n'
                    : worstAgent.latency > 100 
                        ? '- Investigate network issues for high-latency agent.\n- Optimize server resources.\n'
                        : '- Maintain current configurations.\n- Monitor for latency spikes.\n';
                report += `\nCertified by WebXOS on ${checkDate}\n`;
                report += `\n© 2025 WebXOS - Server MCP Controller`;

                try {
                    await navigator.clipboard.writeText(report);
                    logMessage('Diagnostic report copied to clipboard.', true);
                } catch (err) {
                    logMessage(`Clipboard Error: ${err.message}`, true);
                    const textarea = document.createElement('textarea');
                    textarea.value = report;
                    document.body.appendChild(textarea);
                    textarea.select();
                    try {
                        document.execCommand('copy');
                        logMessage('Diagnostic report copied (fallback).', true);
                    } catch (copyErr) {
                        logMessage(`Copy Error: ${copyErr.message}`, true);
                    }
                    document.body.removeChild(textarea);
                }

                logMessage(`Average Latency: ${avgLatency.toFixed(2)}ms`, true);
                if (errorCount > 0) {
                    logMessage(`Errors detected in ${errorCount} agent(s). Review report for details.`, true);
                    flashRedGlow();
                }
                checkBtn.disabled = false;
            } catch (err) {
                logMessage(`Check Error: ${err.message}`, true);
                serverLog(`Check Error: ${err.stack}`);
                document.getElementById('check-btn').disabled = false;
            }
        }

        let monitorActive = false;
        let monitorStartTime = null;
        let monitorInterval = null;

        async function updateServerStats() {
            try {
                for (const [index, agent] of agents.entries()) {
                    const { latency, status, error, analysis } = await agent.checkLatency();
                    const barId = `agent${index + 1}-bar`;
                    const valueId = `agent${index + 1}-value`;
                    document.getElementById(barId).style.width = `${Math.min(100, latency / 2)}%`;
                    document.getElementById(valueId).textContent = `${latency.toFixed(2)} ms`;
                    logMessage(`${agent.name}: ${status} (Latency: ${latency.toFixed(2)}ms)${error ? `\nError: ${error}\nAnalysis: ${analysis}` : ''}`);
                }

                const avgLatency = agents.reduce((sum, agent) => sum + (agent.latencyHistory[agent.latencyHistory.length - 1] || 0), 0) / agents.length;
                const errorCount = (await Promise.all(agents.map(agent => agent.checkLatency()))).filter(res => res.error).length;
                let stateMessage = '';
                let hints = [];

                if (errorCount > 0) {
                    stateMessage = `Server State: Critical - ${errorCount} agent(s) with errors.`;
                    hints = ['Review error analysis in logs.', 'Check Netlify Functions dashboard.', 'Redeploy functions with `netlify deploy --prod`.'];
                    flashRedGlow();
                } else if (avgLatency < 50) {
                    stateMessage = 'Server State: Optimal - Low latency across agents.';
                    hints = ['Maintain current configurations.', 'Continue monitoring for consistency.'];
                } else if (avgLatency < 100) {
                    stateMessage = 'Server State: Moderate - Acceptable latency, optimize further.';
                    hints = ['Check network stability.', 'Optimize server resources.'];
                } else if (avgLatency < 150) {
                    stateMessage = 'Server State: High - Elevated latency, action needed.';
                    hints = ['Investigate network bottlenecks.', 'Scale server resources.'];
                } else {
                    stateMessage = 'Server State: Critical - High latency, immediate action needed.';
                    hints = ['Restart affected agents.', 'Check server logs for errors.'];
                    flashRedGlow();
                }

                logMessage(stateMessage, true);
                hints.forEach(hint => logMessage(`Hint: ${hint}`));
            } catch (err) {
                logMessage(`Monitor Error: ${err.message}`, true);
                serverLog(`Monitor Error: ${err.stack}`);
            }
        }

        async function toggleMonitor() {
            monitorActive = !monitorActive;
            const monitorBtn = document.getElementById('monitor-btn');
            const consoleDiv = document.getElementById('console');
            monitorBtn.classList.toggle('active-monitor', monitorActive);
            consoleDiv.classList.toggle('active-monitor', monitorActive);
            triggerGlow();
            flashRedGlow();

            if (monitorActive) {
                monitorStartTime = new Date();
                logMessage('Monitor: Real-time latency monitoring activated.', true);
                await updateServerStats();
                monitorInterval = setInterval(async () => {
                    if (window.requestIdleCallback) {
                        window.requestIdleCallback(async () => await updateServerStats(), { timeout: 1000 });
                    } else {
                        await updateServerStats();
                    }
                }, 5000);
            } else {
                clearInterval(monitorInterval);
                logMessage('Monitor: Real-time latency monitoring deactivated.', true);

                const stopTime = new Date();
                const timeRanSeconds = Math.round((stopTime - monitorStartTime) / 1000);
                const results = [];
                for (const agent of agents) {
                    const avgLatency = agent.latencyHistory.length > 0 
                        ? agent.latencyHistory.reduce((sum, lat) => sum + lat, 0) / agent.latencyHistory.length 
                        : 0;
                    results.push({ name: agent.name, avgLatency });
                }

                const worstAgent = results.reduce((worst, res) => res.avgLatency > worst.avgLatency ? res : worst, results[0]);
                const avgLatency = results.reduce((sum, res) => sum + res.avgLatency, 0) / results.length;
                const errorCount = (await Promise.all(agents.map(agent => agent.checkLatency()))).filter(res => res.error).length;

                let report = `Server MCP Controller Monitoring Report\n\n`;
                report += `Monitoring Stopped: ${stopTime.toLocaleString()}\n`;
                report += `Monitoring Duration: ${Math.floor(timeRanSeconds / 60)}m ${timeRanSeconds % 60}s\n`;
                report += `Agents: ${agents.length}\n`;
                report += `Errors Detected: ${errorCount}\n\n`;
                report += `Agent Latencies:\n`;
                results.forEach(res => {
                    report += `${res.name}: ${res.avgLatency.toFixed(2)}ms (avg)\n`;
                });
                report += `\nOverall Average Latency: ${avgLatency.toFixed(2)}ms\n`;
                report += `Highest Latency: ${worstAgent.name} (${worstAgent.avgLatency.toFixed(2)}ms)\n`;
                report += `\nRecommendation: ${errorCount > 0 ? 'Resolve errors in affected agents.' : worstAgent.avgLatency > 100 ? 'Investigate high-latency agent for network or resource issues.' : 'Maintain current performance.'}\n`;
                report += `Next Steps:\n${errorCount > 0 ? '- Check Netlify Functions logs.\n- Redeploy with `netlify deploy --prod`.\n' : worstAgent.avgLatency > 100 ? '- Check server logs.\n- Optimize network configuration.\n' : '- Continue monitoring.\n- Scale resources as needed.\n'}`;
                report += `\n© 2025 WebXOS - Server MCP Controller`;

                try {
                    await navigator.clipboard.writeText(report);
                    logMessage('Monitoring report copied to clipboard.', true);
                } catch (err) {
                    logMessage(`Clipboard Error: ${err.message}`, true);
                    const textarea = document.createElement('textarea');
                    textarea.value = report;
                    document.body.appendChild(textarea);
                    textarea.select();
                    try {
                        document.execCommand('copy');
                        logMessage('Monitoring report copied (fallback).', true);
                    } catch (copyErr) {
                        logMessage(`Copy Error: ${copyErr.message}`, true);
                    }
                    document.body.removeChild(textarea);
                }

                logMessage('Monitoring data cleared.', true);
            }
        }

        const debounce = (func, wait) => {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        };

        document.getElementById('check-btn').addEventListener('click', debounce(() => {
            serverLog('Check button clicked via event listener');
            checkServers();
        }, 200));
        document.getElementById('monitor-btn').addEventListener('click', debounce(() => {
            serverLog('Monitor button clicked via event listener');
            toggleMonitor();
        }, 200));
        document.getElementById('clear-btn').addEventListener('click', debounce(() => {
            serverLog('Clear button clicked via event listener');
            clearConsole();
        }, 200));

        document.addEventListener('keydown', e => {
            serverLog(`Key pressed: ${e.key}`);
            if (e.key === 'Enter' || e.key === ' ') checkServers();
            else if (e.key === 'm' || e.key === 'M') toggleMonitor();
            else if (e.key === 'c' || e.key === 'C') clearConsole();
        });

        window.onload = () => {
            logMessage('Server MCP Controller: Check: Run server health checks | Monitor: Toggle real-time latency monitoring | Clear: Reset console', true);
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/static/sw.js', { scope: '/' })
                    .then(reg => serverLog(`Service Worker registered with scope: ${reg.scope}`))
                    .catch(err => {
                        logMessage(`Service Worker Error: ${err.message}`, true);
                        serverLog(`Service Worker Error: ${err.stack}`);
                    });
            }
        };
    </script>
</body>
</html>
