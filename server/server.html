<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <meta name="description" content="WebXOS MCP Terminal 2025: Monitor and control WebXOS chatbot and server agents with neural network integration and debug terminal.">
    <meta name="keywords" content="webXOS, MCP terminal, neural network, AI tools, web applications 2025, digital solutions, webXOS AI, webXOS search, browser-based tools, innovative web apps, web development, AI-powered search, modular web tools, sustainable web solutions, webXOS research, exoskeleton AI technology, green energy, web design, front end, sustainable software, AI, machine learning, eco-friendly tech, web interfaces, user experience, UX design, web technology, AI-driven search, browser-based applications, digital innovation, web utilities, sustainable design, green technology, front-end development, AI applications, web accessibility, interactive web, modern web design, eco-conscious software, AI research, digital transformation, web performance, sustainable digital tools, low-carbon tech, web app development, AI-enhanced tools, online platforms, futuristic web solutions, green computing">
    <meta name="robots" content="index, follow">
    <meta name="author" content="webXOS">
    <meta property="og:title" content="WebXOS MCP Terminal 2025 - Neural Network Control">
    <meta property="og:description" content="Manage WebXOS chatbot and server agents with the MCP Terminal 2025, featuring neural network integration and debug terminal.">
    <meta property="og:url" content="https://webxos.netlify.app/server/server.html">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="webXOS">
    <meta property="og:locale" content="en_US">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@webxos">
    <meta name="twitter:creator" content="@webxos">
    <meta name="twitter:title" content="WebXOS MCP Terminal 2025 - Neural Network Control">
    <meta name="twitter:description" content="Control WebXOS agents with the MCP Terminal 2025, featuring neural network integration.">
    <link rel="canonical" href="https://webxos.netlify.app/server/server.html">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=OCR-A&display=swap">
    <link rel="stylesheet" href="/server/static/style.css">
    <link rel="manifest" href="/manifest.json">
    <link rel="icon" href="/server/static/icon.png">
    <title>WebXOS MCP Terminal 2025</title>
</head>
<body>
    <canvas id="neuralCanvas" style="pointer-events: none;"></canvas>
    <h1 class="title">WebXOS MCP Terminal</h1>
    <div class="input-container">
        <div id="status" class="error-message"></div>
        <div id="controlbox">
            <div id="agent-status">
                <h2>Agent Status</h2>
                <div id="chatbot-agents">
                    <p>Chatbot Agent1: <span class="agent1-color">Inactive</span></p>
                    <p>Chatbot Agent2: <span class="agent2-color">Inactive</span></p>
                    <p>Chatbot Agent3: <span class="agent3-color">Inactive</span></p>
                    <p>Chatbot Agent4: <span class="agent4-color">Inactive</span></p>
                </div>
                <div id="server-agents">
                    <p>Server Agent1: <span class="agent1-color">Checking...</span></p>
                    <p>Server Agent2: <span class="agent2-color">Checking...</span></p>
                    <p>Server Agent3: <span class="agent3-color">Checking...</span></p>
                    <p>Server Agent4: <span class="agent4-color">Checking...</span></p>
                </div>
            </div>
            <div id="llm-config">
                <h2>LLM Configuration</h2>
                <div class="input-group">
                    <input type="text" id="llmApiKey" placeholder="Enter LLM API Key (e.g., Grok, ChatGPT)">
                    <button id="saveApiKey">Save</button>
                </div>
                <p>Status: <span id="llmStatus">Not configured</span></p>
            </div>
            <div id="debug-terminal">
                <h2>Debug Terminal</h2>
                <div id="debug-messages"></div>
                <div class="input-group">
                    <input type="text" id="debugInput" placeholder="Enter debug command (/debug, /logs, /test)">
                    <button id="debugButton">Run</button>
                </div>
            </div>
            <div id="messages"></div>
            <div class="input-group">
                <input type="text" id="commandInput" placeholder="Enter command (/help, /agent1-4, /server1-4, /status)">
                <button id="executeButton">Execute</button>
                <button id="clearButton">Clear</button>
            </div>
            <div id="loading" class="loading-spinner"></div>
        </div>
    </div>
    <footer>
        <div class="copyright">Copyright webXOS 2025</div>
    </footer>
    <script src="/server/static/fuse.min.js"></script>
    <script src="/server/static/neurots.js" defer></script>
    <script>
        const BOT_VERSION = '1.0.0';
        let activeAgents = { chatbot: [], server: [] };
        let llmApiKey = localStorage.getItem('llmApiKey') || '';

        // Show help menu
        function showHelp() {
            const messages = document.getElementById('messages');
            messages.innerHTML = `
                <p><b>MCP Commands:</b></p>
                <p><b>/help</b> - Show this menu.</p>
                <p><b>/clear</b> - Clear terminal and reset neural dots.</p>
                <p><b>/status</b> - Check status of all agents and MCP.</p>
                <p><b>/version</b> - Show MCP version.</p>
                <p><b>/agent1</b> - Activate Chatbot Agent1 (helix pattern).</p>
                <p><b>/agent2</b> - Activate Chatbot Agent2 (cube pattern).</p>
                <p><b>/agent3</b> - Activate Chatbot Agent3 (torus pattern).</p>
                <p><b>/agent4</b> - Activate Chatbot Agent4 (star pattern).</p>
                <p><b>/server1</b> - Control Server Agent1.</p>
                <p><b>/server2</b> - Control Server Agent2.</p>
                <p><b>/server3</b> - Control Server Agent3.</p>
                <p><b>/server4</b> - Control Server Agent4.</p>
                <p><b>/dna</b> - Display collaborative DNA-like agent network.</p>
                <p><b>/galaxy</b> - Display galaxy simulation.</p>
                <p><b>/llm-test</b> - Test LLM configuration.</p>
                <p><b>/mcp-status</b> - Check MCP neural network status.</p>`;
            messages.scrollTop = messages.scrollHeight;
        }

        // Initialize MCP
        window.addEventListener('load', async () => {
            const messages = document.getElementById('messages');
            const debugMessages = document.getElementById('debug-messages');
            try {
                // Check MCP status
                try {
                    const response = await fetch('/api/mcp/status');
                    const data = await response.json();
                    debugMessages.innerHTML += `<p><b>MCP Status:</b> ${data.status} (Agents: ${data.activeAgents.join(', ')})</p>`;
                } catch (error) {
                    debugMessages.innerHTML += `<p><b>Error:</b> Failed to check MCP status: ${error.message} [Copy this for feedback]</p>`;
                }

                // Check server agent status
                const serverAgents = ['agent1', 'agent2', 'agent3', 'agent4'];
                for (const agent of serverAgents) {
                    try {
                        const response = await fetch(`/api/${agent}/health`);
                        const data = await response.json();
                        document.querySelector(`#server-agents p:nth-child(${serverAgents.indexOf(agent) + 1}) span`).textContent = data.status === 'healthy' ? 'Active' : 'Inactive';
                        debugMessages.innerHTML += `<p><b>${agent} Status:</b> ${data.status} (Version: ${data.version})</p>`;
                    } catch (error) {
                        document.querySelector(`#server-agents p:nth-child(${serverAgents.indexOf(agent) + 1}) span`).textContent = 'Error';
                        debugMessages.innerHTML += `<p><b>Error:</b> Failed to check ${agent} status: ${error.message} [Copy this for feedback]</p>`;
                    }
                }

                // Check LLM configuration
                document.getElementById('llmApiKey').value = llmApiKey;
                document.getElementById('llmStatus').textContent = llmApiKey ? 'Configured' : 'Not configured';
                showHelp();
                updateStatus('Success: MCP initialized.');
            } catch (error) {
                messages.innerHTML += `<p><b>Error:</b> ${error.message}</p>`;
                debugMessages.innerHTML += `<p><b>Error:</b> MCP initialization failed: ${error.message} [Copy this for feedback]</p>`;
                updateStatus('Error: MCP initialization failed.', true, error.stack || error.message);
            }

            // Initialize neural dots
            try {
                if (typeof window.initNeurots === 'function') {
                    initNeurots();
                    console.log('Neurots initialized successfully');
                    debugMessages.innerHTML += `<p><b>Neurots:</b> Initialized successfully</p>`;
                } else {
                    throw new Error('initNeurots function not defined');
                }
            } catch (error) {
                console.error('Neurots initialization failed:', error);
                messages.innerHTML += `<p><b>Error:</b> Failed to initialize neural dots. ${error.message}</p>`;
                debugMessages.innerHTML += `<p><b>Error:</b> Failed to initialize neural dots: ${error.message} [Copy this for feedback]</p>`;
                updateStatus('Error: Neural dots failed to initialize.', true, error.stack || error.message);
            }
        });

        function updateStatus(message, isError = false, details = '') {
            const status = document.getElementById('status');
            const timestamp = new Date().toLocaleTimeString();
            status.innerHTML = `<span class="${isError ? 'error' : 'success'}">${message}${isError || details ? `<br><small>Details: ${details} [${timestamp}]</small>` : ''}</span>`;
            status.classList.add('show');
            setTimeout(() => status.classList.remove('show'), 3000);
        }

        function clearTerminal() {
            const messages = document.getElementById('messages');
            const debugMessages = document.getElementById('debug-messages');
            messages.innerHTML = '';
            debugMessages.innerHTML = '';
            activeAgents = { chatbot: [], server: [] };
            setAgentsActive(false);
            for (let i = 1; i <= 4; i++) {
                document.querySelector(`#chatbot-agents p:nth-child(${i}) span`).textContent = 'Inactive';
            }
            updateStatus('Success: Terminal cleared.');
            showHelp();
            messages.scrollTop = messages.scrollHeight;
            debugMessages.scrollTop = debugMessages.scrollHeight;
        }

        async function executeCommand() {
            const command = document.getElementById('commandInput').value.trim().toLowerCase();
            const messages = document.getElementById('messages');
            const debugMessages = document.getElementById('debug-messages');
            const loading = document.getElementById('loading');
            if (!command) {
                updateStatus('Error: Empty command.', true, 'Please enter a command.');
                return;
            }
            let colorClass = '';
            if (command.startsWith('/agent1') || command.startsWith('/server1')) colorClass = 'agent1-color';
            else if (command.startsWith('/agent2') || command.startsWith('/server2')) colorClass = 'agent2-color';
            else if (command.startsWith('/agent3') || command.startsWith('/server3')) colorClass = 'agent3-color';
            else if (command.startsWith('/agent4') || command.startsWith('/server4')) colorClass = 'agent4-color';
            messages.innerHTML += `<p class="${colorClass}"><b>Command:</b> ${command}</p>`;
            loading.style.display = 'block';

            try {
                if (command.startsWith('/')) {
                    const cmd = command.split(' ')[0];
                    switch (cmd) {
                        case '/help':
                            showHelp();
                            updateStatus('Success: Help menu displayed.');
                            setAgentsActive(false);
                            break;
                        case '/clear':
                            clearTerminal();
                            break;
                        case '/status':
                            try {
                                const mcpResponse = await fetch('/api/mcp/status');
                                const mcpData = await mcpResponse.json();
                                messages.innerHTML += `<p><b>MCP Status:</b> ${mcpData.status} (Agents: ${mcpData.activeAgents.join(', ')})</p>`;
                                debugMessages.innerHTML += `<p><b>MCP Status:</b> ${mcpData.status} (Agents: ${mcpData.activeAgents.join(', ')})</p>`;
                            } catch (error) {
                                messages.innerHTML += `<p><b>Error:</b> Failed to check MCP status: ${error.message}</p>`;
                                debugMessages.innerHTML += `<p><b>Error:</b> Failed to check MCP status: ${error.message} [Copy this for feedback]</p>`;
                            }
                            const serverAgents = ['agent1', 'agent2', 'agent3', 'agent4'];
                            for (const agent of serverAgents) {
                                try {
                                    const response = await fetch(`/api/${agent}/health`);
                                    const data = await response.json();
                                    document.querySelector(`#server-agents p:nth-child(${serverAgents.indexOf(agent) + 1}) span`).textContent = data.status === 'healthy' ? 'Active' : 'Inactive';
                                    messages.innerHTML += `<p><b>${agent} Status:</b> ${data.status} (Version: ${data.version})</p>`;
                                    debugMessages.innerHTML += `<p><b>${agent} Status:</b> ${data.status} (Version: ${data.version})</p>`;
                                } catch (error) {
                                    document.querySelector(`#server-agents p:nth-child(${serverAgents.indexOf(agent) + 1}) span`).textContent = 'Error';
                                    messages.innerHTML += `<p><b>Error:</b> Failed to check ${agent} status: ${error.message}</p>`;
                                    debugMessages.innerHTML += `<p><b>Error:</b> Failed to check ${agent} status: ${error.message} [Copy this for feedback]</p>`;
                                }
                            }
                            messages.innerHTML += `<p><b>Chatbot Agents:</b> ${activeAgents.chatbot.length ? activeAgents.chatbot.join(', ') : 'None active'}</p>`;
                            debugMessages.innerHTML += `<p><b>Chatbot Agents:</b> ${activeAgents.chatbot.length ? activeAgents.chatbot.join(', ') : 'None active'}</p>`;
                            updateStatus('Success: Status updated.');
                            setAgentsActive(false);
                            break;
                        case '/version':
                            messages.innerHTML += `<p><b>Version:</b> WebXOS MCP Terminal v${BOT_VERSION}</p>`;
                            debugMessages.innerHTML += `<p><b>Version:</b> WebXOS MCP Terminal v${BOT_VERSION}</p>`;
                            updateStatus('Success: Version displayed.');
                            setAgentsActive(false);
                            break;
                        case '/agent1':
                        case '/agent2':
                        case '/agent3':
                        case '/agent4':
                            const agentName = cmd.slice(1);
                            activeAgents.chatbot = [agentName];
                            document.querySelector(`#chatbot-agents p:nth-child(${parseInt(agentName.slice(-1))}) span`).textContent = 'Active';
                            for (let i = 1; i <= 4; i++) {
                                if (i !== parseInt(agentName.slice(-1))) {
                                    document.querySelector(`#chatbot-agents p:nth-child(${i}) span`).textContent = 'Inactive';
                                }
                            }
                            setAgentsActive(true, [agentName], false, false);
                            messages.innerHTML += `<p class="${agentName}-color"><b>${agentName.toUpperCase()}:</b> Chatbot ${agentName.toUpperCase()} activated.</p>`;
                            debugMessages.innerHTML += `<p><b>${agentName.toUpperCase()}:</b> Chatbot ${agentName.toUpperCase()} activated.</p>`;
                            updateStatus(`Success: Chatbot ${agentName.toUpperCase()} activated.`);
                            break;
                        case '/server1':
                        case '/server2':
                        case '/server3':
                        case '/server4':
                            const serverAgent = cmd.slice(1).replace('server', 'agent');
                            activeAgents.server = [serverAgent];
                            try {
                                const response = await fetch(`/api/${serverAgent}/control`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ command: 'status' })
                                });
                                const data = await response.json();
                                document.querySelector(`#server-agents p:nth-child(${parseInt(serverAgent.slice(-1))}) span`).textContent = data.status === 'healthy' ? 'Active' : 'Inactive';
                                messages.innerHTML += `<p class="${serverAgent}-color"><b>${serverAgent.toUpperCase()}:</b> Server ${serverAgent.toUpperCase()} status: ${data.status} (Version: ${data.version})</p>`;
                                debugMessages.innerHTML += `<p><b>${serverAgent.toUpperCase()}:</b> Server ${serverAgent.toUpperCase()} status: ${data.status} (Version: ${data.version})</p>`;
                                updateStatus(`Success: Server ${serverAgent.toUpperCase()} queried.`);
                            } catch (error) {
                                document.querySelector(`#server-agents p:nth-child(${parseInt(serverAgent.slice(-1))}) span`).textContent = 'Error';
                                messages.innerHTML += `<p><b>Error:</b> Failed to query ${serverAgent}: ${error.message}</p>`;
                                debugMessages.innerHTML += `<p><b>Error:</b> Failed to query ${serverAgent}: ${error.message} [Copy this for feedback]</p>`;
                                updateStatus(`Error: Failed to query ${serverAgent}.`, true, error.message);
                            }
                            setAgentsActive(false);
                            break;
                        case '/dna':
                            activeAgents.chatbot = ['agent1', 'agent2', 'agent3', 'agent4'];
                            for (let i = 1; i <= 4; i++) {
                                document.querySelector(`#chatbot-agents p:nth-child(${i}) span`).textContent = 'Active';
                            }
                            setAgentsActive(true, activeAgents.chatbot, true, false);
                            messages.innerHTML += `<p><b>System:</b> Collaborative DNA-like agent network activated.</p>`;
                            debugMessages.innerHTML += `<p><b>System:</b> Collaborative DNA-like agent network activated.</p>`;
                            updateStatus('Success: DNA activated.');
                            break;
                        case '/galaxy':
                            activeAgents.chatbot = [];
                            for (let i = 1; i <= 4; i++) {
                                document.querySelector(`#chatbot-agents p:nth-child(${i}) span`).textContent = 'Inactive';
                            }
                            setAgentsActive(true, [], false, true);
                            messages.innerHTML += `<p><b>System:</b> Galaxy simulation activated.</p>`;
                            debugMessages.innerHTML += `<p><b>System:</b> Galaxy simulation activated.</p>`;
                            updateStatus('Success: Galaxy activated.');
                            break;
                        case '/llm-test':
                            if (!llmApiKey) {
                                messages.innerHTML += `<p><b>Error:</b> No LLM API key configured.</p>`;
                                debugMessages.innerHTML += `<p><b>Error:</b> No LLM API key configured [Copy this for feedback]</p>`;
                                updateStatus('Error: LLM not configured.', true);
                            } else {
                                try {
                                    const response = await fetch('/api/mcp/control', {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ command: 'llm-test', apiKey: llmApiKey })
                                    });
                                    const data = await response.json();
                                    messages.innerHTML += `<p><b>LLM Test:</b> ${data.message}</p>`;
                                    debugMessages.innerHTML += `<p><b>LLM Test:</b> ${data.message}</p>`;
                                    updateStatus(`Success: LLM test completed.`);
                                } catch (error) {
                                    messages.innerHTML += `<p><b>Error:</b> LLM test failed: ${error.message}</p>`;
                                    debugMessages.innerHTML += `<p><b>Error:</b> LLM test failed: ${error.message} [Copy this for feedback]</p>`;
                                    updateStatus('Error: LLM test failed.', true, error.message);
                                }
                            }
                            break;
                        case '/mcp-status':
                            try {
                                const response = await fetch('/api/mcp/status');
                                const data = await response.json();
                                messages.innerHTML += `<p><b>MCP Status:</b> ${data.status} (Agents: ${data.activeAgents.join(', ')})</p>`;
                                debugMessages.innerHTML += `<p><b>MCP Status:</b> ${data.status} (Agents: ${data.activeAgents.join(', ')})</p>`;
                                updateStatus('Success: MCP status checked.');
                            } catch (error) {
                                messages.innerHTML += `<p><b>Error:</b> Failed to check MCP status: ${error.message}</p>`;
                                debugMessages.innerHTML += `<p><b>Error:</b> Failed to check MCP status: ${error.message} [Copy this for feedback]</p>`;
                                updateStatus('Error: Failed to check MCP status.', true, error.message);
                            }
                            break;
                        default:
                            messages.innerHTML += `<p><b>Error:</b> Unknown command "${cmd}". Type /help for commands.</p>`;
                            debugMessages.innerHTML += `<p><b>Error:</b> Unknown command "${cmd}" [Copy this for feedback]</p>`;
                            updateStatus('Error: Unknown command.', true);
                            setAgentsActive(false);
                    }
                } else {
                    messages.innerHTML += `<p><b>Error:</b> Commands must start with '/'. Type /help for commands.</p>`;
                    debugMessages.innerHTML += `<p><b>Error:</b> Commands must start with '/' [Copy this for feedback]</p>`;
                    updateStatus('Error: Invalid command.', true);
                }
            } catch (error) {
                messages.innerHTML += `<p><b>Error:</b> ${error.message}</p>`;
                debugMessages.innerHTML += `<p><b>Error:</b> Command execution failed: ${error.message} [Copy this for feedback]</p>`;
                updateStatus('Error: Command execution failed.', true, error.stack || error.message);
            } finally {
                loading.style.display = 'none';
                document.getElementById('commandInput').value = '';
                messages.scrollTop = messages.scrollHeight;
                debugMessages.scrollTop = debugMessages.scrollHeight;
            }
        }

        async function executeDebugCommand() {
            const command = document.getElementById('debugInput').value.trim().toLowerCase();
            const debugMessages = document.getElementById('debug-messages');
            const loading = document.getElementById('loading');
            if (!command) {
                updateStatus('Error: Empty debug command.', true, 'Please enter a debug command.');
                return;
            }
            debugMessages.innerHTML += `<p><b>Debug Command:</b> ${command}</p>`;
            loading.style.display = 'block';

            try {
                if (command.startsWith('/')) {
                    const cmd = command.split(' ')[0];
                    switch (cmd) {
                        case '/debug':
                            debugMessages.innerHTML += `<p><b>Debug:</b> Running system diagnostics...</p>`;
                            try {
                                const response = await fetch('/api/mcp/control', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ command: 'diagnostics' })
                                });
                                const data = await response.json();
                                debugMessages.innerHTML += `<p><b>Diagnostics:</b> ${data.message}</p>`;
                                updateStatus('Success: Diagnostics completed.');
                            } catch (error) {
                                debugMessages.innerHTML += `<p><b>Error:</b> Diagnostics failed: ${error.message} [Copy this for feedback]</p>`;
                                updateStatus('Error: Diagnostics failed.', true, error.message);
                            }
                            break;
                        case '/logs':
                            debugMessages.innerHTML += `<p><b>Logs:</b> Fetching system logs...</p>`;
                            try {
                                const response = await fetch('/api/mcp/control', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ command: 'logs' })
                                });
                                const data = await response.json();
                                debugMessages.innerHTML += `<p><b>Logs:</b> ${data.message}</p>`;
                                updateStatus('Success: Logs fetched.');
                            } catch (error) {
                                debugMessages.innerHTML += `<p><b>Error:</b> Failed to fetch logs: ${error.message} [Copy this for feedback]</p>`;
                                updateStatus('Error: Failed to fetch logs.', true, error.message);
                            }
                            break;
                        case '/test':
                            debugMessages.innerHTML += `<p><b>Test:</b> Running test command...</p>`;
                            try {
                                const response = await fetch('/api/mcp/control', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ command: 'test' })
                                });
                                const data = await response.json();
                                debugMessages.innerHTML += `<p><b>Test:</b> ${data.message}</p>`;
                                updateStatus('Success: Test completed.');
                            } catch (error) {
                                debugMessages.innerHTML += `<p><b>Error:</b> Test failed: ${error.message} [Copy this for feedback]</p>`;
                                updateStatus('Error: Test failed.', true, error.message);
                            }
                            break;
                        default:
                            debugMessages.innerHTML += `<p><b>Error:</b> Unknown debug command "${cmd}" [Copy this for feedback]</p>`;
                            updateStatus('Error: Unknown debug command.', true);
                    }
                } else {
                    debugMessages.innerHTML += `<p><b>Error:</b> Debug commands must start with '/' [Copy this for feedback]</p>`;
                    updateStatus('Error: Invalid debug command.', true);
                }
            } catch (error) {
                debugMessages.innerHTML += `<p><b>Error:</b> Debug command execution failed: ${error.message} [Copy this for feedback]</p>`;
                updateStatus('Error: Debug command execution failed.', true, error.stack || error.message);
            } finally {
                loading.style.display = 'none';
                document.getElementById('debugInput').value = '';
                debugMessages.scrollTop = debugMessages.scrollHeight;
            }
        }

        // Save LLM API key
        document.getElementById('saveApiKey').addEventListener('click', () => {
            llmApiKey = document.getElementById('llmApiKey').value.trim();
            localStorage.setItem('llmApiKey', llmApiKey);
            document.getElementById('llmStatus').textContent = llmApiKey ? 'Configured' : 'Not configured';
            updateStatus('Success: LLM API key saved.');
        });

        // Add UI event listeners
        document.getElementById('commandInput').addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                executeCommand();
            }
        });
        document.getElementById('executeButton').addEventListener('click', () => {
            console.log('Execute button clicked');
            executeCommand();
        });
        document.getElementById('clearButton').addEventListener('click', () => {
            console.log('Clear button clicked');
            clearTerminal();
        });
        document.getElementById('debugInput').addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                executeDebugCommand();
            }
        });
        document.getElementById('debugButton').addEventListener('click', () => {
            console.log('Debug button clicked');
            executeDebugCommand();
        });
    </script>
</body>
</html>
