<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Server MCP Controller</title>
    <link rel="icon" href="/static/icon.png">
    <link rel="manifest" href="/static/manifest.json">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=stylesheet" rel="stylesheet">
    <link rel="stylesheet" href="/static/style.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: monospace, sans-serif;
        }

        html, body {
            height: 100vh;
            overflow: hidden;
            background: #000;
            color: #0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: background 0.3s, box-shadow 0.3s;
            -webkit-tap-highlight-color: transparent;
        }

        body.glow {
            background: rgba(255, 0, 0, 0.1);
            box-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000 inset;
        }

        h1 {
            font-size: 1.6rem;
            text-align: center;
            margin: 0.8rem 0;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 0 5px #0f0;
        }

        #console {
            width: 90%;
            max-width: 900px;
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #0f0;
            padding: 0.6rem;
            flex: 1;
            max-height: calc(100vh - 260px);
            overflow-y: auto;
            margin: 0.5rem 0;
            border-radius: 5px;
            font-size: 0.8rem;
            -webkit-overflow-scrolling: touch;
            transition: border-color 0.3s, box-shadow 0.3s;
        }

        #console.active-monitor {
            border-color: #ff0000;
            box-shadow: 0 0 10px #ff0000;
        }

        #console p {
            margin: 0.2rem 0;
        }

        #console .command {
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            text-shadow: 0 0 3px #0f0;
        }

        .button-group {
            display: flex;
            gap: 0.5rem;
            margin: 0.5rem 0;
            padding: 0.5rem;
            flex-wrap: wrap;
            justify-content: center;
            width: 90%;
            max-width: 900px;
        }

        button {
            background: #0f0;
            color: #000;
            border: none;
            padding: 0.6rem 1.2rem;
            font-size: 0.9rem;
            cursor: pointer;
            border-radius: 3px;
            min-width: 90px;
            text-align: center;
            touch-action: manipulation;
            transition: background 0.3s, box-shadow 0.3s;
        }

        button:hover, button:focus {
            background: #0c0;
            outline: 2px solid #0f0;
        }

        button.active-monitor {
            background: #ff0000;
            box-shadow: 0 0 10px #ff0000;
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
        }

        #server-stats {
            width: 90%;
            max-width: 900px;
            margin: 0.5rem 0;
            display: flex;
            flex-direction: column;
            gap: 0.2rem;
        }

        .progress-container {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .progress-label {
            width: 90px;
            font-size: 0.75rem;
        }

        .progress-bar {
            flex: 1;
            height: 8px;
            background: #333;
            border: 1px solid #0f0;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #0f0;
            transition: width 0.5s;
        }

        #search-container {
            width: 90%;
            max-width: 900px;
            margin: 0.5rem 0;
        }

        #search-input {
            width: 100%;
            padding: 0.5rem;
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            border-radius: 3px;
            font-size: 0.8rem;
        }

        #search-results {
            margin-top: 0.5rem;
            max-height: 100px;
            overflow-y: auto;
            font-size: 0.8rem;
            color: #0f0;
        }

        footer {
            width: 100%;
            padding: 0.4rem;
            font-size: 9pt;
            text-align: center;
            color: #0f0;
            background: rgba(0, 0, 0, 0.8);
            line-height: 1.2;
        }

        @media (max-width: 600px) {
            h1 { font-size: 1.1rem; margin: 0.5rem 0; }
            #console { 
                font-size: 0.75rem; 
                padding: 0.5rem; 
                max-height: calc(100vh - 280px); 
            }
            button { 
                padding: 0.5rem 1rem; 
                font-size: 0.85rem; 
                min-width: 80px; 
            }
            #search-input { font-size: 0.75rem; }
            footer { padding: 0.3rem; }
            .progress-label { width: 70px; font-size: 0.7rem; }
            .progress-bar { height: 7px; }
        }

        @media (max-width: 400px) {
            .button-group { flex-direction: column; align-items: center; }
            button { width: 100%; max-width: 160px; }
            #console { max-height: calc(100vh - 260px); }
            #server-stats { gap: 0.15rem; }
        }
    </style>
</head>
<body>
    <h1 role="heading" aria-level="1">Server MCP Controller</h1>
    <div id="search-container">
        <input id="search-input" type="text" placeholder="Search server logs..." aria-label="Search server logs">
        <div id="search-results"></div>
    </div>
    <div id="console" role="log" aria-live="polite">
        <p>Server MCP Controller: Start Server: Launch MCP server | End Server: Stop MCP server | Check: Run health checks | Monitor: Toggle latency monitoring | Clear: Reset console | Copy Logs: Copy logs for analysis | Search: Query logs</p>
    </div>
    <div id="server-stats">
        <div class="progress-container">
            <span class="progress-label">Agent 1:</span>
            <div class="progress-bar"><div class="progress-fill" id="agent1-bar" style="width: 0%"></div></div>
            <span id="agent1-value">0 ms</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">Agent 2:</span>
            <div class="progress-bar"><div class="progress-fill" id="agent2-bar" style="width: 0%"></div></div>
            <span id="agent2-value">0 ms</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">Agent 3:</span>
            <div class="progress-bar"><div class="progress-fill" id="agent3-bar" style="width: 0%"></div></div>
            <span id="agent3-value">0 ms</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">Agent 4:</span>
            <div class="progress-bar"><div class="progress-fill" id="agent4-bar" style="width: 0%"></div></div>
            <span id="agent4-value">0 ms</span>
        </div>
    </div>
    <div class="button-group">
        <button id="start-btn" aria-label="Start MCP server">Start Server</button>
        <button id="end-btn" aria-label="Stop MCP server" disabled>End Server</button>
        <button id="check-btn" aria-label="Run server health checks">Check</button>
        <button id="monitor-btn" aria-label="Toggle real-time latency monitoring">Monitor</button>
        <button id="clear-btn" aria-label="Clear console output">Clear</button>
        <button id="copy-btn" aria-label="Copy console logs">Copy Logs</button>
    </div>
    <footer>
        Â© 2025 WebXOS - Server MCP Controller<br>
        Start Server: Launch MCP server | End Server: Stop MCP server | Check: Run health checks | Monitor: Toggle latency monitoring | Clear: Reset console | Copy Logs: Copy logs for analysis | Search: Query logs
    </footer>

    <script>
        // Load Socket.IO with fallback
        (function loadSocketIO() {
            const cdnScript = document.createElement('script');
            cdnScript.src = 'https://cdn.jsdelivr.net/npm/socket.io@4.7.5/dist/socket.io.min.js';
            cdnScript.onload = () => serverLog('Socket.IO loaded from CDN');
            cdnScript.onerror = () => {
                serverLog('CDN Socket.IO failed, attempting local fallback');
                const localScript = document.createElement('script');
                localScript.src = '/static/socket.io.min.js';
                localScript.onload = () => serverLog('Socket.IO loaded from local fallback');
                localScript.onerror = () => logError('Socket.IO Load Error', new Error('Failed to load Socket.IO from both CDN and local fallback'), 'Verify /static/socket.io.min.js exists and is accessible.');
                document.head.appendChild(localScript);
            };
            document.head.appendChild(cdnScript);
        })();

        // Load Neural Network
        const neuralScript = document.createElement('script');
        neuralScript.src = '/static/neural_network.js';
        neuralScript.onload = () => serverLog('Neural Network script loaded');
        neuralScript.onerror = () => logError('Neural Network Script Load Error', new Error('Failed to load /static/neural_network.js'), 'Verify /static/neural_network.js and /static/neural_network.wasm are deployed correctly.');
        document.head.appendChild(neuralScript);

        let socket = null;
        let serverRunning = false;
        const consoleDiv = document.getElementById('console');
        let logQueue = [];
        let monitorActive = false;
        let monitorInterval = null;
        const agents = [
            { name: 'agent1', latencyHistory: [] },
            { name: 'agent2', latencyHistory: [] },
            { name: 'agent3', latencyHistory: [] },
            { name: 'agent4', latencyHistory: [] }
        ];

        function serverLog(message) {
            console.log(`[SERVER] ${message}`);
        }

        function logError(message, error, analysis) {
            const timestamp = new Date().toISOString();
            const errorDetails = {
                timestamp,
                message,
                error: error.message,
                stack: error.stack || 'No stack trace available',
                analysis: analysis || 'No specific analysis available.'
            };
            logQueue.push(`[${timestamp}] <span class="command">Error: ${message}</span>\nError: ${errorDetails.error}\nStack: ${errorDetails.stack}\nAnalysis: ${errorDetails.analysis}`);
            if (logQueue.length > 50) logQueue.shift();
            throttleConsoleUpdate();
            serverLog(`${message}: ${error.message}\nStack: ${error.stack}\nAnalysis: ${analysis}`);
            return errorDetails;
        }

        function logMessage(message, isCommand = false) {
            const timestamp = new Date().toISOString();
            const formattedMessage = isCommand 
                ? `<span class="command">${message}</span>`
                : message;
            logQueue.push(`[${timestamp}] ${formattedMessage}`);
            if (logQueue.length > 50) logQueue.shift();
            throttleConsoleUpdate();
        }

        const throttleConsoleUpdate = (() => {
            let timeout;
            return () => {
                if (!timeout) {
                    timeout = setTimeout(() => {
                        consoleDiv.innerHTML = logQueue.map(msg => `<p>${msg}</p>`).join('');
                        consoleDiv.scrollTop = consoleDiv.scrollHeight;
                        timeout = null;
                    }, 100);
                }
            };
        })();

        function triggerGlow() {
            document.body.classList.add('glow');
            setTimeout(() => document.body.classList.remove('glow'), 1000);
        }

        function flashRedGlow() {
            consoleDiv.classList.add('active-monitor');
            setTimeout(() => consoleDiv.classList.remove('active-monitor'), 500);
            setTimeout(() => {
                consoleDiv.classList.add('active-monitor');
                setTimeout(() => consoleDiv.classList.remove('active-monitor'), 500);
            }, 1000);
        }

        function copyLogs() {
            serverLog('Copy Logs button clicked');
            try {
                const logText = logQueue.join('\n');
                navigator.clipboard.writeText(logText).then(() => {
                    logMessage('Logs copied to clipboard.', true);
                    triggerGlow();
                }).catch(err => {
                    logError('Clipboard Copy Error', err, 'Failed to copy logs to clipboard. Try selecting manually.');
                    const textarea = document.createElement('textarea');
                    textarea.value = logText;
                    document.body.appendChild(textarea);
                    textarea.select();
                    try {
                        document.execCommand('copy');
                        logMessage('Logs copied (fallback).', true);
                    } catch (copyErr) {
                        logError('Fallback Copy Error', copyErr, 'Manual copy failed. Select and copy logs manually.');
                    }
                    document.body.removeChild(textarea);
                });
            } catch (err) {
                logError('Copy Logs Error', err, 'Unexpected error while copying logs.');
            }
        }

        async function startServer() {
            serverLog('Start Server button clicked');
            if (serverRunning) {
                logMessage('Server already running.', true);
                return;
            }
            try {
                if (typeof io === 'undefined') {
                    throw new Error('Socket.IO not loaded');
                }
                socket = io('ws://localhost:8080', {
                    transports: ['websocket'],
                    reconnectionAttempts: 3,
                    timeout: 5000
                });

                socket.on('connect', () => {
                    logMessage('Connected to MCP server.', true);
                    serverRunning = true;
                    document.getElementById('start-btn').disabled = true;
                    document.getElementById('end-btn').disabled = false;
                    socket.emit('start-server');
                });

                socket.on('server-started', (data) => {
                    logMessage(`[MCP] Server started: ${data.message}`, true);
                    triggerGlow();
                    flashRedGlow();
                    try {
                        if (typeof NeuralNetworkModule === 'undefined') {
                            throw new Error('NeuralNetworkModule not defined');
                        }
                        NeuralNetworkModule().then(module => {
                            module._create_network();
                            const result = module._predict(1.0);
                            logMessage(`Neural Network initialized, test prediction: ${result}`, true);
                        }).catch(err => {
                            logError('Neural Network Error', err, 'Failed to initialize neural network. Verify /static/neural_network.js and /static/neural_network.wasm are deployed correctly.');
                        });
                    } catch (err) {
                        logError('Neural Network Load Error', err, 'NeuralNetworkModule not defined. Verify /static/neural_network.js and /static/neural_network.wasm are deployed correctly.');
                    }
                });

                socket.on('agent-status', (data) => {
                    const agentIndex = agents.findIndex(a => a.name === data.agent);
                    if (agentIndex !== -1) {
                        const latency = data.latency || 0;
                        agents[agentIndex].latencyHistory.push(latency);
                        if (agents[agentIndex].latencyHistory.length > 20) {
                            agents[agentIndex].latencyHistory.shift();
                        }
                        document.getElementById(`agent${agentIndex + 1}-bar`).style.width = `${Math.min(100, latency / 2)}%`;
                        document.getElementById(`agent${agentIndex + 1}-value`).textContent = `${latency.toFixed(2)} ms`;
                        logMessage(`[MCP] ${data.agent}: ${data.status} (Latency: ${latency.toFixed(2)}ms)`, true);
                    }
                });

                socket.on('server-error', (data) => {
                    logError('Server Error', new Error(data.message), data.analysis || 'Check server logs.');
                    flashRedGlow();
                });

                socket.on('connect_error', (err) => {
                    logError('Socket.IO Connect Error', err, 'Failed to connect to MCP server at ws://localhost:8080. Ensure run-server.sh is running and port 8080 is open.');
                    serverRunning = false;
                    document.getElementById('start-btn').disabled = false;
                    document.getElementById('end-btn').disabled = true;
                    clearMonitor();
                });

                socket.on('disconnect', () => {
                    logMessage('Disconnected from MCP server.', true);
                    serverRunning = false;
                    document.getElementById('start-btn').disabled = false;
                    document.getElementById('end-btn').disabled = true;
                    clearMonitor();
                });
            } catch (err) {
                logError('Start Server Error', err, 'Failed to initialize Socket.IO or connect to server. Verify /static/socket.io.min.js and run-server.sh.');
                serverRunning = false;
                document.getElementById('start-btn').disabled = false;
                document.getElementById('end-btn').disabled = true;
            }
        }

        function endServer() {
            serverLog('End Server button clicked');
            if (!serverRunning) {
                logMessage('Server not running.', true);
                return;
            }
            try {
                socket.emit('end-server');
                socket.disconnect();
                logMessage('Server stopped.', true);
                serverRunning = false;
                document.getElementById('start-btn').disabled = false;
                document.getElementById('end-btn').disabled = true;
                clearMonitor();
                triggerGlow();
                flashRedGlow();
            } catch (err) {
                logError('End Server Error', err, 'Failed to stop server. Ensure Socket.IO is loaded and server is running.');
            }
        }

        async function checkServers() {
            serverLog('Check button clicked');
            triggerGlow();
            flashRedGlow();
            if (!serverRunning) {
                logMessage('Server not running. Start server first.', true);
                return;
            }
            try {
                document.getElementById('check-btn').disabled = true;
                logMessage('Running server health checks...', true);
                socket.emit('check-agents');
                setTimeout(() => document.getElementById('check-btn').disabled = false, 2000);
            } catch (err) {
                logError('Check Error', err, 'Failed to check agents. Ensure server is running and Socket.IO is loaded.');
                document.getElementById('check-btn').disabled = false;
            }
        }

        async function updateServerStats() {
            if (!serverRunning) return;
            try {
                socket.emit('check-agents');
            } catch (err) {
                logError('Monitor Error', err, 'Failed to update server stats. Ensure server is running and Socket.IO is loaded.');
            }
        }

        function clearConsole() {
            serverLog('Clear button clicked');
            try {
                logQueue = ['Server MCP Controller: Start Server: Launch MCP server | End Server: Stop MCP server | Check: Run health checks | Monitor: Toggle latency monitoring | Clear: Reset console | Copy Logs: Copy logs for analysis | Search: Query logs'];
                agents.forEach((_, index) => {
                    document.getElementById(`agent${index + 1}-bar`).style.width = '0%';
                    document.getElementById(`agent${index + 1}-value`).textContent = '0 ms';
                });
                throttleConsoleUpdate();
                logMessage('Console and stats cleared.', true);
            } catch (err) {
                logError('Clear Error', err, 'Failed to clear console. Try refreshing the page.');
            }
        }

        function clearMonitor() {
            if (monitorActive) {
                monitorActive = false;
                clearInterval(monitorInterval);
                const monitorBtn = document.getElementById('monitor-btn');
                const consoleDiv = document.getElementById('console');
                monitorBtn.classList.remove('active-monitor');
                consoleDiv.classList.remove('active-monitor');
                logMessage('Monitor: Real-time latency monitoring deactivated.', true);
            }
        }

        async function toggleMonitor() {
            serverLog('Monitor button clicked');
            monitorActive = !monitorActive;
            const monitorBtn = document.getElementById('monitor-btn');
            const consoleDiv = document.getElementById('console');
            monitorBtn.classList.toggle('active-monitor', monitorActive);
            consoleDiv.classList.toggle('active-monitor', monitorActive);
            triggerGlow();
            flashRedGlow();

            if (monitorActive) {
                if (!serverRunning) {
                    logMessage('Server not running. Start server first.', true);
                    monitorActive = false;
                    monitorBtn.classList.remove('active-monitor');
                    consoleDiv.classList.remove('active-monitor');
                    return;
                }
                logMessage('Monitor: Real-time latency monitoring activated.', true);
                await updateServerStats();
                monitorInterval = setInterval(updateServerStats, 5000);
            } else {
                clearMonitor();
            }
        }

        const debounce = (func, wait) => {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        };

        document.getElementById('start-btn').addEventListener('click', debounce(startServer, 200));
        document.getElementById('end-btn').addEventListener('click', debounce(endServer, 200));
        document.getElementById('check-btn').addEventListener('click', debounce(checkServers, 200));
        document.getElementById('monitor-btn').addEventListener('click', debounce(toggleMonitor, 200));
        document.getElementById('clear-btn').addEventListener('click', debounce(clearConsole, 200));
        document.getElementById('copy-btn').addEventListener('click', debounce(copyLogs, 200));

        document.addEventListener('keydown', e => {
            serverLog(`Key pressed: ${e.key}`);
            if (e.key === 'Enter' || e.key === ' ') checkServers();
            else if (e.key === 'm' || e.key === 'M') toggleMonitor();
            else if (e.key === 'c' || e.key === 'C') clearConsole();
            else if (e.key === 's' || e.key === 'S') startServer();
            else if (e.key === 'e' || e.key === 'E') endServer();
            else if (e.key === 'l' || e.key === 'L') copyLogs();
        });

        window.onload = async () => {
            logMessage('Server MCP Controller: Start Server: Launch MCP server | End Server: Stop MCP server | Check: Run health checks | Monitor: Toggle latency monitoring | Clear: Reset console | Copy Logs: Copy logs for analysis | Search: Query logs', true);
            try {
                if (typeof NeuralNetworkModule === 'undefined') {
                    throw new Error('NeuralNetworkModule not defined');
                }
                await NeuralNetworkModule();
                logMessage('Neural Network module loaded successfully.', true);
            } catch (err) {
                logError('Neural Network Load Error', err, 'NeuralNetworkModule not defined. Verify /static/neural_network.js and /static/neural_network.wasm are deployed correctly. Ensure emcc compilation was successful.');
            }
        };
    </script>
</body>
</html>
