<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Server MCP Controller</title>
    <link rel="icon" href="/server/static/icon.png">
    <link rel="manifest" href="/server/static/manifest.json">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=stylesheet" rel="stylesheet">
    <link rel="stylesheet" href="/server/static/style.css">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: monospace, sans-serif;
        }

        html, body {
            height: 100vh;
            overflow: hidden;
            background: #000;
            color: #0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: background 0.3s, box-shadow 0.3s;
            -webkit-tap-highlight-color: transparent;
        }

        body.glow {
            background: rgba(255, 0, 0, 0.1);
            box-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000 inset;
        }

        h1 {
            font-size: 1.6rem;
            text-align: center;
            margin: 0.8rem 0;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 0 5px #0f0;
        }

        #console {
            width: 90%;
            max-width: 900px;
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #0f0;
            padding: 0.6rem;
            flex: 1;
            max-height: calc(100vh - 280px);
            overflow-y: auto;
            margin: 0.5rem 0;
            border-radius: 5px;
            font-size: 0.8rem;
            -webkit-overflow-scrolling: touch;
            transition: border-color 0.3s, box-shadow 0.3s;
        }

        #console.active-monitor {
            border-color: #ff0000;
            box-shadow: 0 0 10px #ff0000;
        }

        #console p {
            margin: 0.2rem 0;
        }

        #console .command {
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            text-shadow: 0 0 3px #0f0;
        }

        #console .error {
            color: #ff0000;
            font-weight: bold;
        }

        #console .next-steps {
            color: #ff0000;
            font-weight: bold;
            margin-top: 0.4rem;
        }

        .button-group {
            display: flex;
            gap: 0.5rem;
            margin: 0.5rem 0;
            padding: 0.5rem;
            flex-wrap: wrap;
            justify-content: center;
            width: 90%;
            max-width: 900px;
        }

        button {
            background: #0f0;
            color: #000;
            border: none;
            padding: 0.6rem 1.2rem;
            font-size: 0.9rem;
            cursor: pointer;
            border-radius: 3px;
            min-width: 90px;
            text-align: center;
            touch-action: manipulation;
            transition: background 0.3s, box-shadow 0.3s;
        }

        button:hover, button:focus {
            background: #0c0;
            outline: 2px solid #0f0;
        }

        button.active-monitor {
            background: #ff0000;
            box-shadow: 0 0 10px #ff0000;
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
        }

        #copy-log-btn {
            background: #ff0000;
            color: #fff;
        }

        #copy-log-btn:hover {
            background: #cc0000;
        }

        #server-stats {
            width: 90%;
            max-width: 900px;
            margin: 0.5rem 0;
            display: flex;
            flex-direction: column;
            gap: 0.2rem;
        }

        .progress-container {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .progress-label {
            width: 90px;
            font-size: 0.75rem;
        }

        .progress-bar {
            flex: 1;
            height: 8px;
            background: #333;
            border: 1px solid #0f0;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #0f0;
            transition: width 0.5s;
        }

        #search-container {
            width: 90%;
            max-width: 900px;
            margin: 0.5rem 0;
        }

        #search-input {
            width: 100%;
            padding: 0.5rem;
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            border-radius: 3px;
            font-size: 0.8rem;
        }

        #search-results {
            margin-top: 0.5rem;
            max-height: 100px;
            overflow-y: auto;
            font-size: 0.8rem;
            color: #0f0;
        }

        footer {
            width: 100%;
            padding: 0.4rem;
            font-size: 9pt;
            text-align: center;
            color: #0f0;
            background: rgba(0, 0, 0, 0.8);
            line-height: 1.2;
        }

        @media (max-width: 600px) {
            h1 { font-size: 1.1rem; margin: 0.5rem 0; }
            #console { font-size: 0.75rem; padding: 0.5rem; max-height: calc(100vh - 300px); }
            button { padding: 0.5rem 1rem; font-size: 0.85rem; min-width: 80px; }
            #search-input { font-size: 0.75rem; }
            footer { padding: 0.3rem; }
            .progress-label { width: 70px; font-size: 0.7rem; }
            .progress-bar { height: 7px; }
        }

        @media (max-width: 400px) {
            .button-group { flex-direction: column; align-items: center; }
            button { width: 100%; max-width: 160px; }
            #console { max-height: calc(100vh - 260px); }
            #server-stats { gap: 0.15rem; }
        }
    </style>
</head>
<body>
    <h1 role="heading" aria-level="1">Server MCP Controller</h1>
    <div id="search-container">
        <input id="search-input" type="text" placeholder="Search server logs..." aria-label="Search server logs">
        <div id="search-results"></div>
    </div>
    <div id="console" role="log" aria-live="polite">
        <p>Server MCP Controller: Check: Run server health checks | Monitor: Toggle real-time latency monitoring | Clear: Reset console | Search: Query logs</p>
    </div>
    <div id="server-stats">
        <div class="progress-container">
            <span class="progress-label">Agent 1:</span>
            <div class="progress-bar"><div class="progress-fill" id="agent1-bar" style="width: 0%"></div></div>
            <span id="agent1-value">0 ms</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">Agent 2:</span>
            <div class="progress-bar"><div class="progress-fill" id="agent2-bar" style="width: 0%"></div></div>
            <span id="agent2-value">0 ms</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">Agent 3:</span>
            <div class="progress-bar"><div class="progress-fill" id="agent3-bar" style="width: 0%"></div></div>
            <span id="agent3-value">0 ms</span>
        </div>
        <div class="progress-container">
            <span class="progress-label">Agent 4:</span>
            <div class="progress-bar"><div class="progress-fill" id="agent4-bar" style="width: 0%"></div></div>
            <span id="agent4-value">0 ms</span>
        </div>
    </div>
    <div class="button-group">
        <button id="check-btn" aria-label="Run server health checks">Check</button>
        <button id="monitor-btn" aria-label="Toggle real-time latency monitoring">Monitor</button>
        <button id="clear-btn" aria-label="Clear console output">Clear</button>
        <button id="copy-log-btn" aria-label="Copy error log and next steps">Copy Log</button>
    </div>
    <footer>
        Â© 2025 WebXOS - Server MCP Controller<br>
        Check: Run server health checks | Monitor: Toggle real-time latency monitoring | Clear: Reset console | Search: Query logs
    </footer>

    <script src="/server/static/fuse.min.js"></script>
    <script src="/server/static/neurots.js"></script>
    <script src="/server/mcp/mcp.js"></script>
    <script src="/server/utils/search.js"></script>
    <script src="/server/static/neural_network.js"></script>
    <script>
        const errorLog = [];
        async function serverLog(message, agentName = 'MCP') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] [${agentName}] ${message}`;
            console.log(logEntry);
            errorLog.push(logEntry);
            try {
                const response = await fetch(`/api/${agentName.toLowerCase()}/log`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message, timestamp })
                });
                if (!response.ok) throw new Error(`HTTP ${response.status}: Log endpoint failed`);
                logMessage(logEntry);
            } catch (err) {
                const errorMessage = `Log Error for ${agentName}: ${err.message}`;
                errorLog.push(`[${timestamp}] [ERROR] ${errorMessage}`);
                logMessage(
                    `<span class="error">${errorMessage}</span><br>` +
                    `<span class="next-steps">Next Steps:<br>` +
                    `- Verify /api/${agentName.toLowerCase()}/log endpoint in server/${agentName.toLowerCase()}/index.js.<br>` +
                    `- Check Netlify Functions dashboard at https://app.netlify.com.<br>` +
                    `- Redeploy with 'netlify deploy --prod'.</span>`, true);
            }
        }

        const consoleDiv = document.getElementById('console');
        let logQueue = [];
        function logMessage(message, isError = false) {
            const formattedMessage = isError 
                ? `<span class="error">${message}</span>` 
                : message;
            logQueue.push(`[${new Date().toLocaleTimeString()}] ${formattedMessage}`);
            if (logQueue.length > 50) logQueue.shift();
            throttleConsoleUpdate();
            if (window.WebXOSSearch && window.WebXOSSearch.updateLog) {
                window.WebXOSSearch.updateLog({ message, timestamp: new Date().toLocaleTimeString() });
            }
        }

        const throttleConsoleUpdate = (() => {
            let timeout;
            return () => {
                if (!timeout) {
                    timeout = setTimeout(() => {
                        consoleDiv.innerHTML = logQueue.map(msg => `<p>${msg}</p>`).join('');
                        consoleDiv.scrollTop = consoleDiv.scrollHeight;
                        timeout = null;
                    }, 100);
                }
            };
        })();

        function triggerGlow() {
            document.body.classList.add('glow');
            setTimeout(() => document.body.classList.remove('glow'), 1000);
        }

        function flashRedGlow() {
            consoleDiv.classList.add('active-monitor');
            setTimeout(() => consoleDiv.classList.remove('active-monitor'), 500);
            setTimeout(() => {
                consoleDiv.classList.add('active-monitor');
                setTimeout(() => consoleDiv.classList.remove('active-monitor'), 500);
            }, 1000);
        }

        function clearConsole() {
            serverLog('Clear button clicked');
            logQueue = ['Server MCP Controller: Check: Run server health checks | Monitor: Toggle real-time latency monitoring | Clear: Reset console | Search: Query logs'];
            document.getElementById('agent1-bar').style.width = '0%';
            document.getElementById('agent1-value').textContent = '0 ms';
            document.getElementById('agent2-bar').style.width = '0%';
            document.getElementById('agent2-value').textContent = '0 ms';
            document.getElementById('agent3-bar').style.width = '0%';
            document.getElementById('agent3-value').textContent = '0 ms';
            document.getElementById('agent4-bar').style.width = '0%';
            document.getElementById('agent4-value').textContent = '0 ms';
            throttleConsoleUpdate();
            logMessage('Console and stats cleared.', true);
            if (window.WebXOSSearch && window.WebXOSSearch.clearLogs) {
                window.WebXOSSearch.clearLogs();
            }
        }

        async function fetchWithErrorHandling(url, options = {}) {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                const response = await fetch(url, { ...options, signal: controller.signal });
                clearTimeout(timeoutId);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const contentType = response.headers.get('content-type');
                if (!contentType || (!contentType.includes('application/json') && !url.endsWith('.js') && !url.endsWith('.wasm') && !url.endsWith('.json') && !url.endsWith('.css'))) {
                    const text = await response.text();
                    throw new Error(`Invalid content type: ${contentType}, got: ${text.slice(0, 50)}...`);
                }
                return url.endsWith('.js') || url.endsWith('.wasm') || url.endsWith('.json') || url.endsWith('.css') ? response : await response.json();
            } catch (error) {
                const nextSteps = url.includes('api') 
                    ? [
                        `Verify ${url} endpoint in server/${url.split('/').slice(-2)[0]}/index.js.`,
                        `Check Netlify Functions at https://app.netlify.com.`,
                        `Redeploy with 'netlify deploy --prod'.`
                    ]
                    : [
                        `Ensure ${url} is in server/${url.replace('/server/', '')} at https://github.com/webxos/webxos.`,
                        `Verify netlify.toml for correct redirects and headers.`,
                        `Redeploy with 'netlify deploy --prod'.`,
                        `Test locally with 'netlify dev' at http://localhost:8888${url}.`
                    ];
                errorLog.push(`[${new Date().toLocaleTimeString()}] [ERROR] Fetch Error for ${url}: ${error.message}`);
                logMessage(
                    `<span class="error">Fetch Error for ${url}: ${error.message}</span><br>` +
                    `<span class="next-steps">Next Steps:<br>- ${nextSteps.join('<br>- ')}</span>`, true);
                serverLog(`Fetch Error for ${url}: ${error.message}`);
                return { error: error.message, nextSteps };
            }
        }

        class ServerAgent {
            constructor(name) {
                this.name = name;
                this.latencyHistory = [];
            }

            async checkLatency() {
                const start = performance.now();
                const response = await fetchWithErrorHandling(`/api/${this.name}/health`);
                const latency = performance.now() - start;
                this.latencyHistory.push(latency);
                if (this.latencyHistory.length > 20) this.latencyHistory.shift();
                const status = response.error ? 'Error' : response.status || 'Healthy';
                let prediction = '';
                try {
                    if (window.NeuroTS && window.NeuroTS.analyzeLatency) {
                        prediction = window.NeuroTS.analyzeLatency(latency, this.name);
                        logMessage(`Neural Analysis for ${this.name}: ${prediction}`);
                    }
                } catch (err) {
                    logMessage(
                        `<span class="error">Neural Analysis Error for ${this.name}: ${err.message}</span><br>` +
                        `<span class="next-steps">Next Steps:<br>` +
                        `- Ensure /server/static/neurots.js and /server/static/neural_network.wasm are loaded.<br>` +
                        `- Verify neural_network.cpp compilation and deployment.</span>`, true);
                    serverLog(`Neural Analysis Error for ${this.name}: ${err.stack}`);
                }
                let mcpResult = '';
                try {
                    if (window.WebXOSMCP && window.WebXOSMCP.analyzeAgent) {
                        mcpResult = window.WebXOSMCP.analyzeAgent(this.name, latency, status);
                        logMessage(`MCP Analysis for ${this.name}: ${mcpResult}`);
                    }
                } catch (err) {
                    logMessage(
                        `<span class="error">MCP Analysis Error for ${this.name}: ${err.message}</span><br>` +
                        `<span class="next-steps">Next Steps:<br>` +
                        `- Ensure /server/mcp/mcp.js is loaded.<br>` +
                        `- Check Netlify deployment logs.</span>`, true);
                    serverLog(`MCP Analysis Error for ${this.name}: ${err.stack}`);
                }
                return { latency, status, error: response.error || null, nextSteps: response.nextSteps || [], prediction, mcpResult };
            }
        }

        const agents = [
            new ServerAgent('agent1'),
            new ServerAgent('agent2'),
            new ServerAgent('agent3'),
            new ServerAgent('agent4')
        ];

        async function checkServers() {
            serverLog('Check button clicked');
            triggerGlow();
            flashRedGlow();
            try {
                const checkBtn = document.getElementById('check-btn');
                checkBtn.disabled = true;
                logMessage('Running server health checks...', true);

                const results = [];
                for (const [index, agent] of agents.entries()) {
                    const { latency, status, error, nextSteps, prediction, mcpResult } = await agent.checkLatency();
                    results.push({ name: agent.name, latency, status, error, nextSteps, prediction, mcpResult });
                    logMessage(
                        `${agent.name}: ${status} (Latency: ${latency.toFixed(2)}ms)` +
                        (error ? `<br><span class="error">Error: ${error}</span><br>` +
                        `<span class="next-steps">Next Steps:<br>- ${nextSteps.join('<br>- ')}</span>` : '') +
                        (prediction ? `<br>Prediction: ${prediction}` : '') +
                        (mcpResult ? `<br>MCP: ${mcpResult}` : ''));
                    document.getElementById(`agent${index + 1}-bar`).style.width = `${Math.min(100, latency / 2)}%`;
                    document.getElementById(`agent${index + 1}-value`).textContent = `${latency.toFixed(2)} ms`;
                }

                const checkDate = new Date().toLocaleString();
                const avgLatency = results.reduce((sum, res) => sum + res.latency, 0) / results.length;
                const worstAgent = results.reduce((worst, res) => res.latency > worst.latency ? res : worst, results[0]);
                const errorCount = results.filter(res => res.error).length;

                let report = `Server MCP Controller Diagnostic Report\n\n`;
                report += `Check Date: ${checkDate}\n`;
                report += `Agents: ${agents.length}\n`;
                report += `Errors Detected: ${errorCount}\n\n`;
                report += `Agent Status:\n`;
                results.forEach(res => {
                    report += `${res.name}: ${res.status} (Latency: ${res.latency.toFixed(2)}ms)${res.error ? `\n  Error: ${res.error}\n  Next Steps: ${res.nextSteps.join('\n  - ')}` : ''}${res.prediction ? `\n  Prediction: ${res.prediction}` : ''}${res.mcpResult ? `\n  MCP: ${res.mcpResult}` : ''}\n`;
                });
                report += `\nAverage Latency: ${avgLatency.toFixed(2)}ms\n`;
                report += `Highest Latency: ${worstAgent.name} (${worstAgent.latency.toFixed(2)}ms)\n`;
                report += `\nNext Steps:\n${errorCount > 0 ? '- Review errors in console and errorlog.md.\n- Check Netlify Functions logs at https://app.netlify.com.\n- Redeploy with `netlify deploy --prod`.\n' : worstAgent.latency > 100 ? '- Optimize high-latency agent.\n- Check network configuration.\n' : '- Maintain current setup.\n- Monitor for issues.\n'}`;
                report += `\nÂ© 2025 WebXOS - Server MCP Controller`;

                try {
                    await navigator.clipboard.writeText(report);
                    logMessage('Diagnostic report copied to clipboard.', true);
                } catch (err) {
                    logMessage(
                        `<span class="error">Clipboard Error: ${err.message}</span><br>` +
                        `<span class="next-steps">Next Steps:<br>` +
                        `- Use fallback copy method (select text manually).<br>` +
                        `- Ensure browser supports clipboard API.</span>`, true);
                    serverLog(`Clipboard Error: ${err.stack}`);
                }

                logMessage(`Average Latency: ${avgLatency.toFixed(2)}ms`, true);
                if (errorCount > 0) {
                    logMessage(
                        `<span class="error">Errors in ${errorCount} agent(s).</span><br>` +
                        `<span class="next-steps">Next Steps:<br>- Review report in clipboard.<br>- Check Netlify logs.</span>`, true);
                    flashRedGlow();
                }
                checkBtn.disabled = false;
            } catch (err) {
                logMessage(
                    `<span class="error">Check Error: ${err.message}</span><br>` +
                    `<span class="next-steps">Next Steps:<br>` +
                    `- Check console for detailed errors.<br>` +
                    `- Verify agent endpoints in server/agent1-4/index.js.</span>`, true);
                serverLog(`Check Error: ${err.stack}`);
                document.getElementById('check-btn').disabled = false;
            }
        }

        let monitorActive = false;
        let monitorStartTime = null;
        let monitorInterval = null;

        async function updateServerStats() {
            try {
                for (const [index, agent] of agents.entries()) {
                    const { latency, status, error, nextSteps, prediction, mcpResult } = await agent.checkLatency();
                    document.getElementById(`agent${index + 1}-bar`).style.width = `${Math.min(100, latency / 2)}%`;
                    document.getElementById(`agent${index + 1}-value`).textContent = `${latency.toFixed(2)} ms`;
                    logMessage(
                        `${agent.name}: ${status} (Latency: ${latency.toFixed(2)}ms)` +
                        (error ? `<br><span class="error">Error: ${error}</span><br>` +
                        `<span class="next-steps">Next Steps:<br>- ${nextSteps.join('<br>- ')}</span>` : '') +
                        (prediction ? `<br>Prediction: ${prediction}` : '') +
                        (mcpResult ? `<br>MCP: ${mcpResult}` : ''));
                }

                const avgLatency = agents.reduce((sum, agent) => sum + (agent.latencyHistory[agent.latencyHistory.length - 1] || 0), 0) / agents.length;
                const errorCount = (await Promise.all(agents.map(agent => agent.checkLatency()))).filter(res => res.error).length;
                let stateMessage = '';
                let nextSteps = [];

                if (errorCount > 0) {
                    stateMessage = `Server State: Critical - ${errorCount} agent(s) with errors.`;
                    nextSteps = [
                        'Review console and errorlog.md.',
                        'Check Netlify Functions at https://app.netlify.com.',
                        'Redeploy with `netlify deploy --prod`.'
                    ];
                    flashRedGlow();
                } else if (avgLatency < 50) {
                    stateMessage = 'Server State: Optimal - Low latency.';
                    nextSteps = ['Maintain current setup.', 'Monitor for consistency.'];
                } else if (avgLatency < 100) {
                    stateMessage = 'Server State: Moderate - Optimize latency.';
                    nextSteps = ['Check network stability.', 'Optimize resources.'];
                } else {
                    stateMessage = 'Server State: High - Action needed.';
                    nextSteps = ['Investigate bottlenecks.', 'Scale resources.'];
                    flashRedGlow();
                }

                logMessage(
                    stateMessage + `<br><span class="next-steps">Next Steps:<br>- ${nextSteps.join('<br>- ')}</span>`, true);
            } catch (err) {
                logMessage(
                    `<span class="error">Monitor Error: ${err.message}</span><br>` +
                    `<span class="next-steps">Next Steps:<br>` +
                    `- Check console for errors.<br>` +
                    `- Verify agent endpoints.</span>`, true);
                serverLog(`Monitor Error: ${err.stack}`);
            }
        }

        async function toggleMonitor() {
            monitorActive = !monitorActive;
            const monitorBtn = document.getElementById('monitor-btn');
            const consoleDiv = document.getElementById('console');
            monitorBtn.classList.toggle('active-monitor', monitorActive);
            consoleDiv.classList.toggle('active-monitor', monitorActive);
            triggerGlow();
            flashRedGlow();

            if (monitorActive) {
                monitorStartTime = new Date();
                logMessage('Monitor: Real-time latency monitoring activated.', true);
                await updateServerStats();
                monitorInterval = setInterval(() => {
                    window.requestIdleCallback ? window.requestIdleCallback(updateServerStats, { timeout: 1000 }) : updateServerStats();
                }, window.WebXOSMCP ? window.WebXOSMCP.pollInterval : 5000);
            } else {
                clearInterval(monitorInterval);
                logMessage('Monitor: Real-time latency monitoring deactivated.', true);

                const stopTime = new Date();
                const timeRanSeconds = Math.round((stopTime - monitorStartTime) / 1000);
                const results = [];
                for (const agent of agents) {
                    const avgLatency = agent.latencyHistory.length > 0 
                        ? agent.latencyHistory.reduce((sum, lat) => sum + lat, 0) / agent.latencyHistory.length 
                        : 0;
                    let prediction = '';
                    let mcpResult = '';
                    try {
                        if (window.NeuroTS && window.NeuroTS.analyzeLatency) {
                            prediction = window.NeuroTS.analyzeLatency(avgLatency, agent.name);
                        }
                        if (window.WebXOSMCP && window.WebXOSMCP.analyzeAgent) {
                            mcpResult = window.WebXOSMCP.analyzeAgent(agent.name, avgLatency, 'Healthy');
                        }
                    } catch (err) {
                        logMessage(
                            `<span class="error">Analysis Error for ${agent.name}: ${err.message}</span><br>` +
                            `<span class="next-steps">Next Steps:<br>` +
                            `- Ensure /server/static/neurots.js and /server/mcp/mcp.js are loaded.<br>` +
                            `- Redeploy with 'netlify deploy --prod'.</span>`, true);
                        serverLog(`Analysis Error for ${agent.name}: ${err.stack}`);
                    }
                    results.push({ name: agent.name, avgLatency, prediction, mcpResult });
                }

                const worstAgent = results.reduce((worst, res) => res.avgLatency > worst.avgLatency ? res : worst, results[0]);
                const avgLatency = results.reduce((sum, res) => sum + res.avgLatency, 0) / results.length;
                const errorCount = (await Promise.all(agents.map(agent => agent.checkLatency()))).filter(res => res.error).length;

                let report = `Server MCP Controller Monitoring Report\n\n`;
                report += `Stopped: ${stopTime.toLocaleString()}\n`;
                report += `Duration: ${Math.floor(timeRanSeconds / 60)}m ${timeRanSeconds % 60}s\n`;
                report += `Agents: ${agents.length}\n`;
                report += `Errors: ${errorCount}\n\n`;
                report += `Agent Latencies:\n`;
                results.forEach(res => {
                    report += `${res.name}: ${res.avgLatency.toFixed(2)}ms (avg)${res.prediction ? `\n  Prediction: ${res.prediction}` : ''}${res.mcpResult ? `\n  MCP: ${res.mcpResult}` : ''}\n`;
                });
                report += `\nAverage Latency: ${avgLatency.toFixed(2)}ms\n`;
                report += `Highest Latency: ${worstAgent.name} (${worstAgent.avgLatency.toFixed(2)}ms)\n`;
                report += `\nNext Steps:\n${errorCount > 0 ? '- Check console and errorlog.md.\n- Redeploy with `netlify deploy --prod`.\n' : worstAgent.avgLatency > 100 ? '- Optimize network.\n- Scale resources.\n' : '- Continue monitoring.\n'}`;
                report += `\nÂ© 2025 WebXOS - Server MCP Controller`;

                try {
                    await navigator.clipboard.writeText(report);
                    logMessage('Monitoring report copied to clipboard.', true);
                } catch (err) {
                    logMessage(
                        `<span class="error">Clipboard Error: ${err.message}</span><br>` +
                        `<span class="next-steps">Next Steps:<br>` +
                        `- Use fallback copy method.<br>` +
                        `- Check browser clipboard support.</span>`, true);
                    serverLog(`Clipboard Error: ${err.stack}`);
                }
            }
        }

        function copyErrorLog() {
            const logText = errorLog.length > 0 
                ? errorLog.join('\n') + '\n\nNext Steps:\n- Paste this log to Grok for further assistance.\n- Check https://github.com/webxos/webxos for missing files.\n- Redeploy with `netlify deploy --prod`.'
                : 'No errors logged yet.';
            try {
                navigator.clipboard.writeText(logText).then(() => {
                    logMessage('Error log copied to clipboard.', true);
                    serverLog('Error log copied to clipboard.');
                }).catch(err => {
                    logMessage(
                        `<span class="error">Clipboard Error: ${err.message}</span><br>` +
                        `<span class="next-steps">Next Steps:<br>` +
                        `- Select text manually to copy.<br>` +
                        `- Verify browser clipboard permissions.</span>`, true);
                    serverLog(`Clipboard Error: ${err.stack}`);
                });
            } catch (err) {
                logMessage(
                    `<span class="error">Clipboard Error: ${err.message}</span><br>` +
                    `<span class="next-steps">Next Steps:<br>` +
                    `- Select text manually to copy.<br>` +
                    `- Verify browser clipboard permissions.</span>`, true);
                serverLog(`Clipboard Error: ${err.stack}`);
            }
        }

        const debounce = (func, wait) => {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        };

        document.getElementById('check-btn').addEventListener('click', debounce(() => {
            serverLog('Check button clicked');
            checkServers();
        }, 200));
        document.getElementById('monitor-btn').addEventListener('click', debounce(() => {
            serverLog('Monitor button clicked');
            toggleMonitor();
        }, 200));
        document.getElementById('clear-btn').addEventListener('click', debounce(() => {
            serverLog('Clear button clicked');
            clearConsole();
        }, 200));
        document.getElementById('copy-log-btn').addEventListener('click', debounce(() => {
            serverLog('Copy log button clicked');
            copyErrorLog();
        }, 200));

        document.getElementById('search-input').addEventListener('input', debounce(() => {
            serverLog('Search input changed');
            const query = document.getElementById('search-input').value;
            if (window.WebXOSSearch && window.WebXOSSearch.search) {
                const results = window.WebXOSSearch.search(query);
                document.getElementById('search-results').innerHTML = results.length 
                    ? results.map(r => `<p>${r.item.message} (${r.item.timestamp})</p>`).join('')
                    : '<p>No results found.</p>';
            } else {
                logMessage(
                    `<span class="error">Search unavailable</span><br>` +
                    `<span class="next-steps">Next Steps:<br>` +
                    `- Ensure /server/utils/search.js and /server/static/fuse.min.js are loaded.<br>` +
                    `- Redeploy with 'netlify deploy --prod'.</span>`, true);
                serverLog('Search unavailable.');
            }
        }, 300));

        document.addEventListener('keydown', e => {
            serverLog(`Key pressed: ${e.key}`);
            if (e.key === 'Enter' || e.key === ' ') checkServers();
            else if (e.key === 'm' || e.key === 'M') toggleMonitor();
            else if (e.key === 'c' || e.key === 'C') clearConsole();
            else if (e.key === 'l' || e.key === 'L') copyErrorLog();
        });

        async function initNeuralNetwork() {
            if (typeof NeuralNetworkModule === 'undefined') {
                logMessage(
                    `<span class="error">Neural Network Error: NeuralNetworkModule not defined</span><br>` +
                    `<span class="next-steps">Next Steps:<br>` +
                    `- Ensure /server/static/neural_network.js is loaded.<br>` +
                    `- Verify neural_network.cpp compilation with Emscripten.<br>` +
                    `- Redeploy with 'netlify deploy --prod'.</span>`, true);
                serverLog('NeuralNetworkModule not defined.');
                return;
            }
            try {
                const Module = await NeuralNetworkModule();
                await new Promise(resolve => {
                    Module.onRuntimeInitialized = () => {
                        logMessage('Emscripten runtime initialized.', true);
                        serverLog('Emscripten runtime initialized.');
                        resolve();
                    };
                });
                const createNetwork = Module.cwrap('create_network', 'number', ['number', 'number', 'number']);
                const predict = Module.cwrap('predict', 'number', ['number', 'number', 'number', 'number']);
                const freeResult = Module.cwrap('free_result', null, ['number']);
                const nn = createNetwork(3, 4, 2);
                const input = new Float32Array([0.5, 0.3, 0.7]);
                const inputPtr = Module._malloc(input.length * input.BYTES_PER_ELEMENT);
                Module.HEAPF32.set(input, inputPtr / input.BYTES_PER_ELEMENT);
                const outputSizePtr = Module._malloc(4);
                const outputPtr = predict(nn, inputPtr, input.length, outputSizePtr);
                const outputSize = Module.getValue(outputSizePtr, 'i32');
                const output = new Float32Array(Module.HEAPF32.buffer, outputPtr, outputSize);
                logMessage(`Neural Network Prediction: [${output.join(', ')}]`, true);
                serverLog(`Neural Network Prediction: [${output.join(', ')}]`);
                Module._free(inputPtr);
                Module._free(outputSizePtr);
                freeResult(outputPtr);
            } catch (err) {
                logMessage(
                    `<span class="error">Neural Network Error: ${err.message}</span><br>` +
                    `<span class="next-steps">Next Steps:<br>` +
                    `- Ensure /server/static/neural_network.wasm and .js are deployed.<br>` +
                    `- Verify neural_network.cpp compilation.<br>` +
                    `- Check Netlify logs at https://app.netlify.com.</span>`, true);
                serverLog(`Neural Network Error: ${err.stack}`);
            }
        }

        window.onload = async () => {
            logMessage('Server MCP Controller initialized.', true);
            const filesToCheck = [
                '/server/static/style.css',
                '/server/static/fuse.min.js',
                '/server/static/neurots.js',
                '/server/mcp/mcp.js',
                '/server/utils/search.js',
                '/server/static/neural_network.js',
                '/server/static/neural_network.wasm',
                '/server/utils/site_index.json',
                '/server/static/sw.js',
                '/server/static/icon.png',
                '/server/static/manifest.json'
            ];
            for (const file of filesToCheck) {
                try {
                    const res = await fetch(file, { method: 'HEAD' });
                    if (!res.ok) throw new Error(`HTTP ${res.status}: Failed to load ${file}`);
                    logMessage(`${file} loaded successfully.`, true);
                    serverLog(`${file} loaded successfully.`);
                } catch (err) {
                    logMessage(
                        `<span class="error">Error loading ${file}: ${err.message}</span><br>` +
                        `<span class="next-steps">Next Steps:<br>` +
                        `- Ensure ${file} is in server/${file.replace('/server/', '')} at https://github.com/webxos/webxos.<br>` +
                        `- Verify netlify.toml redirects and headers.<br>` +
                        `- Redeploy with 'netlify deploy --prod'.</span>`, true);
                    serverLog(`File Error for ${file}: ${err.message}`);
                }
            }
            try {
                if (window.NeuroTS && window.NeuroTS.init) {
                    await window.NeuroTS.init('/server/static/neural_network.wasm');
                    logMessage('NeuroTS initialized successfully.', true);
                    serverLog('NeuroTS initialized successfully.');
                } else {
                    logMessage(
                        `<span class="error">NeuroTS unavailable</span><br>` +
                        `<span class="next-steps">Next Steps:<br>` +
                        `- Ensure /server/static/neurots.js is loaded.<br>` +
                        `- Redeploy with 'netlify deploy --prod'.</span>`, true);
                    serverLog('NeuroTS unavailable.');
                }
            } catch (err) {
                logMessage(
                    `<span class="error">NeuroTS Error: ${err.message}</span><br>` +
                    `<span class="next-steps">Next Steps:<br>` +
                    `- Verify /server/static/neurots.js and .wasm are deployed.<br>` +
                    `- Check Netlify logs.</span>`, true);
                serverLog(`NeuroTS Error: ${err.stack}`);
            }
            try {
                if (window.WebXOSMCP && window.WebXOSMCP.init) {
                    await window.WebXOSMCP.init();
                    logMessage('MCP initialized successfully.', true);
                    serverLog('MCP initialized successfully.');
                } else {
                    logMessage(
                        `<span class="error">MCP unavailable</span><br>` +
                        `<span class="next-steps">Next Steps:<br>` +
                        `- Ensure /server/mcp/mcp.js is loaded.<br>` +
                        `- Redeploy with 'netlify deploy --prod'.</span>`, true);
                    serverLog('MCP unavailable.');
                }
            } catch (err) {
                logMessage(
                    `<span class="error">MCP Error: ${err.message}</span><br>` +
                    `<span class="next-steps">Next Steps:<br>` +
                    `- Verify /server/mcp/mcp.js is deployed.<br>` +
                    `- Check Netlify logs.</span>`, true);
                serverLog(`MCP Error: ${err.stack}`);
            }
            try {
                if (window.WebXOSSearch && window.WebXOSSearch.init) {
                    await window.WebXOSSearch.init('/server/utils/site_index.json');
                    logMessage('Search initialized successfully.', true);
                    serverLog('Search initialized successfully.');
                } else {
                    logMessage(
                        `<span class="error">Search unavailable</span><br>` +
                        `<span class="next-steps">Next Steps:<br>` +
                        `- Ensure /server/utils/search.js and /server/static/fuse.min.js are loaded.<br>` +
                        `- Redeploy with 'netlify deploy --prod'.</span>`, true);
                    serverLog('Search unavailable.');
                }
            } catch (err) {
                logMessage(
                    `<span class="error">Search Error: ${err.message}</span><br>` +
                    `<span class="next-steps">Next Steps:<br>` +
                    `- Verify /server/utils/search.js and /server/static/fuse.min.js are deployed.<br>` +
                    `- Check Netlify logs.</span>`, true);
                serverLog(`Search Error: ${err.stack}`);
            }
            if ('serviceWorker' in navigator) {
                try {
                    const res = await fetch('/server/static/sw.js');
                    if (!res.ok) throw new Error(`HTTP ${res.status}: Failed to fetch /server/static/sw.js`);
                    const reg = await navigator.serviceWorker.register('/server/static/sw.js', { scope: '/' });
                    logMessage('Service Worker registered successfully.', true);
                    serverLog(`Service Worker registered with scope: ${reg.scope}`);
                } catch (err) {
                    logMessage(
                        `<span class="error">Service Worker Error: ${err.message}</span><br>` +
                        `<span class="next-steps">Next Steps:<br>` +
                        `- Verify /server/static/sw.js is deployed.<br>` +
                        `- Check netlify.toml for Content-Type: text/javascript.<br>` +
                        `- Redeploy with 'netlify deploy --prod'.</span>`, true);
                    serverLog(`Service Worker Error: ${err.stack}`);
                }
            } else {
                logMessage('Service Worker not supported.', true);
                serverLog('Service Worker not supported.');
            }
            initNeuralNetwork();
        };
    </script>
</body>
</html>
