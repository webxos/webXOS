<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>edTV: CHANNEL 11</title>
    <meta name="theme-color" content="#000000">
    <link rel="manifest" href="data:application/manifest+json,{
        \"name\": \"3D Data Capture\",
        \"short_name\": \"3D Capture\",
        \"description\": \"3D geometry data capture and export\",
        \"start_url\": \"./\",
        \"display\": \"fullscreen\",
        \"background_color\": \"#000000\",
        \"theme_color\": \"#000000\",
        \"icons\": [
            {
                \"src\": \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkyIiBoZWlnaHQ9IjE5MiIgdmlld0JveD0iMCAwIDE5MiAxOTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxOTIiIGhlaWdodD0iMTkyIiBmaWxsPSIjMDAwMDAwIi8+CjxwYXRoIGQ9Ik05NiAxMjhMMTI4IDk2SDY0TDEyOCA2NEw5NiAzMkw2NCA2NEgxMjhMNjQgOTZIMTI4TDk2IDEyOFoiIGZpbGw9IiMwMGZmMDAiLz4KPC9zdmc+Cg==\",
                \"sizes\": \"192x192\",
                \"type\": \"image/svg+xml\"
            }
        ]
    }">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js"></script>
    <script src="https://docs.opencv.org/4.5.0/opencv.js"></script>
    <script src="./alva_ar.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        *{margin:0;padding:0;box-sizing:border-box;font-family:'Press Start 2P',cursive;image-rendering:pixelated}
        body{background:#000;color:#0f0;overflow:hidden;height:100vh;user-select:none;-webkit-tap-highlight-color:transparent}
        #appContainer{position:relative;width:100%;height:100vh;overflow:hidden}
        .matrix-grid{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(rgba(0,255,0,0.1)1px,transparent 1px),linear-gradient(90deg,rgba(0,255,0,0.1)1px,transparent 1px);background-size:16px 16px;opacity:0.3}
        .crt-overlay{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(to bottom,transparent 50%,rgba(0,20,0,0.1)50%);background-size:100% 4px;z-index:5;pointer-events:none;animation:scanline 8s linear infinite}
        @keyframes scanline{0%{background-position:0 0}100%{background-position:0 100%}}
        #visualizationContainer{position:absolute;top:0;left:0;width:100%;height:100%;z-index:2}
        #ideInterface{position:absolute;top:0;left:0;width:100%;height:100%;z-index:10}
       
        /* Top Banner */
        .top-banner {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 40px;
            background: rgba(255, 0, 255, 0.9);
            border-bottom: 2px solid #f0f;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 12;
            overflow: hidden;
            animation: glitch 3s infinite;
        }
       
        @keyframes glitch {
            0%, 100% { transform: translateX(0); }
            5% { transform: translateX(-2px); }
            10% { transform: translateX(2px); }
            15% { transform: translateX(-1px); }
            20% { transform: translateX(1px); }
            25% { transform: translateX(0); }
            50% { transform: translateX(0); }
            55% { transform: translateX(-1px) skewX(-2deg); }
            60% { transform: translateX(1px) skewX(2deg); }
            65% { transform: translateX(-1px) skewX(-1deg); }
            70% { transform: translateX(1px) skewX(1deg); }
            75% { transform: translateX(0); }
        }
       
        .top-banner-text {
            font-size: 12px;
            color: #000;
            text-shadow: 1px 1px 0 #fff;
            letter-spacing: 1px;
        }
       
        /* Control Buttons */
        .ctrl-btn{
            width:120px;height:52px;background:#000;border:3px solid #0ff;color:#0ff;
            font-size:10px;display:flex;align-items:center;justify-content:center;cursor:pointer;
            box-shadow:3px 3px 0 #000;transform:skew(-2deg);transition:background 0.1s,color 0.1s;
            touch-action:none;margin:10px;
        }
        .ctrl-btn:hover,.ctrl-btn:active{background:#0ff;color:#000}
        .ctrl-btn.active{background:#0ff;color:#000}
       
        .export-btn{
            border-color:#f0f;color:#f0f;
        }
        .export-btn:hover,.export-btn:active{background:#f0f;color:#000}
        .export-btn.active{background:#f0f;color:#000}
       
        .controls-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 11;
            flex-wrap: wrap;
            justify-content: center;
        }
       
        /* Mirror Popup */
        .mirror-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 10, 0, 0.95);
            border: 3px solid #0ff;
            padding: 8px;
            z-index: 100;
            box-shadow: 6px 6px 0 #000, inset 2px 2px 0 #0ff;
            width: 320px;
            height: 400px;
            resize: both;
            overflow: hidden;
            font-size: 8px;
            color: #0ff;
            border-radius: 4px;
        }
       
        .mirror-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 8px;
            background: rgba(0, 255, 255, 0.2);
            border-bottom: 2px solid #0ff;
            margin-bottom: 8px;
            cursor: move;
            user-select: none;
        }
       
        .mirror-title {
            font-size: 10px;
            color: #0ff;
            text-shadow: 1px 1px 0 #000;
        }
       
        .mirror-close {
            width: 24px;
            height: 24px;
            background: #000;
            border: 2px solid #f00;
            color: #f00;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
        }
       
        .mirror-close:hover,.mirror-close:active{background:#f00;color:#000}
       
        .mirror-content {
            width: 100%;
            height: calc(100% - 40px);
            position: relative;
        }
       
        /* Webcam Mesh Styles */
        .webcam-mesh-container {
            width: 100%;
            height: 200px;
            background: #000;
            border: 2px solid #0f0;
            position: relative;
            overflow: hidden;
        }
       
        .webcam-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                linear-gradient(rgba(0, 255, 0, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 0, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
            z-index: 1;
        }
       
        .face-direction-arrow {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            transform-origin: center;
            z-index: 3;
            transition: transform 0.1s ease;
        }
       
        .face-direction-arrow::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 20px solid #f00;
        }
       
        .face-direction-arrow::after {
            content: '';
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 4px;
            height: 20px;
            background: #f00;
        }
       
        .user-position-marker {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #0ff;
            border-radius: 50%;
            z-index: 2;
            box-shadow: 0 0 10px #0ff;
        }
       
        #calibStatus{font-size:6px;color:#ff0;margin:4px 0;text-align:center}
       
        /* Radar Canvas Styles */
        #radarCanvas {
            width: 100%;
            height: 100px;
            border: 2px solid #0f0;
            background: #000;
            display: block;
            margin-top: 8px;
        }
       
        .radar-container {
            position: relative;
            width: 100%;
            height: 100px;
        }
       
        /* HUD Warning */
        #hudWarning{position:absolute;top:20%;left:50%;transform:translate(-50%,-50%);color:#f00;font-size:12px;text-shadow:1px 1px 0 #000;z-index:11;display:none}
       
        /* Mobile Optimization */
        @media (max-width:767px){
            .mirror-popup{width:300px;height:380px}
            .controls-container{flex-direction:column;align-items:center;bottom:80px;}
            .ctrl-btn{width:140px;height:56px;font-size:12px}
        }
       
        /* Webcam Canvas */
        #webcamCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }
       
        /* Scene Click Area */
        #sceneClickArea {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: calc(100% - 80px);
            z-index: 3;
            cursor: pointer;
        }
       
        /* Status Panel */
        .status-panel {
            position: absolute;
            top: 50px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #0ff;
            padding: 8px;
            font-size: 8px;
            color: #0ff;
            max-width: 200px;
            z-index: 11;
        }

        /* Scanner Animation */
        @keyframes scan {
            0% {top:0%}
            50% {top:100%}
            100% {top:0%}
        }
    </style>
</head>
<body>
<div id="appContainer">
    <div class="matrix-grid"></div>
    <div class="crt-overlay"></div>
   
    <!-- Top Banner -->
    <div class="top-banner">
        <div class="top-banner-text">edTV: CHANNEL 11</div>
    </div>
   
    <!-- 3D SCENE -->
    <div id="visualizationContainer">
        <canvas id="visualizationCanvas"></canvas>
        <div id="sceneClickArea" title="Click to center view"></div>
    </div>
   
    <!-- Status Panel -->
    <div class="status-panel">
        <div>OBJECTS: <span id="objectCount">0</span></div>
        <div>FACES: <span id="faceCount">0</span></div>
        <div>DATA POINTS: <span id="dataPointCount">0</span></div>
    </div>
   
    <div id="ideInterface">
        <!-- CONTROL BUTTONS -->
        <div class="controls-container">
            <button id="mirrorBtn" class="ctrl-btn" aria-label="Open Calibration">CALIBRATE</button>
            <button id="exportBtn" class="ctrl-btn export-btn" aria-label="Export 3D Data">EXPORT</button>
            <button id="clearBtn" class="ctrl-btn" aria-label="Clear Data" style="border-color:#ff0;color:#ff0">CLEAR</button>
            <button id="loadCustomBtn" class="ctrl-btn" style="border-color:#f00;color:#f00">LOAD CUSTOM</button>
        </div>
       
        <!-- HUD -->
        <div id="hudWarning">NO DATA CAPTURED</div>
    </div>
    <!-- MIRROR POPUP -->
    <div class="mirror-popup" id="mirrorPopup">
        <div class="mirror-header">
            <div class="mirror-title">3D DATA CALIBRATION</div>
            <div class="mirror-close" aria-label="Close Mirror">X</div>
        </div>
        <div class="mirror-content">
            <div class="webcam-mesh-container" id="webcamMeshContainer">
                <canvas id="webcamCanvas"></canvas>
                <div class="webcam-grid"></div>
                <div class="face-direction-arrow" id="faceDirectionArrow"></div>
                <div class="user-position-marker" id="userPositionMarker" style="top: 50%; left: 50%;"></div>
                <div id="scannerBar" style="position:absolute;left:0;width:100%;height:2px;background:#f00;z-index:3;animation:scan 2s linear infinite"></div>
            </div>
            <div id="calibStatus">CALIBRATING...</div>
            <div id="matchID" style="text-align:center;color:#0ff;font-size:10px;"></div>
            <div class="radar-container">
                <canvas id="radarCanvas"></canvas>
            </div>
            <canvas id="matchChart" style="width:100%;height:100px;margin-top:8px;"></canvas>
            <div id="scanText" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#f00;font-size:16px;text-shadow:1px 1px #000;z-index:4;pointer-events:none">SCANNING FACE</div>
        </div>
    </div>

    <!-- PIP Webcam -->
    <div id="pipWindow" style="position:absolute;top:50px;right:10px;width:120px;height:90px;background:#000;border:2px solid #0f0;z-index:11;overflow:hidden;">
        <canvas id="pipCanvas" width="120" height="90"></canvas>
    </div>

    <input type="file" id="customFileInput" style="display:none" accept=".json">
</div>
<script>
    // Main Application Variables
    let scene, cam, ren, clock;
    let userObj, objects = [];
    let faceDirection = 0, userDetected = false;
    let stream, faceMesh, camera, objectDetector;
    let isFrontCam = true;
    const user = new THREE.Vector3(0, 1, 0);
    let animationId = null;
    let serviceWorkerUrl = null;
    let mirrorDragging = false;
    let mirrorOffset = { x: 0, y: 0 };
    let cameraDistance = 5;
    let alva;
    let facePoints;
    let faceLines;
    let customFaces = [];
    let matchChart;
    // 3D Data Schema
    const geometryDataSchema = {
        version: "1.0",
        timestamp: "",
        metadata: {
            app: "edTV_CHANNEL_11",
            captureType: "face_objects_3d",
            coordinateSystem: "right_handed"
        },
        faceGeometry: {
            vertices: [],
            normals: [],
            faces: [],
            landmarks: []
        },
        environmentObjects: [],
        camera: {
            position: { x: 0, y: 0, z: 0 },
            rotation: { x: 0, y: 0, z: 0 },
            fov: 75
        }
    };
    // DOM utility functions
    const $ = s => document.querySelector(s);
    const $$ = s => document.querySelectorAll(s);
    async function init() {
        try {
            init3D();
            setupFaceDetection();
            await setupObjectDetection();
            await setupSLAM();
            setupServiceWorker();
            setupEventListeners();
            setupChart();
            autoStartMirror();
            animate();
           
            console.log("3D Data Capture initialized successfully");
        } catch (error) {
            console.error('Initialization error:', error);
        }
    }
    function setupChart() {
        const chartCtx = $('#matchChart').getContext('2d');
        matchChart = new Chart(chartCtx, {
            type: 'bar',
            data: {
                labels: [],
                datasets: [{ label: 'Confidence', data: [], backgroundColor: '#0ff' }]
            },
            options: {
                scales: { y: { beginAtZero: true, max: 1 } },
                responsive: true,
                maintainAspectRatio: false
            }
        });
    }
    function init3D() {
        try {
            // Initialize Three.js scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
           
            cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            cam.position.set(0, 1, cameraDistance);
           
            const canvas = $('#visualizationCanvas');
            ren = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: false,
                powerPreference: "high-performance"
            });
            ren.setSize(window.innerWidth, window.innerHeight);
            ren.setPixelRatio(Math.min(window.devicePixelRatio, 2));
           
            clock = new THREE.Clock();
            // Lighting
            scene.add(new THREE.AmbientLight(0x003300));
            const dir = new THREE.DirectionalLight(0x00ff00, 0.4);
            dir.position.set(5, 10, 5);
            scene.add(dir);
            // Grid
            const gridSize = 20, gridDiv = 20;
            const gridMat = new THREE.LineBasicMaterial({ color: 0x004400 });
            const gridGeo = new THREE.BufferGeometry();
            const positions = [];
            for (let i = -gridSize / 2; i <= gridSize / 2; i += gridSize / gridDiv) {
                positions.push(i, 0, -gridSize / 2, i, 0, gridSize / 2);
                positions.push(-gridSize / 2, 0, i, gridSize / 2, 0, i);
            }
            gridGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            scene.add(new THREE.LineSegments(gridGeo, gridMat));
            // User object
            userObj = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0x00ffff })
            );
            userObj.position.copy(user);
            scene.add(userObj);
            // User direction arrow
            const arrowGeometry = new THREE.ConeGeometry(0.1, 0.3, 8);
            const arrowMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const userArrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
            userArrow.position.set(0, 0.3, 0);
            userArrow.rotation.x = Math.PI / 2;
            userObj.add(userArrow);
            cam.lookAt(user);
            ren.render(scene, cam);
           
        } catch (error) {
            console.error('3D initialization error:', error);
            throw new Error(`3D setup failed: ${error.message}`);
        }
    }
    function createThermalMaterial() {
    return new THREE.ShaderMaterial({
        uniforms: {
            time: { value: 0 },
            points: { value: null }
        },
        vertexShader: `
            attribute float depth;
            varying float vDepth;
            void main() {
                vDepth = depth;
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                gl_PointSize = 3.0 * (300.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `,
        fragmentShader: `
            varying float vDepth;
            void main() {
                float heat = 1.0 - smoothstep(0.5, 3.0, vDepth);
                vec3 cold = vec3(0.0, 0.0, 1.0);
                vec3 hot = vec3(1.0, 0.0, 0.0);
                vec3 color = mix(cold, hot, heat);
                gl_FragColor = vec4(color, 1.0);
            }
        `,
        transparent: true,
        depthWrite: false
    });
}
    function setupFaceDetection() {
        try {
            faceMesh = new FaceMesh({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
                }
            });
           
            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
           
            faceMesh.onResults(onFaceMeshResults);
           
            console.log("Face Mesh detection initialized");
        } catch (error) {
            console.error('Face detection setup error:', error);
        }
    }
    async function setupObjectDetection() {
        try {
            objectDetector = await cocoSsd.load();
            console.log("Object detection initialized");
        } catch (error) {
            console.error('Object detection setup error:', error);
        }
    }
    async function setupSLAM() {
    const video = $('#webcamVideo');
    if (!video) return;
    alva = await AlvaAR.Initialize(video.videoWidth, video.videoHeight);
    console.log("SLAM initialized");
}
    let facePoints;
let faceLines;
function onFaceMeshResults(results) {
    userDetected = !!results.multiFaceLandmarks?.length;
    const canvas = $('#webcamCanvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (results.image) {
        ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
    }
    if (userDetected) {
        const landmarks = results.multiFaceLandmarks[0];
        drawConnectors(ctx, landmarks, FACEMESH_TESSELATION, {color: '#00ffff', lineWidth: 1});
        geometryDataSchema.faceGeometry.landmarks = landmarks.map(p => ({x:p.x, y:p.y, z:p.z}));
        // Remove old points and lines
        if (facePoints) scene.remove(facePoints);
        if (faceLines) scene.remove(faceLines);
        // Create thermal point cloud
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(landmarks.length * 3);
        const depths = new Float32Array(landmarks.length);
        landmarks.forEach((lm, i) => {
            const x = (lm.x - 0.5) * 5;
            const y = (0.5 - lm.y) * 5;
            const z = -lm.z * 8;
            positions[i*3] = x;
            positions[i*3+1] = y;
            positions[i*3+2] = z;
            depths[i] = -z;
        });
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('depth', new THREE.BufferAttribute(depths, 1));
        const material = createThermalMaterial();
        facePoints = new THREE.Points(geometry, material);
        scene.add(facePoints);
        // Add 3D wireframe reconstruction
        const lineGeometry = new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const lineIndices = [];
        FACEMESH_TESSELATION.forEach(([a, b]) => {
            lineIndices.push(a, b);
        });
        lineGeometry.setIndex(lineIndices);
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
        faceLines = new THREE.LineSegments(lineGeometry, lineMaterial);
        scene.add(faceLines);
        // Update yaw
        const left = landmarks[234], right = landmarks[454];
        faceDirection = Math.atan2(right.x - left.x, right.z - left.z) * 180 / Math.PI;
        // Custom ID matching
        if (customFaces.length > 0 && landmarks) {
            const currentLandmarks = landmarks;
            const confidences = customFaces.map(cf => {
                let totalDist = 0;
                for (let i = 0; i < Math.min(currentLandmarks.length, cf.landmarks.length); i++) {
                    const p1 = currentLandmarks[i];
                    const p2 = cf.landmarks[i];
                    const dx = p1.x - p2.x;
                    const dy = p1.y - p2.y;
                    const dz = p1.z - p2.z;
                    totalDist += Math.sqrt(dx*dx + dy*dy + dz*dz);
                }
                const avgDist = totalDist / currentLandmarks.length;
                const confidence = 1 / (1 + avgDist * 100);
                return {id: cf.id, conf: confidence};
            });
            confidences.sort((a,b) => b.conf - a.conf);
            const top = confidences.slice(0, 5);
            matchChart.data.labels = top.map(t => t.id);
            matchChart.data.datasets[0].data = top.map(t => t.conf);
            matchChart.update();
            const best = confidences[0];
            if (best.conf > 0.5) {
                $('#matchID').textContent = `Matched: ${best.id} (${(best.conf*100).toFixed(0)}%)`;
            } else {
                $('#matchID').textContent = 'No Match';
            }
        } else {
            $('#matchID').textContent = '';
        }
        // Hide scan overlay when face detected
        $('#scanText').style.display = 'none';
        $('#scannerBar').style.display = 'none';
    } else {
        // Show scan overlay when no face
        $('#scanText').style.display = 'block';
        $('#scannerBar').style.display = 'block';
    }
    // Copy to PIP canvas
    const pipCtx = $('#pipCanvas').getContext('2d');
    pipCtx.drawImage(canvas, 0, 0, 120, 90);
    updateStatusPanel();
}
    // Add function for onObjectDetectionResults
    function onObjectDetectionResults(results) {
        if (results.detections) {
            results.detections.forEach(detection => {
                if (detection.categories[0].score > 0.5) {
                    addDetectedObject(detection, detection.categories[0].categoryName);
                }
            });
        }
    }
    function addDetectedObject(detection, className) {
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * 5 + 2;
        const pos = new THREE.Vector3(
            user.x + Math.sin(angle) * distance,
            user.y + (Math.random() * 2),
            user.z + Math.cos(angle) * distance
        );
        let geometry;
        switch (className) {
            case 'person':
                geometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                break;
            default:
                geometry = new THREE.SphereGeometry(0.2, 8, 6);
        }
        const material = new THREE.MeshBasicMaterial({ color: 0xff00ff, wireframe: true });
        const obj = new THREE.Mesh(geometry, material);
        obj.position.copy(pos);
        obj.userData = { type: 'detected', class: className, distance: distance };
        scene.add(obj);
        objects.push(obj);
        geometryDataSchema.environmentObjects.push({
            class: className,
            type: geometry.type,
            position: { x: pos.x, y: pos.y, z: pos.z },
            parameters: geometry.parameters
        });
        updateStatusPanel();
    }
    // ArUco detection for planar
    function detectArUco(video) {
        let src = cv.fromElement(video);
        let dst = new cv.Mat();
        cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY);
        let dictionary = new cv.Dictionary(cv.DICT_6X6_250);
        let parameters = new cv.DetectorParameters();
        let markerCorners = new cv.MatVector();
        let markerIds = new cv.Mat();
        cv.detectMarkers(dst, dictionary, markerCorners, markerIds, parameters);
        if (markerIds.rows > 0) {
            // Process detected markers
            for (let i = 0; i < markerIds.rows; ++i) {
                // Add to 3D as planar
                addDetectedObject({}, 'planar');
            }
        }
        src.delete(); dst.delete(); markerCorners.delete(); markerIds.delete();
    }
    // For sphere, add color blob detection
    function detectSphere(video) {
        // Simple color threshold for colored sphere
        let src = cv.fromElement(video);
        let hsv = new cv.Mat();
        cv.cvtColor(src, hsv, cv.COLOR_RGB2HSV);
        let low = new cv.Scalar(0, 100, 100); // red example
        let high = new cv.Scalar(10, 255, 255);
        let mask = new cv.Mat();
        cv.inRange(hsv, low, high, mask);
        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        cv.findContours(mask, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
        for (let i = 0; i < contours.size(); ++i) {
            let cnt = contours.get(i);
            let area = cv.contourArea(cnt);
            if (area > 100) {
                // Found blob, add as sphere
                addDetectedObject({}, 'sphere');
                break;
            }
        }
        // Clean up
        src.delete(); hsv.delete(); mask.delete(); contours.delete(); hierarchy.delete();
    }
    function setupEventListeners() {
        // Mirror button
        $('#mirrorBtn').addEventListener('click', () => {
            if ($('#mirrorPopup').style.display === 'block') {
                closeMirror();
            } else {
                openMirror();
                startWebcam();
            }
        });
       
        // Export button
        $('#exportBtn').addEventListener('click', exportGeometryData);
       
        // Clear button
        $('#clearBtn').addEventListener('click', clearData);
       
        // Load Custom button
        $('#loadCustomBtn').addEventListener('click', () => $('#customFileInput').click());
        $('#customFileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    try {
                        customFaces = JSON.parse(ev.target.result);
                        console.log('Loaded ' + customFaces.length + ' custom IDs');
                    } catch (err) {
                        console.error('JSON parse error', err);
                    }
                };
                reader.readAsText(file);
            }
        });
       
        // Mirror close button
        $('.mirror-close').addEventListener('click', closeMirror);
       
        // Scene click area
        $('#sceneClickArea').addEventListener('click', centerView);
       
        // Mirror dragging
        const mirrorHeader = $('.mirror-header');
        const mirrorPopup = $('#mirrorPopup');
       
        mirrorHeader.addEventListener('mousedown', startDrag);
        mirrorHeader.addEventListener('touchstart', startDrag);
       
        function startDrag(e) {
            e.preventDefault();
            mirrorDragging = true;
           
            const rect = mirrorPopup.getBoundingClientRect();
            if (e.type === 'mousedown') {
                mirrorOffset.x = e.clientX - rect.left;
                mirrorOffset.y = e.clientY - rect.top;
            } else if (e.type === 'touchstart') {
                mirrorOffset.x = e.touches[0].clientX - rect.left;
                mirrorOffset.y = e.touches[0].clientY - rect.top;
            }
           
            document.addEventListener('mousemove', dragMirror);
            document.addEventListener('touchmove', dragMirror);
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchend', stopDrag);
        }
       
        function dragMirror(e) {
            if (!mirrorDragging) return;
            e.preventDefault();
           
            let clientX, clientY;
            if (e.type === 'mousemove') {
                clientX = e.clientX;
                clientY = e.clientY;
            } else if (e.type === 'touchmove') {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            }
           
            mirrorPopup.style.left = (clientX - mirrorOffset.x) + 'px';
            mirrorPopup.style.top = (clientY - mirrorOffset.y) + 'px';
            mirrorPopup.style.transform = 'none';
        }
       
        function stopDrag() {
            mirrorDragging = false;
            document.removeEventListener('mousemove', dragMirror);
            document.removeEventListener('touchmove', dragMirror);
            document.removeEventListener('mouseup', stopDrag);
            document.removeEventListener('touchend', stopDrag);
        }
       
        // Window resize
        window.addEventListener('resize', () => {
            cam.aspect = window.innerWidth / window.innerHeight;
            cam.updateProjectionMatrix();
            ren.setSize(window.innerWidth, window.innerHeight);
        }, { passive: true });
       
        // Cleanup
        window.addEventListener('beforeunload', cleanup);
       
        console.log("Event listeners setup complete");
    }
    function openMirror() {
        $('#mirrorPopup').style.display = 'block';
        $('#scanText').style.display = 'block';
        $('#scannerBar').style.display = 'block';
    }
    function closeMirror() {
        $('#mirrorPopup').style.display = 'none';
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            stream = null;
        }
        if (camera) camera.stop();
    }
    function exportGeometryData() {
        geometryDataSchema.timestamp = new Date().toISOString();
        geometryDataSchema.camera.position = { x: cam.position.x, y: cam.position.y, z: cam.position.z };
        geometryDataSchema.camera.rotation = { x: cam.rotation.x, y: cam.rotation.y, z: cam.rotation.z };
        const blob = new Blob([JSON.stringify(geometryDataSchema, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'geometry_data.json';
        a.click();
        URL.revokeObjectURL(url);
        if (objects.length === 0) $('#hudWarning').style.display = 'block';
        else $('#hudWarning').style.display = 'none';
    }
    function clearData() {
        objects.forEach(obj => scene.remove(obj));
        objects = [];
        geometryDataSchema.environmentObjects = [];
        geometryDataSchema.faceGeometry.landmarks = [];
        if (facePoints) scene.remove(facePoints);
        if (faceLines) scene.remove(faceLines);
        updateStatusPanel();
    }
    function centerView() {
        cam.position.set(0, 1, cameraDistance);
        cam.lookAt(user);
    }
    function setupServiceWorker() {
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./sw.js').then(() => console.log('SW registered')).catch(e => console.error('SW error', e));
        }
    }
    function updateStatusPanel() {
        $('#objectCount').textContent = objects.length;
        $('#faceCount').textContent = userDetected ? 1 : 0;
        $('#dataPointCount').textContent = geometryDataSchema.faceGeometry.landmarks.length;
    }
    function autoStartMirror() {
        // Optionally auto open on load
        // openMirror();
        // startWebcam();
    }
    function cleanup() {
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
        }
        if (animationId) cancelAnimationFrame(animationId);
    }
    function startWebcam() {
        if (stream) {
            return;
        }
       
        const status = $('#calibStatus');
        status.textContent = 'INITIALIZING CAMERA...';
       
        try {
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            isFrontCam = isMobile;
           
            navigator.mediaDevices.getUserMedia({
                video: {
                    facingMode: isFrontCam ? 'user' : 'environment',
                    width: { ideal: 640 },
                    height: { ideal: 480 }
                }
            })
            .then(s => {
                stream = s;
               
                const video = document.createElement('video');
                video.id = 'webcamVideo';
                video.srcObject = stream;
                video.autoplay = true;
                video.playsInline = true;
                video.style.display = 'none';
                document.body.appendChild(video);
               
                camera = new Camera(video, {
                    onFrame: async () => {
                        await faceMesh.send({ image: video });
                        const detections = await objectDetector.detect(video);
                        onObjectDetectionResults({detections});
                        detectArUco(video);
                        detectSphere(video);
                        if (alva) {
    const canvas = document.createElement('canvas');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(video, 0, 0);
    const frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
    
    const cameraPose = alva.findCameraPose(frame); // Update cam with pose
    if (cameraPose) {
        const rotation = new THREE.Matrix4().fromArray(cameraPose.rotation).transpose();
        cam.quaternion.setFromRotationMatrix(rotation);
        cam.position.fromArray(cameraPose.translation);
    }
    
    const planePose = alva.findPlane();
    if (planePose) {
        // Add hero plane mesh
        const planeGeo = new THREE.PlaneGeometry(2, 2);
        const planeMat = new THREE.MeshBasicMaterial({color: 0x00ff00, wireframe: true});
        const heroPlane = new THREE.Mesh(planeGeo, planeMat);
        heroPlane.position.fromArray(planePose.position);
        heroPlane.quaternion.fromArray(planePose.quaternion);
        scene.add(heroPlane);
        objects.push(heroPlane);
    }
    
    const points = alva.getFramePoints();
    if (points.length) {
        // Add hero point cloud
        const pointGeo = new THREE.BufferGeometry();
        const posArr = new Float32Array(points.length * 3);
        points.forEach((p, i) => {
            posArr[i*3] = p.x;
            posArr[i*3+1] = p.y;
            posArr[i*3+2] = p.z;
        });
        pointGeo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
        const pointMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.05});
        const heroPoints = new THREE.Points(pointGeo, pointMat);
        scene.add(heroPoints);
        objects.push(heroPoints);
    }
}
                    },
                    width: 640,
                    height: 480
                });
               
                camera.start();
               
                const canvas = $('#webcamCanvas');
                canvas.width = 300;
                canvas.height = 200;
               
                status.textContent = 'READY FOR 3D CAPTURE';
               
                console.log("Webcam started successfully");
            })
            .catch(error => {
                console.error('Webcam error:', error);
               
                let errorMessage = 'CAMERA ACCESS DENIED';
                if (error.name === 'NotAllowedError') {
                    errorMessage = 'CAMERA ACCESS DENIED BY USER';
                } else if (error.name === 'NotFoundError') {
                    errorMessage = 'NO CAMERA FOUND';
                } else if (error.name === 'NotSupportedError') {
                    errorMessage = 'CAMERA NOT SUPPORTED';
                }
               
                status.textContent = errorMessage;
                stream = null;
            });
           
        } catch (error) {
            console.error('Webcam setup error:', error);
            status.textContent = 'WEBCAM SETUP FAILED';
        }
    }
    function animate() {
        animationId = requestAnimationFrame(animate);
        const deltaTime = clock.getDelta();
       
        // Update user arrow direction
        if (userObj && userObj.children.length > 0) {
            const arrow = userObj.children[0];
            arrow.rotation.y = -faceDirection * Math.PI / 180;
        }
       
        // Animate objects
        objects.forEach((obj, index) => {
            obj.rotation.y += deltaTime * 0.5;
           
            // Add subtle floating animation
            obj.position.y += Math.sin(Date.now() * 0.001 + index) * 0.005;
        });
       
        // Render scene
        ren.render(scene, cam);
        if (facePoints) {
    facePoints.material.uniforms.time.value = clock.getElapsedTime();
}
    }
    window.addEventListener('load', init);
</script>
</body>
</html>
