<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>webXOS: GLITCH RUNNER</title>
    
    <!-- Load Three.js first -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Load font with fallback -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
        }
        
        /* Apply Press Start 2P when loaded */
        .font-loaded * {
            font-family: 'Press Start 2P', 'Courier New', monospace;
        }
        
        body {
            background: #000;
            color: #0f0;
            overflow: hidden;
            height: 100vh;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }
        
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        /* Menu Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            background: #000;
            color: #0f0;
            text-align: center;
        }
        
        #endGameScreen {
            display: none;
            z-index: 200;
            background: rgba(0, 0, 0, 0.9);
        }
        
        .end-game-stats {
            background: rgba(0, 20, 0, 0.8);
            border: 3px solid #0f0;
            padding: 30px;
            border-radius: 10px;
            max-width: 600px;
            width: 90%;
        }
        
        .end-game-title {
            font-size: 28px;
            color: #0f0;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #0f0;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-size: 14px;
            color: #0f0;
        }
        
        .stat-label {
            text-align: left;
        }
        
        .stat-value {
            text-align: right;
            color: #ff0;
        }
        
        .final-score {
            font-size: 24px;
            color: #ff0;
            margin: 20px 0;
            text-shadow: 0 0 10px #ff0;
        }
        
        /* Typewriter effect for end screen */
        .typewriter {
            overflow: hidden;
            border-right: 2px solid #0f0;
            white-space: nowrap;
            animation: typing 3s steps(40, end), blink-caret 0.75s step-end infinite;
        }
        
        @keyframes typing {
            from { width: 0 }
            to { width: 100% }
        }
        
        @keyframes blink-caret {
            from, to { border-color: transparent }
            50% { border-color: #0f0 }
        }
        
        #neurotIntro {
            background: #000;
        }
        
        #bootSequence {
            background: #000;
        }
        
        #storyScroll {
            background: #000;
            overflow: hidden;
            perspective: 400px;
        }
        
        #mainMenu {
            background: #000;
        }
        
        /* Skip Button */
        .skip-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 8px 16px;
            background: #000;
            border: 2px solid #0f0;
            color: #0f0;
            font-size: 12px;
            cursor: pointer;
            z-index: 101;
        }
        
        .skip-btn:hover {
            background: #0f0;
            color: #000;
        }
        
        /* NEUROT Intro */
        .neurot-title {
            font-size: 60px;
            color: #fff;
            text-shadow: 0 0 10px #fff, 0 0 20px #fff;
            margin-bottom: 20px;
            animation: glow 2s infinite alternate;
        }
        
        .neurot-subtitle {
            font-size: 18px;
            color: #0f0;
            margin-bottom: 10px;
        }
        
        .neurot-copyright {
            font-size: 12px;
            color: #0f0;
            position: absolute;
            bottom: 60px;
        }
        
        /* Boot Sequence */
        .boot-title {
            font-size: 48px;
            color: #0f0;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #0f0;
        }
        
        .boot-subtitle {
            font-size: 24px;
            color: #f00;
            margin-bottom: 30px;
            text-shadow: 0 0 10px #f00;
        }
        
        .boot-progress {
            width: 400px;
            height: 20px;
            background: #000;
            border: 2px solid #0f0;
            margin: 20px 0;
            overflow: hidden;
        }
        
        .boot-progress-fill {
            height: 100%;
            background: #0f0;
            width: 0%;
            transition: width 0.5s;
        }
        
        .boot-text {
            font-size: 14px;
            color: #0f0;
            margin-top: 20px;
            height: 20px;
        }
        
        /* Story Scroll */
        .story-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: rotateX(30deg) translateY(100%);
            animation: scroll 60s linear forwards;
        }
        
        .story-content {
            width: 80%;
            max-width: 800px;
            margin: 0 auto;
            color: #ff0;
            font-size: 24px;
            line-height: 1.5;
            text-align: justify;
        }
        
        .story-title {
            font-size: 36px;
            text-align: center;
            margin-bottom: 40px;
            color: #0f0;
        }
        
        /* Main Menu */
        .menu-title {
            position: relative;
            font-size: 36px;
            color: #0f0;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #0f0;
        }
        
        .glitch {
            position: relative;
        }
        
        .glitch::before,
        .glitch::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .glitch::before {
            color: #ff00ff;
            left: 2px;
            text-shadow: -2px 0 #ff00ff;
            clip-path: rect(0, 9999px, 50px, 0);
            animation: glitch-1 3s infinite linear alternate-reverse;
        }
        
        .glitch::after {
            color: #00ffff;
            left: -2px;
            text-shadow: 2px 0 #00ffff;
            clip-path: rect(50px, 9999px, 9999px, 0);
            animation: glitch-2 2s infinite linear alternate-reverse;
        }
        
        @keyframes glitch-1 {
            0%,100% { clip-path: rect(0,9999px,50px,0); }
            20% { clip-path: rect(20px,9999px,80px,0); }
            40% { clip-path: rect(10px,9999px,40px,0); }
            60% { clip-path: rect(60px,9999px,90px,0); }
            80% { clip-path: rect(30px,9999px,70px,0); }
        }
        
        @keyframes glitch-2 {
            0%,100% { clip-path: rect(50px,9999px,9999px,0); }
            15% { clip-path: rect(70px,9999px,9999px,0); }
            35% { clip-path: rect(40px,9999px,9999px,0); }
            55% { clip-path: rect(90px,9999px,9999px,0); }
            75% { clip-path: rect(55px,9999px,9999px,0); }
        }
        
        .menu-subtitle {
            font-size: 18px;
            color: #f00;
            margin-bottom: 5px;
        }
        
        .menu-version {
            font-size: 14px;
            color: #0f0;
            margin-bottom: 40px;
        }
        
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .menu-btn {
            padding: 12px 24px;
            background: #000;
            border: 2px solid #0f0;
            color: #0f0;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .menu-btn:hover {
            background: #0f0;
            color: #000;
        }
        
        /* Class Selection */
        .class-selection {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            margin-top: 20px;
        }
        
        .class-title {
            font-size: 24px;
            color: #0f0;
            margin-bottom: 10px;
        }
        
        .class-options {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .class-option {
            width: 200px;
            padding: 15px;
            background: rgba(0, 20, 0, 0.5);
            border: 2px solid #0f0;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .class-option:hover {
            background: rgba(0, 255, 0, 0.2);
            border-color: #ff0;
        }
        
        .class-option.selected {
            background: rgba(0, 255, 0, 0.3);
            border-color: #ff0;
            box-shadow: 0 0 15px #ff0;
        }
        
        .class-name {
            font-size: 16px;
            color: #0f0;
            margin-bottom: 10px;
        }
        
        .class-description {
            font-size: 12px;
            color: #0f0;
            line-height: 1.4;
        }
        
        /* HUD Elements */
        .hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }
        
        .fps-counter {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 12px;
            color: #0f0;
            background: rgba(0, 0, 0, 0.8);
            padding: 3px 6px;
            border: 1px solid #0f0;
        }
        
        .health-container {
            position: absolute;
            top: 5px;
            left: 5px;
            width: 150px;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px;
            border: 1px solid #0f0;
        }
        
        .health-label {
            font-size: 12px;
            margin-bottom: 3px;
            color: #0f0;
        }
        
        .health-bar {
            width: 100%;
            height: 12px;
            background: rgba(0, 20, 0, 0.7);
            border: 1px solid #0f0;
            position: relative;
            overflow: hidden;
        }
        
        .health-fill {
            height: 100%;
            background: #0f0;
            width: 100%;
        }
        
        .health-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: #000;
            font-weight: bold;
        }
        
        .bandwidth-container {
            position: absolute;
            top: 60px;
            left: 5px;
            width: 150px;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px;
            border: 1px solid #0f0;
        }
        
        .bandwidth-label {
            font-size: 12px;
            margin-bottom: 3px;
            color: #0f0;
        }
        
        .bandwidth-bar {
            width: 100%;
            height: 12px;
            background: rgba(20, 20, 0, 0.7);
            border: 1px solid #0f0;
            position: relative;
            overflow: hidden;
        }
        
        .bandwidth-fill {
            height: 100%;
            background: #ff0;
            width: 100%;
        }
        
        .bandwidth-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: #000;
            font-weight: bold;
        }
        
        .ammo-container {
            position: absolute;
            bottom: 5px;
            right: 5px;
            text-align: right;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px;
            border: 1px solid #0f0;
        }
        
        .ammo-count {
            font-size: 14px;
            margin-bottom: 2px;
            color: #0f0;
        }
        
        .weapon-name {
            font-size: 12px;
            opacity: 0.9;
            color: #0f0;
        }
        
        .enemy-counter {
            position: absolute;
            top: 40px;
            right: 5px;
            font-size: 12px;
            color: #0f0;
            background: rgba(0, 0, 0, 0.8);
            padding: 3px 6px;
            border: 1px solid #0f0;
        }
        
        .ability-container {
            position: absolute;
            bottom: 40px;
            left: 5px;
            width: 150px;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px;
            border: 1px solid #0f0;
        }
        
        .ability-label {
            font-size: 12px;
            margin-bottom: 3px;
            color: #0f0;
        }
        
        .ability-bar {
            width: 100%;
            height: 12px;
            background: rgba(20, 0, 0, 0.7);
            border: 1px solid #0f0;
            position: relative;
            overflow: hidden;
        }
        
        .ability-fill {
            height: 100%;
            background: #0f0;
            width: 0%;
            transition: width 0.3s;
        }
        
        .ability-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: #fff;
            font-weight: bold;
        }
        
        .zone-progress-container {
            position: absolute;
            top: 120px;
            left: 5px;
            font-size: 12px;
            color: #0f0;
            background: rgba(0, 0, 0, 0.8);
            padding: 3px 6px;
            border: 1px solid #0f0;
        }
        
        .mission-info {
            position: absolute;
            top: 40px;
            left: 5px;
            font-size: 12px;
            color: #0f0;
            background: rgba(0, 0, 0, 0.8);
            padding: 3px 6px;
            border: 1px solid #0f0;
        }
        
        .level-info {
            position: absolute;
            top: 80px;
            left: 5px;
            font-size: 12px;
            color: #0f0;
            background: rgba(0, 0, 0, 0.8);
            padding: 3px 6px;
            border: 1px solid #0f0;
        }
        
        .save-load-container {
            position: absolute;
            bottom: 5px;
            left: 5px;
            font-size: 12px;
            color: #0f0;
            background: rgba(0, 0, 0, 0.8);
            padding: 3px 6px;
            border: 1px solid #0f0;
        }
        
        /* Timer positioning at center top */
        .timer-container {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            z-index: 10;
        }
        
        .buzzer-timer {
            font-size: 20px;
            color: #f00;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 16px;
            border: 3px solid #f00;
            border-radius: 10px;
            text-shadow: 0 0 10px #f00;
            font-weight: bold;
        }
        
        .countdown-timer {
            font-size: 24px;
            color: #ff0;
            text-shadow: 0 0 10px #ff0;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px 10px;
            border-radius: 5px;
        }
        
        .portal-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border: 2px solid #0ff;
            border-radius: 10px;
            z-index: 10;
            display: none;
            animation: portalGlow 2s infinite;
        }
        
        .laser-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 0, 0, 0.2);
            z-index: 3;
            pointer-events: none;
            display: none;
        }
        
        /* Crosshair HUD */
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            pointer-events: none;
            z-index: 5;
        }
        
        .crosshair-dot {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: #0f0;
            border-radius: 50%;
            box-shadow: 0 0 10px #0f0;
        }
        
        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: #0f0;
            box-shadow: 0 0 5px #0f0;
        }
        
        .crosshair::before {
            top: 50%;
            left: 0;
            width: 100%;
            height: 1px;
            transform: translateY(-50%);
        }
        
        .crosshair::after {
            left: 50%;
            top: 0;
            height: 100%;
            width: 1px;
            transform: translateX(-50%);
        }
        
        .crosshair.targeting {
            border: 1px solid #0f0;
            box-shadow: 0 0 15px #0f0;
        }
        
        .crosshair.targeting .crosshair-dot {
            background: #f00;
            box-shadow: 0 0 10px #f00;
        }
        
        /* Enemy Health Bars */
        .enemy-health-bar-overhead {
            position: absolute;
            width: 100px;
            height: 8px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #f00;
            z-index: 5;
            display: none;
        }
        
        .enemy-health-fill-overhead {
            height: 100%;
            background: #f00;
            width: 100%;
        }
        
        /* Animations */
        @keyframes glow {
            from { text-shadow: 0 0 10px #fff, 0 0 20px #fff; }
            to { text-shadow: 0 0 20px #fff, 0 0 30px #fff, 0 0 40px #fff; }
        }
        
        @keyframes scroll {
            0% { transform: rotateX(30deg) translateY(100%); }
            100% { transform: rotateX(30deg) translateY(-300%); }
        }
        
        @keyframes laserPulse {
            0% { opacity: 0.2; }
            50% { opacity: 0.4; }
            100% { opacity: 0.2; }
        }
        
        @keyframes portalGlow {
            0% { opacity: 0.5; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            100% { opacity: 0.5; transform: translate(-50%, -50%) scale(1); }
        }
        
        /* Mobile Controls */
        #mobileControls {
            position: absolute;
            bottom: 10px;
            left: 0;
            width: 100%;
            display: none;
            z-index: 10;
        }
        
        .mobile-controls-row {
            display: flex;
            justify-content: space-between;
            padding: 0 10px;
            margin-bottom: 10px;
        }
        
        .mobile-btn {
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #0f0;
            color: #0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            border-radius: 50%;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        .mobile-joystick {
            width: 80px;
            height: 80px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #0f0;
            border-radius: 50%;
            position: relative;
            touch-action: none;
        }
        
        .mobile-joystick-handle {
            width: 40px;
            height: 40px;
            background: rgba(0, 255, 0, 0.5);
            border-radius: 50%;
            position: absolute;
            top: 20px;
            left: 20px;
        }
        
        @media (max-width: 768px) {
            #mobileControls {
                display: block;
            }
            
            /* Reduce animation complexity on mobile */
            .glitch::before,
            .glitch::after {
                animation: none;
            }
        }

        /* Champion Emblem */
        .champion-emblem {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: #ff0;
            text-shadow: 0 0 20px #ff0;
            z-index: 15;
            display: none;
            animation: glow 2s infinite alternate;
        }
        
        /* Shield Effect */
        .shield-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 3px solid #0f0;
            box-shadow: 0 0 20px #0f0;
            z-index: 5;
            display: none;
            pointer-events: none;
        }
        
        /* Laser Scope Overlay */
        .laser-scope {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            border: 2px solid #f00;
            border-radius: 50%;
            box-shadow: 0 0 20px #f00;
            z-index: 4;
            display: none;
            pointer-events: none;
        }
        
        .laser-scope::before,
        .laser-scope::after {
            content: '';
            position: absolute;
            background: #f00;
        }
        
        .laser-scope::before {
            top: 50%;
            left: 0;
            width: 100%;
            height: 1px;
            transform: translateY(-50%);
        }
        
        .laser-scope::after {
            left: 50%;
            top: 0;
            height: 100%;
            width: 1px;
            transform: translateX(-50%);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Menu Screens -->
        <div id="neurotIntro" class="screen">
            <div class="neurot-title">GLITCH RUNNER ENGINE</div>
            <div class="neurot-subtitle">DEMOSCENE</div>
            <div class="neurot-copyright">Â© 2025 webXOS</div>
            <button class="skip-btn" id="skipIntro" style="display: none;">SKIP INTRO</button>
        </div>
        
        <div id="bootSequence" class="screen" style="display: none;">
            <div class="boot-title">GLITCH RUNNER</div>
            <div class="boot-subtitle">DEMO</div>
            <div class="boot-progress">
                <div class="boot-progress-fill" id="bootProgress"></div>
            </div>
            <div class="boot-text" id="bootText">LOADING DEMOSCENE...</div>
        </div>
        
        <div id="storyScroll" class="screen" style="display: none;">
            <div class="story-container">
                <div class="story-content">
                    <div class="story-title">GLITCH RUNNER</div>
                    <p>This is a three js based game engine that runs in one html page...</p>
                    <p>If you load this demoscene into a LLM, this engine can be used to make other custom games.</p>
                    <p>This is a micro game, you must traverse the wireframe cityscape.</p>
                    <p>Hack the corrupted nodes. Purge the viral entities. Restore balance to the grid.</p>
                    <p>Your mission: Test the games core and confront the final boss.</p>
                    <p>webXOS 2025</p>
                </div>
            </div>
            <button class="skip-btn" id="skipStory" style="display: none;">SKIP STORY</button>
        </div>
        
        <div id="mainMenu" class="screen" style="display: none;">
            <div class="menu-title glitch" data-text="PROJECT NEUROT">DEMOSCENE</div>
            <div class="menu-subtitle">GLITCH RUNNER ENGINE</div>
            <div class="menu-version">webXOS Games 2025</div>
            <div class="menu-buttons">
                <button class="menu-btn" id="startBtn">START RUN</button>
                <button class="menu-btn" id="loadBtn">LOAD CHARACTER</button>
                <button class="menu-btn" id="settingsBtn">SETTINGS</button>
            </div>
            
            <!-- Class Selection -->
            <div class="class-selection" id="classSelection">
                <div class="class-title">SELECT YOUR CLASS</div>
                <div class="class-options">
                    <div class="class-option" data-class="glitch">
                        <div class="class-name">THE GLITCH</div>
                        <div class="class-description">Focuses on disruption. Create mist clouds for stealth and fire unstable neurot projectiles that debuff enemies.</div>
                    </div>
                    <div class="class-option" data-class="architect">
                        <div class="class-name">THE ARCHITECT</div>
                        <div class="class-description">Focuses on control. Solidify wireframe structures for cover and deploy mist to obscure enemy vision.</div>
                    </div>
                    <div class="class-option" data-class="vector">
                        <div class="class-name">THE VECTOR</div>
                        <div class="class-description">Focuses on offense. High-velocity neurot projectiles cause massive damage and create explosive shrapnel.</div>
                    </div>
                </div>
                <button class="menu-btn" id="confirmClassBtn" style="display: none;">CONFIRM CLASS</button>
            </div>
        </div>
        
        <!-- End Game Screen -->
        <div id="endGameScreen" class="screen">
            <div class="end-game-stats">
                <div class="end-game-title typewriter" id="endGameTitle">DEMOSCENE COMPLETE</div>
                <div class="stat-row">
                    <div class="stat-label">TIME ELAPSED:</div>
                    <div class="stat-value" id="endTime">00:00</div>
                </div>
                <div class="stat-row">
                    <div class="stat-label">ENEMIES PURGED:</div>
                    <div class="stat-value" id="endEnemies">0</div>
                </div>
                <div class="stat-row">
                    <div class="stat-label">DAMAGE TAKEN:</div>
                    <div class="stat-value" id="endDamage">0</div>
                </div>
                <div class="stat-row">
                    <div class="stat-label">ACCURACY:</div>
                    <div class="stat-value" id="endAccuracy">0%</div>
                </div>
                <div class="stat-row">
                    <div class="stat-label">DATA PACKS COLLECTED:</div>
                    <div class="stat-value" id="endDataPacks">0</div>
                </div>
                <div class="final-score typewriter" id="finalScore">SCORE: 0</div>
                <div class="menu-buttons">
                    <button class="menu-btn" id="restartBtn">NEW RUN</button>
                    <button class="menu-btn" id="menuBtn">MAIN MENU</button>
                </div>
            </div>
        </div>
        
        <!-- Game Canvas -->
        <canvas id="gameCanvas">
            Your browser does not support the HTML5 canvas element.
            Please try using a modern browser like Chrome, Firefox, or Edge.
        </canvas>
        
        <!-- HUD Elements -->
        <div class="hud">
            <div class="fps-counter" id="fpsCounter">FPS: 60</div>
            
            <div class="health-container">
                <div class="health-label">RUNNER INTEGRITY</div>
                <div class="health-bar">
                    <div class="health-fill" id="healthFill"></div>
                    <div class="health-text">HEALTH: <span id="healthPercent">100%</span></div>
                </div>
            </div>
            
            <div class="bandwidth-container">
                <div class="bandwidth-label">BANDWIDTH</div>
                <div class="bandwidth-bar">
                    <div class="bandwidth-fill" id="bandwidthFill"></div>
                    <div class="bandwidth-text">BANDWIDTH: <span id="bandwidthPercent">100%</span></div>
                </div>
            </div>
            
            <div class="ammo-container">
                <div class="ammo-count" id="ammoCount">NEUROT: 100%</div>
                <div class="weapon-name" id="weaponName">NEUROT PULSE</div>
            </div>
            
            <div class="enemy-counter">
                ZONE: <span id="zoneCount">1</span>/4
            </div>
            
            <div class="ability-container" id="abilityContainer">
                <div class="ability-label" id="abilityLabel">CLASS ABILITY</div>
                <div class="ability-bar">
                    <div class="ability-fill" id="abilityFill"></div>
                    <div class="ability-text">COOLDOWN: <span id="abilityPercent">0%</span></div>
                </div>
            </div>
            
            <div class="zone-progress-container">
                NODES CLEARED: <span id="zoneProgress">0</span>/<span id="zoneTotal">3</span>
            </div>
            
            <div class="mission-info">
                MISSION: <span id="missionName">PURGE CORRUPTED NODES</span>
            </div>
            
            <div class="level-info">
                LEVEL: <span id="playerLevel">1</span> | EXP: <span id="playerExp">0</span>/<span id="nextLevelExp">100</span>
            </div>
            
            <div class="save-load-container">
                SAVE/LOAD [O/L]
            </div>
            
            <!-- Timer Container at Center Top -->
            <div class="timer-container">
                <div class="buzzer-timer" id="buzzerTimer">
                    00:00
                </div>
                <div class="countdown-timer" id="countdownTimer" style="display: none;">
                    III
                </div>
            </div>
            
            <div class="portal-notification" id="portalNotification">
                DATA PORTAL ACTIVATED! ENTER TO PROCEED
            </div>
            
            <div class="crosshair" id="crosshair">
                <div class="crosshair-dot"></div>
            </div>
            
            <div class="laser-overlay" id="laserOverlay"></div>
            
            <!-- New HUD Elements -->
            <div class="champion-emblem" id="championEmblem">CHAMPION</div>
            <div class="shield-effect" id="shieldEffect"></div>
            <div class="laser-scope" id="laserScope"></div>
        </div>
        
        <!-- Enemy Health Bars Container -->
        <div id="enemyHealthBars"></div>
        
        <!-- Mobile Controls -->
        <div id="mobileControls">
            <div class="mobile-controls-row">
                <div class="mobile-joystick" id="moveJoystick">
                    <div class="mobile-joystick-handle"></div>
                </div>
                <div class="mobile-btn" id="jumpBtn">JUMP</div>
                <div class="mobile-btn" id="dashBtn">DASH</div>
            </div>
            <div class="mobile-controls-row">
                <div class="mobile-btn" id="firePrimaryBtn">PRIMARY</div>
                <div class="mobile-btn" id="fireSecondaryBtn">SECONDARY</div>
                <div class="mobile-btn" id="abilityBtn">ABILITY</div>
                <div class="mobile-btn" id="cpuBtn">CPU</div>
            </div>
        </div>
    </div>

    <script>
        // ============================
        // GAME STATE AND VARIABLES
        // ============================
        
        // Game State
        const GameState = {
            MENU: 0,
            PLAYING: 1,
            GAME_OVER: 2,
            LOADING: 3,
            ZONE_TRANSITION: 4,
            COUNTDOWN: 5,
            CINEMATIC: 6,
            END_GAME: 7
        };
        
        let currentState = GameState.LOADING;
        let mouseSensitivity = 0.002;
        let pointerLocked = false;
        let immortalMode = true; // Set to true for testing
        let cpuMode = false;

        // Three.js variables
        let scene, camera, renderer;
        let player, enemies = [], projectiles = [], particles = [];
        let buildings = [], gridFloor = null, portal = null, dataPacks = [];
        let clock = new THREE.Clock();
        let gameStartTime = 0;
        let gameTimer = 0;
        let runTime = 0;
        let timerInterval;
        let frameCount = 0;
        let lastFpsUpdate = 0;
        let fps = 60;
        let animationFrameId;
        
        // Player class variables
        let playerClass = null;
        const playerClasses = {
            GLITCH: {
                name: "The Glitch",
                primaryColor: 0xff00ff,
                secondaryColor: 0x00ffff,
                health: 100,
                speed: 15,
                jumpHeight: 12,
                primaryDamage: 25,
                secondaryDamage: 40,
                abilityCooldown: 10,
                abilityDuration: 5,
                description: "Disruption specialist with stealth capabilities"
            },
            ARCHITECT: {
                name: "The Architect",
                primaryColor: 0x00ff00,
                secondaryColor: 0x0000ff,
                health: 120,
                speed: 12,
                jumpHeight: 10,
                primaryDamage: 20,
                secondaryDamage: 35,
                abilityCooldown: 8,
                abilityDuration: 6,
                description: "Control specialist with defensive capabilities"
            },
            VECTOR: {
                name: "The Vector",
                primaryColor: 0xff0000,
                secondaryColor: 0xffff00,
                health: 90,
                speed: 18,
                jumpHeight: 14,
                primaryDamage: 30,
                secondaryDamage: 50,
                abilityCooldown: 12,
                abilityDuration: 4,
                description: "Offense specialist with high damage output"
            }
        };
        
        // Neurot weapon variables
        let neurotWeapon = null;
        let neurotCharge = 100;
        let maxNeurotCharge = 100;
        let neurotRechargeRate = 20;
        let neurotOverloaded = false;
        
        // Ability variables
        let abilityCooldown = 0;
        let abilityActive = false;
        let abilityTime = 0;
        
        // Bandwidth resource
        let bandwidth = 100;
        let maxBandwidth = 100;
        let bandwidthRegenRate = 15;
        
        // Leveling system
        let playerLevel = 1;
        let playerExp = 0;
        let nextLevelExp = 100;
        
        // Level progression bonuses
        let speedBoostMultiplier = 1.5;
        let doubleJumpUnlocked = false;
        let wallRunUnlocked = false;
        let damageBoost = 1;
        let bandwidthBoost = 1;
        
        // Timer variables
        let buzzerTimer = 0;
        let countdownTimer = 10;
        let countdownActive = false;
        let countdownInterval = null;
        let romanNumerals = ['X', 'IX', 'VIII', 'VII', 'VI', 'V', 'IV', 'III', 'II', 'I'];
        
        // Portal variables
        let portalActive = false;
        let portalSpawned = false;
        let portalTriggerTime = 0;
        
        // Data pack variables
        let dataPacksCollected = 0;
        let totalDataPacks = 0;
        
        // Game stats for end screen
        let gameStats = {
            score: 0,
            currentZone: 1,
            totalZones: 4,
            playerHealth: 100,
            maxPlayerHealth: 100,
            playerSpeed: 12,
            playerDamage: 25,
            bandwidth: 100,
            maxBandwidth: 100,
            damageTaken: 0,
            enemiesPurged: 0,
            nodesCleared: 0,
            totalNodes: 3,
            enemyCount: 0,
            shotsFired: 0,
            shotsHit: 0,
            dataPacksCollected: 0
        };
        
        // Save system
        let saveData = {
            playerLevel: 1,
            playerExp: 0,
            nextLevelExp: 100,
            playerClass: null,
            dataPacksCollected: 0,
            gameStats: {}
        };
        
        // Enemy AI System
        const enemyTypes = {
            CORRUPTED_NODE: {
                name: "CORRUPTED NODE",
                color: 0xff0000,
                health: 500,
                damage: 10,
                speed: 5,
                size: 3.0,
                behavior: "stationary",
                xpReward: 50,
                fireRate: 1000,
                description: "Stationary defense node that fires neurot projectiles"
            },
            VIRAL_ENTITY: {
                name: "VIRAL ENTITY",
                color: 0xff00ff,
                health: 300,
                damage: 15,
                speed: 8,
                size: 2.0,
                behavior: "patrol",
                xpReward: 75,
                fireRate: 800,
                description: "Mobile entity that patrols areas and attacks on sight"
            },
            DATA_HUNTER: {
                name: "DATA HUNTER",
                color: 0x00ffff,
                health: 400,
                damage: 20,
                speed: 10,
                size: 2.5,
                behavior: "hunter",
                xpReward: 100,
                fireRate: 600,
                description: "Aggressive hunter that actively seeks out the player"
            },
            ARCHITECT_GUARDIAN: {
                name: "ARCHITECT GUARDIAN",
                color: 0xffff00,
                health: 2000,
                damage: 30,
                speed: 6,
                size: 5.0,
                behavior: "boss",
                xpReward: 500,
                fireRate: 500,
                description: "Powerful guardian protecting the central core"
            }
        };

        // Controls
        const controls = {
            moveForward: false,
            moveBackward: false,
            moveLeft: false,
            moveRight: false,
            jump: false,
            dash: false,
            firePrimary: false,
            fireSecondary: false,
            useAbility: false,
            mouseX: 0,
            mouseY: 0
        };

        // ============================
        // EPIC MENU SYSTEM
        // ============================

        // Start the menu sequence
        function startMenuSequence() {
            // Show NEUROT intro
            document.getElementById('neurotIntro').style.display = 'flex';
            
            // Show skip button after 2 seconds
            setTimeout(() => {
                document.getElementById('skipIntro').style.display = 'block';
            }, 2000);
            
            // Auto-advance after 5 seconds
            setTimeout(() => {
                if (document.getElementById('neurotIntro').style.display !== 'none') {
                    showBootSequence();
                }
            }, 5000);
        }

        // Show boot sequence
        function showBootSequence() {
            document.getElementById('neurotIntro').style.display = 'none';
            document.getElementById('bootSequence').style.display = 'flex';
            
            let progress = 0;
            const bootTexts = [
                "LOADING NEURAL INTERFACE...",
                "INITIALIZING NEUROT SYSTEMS...",
                "CALIBRATING PARKOUR MODULE...",
                "SYNCING WIREFRAME RENDER...",
                "SYSTEMS READY. LAUNCHING..."
            ];
            let textIndex = 0;
            
            const bootInterval = setInterval(() => {
                progress += 20;
                document.getElementById('bootProgress').style.width = `${progress}%`;
                
                if (progress % 20 === 0 && textIndex < bootTexts.length) {
                    document.getElementById('bootText').textContent = bootTexts[textIndex];
                    textIndex++;
                }
                
                if (progress >= 100) {
                    clearInterval(bootInterval);
                    setTimeout(() => {
                        showStoryScroll();
                    }, 1000);
                }
            }, 500);
        }

        // Show story scroll
        function showStoryScroll() {
            document.getElementById('bootSequence').style.display = 'none';
            document.getElementById('storyScroll').style.display = 'flex';
            
            // Show skip button after 2 seconds
            setTimeout(() => {
                document.getElementById('skipStory').style.display = 'block';
            }, 2000);
            
            // Auto-advance after 30 seconds
            setTimeout(() => {
                if (document.getElementById('storyScroll').style.display !== 'none') {
                    showMainMenu();
                }
            }, 30000);
        }

        // Show main menu
        function showMainMenu() {
            document.getElementById('storyScroll').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'flex';
            
            // Show class selection if no class is selected
            if (!playerClass) {
                document.getElementById('classSelection').style.display = 'flex';
                
                // Add event listeners to class options
                const classOptions = document.querySelectorAll('.class-option');
                classOptions.forEach(option => {
                    option.addEventListener('click', () => {
                        // Remove selected class from all options
                        classOptions.forEach(opt => opt.classList.remove('selected'));
                        // Add selected class to clicked option
                        option.classList.add('selected');
                        // Show confirm button
                        document.getElementById('confirmClassBtn').style.display = 'block';
                    });
                });
                
                // Add event listener to confirm button
                document.getElementById('confirmClassBtn').addEventListener('click', () => {
                    const selectedOption = document.querySelector('.class-option.selected');
                    if (selectedOption) {
                        playerClass = playerClasses[selectedOption.dataset.class.toUpperCase()];
                        document.getElementById('classSelection').style.display = 'none';
                        document.getElementById('confirmClassBtn').style.display = 'none';
                    }
                });
            }
        }

        // Show end game screen
        function showEndGameScreen() {
            document.getElementById('endGameScreen').style.display = 'flex';
            
            // Calculate stats
            const accuracy = gameStats.shotsFired > 0 ? 
                Math.round((gameStats.shotsHit / gameStats.shotsFired) * 100) : 0;
            
            // Calculate score
            const baseScore = gameStats.enemiesPurged * 100 + gameStats.dataPacksCollected * 500;
            const damagePenalty = gameStats.damageTaken * 5;
            const timeBonus = Math.max(0, 300 - buzzerTimer) * 10;
            const finalScore = Math.max(0, baseScore - damagePenalty + timeBonus);
            
            // Update UI with typewriter effect
            document.getElementById('endTime').textContent = 
                `${Math.floor(buzzerTimer / 60).toString().padStart(2, '0')}:${(buzzerTimer % 60).toString().padStart(2, '0')}`;
            document.getElementById('endEnemies').textContent = gameStats.enemiesPurged;
            document.getElementById('endDamage').textContent = gameStats.damageTaken;
            document.getElementById('endAccuracy').textContent = `${accuracy}%`;
            document.getElementById('endDataPacks').textContent = gameStats.dataPacksCollected;
            document.getElementById('finalScore').textContent = `SCORE: ${finalScore}`;
            
            // Update title based on victory/defeat
            if (gameStats.currentZone > gameStats.totalZones) {
                document.getElementById('endGameTitle').textContent = "MISSION ACCOMPLISHED";
            } else {
                document.getElementById('endGameTitle').textContent = "MISSION FAILED";
            }
            
            currentState = GameState.END_GAME;
        }

        // ============================
        // EPIC GAME INITIALIZATION
        // ============================

        // Initialize the game
        function init() {
            try {
                // Check for WebGL support
                if (!isWebGLAvailable()) {
                    alert("WebGL is not supported in your browser. Please try a modern browser like Chrome, Firefox, or Edge.");
                    return;
                }
                
                // Start the menu sequence
                startMenuSequence();
                
                // Set up Three.js
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000000);
                scene.fog = new THREE.Fog(0x000000, 30, 300);
                
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                
                const canvas = document.getElementById('gameCanvas');
                renderer = new THREE.WebGLRenderer({
                    canvas: canvas,
                    antialias: false,
                    powerPreference: "low-power"
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = false;
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                
                const ambientLight = new THREE.AmbientLight(0x202020);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0x00ff00, 0.6);
                directionalLight.position.set(12, 12, 12);
                scene.add(directionalLight);
                
                setupEventListeners();
                
                // Set up mobile controls if needed
                if (isMobile()) {
                    setupMobileControls();
                }
                
                // Load saved game if available
                loadGame();
                
                animate();
            } catch (error) {
                console.error("Error during game initialization:", error);
                alert("Failed to initialize the game. Please refresh the page.");
            }
        }

        // Check if WebGL is available
        function isWebGLAvailable() {
            try {
                const canvas = document.createElement('canvas');
                return !!(window.WebGLRenderingContext && 
                    (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
            } catch (e) {
                return false;
            }
        }

        // Check if mobile device
        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                   window.innerWidth <= 768;
        }

        // Set up mobile controls
        function setupMobileControls() {
            try {
                const moveJoystick = document.getElementById('moveJoystick');
                const jumpBtn = document.getElementById('jumpBtn');
                const dashBtn = document.getElementById('dashBtn');
                const firePrimaryBtn = document.getElementById('firePrimaryBtn');
                const fireSecondaryBtn = document.getElementById('fireSecondaryBtn');
                const abilityBtn = document.getElementById('abilityBtn');
                const cpuBtn = document.getElementById('cpuBtn');
                
                // Move joystick
                let joystickActive = false;
                let joystickStartX = 0;
                let joystickStartY = 0;
                let joystickHandle = moveJoystick.querySelector('.mobile-joystick-handle');
                
                moveJoystick.addEventListener('touchstart', (e) => {
                    joystickActive = true;
                    const rect = moveJoystick.getBoundingClientRect();
                    joystickStartX = rect.left + rect.width / 2;
                    joystickStartY = rect.top + rect.height / 2;
                    e.preventDefault();
                });
                
                document.addEventListener('touchmove', (e) => {
                    if (!joystickActive) return;
                    
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - joystickStartX;
                    const deltaY = touch.clientY - joystickStartY;
                    
                    // Calculate distance and angle
                    const distance = Math.min(30, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
                    const angle = Math.atan2(deltaY, deltaX);
                    
                    // Update handle position
                    const handleX = Math.cos(angle) * distance;
                    const handleY = Math.sin(angle) * distance;
                    joystickHandle.style.transform = `translate(${handleX}px, ${handleY}px)`;
                    
                    // Update controls based on angle and distance
                    const threshold = 10;
                    controls.moveForward = deltaY < -threshold;
                    controls.moveBackward = deltaY > threshold;
                    controls.moveLeft = deltaX < -threshold;
                    controls.moveRight = deltaX > threshold;
                    
                    e.preventDefault();
                });
                
                document.addEventListener('touchend', (e) => {
                    if (joystickActive) {
                        joystickActive = false;
                        joystickHandle.style.transform = 'translate(0, 0)';
                        controls.moveForward = false;
                        controls.moveBackward = false;
                        controls.moveLeft = false;
                        controls.moveRight = false;
                        e.preventDefault();
                    }
                });
                
                // Button controls
                jumpBtn.addEventListener('touchstart', () => { controls.jump = true; });
                jumpBtn.addEventListener('touchend', () => { controls.jump = false; });
                
                dashBtn.addEventListener('touchstart', () => { controls.dash = true; });
                dashBtn.addEventListener('touchend', () => { controls.dash = false; });
                
                firePrimaryBtn.addEventListener('touchstart', () => { controls.firePrimary = true; });
                firePrimaryBtn.addEventListener('touchend', () => { controls.firePrimary = false; });
                
                fireSecondaryBtn.addEventListener('touchstart', () => { 
                    controls.fireSecondary = true; 
                    fireSecondary();
                });
                fireSecondaryBtn.addEventListener('touchend', () => { controls.fireSecondary = false; });
                
                abilityBtn.addEventListener('touchstart', () => { 
                    if (!controls.useAbility) {
                        controls.useAbility = true;
                        useClassAbility();
                    }
                });
                abilityBtn.addEventListener('touchend', () => { controls.useAbility = false; });
                
                cpuBtn.addEventListener('touchstart', () => { 
                    cpuMode = !cpuMode;
                    cpuBtn.style.background = cpuMode ? 'rgba(0, 255, 0, 0.8)' : 'rgba(0, 0, 0, 0.6)';
                });
            } catch (error) {
                console.error("Error setting up mobile controls:", error);
            }
        }

        // Create the player with cyber runner design
        function createPlayer() {
            player = new THREE.Object3D();
            player.position.set(0, 1.7, 0);
            player.rotation.y = Math.PI;
            scene.add(player);
            
            camera.position.set(0, 1.7, 0);
            player.add(camera);
            
            createNeurotWeapon();
            
            player.velocity = new THREE.Vector3();
            player.isGrounded = true;
            player.currentTarget = null;
            player.canDoubleJump = false;
            player.isWallRunning = false;
            player.wallRunDirection = new THREE.Vector3();
            
            // Set player stats based on class
            if (playerClass) {
                gameStats.maxPlayerHealth = playerClass.health;
                gameStats.playerHealth = playerClass.health;
                gameStats.playerSpeed = playerClass.speed;
                gameStats.playerDamage = playerClass.primaryDamage;
                
                // Update HUD colors based on class
                document.documentElement.style.setProperty('--primary-color', `rgb(${playerClass.primaryColor >> 16}, ${(playerClass.primaryColor >> 8) & 255}, ${playerClass.primaryColor & 255})`);
                document.documentElement.style.setProperty('--secondary-color', `rgb(${playerClass.secondaryColor >> 16}, ${(playerClass.secondaryColor >> 8) & 255}, ${playerClass.secondaryColor & 255})`);
            }
        }

        // Create the Neurot Weapon
        function createNeurotWeapon() {
            const weaponGroup = new THREE.Group();
            
            // Main body - cyber design
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 0.3, 0.8),
                new THREE.MeshBasicMaterial({ color: playerClass ? playerClass.primaryColor : 0x00ff00, wireframe: true })
            );
            weaponGroup.add(body);
            
            // Energy core
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 8, 8),
                new THREE.MeshBasicMaterial({ color: playerClass ? playerClass.secondaryColor : 0x00ff00, wireframe: true })
            );
            core.position.set(0, 0, 0.2);
            weaponGroup.add(core);
            
            // Barrel
            const barrel = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 0.6, 8),
                new THREE.MeshBasicMaterial({ color: playerClass ? playerClass.primaryColor : 0x00ff00, wireframe: true })
            );
            barrel.position.set(0, 0, 0.5);
            barrel.rotation.x = Math.PI / 2;
            weaponGroup.add(barrel);
            
            // Handle
            const handle = new THREE.Mesh(
                new THREE.BoxGeometry(0.15, 0.3, 0.4),
                new THREE.MeshBasicMaterial({ color: playerClass ? playerClass.primaryColor : 0x00ff00, wireframe: true })
            );
            handle.position.set(0, -0.2, 0);
            weaponGroup.add(handle);
            
            weaponGroup.position.set(0.3, -0.4, -0.8);
            weaponGroup.rotation.y = Math.PI;
            camera.add(weaponGroup);
            
            neurotWeapon = weaponGroup;
        }

        // Create Cyber Wireframe Enemy
        function createWireframeEnemy(position, enemyType) {
            try {
                const enemyGroup = new THREE.Group();
                
                // Core body
                const bodyGeometry = new THREE.OctahedronGeometry(enemyType.size * 0.5, 0);
                const body = new THREE.LineSegments(
                    new THREE.WireframeGeometry(bodyGeometry),
                    new THREE.LineBasicMaterial({ color: enemyType.color })
                );
                enemyGroup.add(body);
                
                // Spikes/appendages
                const spikeCount = 8;
                for (let i = 0; i < spikeCount; i++) {
                    const angle = (i / spikeCount) * Math.PI * 2;
                    const spikeGeometry = new THREE.ConeGeometry(0.1 * enemyType.size, 0.5 * enemyType.size, 4);
                    const spike = new THREE.LineSegments(
                        new THREE.WireframeGeometry(spikeGeometry),
                        new THREE.LineBasicMaterial({ color: enemyType.color })
                    );
                    spike.position.set(
                        Math.cos(angle) * enemyType.size * 0.7,
                        0,
                        Math.sin(angle) * enemyType.size * 0.7
                    );
                    spike.rotation.x = Math.PI / 2;
                    spike.rotation.z = angle;
                    enemyGroup.add(spike);
                }
                
                // Floating rings
                const ringCount = 3;
                for (let i = 0; i < ringCount; i++) {
                    const ringGeometry = new THREE.TorusGeometry(enemyType.size * 0.8, 0.05 * enemyType.size, 8, 12);
                    const ring = new THREE.LineSegments(
                        new THREE.WireframeGeometry(ringGeometry),
                        new THREE.LineBasicMaterial({ color: enemyType.color })
                    );
                    ring.position.y = (i - 1) * 0.3 * enemyType.size;
                    ring.rotation.x = Math.PI / 2;
                    enemyGroup.add(ring);
                    enemyGroup.userData[`ring${i}`] = ring;
                }
                
                // Create point cloud effect
                const mistParticles = createPointCloudMist(enemyType.color, enemyType.size * 1.5, true);
                enemyGroup.add(mistParticles);
                enemyGroup.userData.mistParticles = mistParticles;
                
                enemyGroup.position.copy(position);
                
                enemyGroup.health = enemyType.health;
                enemyGroup.maxHealth = enemyType.health;
                enemyGroup.speed = enemyType.speed;
                enemyGroup.target = player;
                enemyGroup.lastFire = 0;
                enemyGroup.fireRate = enemyType.fireRate;
                enemyGroup.damage = enemyType.damage;
                enemyGroup.enemyType = enemyType;
                enemyGroup.id = enemies.length;
                enemyGroup.behavior = enemyType.behavior;
                enemyGroup.patrolPoint = 0;
                enemyGroup.patrolPath = [];
                enemyGroup.rotationSpeed = 0.02;
                
                // Create patrol path for patrol behavior
                if (enemyGroup.behavior === "patrol") {
                    const pointCount = 4;
                    for (let i = 0; i < pointCount; i++) {
                        const angle = (i / pointCount) * Math.PI * 2;
                        const radius = 15;
                        enemyGroup.patrolPath.push(new THREE.Vector3(
                            position.x + Math.cos(angle) * radius,
                            position.y,
                            position.z + Math.sin(angle) * radius
                        ));
                    }
                }
                
                // Create health bar
                const healthBar = document.createElement('div');
                healthBar.className = 'enemy-health-bar-overhead';
                healthBar.id = `enemyHealthBar${enemyGroup.id}`;
                
                const healthFill = document.createElement('div');
                healthFill.className = 'enemy-health-fill-overhead';
                healthBar.appendChild(healthFill);
                
                document.getElementById('enemyHealthBars').appendChild(healthBar);
                enemyGroup.healthBar = healthBar;
                enemyGroup.healthFill = healthFill;
                
                scene.add(enemyGroup);
                enemies.push(enemyGroup);
                
                gameStats.enemyCount++;
                updateEnemyCounter();
                
                return enemyGroup;
            } catch (error) {
                console.error("Error creating enemy:", error);
                return null;
            }
        }

        // Create point cloud mist effect
        function createPointCloudMist(color, size, isGlitch = false) {
            const particleCount = isGlitch ? 150 : 100;
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const glitchOffsets = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount * 3; i += 3) {
                const radius = size * (0.8 + Math.random() * 0.4);
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                positions[i] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i + 2] = radius * Math.cos(phi);
                
                // Color with variations
                const r = (color >> 16 & 255) / 255;
                const g = (color >> 8 & 255) / 255;
                const b = (color & 255) / 255;
                
                if (isGlitch) {
                    // Glitch effect
                    colors[i] = r * (0.5 + Math.random() * 0.5);
                    colors[i + 1] = g * (0.1 + Math.random() * 0.2);
                    colors[i + 2] = b * (0.1 + Math.random() * 0.2);
                } else {
                    colors[i] = r * (0.7 + Math.random() * 0.3);
                    colors[i + 1] = g * (0.7 + Math.random() * 0.3);
                    colors[i + 2] = b * (0.7 + Math.random() * 0.3);
                }
                
                // Glitch offset for animation
                glitchOffsets[i] = (Math.random() - 0.5) * 0.1;
                glitchOffsets[i + 1] = (Math.random() - 0.5) * 0.1;
                glitchOffsets[i + 2] = (Math.random() - 0.5) * 0.1;
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('glitchOffset', new THREE.BufferAttribute(glitchOffsets, 3));
            
            const material = new THREE.PointsMaterial({
                size: size * 0.05,
                vertexColors: true,
                transparent: true,
                opacity: isGlitch ? 0.8 : 0.6,
                blending: THREE.AdditiveBlending
            });
            
            const pointCloud = new THREE.Points(geometry, material);
            pointCloud.userData.isGlitch = isGlitch;
            pointCloud.userData.glitchTime = 0;
            
            return pointCloud;
        }

        // Update point cloud mist with glitch effects
        function updatePointCloudMist(mistParticles, delta) {
            if (!mistParticles || !mistParticles.geometry) return;
            
            const positions = mistParticles.geometry.attributes.position.array;
            const glitchOffsets = mistParticles.geometry.attributes.glitchOffset.array;
            const time = performance.now() * 0.001;
            
            mistParticles.userData.glitchTime += delta;
            
            for (let i = 0; i < positions.length; i += 3) {
                // Base floating motion
                positions[i] += (Math.sin(time + i) * 0.01) * delta * 60;
                positions[i + 1] += (Math.cos(time + i * 0.7) * 0.01) * delta * 60;
                positions[i + 2] += (Math.sin(time + i * 0.3) * 0.01) * delta * 60;
                
                // Enhanced glitch effect
                if (mistParticles.userData.isGlitch) {
                    const glitchIntensity = 0.3 + Math.sin(mistParticles.userData.glitchTime * 5) * 0.2;
                    
                    // Data corruption glitch effect
                    if (Math.random() < 0.1) {
                        positions[i] += (Math.random() - 0.5) * glitchIntensity;
                        positions[i + 1] += (Math.random() - 0.5) * glitchIntensity;
                        positions[i + 2] += (Math.random() - 0.5) * glitchIntensity;
                    }
                    
                    // Digital static effect
                    if (Math.random() < 0.05) {
                        positions[i] = glitchOffsets[i] * glitchIntensity * 10;
                        positions[i + 1] = glitchOffsets[i + 1] * glitchIntensity * 10;
                        positions[i + 2] = glitchOffsets[i + 2] * glitchIntensity * 10;
                    }
                }
            }
            
            mistParticles.geometry.attributes.position.needsUpdate = true;
        }

        // Create neon grid floor
        function createGridFloor() {
            try {
                if (gridFloor && scene) scene.remove(gridFloor);
                
                const gridSize = 300;
                const gridDivisions = 100;
                const gridColor = 0x00ff00;
                
                const gridGeometry = new THREE.PlaneGeometry(gridSize, gridSize, gridDivisions, gridDivisions);
                const gridMaterial = new THREE.MeshBasicMaterial({ 
                    color: gridColor, 
                    wireframe: true,
                    transparent: true,
                    opacity: 0.3
                });
                
                gridFloor = new THREE.Mesh(gridGeometry, gridMaterial);
                gridFloor.rotation.x = -Math.PI / 2;
                gridFloor.position.y = 0.1;
                scene.add(gridFloor);
            } catch (error) {
                console.error("Error creating grid floor:", error);
            }
        }

        // Update grid floor pulse
        function updateGridFloor(delta) {
            try {
                if (!gridFloor || !gridFloor.material) return;
                
                const pulseSpeed = 1;
                const minOpacity = 0.1;
                const maxOpacity = 0.5;
                
                // Calculate pulse based on time
                const time = performance.now() * 0.001;
                const pulse = (Math.sin(time * pulseSpeed) + 1) * 0.5;
                gridFloor.material.opacity = minOpacity + pulse * (maxOpacity - minOpacity);
            } catch (error) {
                console.error("Error updating grid floor:", error);
            }
        }

        // Create the Cyber Wireframe City
        function createCity() {
            try {
                // Clean up existing buildings
                if (buildings && buildings.length > 0) {
                    buildings.forEach(building => {
                        if (building && scene) scene.remove(building);
                    });
                }
                buildings = [];
                
                // Create grid floor
                createGridFloor();
                
                const buildingMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
                
                // Create optimized number of buildings for performance
                const buildingCount = 25;
                const zoneSize = 120;
                
                for (let i = 0; i < buildingCount; i++) {
                    const height = 15 + Math.random() * 25;
                    const width = 3 + Math.random() * 4;
                    const depth = 3 + Math.random() * 4;
                    
                    const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
                    const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                    
                    // Position buildings in a larger area
                    building.position.set(
                        (Math.random() - 0.5) * zoneSize,
                        height / 2,
                        (Math.random() - 0.5) * zoneSize
                    );
                    
                    scene.add(building);
                    buildings.push(building);
                }
                
                // Add platforms for parkour
                const platformCount = 10;
                for (let i = 0; i < platformCount; i++) {
                    const platformWidth = 5 + Math.random() * 10;
                    const platformDepth = 5 + Math.random() * 10;
                    const platformHeight = 5 + i * 8;
                    
                    const platformGeometry = new THREE.BoxGeometry(platformWidth, 0.5, platformDepth);
                    const platform = new THREE.Mesh(platformGeometry, buildingMaterial);
                    
                    platform.position.set(
                        (Math.random() - 0.5) * zoneSize,
                        platformHeight,
                        (Math.random() - 0.5) * zoneSize
                    );
                    
                    scene.add(platform);
                    buildings.push(platform);
                }
                
                // Add stars for background
                const starGeometry = new THREE.BufferGeometry();
                const starMaterial = new THREE.PointsMaterial({ color: 0x00ff00, size: 0.3, sizeAttenuation: true });
                
                const starVertices = [];
                for (let i = 0; i < 300; i++) {
                    const x = (Math.random() - 0.5) * 1500;
                    const y = (Math.random() - 0.5) * 1500;
                    const z = (Math.random() - 0.5) * 1500;
                    starVertices.push(x, y, z);
                }
                
                starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
                const stars = new THREE.Points(starGeometry, starMaterial);
                scene.add(stars);
                buildings.push(stars);
            } catch (error) {
                console.error("Error creating city:", error);
            }
        }

        // Create Data Pack collectible
        function createDataPack(position) {
            try {
                const dataPackGroup = new THREE.Group();
                
                // Core data sphere
                const coreGeometry = new THREE.SphereGeometry(1, 8, 8);
                const core = new THREE.LineSegments(
                    new THREE.WireframeGeometry(coreGeometry),
                    new THREE.LineBasicMaterial({ color: 0x00ffff })
                );
                dataPackGroup.add(core);
                
                // Rotating rings
                const ringCount = 3;
                for (let i = 0; i < ringCount; i++) {
                    const ringGeometry = new THREE.TorusGeometry(1.5, 0.1, 8, 12);
                    const ring = new THREE.LineSegments(
                        new THREE.WireframeGeometry(ringGeometry),
                        new THREE.LineBasicMaterial({ color: 0x00ffff })
                    );
                    ring.rotation.x = Math.PI / 2;
                    ring.rotation.y = (i / ringCount) * Math.PI;
                    dataPackGroup.add(ring);
                    dataPackGroup.userData[`ring${i}`] = ring;
                }
                
                // Floating particles
                const particleGeometry = new THREE.BufferGeometry();
                const particlePositions = new Float32Array(30 * 3);
                const particleColors = new Float32Array(30 * 3);
                
                for (let i = 0; i < 30 * 3; i += 3) {
                    const radius = 2;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    particlePositions[i] = radius * Math.sin(phi) * Math.cos(theta);
                    particlePositions[i + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    particlePositions[i + 2] = radius * Math.cos(phi);
                    
                    particleColors[i] = 0;
                    particleColors[i + 1] = 1;
                    particleColors[i + 2] = 1;
                }
                
                particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
                particleGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
                
                const particleMaterial = new THREE.PointsMaterial({
                    size: 0.1,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8
                });
                
                const particles = new THREE.Points(particleGeometry, particleMaterial);
                dataPackGroup.add(particles);
                dataPackGroup.userData.particles = particles;
                
                dataPackGroup.position.copy(position);
                dataPackGroup.userData.collected = false;
                dataPackGroup.userData.rotationSpeed = 0.01;
                
                scene.add(dataPackGroup);
                dataPacks.push(dataPackGroup);
                totalDataPacks++;
                
                return dataPackGroup;
            } catch (error) {
                console.error("Error creating data pack:", error);
                return null;
            }
        }

        // Update data pack animation
        function updateDataPacks(delta) {
            dataPacks.forEach(dataPack => {
                if (dataPack && !dataPack.userData.collected) {
                    // Rotate the data pack
                    dataPack.rotation.y += dataPack.userData.rotationSpeed * delta * 60;
                    
                    // Rotate rings at different speeds
                    for (let i = 0; i < 3; i++) {
                        const ring = dataPack.userData[`ring${i}`];
                        if (ring) {
                            ring.rotation.z += (0.02 + i * 0.01) * delta * 60;
                        }
                    }
                    
                    // Float up and down
                    const time = performance.now() * 0.001;
                    dataPack.position.y += Math.sin(time * 2) * 0.01 * delta * 60;
                    
                    // Check for player collection
                    if (player && dataPack.position.distanceTo(player.position) < 3) {
                        collectDataPack(dataPack);
                    }
                }
            });
        }

        // Collect data pack
        function collectDataPack(dataPack) {
            if (dataPack.userData.collected) return;
            
            dataPack.userData.collected = true;
            scene.remove(dataPack);
            
            // Create collection effect
            createExplosion(dataPack.position, 0x00ffff, 10);
            
            gameStats.dataPacksCollected++;
            dataPacksCollected++;
            
            // Award experience
            playerExp += 50;
            checkLevelUp();
            
            // Show collection notification
            const portalNotification = document.getElementById('portalNotification');
            portalNotification.textContent = "DATA PACK COLLECTED! +50 EXP";
            portalNotification.style.display = 'block';
            setTimeout(() => {
                portalNotification.style.display = 'none';
            }, 2000);
            
            // Update HUD
            updateLevelInfo();
        }

        // Create ENHANCED DATA PORTAL
        function createPortal() {
            try {
                if (portal && scene) scene.remove(portal);
                
                const portalGroup = new THREE.Group();
                
                // Main portal frame - circular
                const frameRadius = 6;
                const frameGeometry = new THREE.TorusGeometry(frameRadius, 0.3, 8, 24);
                const frameMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff, 
                    wireframe: true 
                });
                const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                frame.rotation.x = Math.PI / 2;
                portalGroup.add(frame);
                
                // Portal energy field
                const energyGeometry = new THREE.CircleGeometry(frameRadius - 0.5, 16);
                const energyMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff, 
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide,
                    wireframe: true
                });
                const energyField = new THREE.Mesh(energyGeometry, energyMaterial);
                energyField.rotation.x = -Math.PI / 2;
                portalGroup.add(energyField);
                
                // Particle effect inside portal
                const portalParticles = createPointCloudMist(0x00ffff, 8, true);
                portalGroup.add(portalParticles);
                portalGroup.userData.portalParticles = portalParticles;
                
                // Rotating inner rings
                const ringCount = 3;
                for (let i = 0; i < ringCount; i++) {
                    const ringGeometry = new THREE.TorusGeometry(4 - i * 1.2, 0.2, 8, 20);
                    const ringMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0x00ffff, 
                        wireframe: true 
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = Math.PI / 2;
                    portalGroup.add(ring);
                    portalGroup.userData[`ring${i}`] = ring;
                }
                
                portalGroup.position.set(0, 2, 0);
                scene.add(portalGroup);
                
                portal = portalGroup;
                portalActive = true;
                portalSpawned = true;
                
                // Show portal notification
                const portalNotification = document.getElementById('portalNotification');
                portalNotification.textContent = "DATA PORTAL ACTIVATED! ENTER TO PROCEED";
                portalNotification.style.display = 'block';
                setTimeout(() => {
                    portalNotification.style.display = 'none';
                }, 3000);
            } catch (error) {
                console.error("Error creating portal:", error);
            }
        }

        // Update portal animation
        function updatePortal(delta) {
            try {
                if (!portal || !portalActive) return;
                
                portal.rotation.y += 0.01 * delta * 60;
                
                const time = performance.now() * 0.005;
                
                // Update portal particles
                if (portal.userData.portalParticles) {
                    updatePointCloudMist(portal.userData.portalParticles, delta);
                }
                
                // Rotate rings at different speeds
                for (let i = 0; i < 3; i++) {
                    const ring = portal.userData[`ring${i}`];
                    if (ring) {
                        ring.rotation.z += (0.02 + i * 0.01) * delta * 60;
                    }
                }
                
                // Pulse energy field
                const energyField = portal.children[1];
                if (energyField) {
                    energyField.material.opacity = 0.5 + 0.3 * Math.sin(time * 2);
                }
            } catch (error) {
                console.error("Error updating portal:", error);
            }
        }

        // Start the game
        function startGame() {
            try {
                // Check if player class is selected
                if (!playerClass) {
                    alert("Please select a class first!");
                    return;
                }
                
                document.getElementById('mainMenu').style.display = 'none';
                document.getElementById('endGameScreen').style.display = 'none';
                
                // Clear any existing health bars
                document.getElementById('enemyHealthBars').innerHTML = '';
                
                // Reset game stats
                gameStats = {
                    score: 0,
                    currentZone: 1,
                    totalZones: 4,
                    playerHealth: playerClass.health,
                    maxPlayerHealth: playerClass.health,
                    playerSpeed: playerClass.speed,
                    playerDamage: playerClass.primaryDamage,
                    bandwidth: 100,
                    maxBandwidth: 100,
                    damageTaken: 0,
                    enemiesPurged: 0,
                    nodesCleared: 0,
                    totalNodes: 3,
                    enemyCount: 0,
                    shotsFired: 0,
                    shotsHit: 0,
                    dataPacksCollected: 0
                };
                
                playerLevel = saveData.playerLevel || 1;
                playerExp = saveData.playerExp || 0;
                nextLevelExp = 100 + (playerLevel - 1) * 50;
                updateLevelInfo();
                
                abilityCooldown = 0;
                abilityActive = false;
                
                neurotCharge = 100;
                updateNeurotChargeUI();
                
                bandwidth = 100;
                updateBandwidthBar();
                
                buzzerTimer = 0;
                updateBuzzerTimer();
                
                portalActive = false;
                portalSpawned = false;
                portalTriggerTime = 0;
                
                dataPacksCollected = 0;
                totalDataPacks = 0;
                
                // Reset level bonuses
                speedBoostMultiplier = 1.5;
                doubleJumpUnlocked = false;
                wallRunUnlocked = false;
                damageBoost = 1;
                bandwidthBoost = 1;
                
                // Apply level bonuses based on current level
                applyLevelBonuses();
                
                createPlayer();
                
                clearEntities();
                
                updateHealthBar();
                updateEnemyCounter();
                updateZoneProgress();
                
                // Update weapon name based on class
                document.getElementById('weaponName').textContent = `${playerClass.name.toUpperCase()} NEUROT`;
                
                // Update ability label based on class
                document.getElementById('abilityLabel').textContent = `${playerClass.name.toUpperCase()} ABILITY`;
                
                // Create city once at the start
                createCity();
                
                startZone(1);
                
                currentState = GameState.PLAYING;
                gameStartTime = performance.now();
                runTime = 0;
                
                // Clear any existing timer intervals
                if (timerInterval) clearInterval(timerInterval);
                if (countdownInterval) clearInterval(countdownInterval);
                
                // Start buzzer timer
                timerInterval = setInterval(() => {
                    if (currentState === GameState.PLAYING) {
                        buzzerTimer++;
                        updateBuzzerTimer();
                    }
                }, 1000);
            } catch (error) {
                console.error("Error starting game:", error);
            }
        }

        // Apply level bonuses based on current player level
        function applyLevelBonuses() {
            if (playerLevel >= 5) {
                doubleJumpUnlocked = true;
            }
            
            if (playerLevel >= 10) {
                wallRunUnlocked = true;
            }
            
            if (playerLevel >= 15) {
                speedBoostMultiplier = 2;
            }
            
            if (playerLevel >= 20) {
                damageBoost = 1.5;
            }
            
            if (playerLevel >= 25) {
                bandwidthBoost = 1.5;
            }
        }

        // Start a zone
        function startZone(zoneNumber) {
            try {
                gameStats.currentZone = zoneNumber;
                gameStats.nodesCleared = 0;
                clearEntities();
                
                let enemyType;
                switch(zoneNumber) {
                    case 1:
                        enemyType = enemyTypes.CORRUPTED_NODE;
                        break;
                    case 2:
                        enemyType = enemyTypes.VIRAL_ENTITY;
                        break;
                    case 3:
                        enemyType = enemyTypes.DATA_HUNTER;
                        break;
                    case 4:
                        enemyType = enemyTypes.ARCHITECT_GUARDIAN;
                        break;
                    default:
                        enemyType = enemyTypes.CORRUPTED_NODE;
                }
                
                // Update mission info
                document.getElementById('missionName').textContent = `PURGE ${enemyType.name}S`;
                document.getElementById('zoneTotal').textContent = enemyType.count || 3;
                document.getElementById('zoneProgress').textContent = '0';
                
                if (zoneNumber < 4) {
                    gameStats.totalNodes = enemyType.count || 3;
                    
                    // Create enemies
                    const enemyCount = enemyType.count || 3;
                    
                    for (let i = 0; i < enemyCount; i++) {
                        const angle = (i / enemyCount) * Math.PI * 2;
                        const radius = 50;
                        const x = Math.cos(angle) * radius;
                        const z = Math.sin(angle) * radius;
                        
                        createWireframeEnemy(new THREE.Vector3(x, 10, z), enemyType);
                    }
                    
                    // Create data packs
                    const dataPackCount = 3;
                    for (let i = 0; i < dataPackCount; i++) {
                        const angle = (i / dataPackCount) * Math.PI * 2;
                        const radius = 40;
                        const x = Math.cos(angle) * radius;
                        const z = Math.sin(angle) * radius;
                        
                        createDataPack(new THREE.Vector3(x, 5, z));
                    }
                    
                    updateZoneProgress();
                    
                    // Start countdown
                    startCountdown();
                    
                } else {
                    // Final zone - Architect Guardian
                    gameStats.totalNodes = 1;
                    
                    const bossPosition = new THREE.Vector3(0, 15, 0);
                    const boss = createWireframeEnemy(bossPosition, enemyType);
                    boss.isBoss = true;
                    
                    updateZoneProgress();
                    
                    // Create data packs around boss
                    const dataPackCount = 5;
                    for (let i = 0; i < dataPackCount; i++) {
                        const angle = (i / dataPackCount) * Math.PI * 2;
                        const radius = 20;
                        const x = Math.cos(angle) * radius;
                        const z = Math.sin(angle) * radius;
                        
                        createDataPack(new THREE.Vector3(x, 5, z));
                    }
                    
                    // Start countdown
                    startCountdown();
                }
                
                updateEnemyCounter();
                updateZoneProgress();
            } catch (error) {
                console.error("Error starting zone:", error);
            }
        }

        // Start countdown for zone
        function startCountdown() {
            try {
                countdownActive = true;
                countdownTimer = 10;
                document.getElementById('countdownTimer').style.display = 'block';
                updateCountdownTimer();
                
                // Clear any existing countdown interval
                if (countdownInterval) clearInterval(countdownInterval);
                
                countdownInterval = setInterval(() => {
                    if (currentState !== GameState.PLAYING) {
                        clearInterval(countdownInterval);
                        return;
                    }
                    
                    countdownTimer--;
                    updateCountdownTimer();
                    
                    if (countdownTimer <= 0) {
                        clearInterval(countdownInterval);
                        document.getElementById('countdownTimer').style.display = 'none';
                        countdownActive = false;
                        
                        // Apply penalty for not clearing zone in time
                        if (enemies.length > 0 && !portalActive) {
                            gameStats.playerHealth -= 10;
                            gameStats.damageTaken += 10;
                            updateHealthBar();
                            checkPlayerDeath();
                        }
                    }
                }, 1000);
            } catch (error) {
                console.error("Error starting countdown:", error);
            }
        }

        // Update countdown timer display
        function updateCountdownTimer() {
            if (countdownTimer > 0 && countdownTimer <= 10) {
                document.getElementById('countdownTimer').textContent = romanNumerals[10 - countdownTimer];
            } else {
                document.getElementById('countdownTimer').textContent = "X";
            }
        }

        // Update buzzer timer display
        function updateBuzzerTimer() {
            const minutes = Math.floor(buzzerTimer / 60);
            const seconds = buzzerTimer % 60;
            document.getElementById('buzzerTimer').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Update level info
        function updateLevelInfo() {
            document.getElementById('playerLevel').textContent = playerLevel;
            document.getElementById('playerExp').textContent = playerExp;
            document.getElementById('nextLevelExp').textContent = nextLevelExp;
        }

        // Update neurot charge UI
        function updateNeurotChargeUI() {
            const chargePercent = (neurotCharge / maxNeurotCharge) * 100;
            document.getElementById('ammoCount').textContent = `NEUROT: ${Math.round(chargePercent)}%`;
            
            if (neurotOverloaded) {
                document.getElementById('ammoCount').style.color = '#ff0000';
            } else if (chargePercent > 70) {
                document.getElementById('ammoCount').style.color = '#ff0';
            } else {
                document.getElementById('ammoCount').style.color = '#0f0';
            }
        }

        // Clear entities
        function clearEntities() {
            try {
                // Remove enemies from scene
                enemies.forEach(enemy => {
                    if (enemy && scene) {
                        scene.remove(enemy);
                        // Dispose of geometries and materials
                        enemy.traverse(child => {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(m => m.dispose());
                                } else {
                                    child.material.dispose();
                                }
                            }
                        });
                        
                        // Remove health bar
                        if (enemy.healthBar) {
                            enemy.healthBar.remove();
                        }
                    }
                });
                enemies = [];
                gameStats.enemyCount = 0;
                
                // Remove projectiles from scene
                projectiles.forEach(projectile => {
                    if (projectile && scene) {
                        scene.remove(projectile);
                        if (projectile.geometry) projectile.geometry.dispose();
                        if (projectile.material) projectile.material.dispose();
                    }
                });
                projectiles = [];
                
                // Remove particles from scene
                particles.forEach(particle => {
                    if (particle && scene) {
                        scene.remove(particle);
                        if (particle.geometry) particle.geometry.dispose();
                        if (particle.material) particle.material.dispose();
                    }
                });
                particles = [];
                
                // Remove data packs
                dataPacks.forEach(dataPack => {
                    if (dataPack && scene) {
                        scene.remove(dataPack);
                        dataPack.traverse(child => {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(m => m.dispose());
                                } else {
                                    child.material.dispose();
                                }
                            }
                        });
                    }
                });
                dataPacks = [];
                
                // Remove portal
                if (portal && scene) {
                    scene.remove(portal);
                    portal.traverse(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(m => m.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    });
                    portal = null;
                    portalActive = false;
                    portalSpawned = false;
                }
            } catch (error) {
                console.error("Error clearing entities:", error);
            }
        }

        // Update enemy counter
        function updateEnemyCounter() {
            document.getElementById('zoneCount').textContent = gameStats.currentZone;
        }

        // Update zone progress
        function updateZoneProgress() {
            document.getElementById('zoneProgress').textContent = gameStats.nodesCleared;
            document.getElementById('zoneTotal').textContent = gameStats.totalNodes;
        }

        // Update health bar
        function updateHealthBar() {
            const healthPercent = (gameStats.playerHealth / gameStats.maxPlayerHealth) * 100;
            document.getElementById('healthFill').style.width = `${healthPercent}%`;
            document.getElementById('healthPercent').textContent = `${Math.round(healthPercent)}%`;
        }

        // Update bandwidth bar
        function updateBandwidthBar() {
            const bandwidthPercent = (bandwidth / maxBandwidth) * 100;
            document.getElementById('bandwidthFill').style.width = `${bandwidthPercent}%`;
            document.getElementById('bandwidthPercent').textContent = `${Math.round(bandwidthPercent)}%`;
        }

        // Update ability cooldown
        function updateAbilityCooldown() {
            const cooldownPercent = (abilityCooldown / playerClass.abilityCooldown) * 100;
            document.getElementById('abilityFill').style.width = `${100 - cooldownPercent}%`;
            
            if (abilityCooldown > 0) {
                document.getElementById('abilityPercent').textContent = `COOLDOWN: ${Math.ceil(abilityCooldown)}s`;
            } else if (abilityActive) {
                document.getElementById('abilityPercent').textContent = `ACTIVE: ${Math.ceil(playerClass.abilityDuration - abilityTime)}s`;
            } else {
                document.getElementById('abilityPercent').textContent = "READY [F]";
            }
        }

        // Create projectile system with neurot effects
        function createProjectile(position, direction, speed, color, damage, isPlayerProjectile = false) {
            try {
                // Create neurot projectiles
                const geometry = new THREE.SphereGeometry(0.2, 6, 6);
                const material = new THREE.MeshBasicMaterial({ 
                    color: color,
                    wireframe: true
                });
                const projectile = new THREE.Mesh(geometry, material);
                projectile.position.copy(position);
                
                // Add neurot trail
                const trailGeometry = new THREE.BufferGeometry();
                const trailPositions = new Float32Array(20 * 3);
                trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
                
                const trailMaterial = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.6
                });
                
                const trail = new THREE.Line(trailGeometry, trailMaterial);
                projectile.add(trail);
                projectile.userData.trail = trail;
                projectile.userData.trailPositions = trailPositions;
                projectile.userData.trailIndex = 0;
                
                projectile.userData.direction = direction.clone().normalize();
                projectile.userData.speed = speed;
                projectile.userData.damage = damage;
                projectile.userData.isPlayerProjectile = isPlayerProjectile;
                projectile.userData.lifetime = 3.0;
                
                scene.add(projectile);
                projectiles.push(projectile);
                return projectile;
            } catch (error) {
                console.error("Error creating projectile:", error);
                return null;
            }
        }

        // Update projectile trails
        function updateProjectileTrail(projectile) {
            const trail = projectile.userData.trail;
            const trailPositions = projectile.userData.trailPositions;
            const trailIndex = projectile.userData.trailIndex;
            
            // Add current position to trail
            const currentIndex = (trailIndex % 10) * 3;
            trailPositions[currentIndex] = projectile.position.x;
            trailPositions[currentIndex + 1] = projectile.position.y;
            trailPositions[currentIndex + 2] = projectile.position.z;
            
            projectile.userData.trailIndex = (trailIndex + 1) % 10;
            trail.geometry.attributes.position.needsUpdate = true;
        }

        // Create explosion particles
        function createExplosion(position, color, count) {
            try {
                for (let i = 0; i < count; i++) {
                    const geometry = new THREE.SphereGeometry(0.05 + Math.random() * 0.1, 4, 4);
                    const material = new THREE.MeshBasicMaterial({ 
                        color: color,
                        wireframe: true
                    });
                    const particle = new THREE.Mesh(geometry, material);
                    particle.position.copy(position);
                    particle.userData = {
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 10,
                            (Math.random() - 0.5) * 10,
                            (Math.random() - 0.5) * 10
                        ),
                        lifetime: 1.0 + Math.random() * 0.5
                    };
                    scene.add(particle);
                    particles.push(particle);
                }
            } catch (error) {
                console.error("Error creating explosion:", error);
            }
        }

        // Update particles
        function updateParticles(delta) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                if (!particle) continue;
                
                particle.userData.lifetime -= delta;
                if (particle.userData.lifetime <= 0) {
                    scene.remove(particle);
                    if (particle.geometry) particle.geometry.dispose();
                    if (particle.material) particle.material.dispose();
                    particles.splice(i, 1);
                    continue;
                }
                
                // Move particle
                particle.position.add(particle.userData.velocity.clone().multiplyScalar(delta));
                
                // Fade out
                particle.material.opacity = particle.userData.lifetime;
            }
        }

        // Check player death
        function checkPlayerDeath() {
            if (gameStats.playerHealth <= 0 && !immortalMode) {
                gameStats.playerHealth = 0;
                updateHealthBar();
                console.log("GAME OVER - Player defeated");
                saveGame();
                showEndGameScreen();
            }
        }

        // Save game function
        function saveGame() {
            try {
                saveData = {
                    playerLevel: playerLevel,
                    playerExp: playerExp,
                    nextLevelExp: nextLevelExp,
                    playerClass: playerClass,
                    dataPacksCollected: dataPacksCollected,
                    gameStats: { ...gameStats }
                };
                
                localStorage.setItem('projectNeurotSave', JSON.stringify(saveData));
                console.log("Game saved successfully");
                
                // Show save notification
                const portalNotification = document.getElementById('portalNotification');
                portalNotification.textContent = "GAME SAVED!";
                portalNotification.style.display = 'block';
                setTimeout(() => {
                    portalNotification.style.display = 'none';
                }, 2000);
            } catch (error) {
                console.error("Error saving game:", error);
            }
        }

        // Load game function
        function loadGame() {
            try {
                const savedData = localStorage.getItem('projectNeurotSave');
                if (savedData) {
                    saveData = JSON.parse(savedData);
                    console.log("Game loaded successfully");
                    
                    // Set player class from save
                    if (saveData.playerClass) {
                        playerClass = saveData.playerClass;
                    }
                    
                    // Update load button text
                    document.getElementById('loadBtn').textContent = `LOAD (Lvl ${saveData.playerLevel})`;
                }
            } catch (error) {
                console.error("Error loading game:", error);
            }
        }

        // Set up event listeners
        function setupEventListeners() {
            // Menu event listeners
            document.getElementById('skipIntro').addEventListener('click', showBootSequence);
            document.getElementById('skipStory').addEventListener('click', showMainMenu);
            document.getElementById('startBtn').addEventListener('click', startGame);
            document.getElementById('loadBtn').addEventListener('click', () => {
                if (saveData.playerLevel > 1) {
                    playerLevel = saveData.playerLevel;
                    playerExp = saveData.playerExp;
                    nextLevelExp = saveData.nextLevelExp;
                    dataPacksCollected = saveData.dataPacksCollected;
                    startGame();
                } else {
                    alert("No saved game found!");
                }
            });
            document.getElementById('settingsBtn').addEventListener('click', () => {
                alert("Settings would show control list here");
            });
            
            // End game screen buttons
            document.getElementById('restartBtn').addEventListener('click', startGame);
            document.getElementById('menuBtn').addEventListener('click', showMainMenu);
            
            // Game control event listeners
            document.addEventListener('keydown', (e) => {
                if (currentState !== GameState.PLAYING) return;
                
                switch(e.code) {
                    case 'KeyW': controls.moveForward = true; break;
                    case 'KeyS': controls.moveBackward = true; break;
                    case 'KeyA': controls.moveLeft = true; break;
                    case 'KeyD': controls.moveRight = true; break;
                    case 'Space': 
                        controls.jump = true;
                        break;
                    case 'ShiftLeft':
                    case 'ShiftRight': controls.dash = true; break;
                    case 'KeyF':
                        if (!controls.useAbility && abilityCooldown <= 0) {
                            controls.useAbility = true;
                            useClassAbility();
                        }
                        break;
                    case 'KeyC': 
                        cpuMode = !cpuMode;
                        break;
                    case 'KeyP':
                        // Portal interaction
                        if (portalActive && player && portal) {
                            const distance = player.position.distanceTo(portal.position);
                            if (distance < 5) {
                                portalTriggerTime = performance.now();
                            }
                        }
                        break;
                    case 'KeyO': // Save game
                        saveGame();
                        break;
                    case 'KeyL': // Load game
                        if (confirm("Load saved game? Current progress will be lost.")) {
                            loadGame();
                            startGame();
                        }
                        break;
                    case 'Escape': 
                        if (currentState === GameState.PLAYING) {
                            showMainMenu();
                            currentState = GameState.MENU;
                            saveGame();
                        }
                        break;
                }
            });
            
            document.addEventListener('keyup', (e) => {
                switch(e.code) {
                    case 'KeyW': controls.moveForward = false; break;
                    case 'KeyS': controls.moveBackward = false; break;
                    case 'KeyA': controls.moveLeft = false; break;
                    case 'KeyD': controls.moveRight = false; break;
                    case 'Space': controls.jump = false; break;
                    case 'ShiftLeft':
                    case 'ShiftRight': controls.dash = false; break;
                    case 'KeyF': controls.useAbility = false; break;
                }
            });
            
            document.addEventListener('mousedown', (e) => {
                if (currentState === GameState.PLAYING && pointerLocked) {
                    if (e.button === 0) controls.firePrimary = true;
                    else if (e.button === 2) {
                        controls.fireSecondary = true;
                        fireSecondary();
                    }
                }
            });
            
            document.addEventListener('mouseup', (e) => {
                if (e.button === 0) controls.firePrimary = false;
                else if (e.button === 2) controls.fireSecondary = false;
            });
            
            document.addEventListener('contextmenu', (e) => { e.preventDefault(); });
            
            // Pointer lock setup
            const canvas = document.getElementById('gameCanvas');
            
            canvas.addEventListener('click', () => {
                if (!pointerLocked && currentState === GameState.PLAYING) {
                    if ('pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document) {
                        canvas.requestPointerLock();
                    } else {
                        alert("Pointer lock not supported in this browser");
                    }
                }
            });
            
            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === canvas) {
                    pointerLocked = true;
                } else {
                    pointerLocked = false;
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                if (pointerLocked && currentState === GameState.PLAYING) {
                    controls.mouseX = e.movementX * mouseSensitivity;
                    controls.mouseY = e.movementY * mouseSensitivity;
                    
                    if (player) {
                        player.rotation.y -= controls.mouseX;
                        camera.rotation.x -= controls.mouseY;
                        
                        camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                    }
                }
            });
            
            window.addEventListener('resize', () => {
                if (camera) {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                }
                if (renderer) {
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
            });
        }

        // Fire primary neurot weapon
        function firePrimary() {
            if (neurotOverloaded || abilityActive) return;
            
            const now = Date.now();
            if (now - gameStats.lastFireTime < 100) return;
            
            const cameraWorldPosition = new THREE.Vector3();
            camera.getWorldPosition(cameraWorldPosition);
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            
            // Create projectile
            createProjectile(cameraWorldPosition, direction, 40, playerClass.primaryColor, gameStats.playerDamage * damageBoost, true);
            
            gameStats.lastFireTime = now;
            gameStats.shotsFired++;
            
            // Decrease neurot charge
            neurotCharge = Math.max(0, neurotCharge - 5);
            updateNeurotChargeUI();
            
            if (neurotCharge <= 0) {
                neurotOverloaded = true;
                setTimeout(() => {
                    neurotOverloaded = false;
                }, 2000);
            }
        }

        // Fire secondary neurot weapon
        function fireSecondary() {
            if (neurotCharge < 20 || abilityActive) return;
            
            // Use bandwidth for secondary fire
            if (bandwidth < 20) return;
            
            const cameraWorldPosition = new THREE.Vector3();
            camera.getWorldPosition(cameraWorldPosition);
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            
            // Create powerful projectile
            createProjectile(cameraWorldPosition, direction, 60, playerClass.secondaryColor, playerClass.secondaryDamage * damageBoost, true);
            
            gameStats.shotsFired++;
            
            // Decrease resources
            neurotCharge = Math.max(0, neurotCharge - 20);
            bandwidth = Math.max(0, bandwidth - 20);
            
            updateNeurotChargeUI();
            updateBandwidthBar();
        }

        // Use class ability
        function useClassAbility() {
            if (abilityCooldown > 0 || bandwidth < 30) return;
            
            abilityCooldown = playerClass.abilityCooldown;
            abilityActive = true;
            abilityTime = 0;
            
            // Use bandwidth for ability
            bandwidth = Math.max(0, bandwidth - 30);
            updateBandwidthBar();
            
            // Class-specific ability effects
            switch(playerClass.name) {
                case "The Glitch":
                    // Create stealth mist
                    createStealthMist();
                    break;
                case "The Architect":
                    // Create defensive structures
                    createDefensiveStructures();
                    break;
                case "The Vector":
                    // Create damage boost
                    createDamageBoost();
                    break;
            }
            
            // Show ability notification
            const portalNotification = document.getElementById('portalNotification');
            portalNotification.textContent = `${playerClass.name.toUpperCase()} ABILITY ACTIVATED!`;
            portalNotification.style.display = 'block';
            setTimeout(() => {
                portalNotification.style.display = 'none';
            }, 2000);
        }

        // Glitch ability: Create stealth mist
        function createStealthMist() {
            // Create a large mist cloud around player
            const mist = createPointCloudMist(playerClass.primaryColor, 20, true);
            mist.position.copy(player.position);
            scene.add(mist);
            
            // Mist will dissipate after ability duration
            setTimeout(() => {
                if (scene && mist) {
                    scene.remove(mist);
                }
            }, playerClass.abilityDuration * 1000);
        }

        // Architect ability: Create defensive structures
        function createDefensiveStructures() {
            // Create defensive walls around player
            const wallCount = 4;
            for (let i = 0; i < wallCount; i++) {
                const angle = (i / wallCount) * Math.PI * 2;
                const distance = 10;
                
                const wallGeometry = new THREE.BoxGeometry(2, 5, 0.5);
                const wallMaterial = new THREE.MeshBasicMaterial({ 
                    color: playerClass.primaryColor, 
                    wireframe: true 
                });
                const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                
                wall.position.set(
                    player.position.x + Math.cos(angle) * distance,
                    player.position.y + 2.5,
                    player.position.z + Math.sin(angle) * distance
                );
                
                wall.rotation.y = angle;
                
                scene.add(wall);
                
                // Walls will disappear after ability duration
                setTimeout(() => {
                    if (scene && wall) {
                        scene.remove(wall);
                    }
                }, playerClass.abilityDuration * 1000);
            }
        }

        // Vector ability: Create damage boost
        function createDamageBoost() {
            // Temporary damage boost
            const originalDamageBoost = damageBoost;
            damageBoost = 2.5;
            
            // Create visual effect
            const boostEffect = createPointCloudMist(playerClass.primaryColor, 5, true);
            boostEffect.position.copy(player.position);
            scene.add(boostEffect);
            
            // Reset after ability duration
            setTimeout(() => {
                damageBoost = originalDamageBoost;
                if (scene && boostEffect) {
                    scene.remove(boostEffect);
                }
            }, playerClass.abilityDuration * 1000);
        }

        // Update ability system
        function updateAbilitySystem(delta) {
            if (abilityCooldown > 0) {
                abilityCooldown -= delta;
                if (abilityCooldown < 0) abilityCooldown = 0;
            }
            
            if (abilityActive) {
                abilityTime += delta;
                if (abilityTime >= playerClass.abilityDuration) {
                    abilityActive = false;
                    abilityTime = 0;
                }
            }
            
            updateAbilityCooldown();
        }

        // Update neurot charge
        function updateNeurotCharge(delta) {
            if (neurotCharge < maxNeurotCharge && !controls.firePrimary) {
                neurotCharge = Math.min(maxNeurotCharge, neurotCharge + neurotRechargeRate * delta);
                updateNeurotChargeUI();
            }
        }

        // Update bandwidth
        function updateBandwidth(delta) {
            if (bandwidth < maxBandwidth) {
                bandwidth = Math.min(maxBandwidth, bandwidth + bandwidthRegenRate * delta * bandwidthBoost);
                updateBandwidthBar();
            }
        }

        // Update enemy AI
        function updateEnemyAI(enemy, delta) {
            if (!enemy || !player || enemy.health <= 0) return;
            
            const time = performance.now() * 0.001;
            
            // Rotate enemy
            enemy.rotation.y += enemy.rotationSpeed * delta * 60;
            
            // Rotate rings at different speeds
            for (let i = 0; i < 3; i++) {
                const ring = enemy.userData[`ring${i}`];
                if (ring) {
                    ring.rotation.y += (0.02 + i * 0.01) * delta * 60;
                }
            }
            
            // Update point cloud mist if it exists
            if (enemy.userData && enemy.userData.mistParticles) {
                updatePointCloudMist(enemy.userData.mistParticles, delta);
            }
            
            const distanceToPlayer = enemy.position.distanceTo(player.position);
            
            // Behavior-based AI
            switch(enemy.behavior) {
                case "stationary":
                    // Stationary enemies just rotate and fire
                    if (distanceToPlayer < 30) {
                        fireAtPlayer(enemy);
                    }
                    break;
                    
                case "patrol":
                    // Patrol between points
                    if (enemy.patrolPath.length > 0) {
                        const targetPoint = enemy.patrolPath[enemy.patrolPoint];
                        const direction = new THREE.Vector3().subVectors(targetPoint, enemy.position).normalize();
                        
                        enemy.position.add(direction.multiplyScalar(enemy.speed * 0.5 * delta));
                        
                        // Check if reached patrol point
                        if (enemy.position.distanceTo(targetPoint) < 2) {
                            enemy.patrolPoint = (enemy.patrolPoint + 1) % enemy.patrolPath.length;
                        }
                        
                        // Fire if player is close
                        if (distanceToPlayer < 25) {
                            fireAtPlayer(enemy);
                        }
                    }
                    break;
                    
                case "hunter":
                    // Actively hunt the player
                    if (distanceToPlayer < 40) {
                        const direction = new THREE.Vector3().subVectors(player.position, enemy.position).normalize();
                        enemy.position.add(direction.multiplyScalar(enemy.speed * 0.7 * delta));
                        
                        // Fire at player
                        fireAtPlayer(enemy);
                    }
                    break;
                    
                case "boss":
                    // Boss behavior - more complex
                    if (distanceToPlayer < 50) {
                        const direction = new THREE.Vector3().subVectors(player.position, enemy.position).normalize();
                        
                        // Move toward player but maintain distance
                        if (distanceToPlayer > 15) {
                            enemy.position.add(direction.multiplyScalar(enemy.speed * 0.5 * delta));
                        } else if (distanceToPlayer < 10) {
                            enemy.position.add(direction.multiplyScalar(-enemy.speed * 0.3 * delta));
                        }
                        
                        // Fire at player with higher rate
                        if (Date.now() - enemy.lastFire > enemy.fireRate / 2) {
                            fireAtPlayer(enemy);
                        }
                    }
                    break;
            }
            
            // Keep enemies in bounds
            enemy.position.x = Math.max(-100, Math.min(100, enemy.position.x));
            enemy.position.z = Math.max(-100, Math.min(100, enemy.position.z));
            enemy.position.y = Math.max(5, Math.min(40, enemy.position.y));
        }

        function fireAtPlayer(enemy) {
            const now = Date.now();
            if (now - enemy.lastFire < enemy.fireRate) return;
            
            const direction = new THREE.Vector3();
            direction.subVectors(player.position, enemy.position).normalize();
            
            // Add some spread
            direction.x += (Math.random() - 0.5) * 0.1;
            direction.y += (Math.random() - 0.5) * 0.1;
            direction.z += (Math.random() - 0.5) * 0.1;
            direction.normalize();
            
            createProjectile(enemy.position, direction, 20, enemy.enemyType.color, enemy.damage, false);
            enemy.lastFire = now;
        }

        // Update player movement with parkour
        function updatePlayer(delta) {
            if (!player || currentState !== GameState.PLAYING) return;
            
            if (controls.firePrimary && !neurotOverloaded && !abilityActive) firePrimary();
            
            // Update neurot charge
            updateNeurotCharge(delta);
            
            // Update bandwidth
            updateBandwidth(delta);
            
            // Update ability system
            updateAbilitySystem(delta);
            
            // Movement input
            const moveVector = new THREE.Vector3();
            if (controls.moveForward) moveVector.z -= 1;
            if (controls.moveBackward) moveVector.z += 1;
            if (controls.moveLeft) moveVector.x -= 1;
            if (controls.moveRight) moveVector.x += 1;
            if (moveVector.length() > 0) moveVector.normalize();
            moveVector.applyEuler(new THREE.Euler(0, player.rotation.y, 0));
            
            // Speed
            let speed = gameStats.playerSpeed;
            if (controls.dash) speed *= speedBoostMultiplier;
            
            // Set horizontal velocity
            const horizontalVelocity = moveVector.multiplyScalar(speed);
            player.velocity.x = horizontalVelocity.x;
            player.velocity.z = horizontalVelocity.z;
            
            // Jump and gravity
            if (controls.jump && player.isGrounded) {
                player.velocity.y = playerClass.jumpHeight;
                player.isGrounded = false;
                player.canDoubleJump = doubleJumpUnlocked;
            } else if (controls.jump && player.canDoubleJump && !player.isGrounded) {
                player.velocity.y = playerClass.jumpHeight * 0.8;
                player.canDoubleJump = false;
            } else if (!player.isGrounded) {
                player.velocity.y -= 20 * delta;
            }
            
            // Wall running
            if (wallRunUnlocked && !player.isGrounded && player.velocity.y < 0) {
                // Simple wall run check - would need raycasting for proper implementation
                if (Math.abs(player.position.x) > 45 || Math.abs(player.position.z) > 45) {
                    player.isWallRunning = true;
                    player.velocity.y = 0;
                    
                    // Push away from wall
                    const wallDirection = new THREE.Vector3();
                    if (Math.abs(player.position.x) > 45) {
                        wallDirection.x = -Math.sign(player.position.x) * 5;
                    }
                    if (Math.abs(player.position.z) > 45) {
                        wallDirection.z = -Math.sign(player.position.z) * 5;
                    }
                    
                    player.velocity.add(wallDirection.multiplyScalar(delta));
                } else {
                    player.isWallRunning = false;
                }
            }
            
            // Apply velocity to position
            player.position.add(player.velocity.clone().multiplyScalar(delta));
            
            // Ground collision
            if (player.position.y < 1.7) {
                player.position.y = 1.7;
                player.velocity.y = 0;
                player.isGrounded = true;
                player.isWallRunning = false;
            }
            
            // Bounds - larger for expanded map
            const zoneSize = 120;
            player.position.x = Math.max(-zoneSize, Math.min(zoneSize, player.position.x));
            player.position.z = Math.max(-zoneSize, Math.min(zoneSize, player.position.z));
            player.position.y = Math.max(1.7, Math.min(80, player.position.y));
            
            // Update crosshair targeting
            updateCrosshairTargeting();
            
            // Check portal interaction
            if (portalActive && portal) {
                const distance = player.position.distanceTo(portal.position);
                if (distance < 5) {
                    if (portalTriggerTime === 0) {
                        portalTriggerTime = performance.now();
                    } else if (performance.now() - portalTriggerTime > 1000) {
                        // Warp after 1 second in portal
                        if (gameStats.currentZone < 4) {
                            startZone(gameStats.currentZone + 1);
                        } else {
                            // Game completed
                            showEndGameScreen();
                        }
                        portalTriggerTime = 0;
                    }
                } else {
                    portalTriggerTime = 0;
                }
            }
            
            updateHealthBar();
            
            // Check for level up
            checkLevelUp();
        }

        // Check for level up
        function checkLevelUp() {
            if (playerExp >= nextLevelExp) {
                playerLevel++;
                playerExp -= nextLevelExp;
                nextLevelExp = 100 + (playerLevel - 1) * 50;
                
                // Level up benefits
                gameStats.maxPlayerHealth += 10;
                gameStats.playerHealth = gameStats.maxPlayerHealth;
                gameStats.playerDamage += 5;
                gameStats.playerSpeed += 0.5;
                
                // Apply level-specific bonuses
                applyLevelBonuses();
                
                // Update companion dragons
                // Note: In this version, we don't have companion dragons like in TRIOS
                
                updateHealthBar();
                updateLevelInfo();
                
                // Show level up notification
                const portalNotification = document.getElementById('portalNotification');
                portalNotification.textContent = `LEVEL UP! NOW LEVEL ${playerLevel}`;
                portalNotification.style.display = 'block';
                setTimeout(() => {
                    portalNotification.style.display = 'none';
                }, 2000);
            }
        }

        // Update crosshair targeting
        function updateCrosshairTargeting() {
            const crosshair = document.getElementById('crosshair');
            let isTargeting = false;
            
            // Check if player is targeting an enemy
            enemies.forEach(enemy => {
                if (enemy && enemy.health > 0) {
                    const cameraWorldPosition = new THREE.Vector3();
                    camera.getWorldPosition(cameraWorldPosition);
                    const direction = new THREE.Vector3();
                    camera.getWorldDirection(direction);
                    
                    const enemyDirection = new THREE.Vector3().subVectors(enemy.position, cameraWorldPosition).normalize();
                    const dot = direction.dot(enemyDirection);
                    
                    // If enemy is in front of player and within a certain angle
                    if (dot > 0.95) {
                        isTargeting = true;
                    }
                }
            });
            
            if (isTargeting) {
                crosshair.classList.add('targeting');
            } else {
                crosshair.classList.remove('targeting');
            }
        }

        // Update enemy health bars
        function updateEnemyHealthBars() {
            enemies.forEach(enemy => {
                if (enemy.healthBar && enemy.health > 0) {
                    // Calculate screen position
                    const vector = new THREE.Vector3();
                    enemy.getWorldPosition(vector);
                    vector.project(camera);
                    
                    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;
                    
                    // Position health bar above enemy
                    enemy.healthBar.style.display = 'block';
                    enemy.healthBar.style.left = `${x - 50}px`;
                    enemy.healthBar.style.top = `${y - 50}px`;
                    
                    // Update health fill
                    const healthPercent = (enemy.health / enemy.maxHealth) * 100;
                    enemy.healthFill.style.width = `${healthPercent}%`;
                } else if (enemy.healthBar) {
                    enemy.healthBar.style.display = 'none';
                }
            });
        }

        // Update enemies
        function updateEnemies(delta) {
            for (let i = 0; i < enemies.length; i++) {
                const enemy = enemies[i];
                if (!enemy || enemy.health <= 0) continue;
                
                // Update enemy AI
                updateEnemyAI(enemy, delta);
            }
        }

        // Enemy defeated
        function enemyDefeated(enemy) {
            if (!enemy) return;
            
            // Create explosion effect
            createExplosion(enemy.position, enemy.enemyType.color, 15);
            
            scene.remove(enemy);
            
            // Remove health bar
            if (enemy.healthBar) {
                enemy.healthBar.remove();
            }
            
            const index = enemies.indexOf(enemy);
            if (index > -1) enemies.splice(index, 1);
            
            gameStats.enemiesPurged++;
            gameStats.enemyCount--;
            
            if (gameStats.currentZone < 4) {
                gameStats.nodesCleared++;
                updateZoneProgress();
                
                // Check if all enemies are defeated
                if (enemies.length === 0 && !portalSpawned) {
                    createPortal();
                }
            } else {
                // Check if boss is defeated
                if (enemy.isBoss && !portalSpawned) {
                    createPortal();
                    
                    // Game completed - show victory message
                    const portalNotification = document.getElementById('portalNotification');
                    portalNotification.textContent = "ARCHITECT GUARDIAN DEFEATED! MISSION ACCOMPLISHED!";
                    portalNotification.style.display = 'block';
                    
                    // Save game on victory
                    saveGame();
                    
                    // Show end game screen after a delay
                    setTimeout(() => {
                        showEndGameScreen();
                    }, 3000);
                }
            }
            
            updateEnemyCounter();
            
            // Award experience
            playerExp += enemy.enemyType.xpReward;
            checkLevelUp();
            
            if (gameStats.currentZone >= gameStats.totalZones && enemies.length === 0 && !portalSpawned) {
                // Game victory
                createPortal();
            }
        }

        // Update projectiles
        function updateProjectiles(delta) {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const projectile = projectiles[i];
                if (!projectile) continue;
                
                // Move projectile
                projectile.position.add(projectile.userData.direction.clone().multiplyScalar(projectile.userData.speed * delta));
                
                // Update trail
                updateProjectileTrail(projectile);
                
                // Update lifetime
                projectile.userData.lifetime -= delta;
                if (projectile.userData.lifetime <= 0) {
                    scene.remove(projectile);
                    if (projectile.geometry) projectile.geometry.dispose();
                    if (projectile.material) projectile.material.dispose();
                    projectiles.splice(i, 1);
                    continue;
                }
                
                // Check collisions
                if (projectile.userData.isPlayerProjectile) {
                    // Player projectiles hit enemies
                    for (let j = 0; j < enemies.length; j++) {
                        const enemy = enemies[j];
                        if (enemy && enemy.health > 0 && projectile.position.distanceTo(enemy.position) < enemy.enemyType.size * 1.5) {
                            // Hit enemy
                            enemy.health -= projectile.userData.damage;
                            createExplosion(projectile.position, enemy.enemyType.color, 5);
                            
                            gameStats.shotsHit++;
                            
                            if (enemy.health <= 0) {
                                enemyDefeated(enemy);
                            }
                            
                            scene.remove(projectile);
                            if (projectile.geometry) projectile.geometry.dispose();
                            if (projectile.material) projectile.material.dispose();
                            projectiles.splice(i, 1);
                            break;
                        }
                    }
                } else {
                    // Enemy projectiles hit player
                    if (player && projectile.position.distanceTo(player.position) < 1.5) {
                        // Hit player
                        if (!immortalMode) {
                            gameStats.playerHealth -= projectile.userData.damage;
                            gameStats.damageTaken += projectile.userData.damage;
                            updateHealthBar();
                            createExplosion(projectile.position, 0x00ff00, 3);
                            checkPlayerDeath();
                        }
                        
                        scene.remove(projectile);
                        if (projectile.geometry) projectile.geometry.dispose();
                        if (projectile.material) projectile.material.dispose();
                        projectiles.splice(i, 1);
                    }
                }
            }
        }

        // Update FPS counter
        function updateFPS(delta) {
            frameCount++;
            lastFpsUpdate += delta;
            if (lastFpsUpdate >= 1.0) {
                fps = Math.round(frameCount / lastFpsUpdate);
                document.getElementById('fpsCounter').textContent = `FPS: ${fps}`;
                frameCount = 0;
                lastFpsUpdate = 0;
            }
        }

        // CPU auto-mode
        function updateCPUMode(delta) {
            if (!cpuMode || !player) return;
            
            // Auto-target nearest enemy
            let nearestEnemy = null;
            let minDistance = Infinity;
            enemies.forEach(enemy => {
                if (enemy && enemy.health > 0) {
                    const distance = player.position.distanceTo(enemy.position);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestEnemy = enemy;
                    }
                }
            });
            
            if (nearestEnemy) {
                // Look at the enemy
                const direction = new THREE.Vector3();
                direction.subVectors(nearestEnemy.position, player.position).normalize();
                const targetYaw = Math.atan2(direction.x, direction.z);
                const targetPitch = Math.asin(-direction.y);
                
                player.rotation.y = THREE.MathUtils.lerp(player.rotation.y, targetYaw, 0.1);
                camera.rotation.x = THREE.MathUtils.lerp(camera.rotation.x, targetPitch, 0.1);
                
                // Auto-fire
                controls.firePrimary = true;
                
                // Auto-move to maintain distance
                const idealDistance = 25;
                if (minDistance < idealDistance - 5) {
                    controls.moveBackward = true;
                    controls.moveForward = false;
                } else if (minDistance > idealDistance + 5) {
                    controls.moveForward = true;
                    controls.moveBackward = false;
                } else {
                    controls.moveForward = false;
                    controls.moveBackward = false;
                }
                
                // Strafe randomly
                if (Math.random() < 0.01) {
                    controls.moveLeft = !controls.moveLeft;
                    controls.moveRight = !controls.moveRight;
                }
                
                // Use ability when available
                if (abilityCooldown <= 0 && bandwidth >= 30 && Math.random() < 0.01) {
                    useClassAbility();
                }
            } else {
                controls.firePrimary = false;
                controls.moveForward = false;
                controls.moveBackward = false;
                controls.moveLeft = false;
                controls.moveRight = false;
            }
        }

        // Main animation loop
        function animate() {
            try {
                animationFrameId = requestAnimationFrame(animate);
                const delta = Math.min(clock.getDelta(), 0.1);
                runTime += delta;
                
                updateFPS(delta);
                
                switch(currentState) {
                    case GameState.PLAYING:
                        if (cpuMode) updateCPUMode(delta);
                        updatePlayer(delta);
                        updateEnemies(delta);
                        updateProjectiles(delta);
                        updateParticles(delta);
                        updateDataPacks(delta);
                        updateGridFloor(delta);
                        updatePortal(delta);
                        updateEnemyHealthBars();
                        break;
                }
                
                if (renderer && scene && camera) {
                    renderer.render(scene, camera);
                }
            } catch (error) {
                console.error("Error in animation loop:", error);
                // Attempt to recover by restarting animation
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }
                setTimeout(() => {
                    animate();
                }, 100);
            }
        }

        // Initialize the game when page loads
        window.addEventListener('load', init);
        
        // Font loading fallback
        const fontLink = document.querySelector('link[href*="Press+Start+2P"]');
        if (fontLink) {
            fontLink.addEventListener('load', () => {
                document.body.classList.add('font-loaded');
            });
            fontLink.addEventListener('error', () => {
                console.warn('Press Start 2P font failed to load, using fallback fonts');
            });
        }
    </script>
</body>
</html>
