<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>GALAXYCRAFT: TOWER DEFENSE</title>
  <meta name="description" content="Defend the data core against 100 waves of red drones in GALAXYCRAFT: TOWER DEFENSE">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Orbitron', monospace; }
    body { background: #000; color: #0f0; height: 100vh; overflow: hidden; touch-action: none; }
    #gameCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; }
    
    /* Minimal HUD */
    .hud-container { 
      position: fixed; bottom: 10px; left: 10px; z-index: 20; 
      background: rgba(0, 20, 0, 0.7); padding: 10px; 
      border: 1px solid #0f0; border-radius: 5px;
      font-size: 14px;
    }
    
    .core-health { 
      position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); 
      background: rgba(0, 20, 0, 0.7); padding: 8px 15px; border: 1px solid #0f0; 
      border-radius: 5px; font-size: 14px; color: #0f0; z-index: 20; 
    }
    
    .wave-info { 
      position: fixed; top: 10px; left: 50%; transform: translateX(-50%); 
      background: rgba(0, 20, 0, 0.7); padding: 8px 15px; border: 1px solid #0f0; 
      border-radius: 5px; font-size: 14px; color: #0f0; z-index: 20; 
    }
    
    /* Advanced Crosshair */
    .crosshair { 
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
      width: 40px; height: 40px; z-index: 10; pointer-events: none; 
    }
    .crosshair-inner {
      position: absolute; width: 6px; height: 6px; 
      background: #0f0; border-radius: 50%; top: 50%; left: 50%;
      transform: translate(-50%, -50%); box-shadow: 0 0 10px #0f0;
    }
    .crosshair-line {
      position: absolute; background: #0f0;
    }
    .crosshair-top { width: 2px; height: 12px; top: 0; left: 50%; transform: translateX(-50%); }
    .crosshair-bottom { width: 2px; height: 12px; bottom: 0; left: 50%; transform: translateX(-50%); }
    .crosshair-left { width: 12px; height: 2px; left: 0; top: 50%; transform: translateY(-50%); }
    .crosshair-right { width: 12px; height: 2px; right: 0; top: 50%; transform: translateY(-50%); }
    
    /* Console Messages */
    .console-message { 
      position: fixed; top: 50px; left: 50%; transform: translateX(-50%); 
      background: rgba(0, 20, 0, 0.8); padding: 8px 15px; border: 1px solid #0f0; 
      border-radius: 5px; color: #0f0; font-size: 14px; opacity: 0; 
      transition: opacity 0.5s ease; z-index: 25; text-align: center; 
    }
    .console-message.active { opacity: 1; }
    
    /* UI Toggle Button */
    .ui-toggle {
      position: fixed; top: 10px; right: 10px;
      width: 30px; height: 30px; background: rgba(0, 20, 0, 0.7);
      border: 1px solid #0f0; border-radius: 5px; color: #0f0;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer; z-index: 30;
    }
    
    /* Main Menu - Area 51 Style */
    .main-menu { 
      position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
      background: linear-gradient(rgba(0, 20, 0, 0.9), rgba(0, 10, 0, 0.95)); 
      display: flex; flex-direction: column; align-items: center; justify-content: center; 
      z-index: 100; color: #0f0; 
    }
    .game-title { 
      font-size: 48px; margin-bottom: 10px; 
      text-shadow: 0 0 20px rgba(0, 255, 0, 0.8); 
      letter-spacing: 4px; color: #0f0; text-align: center; 
      animation: titleGlow 3s infinite alternate; 
    }
    @keyframes titleGlow { 
      0% { text-shadow: 0 0 20px rgba(0, 255, 0, 0.8); } 
      100% { text-shadow: 0 0 30px rgba(0, 255, 0, 1), 0 0 40px rgba(0, 255, 0, 0.6); } 
    }
    .game-subtitle { 
      font-size: 24px; margin-bottom: 30px; 
      text-shadow: 0 0 10px rgba(0, 255, 0, 0.8); 
      color: #afa; text-align: center; 
    }
    .copyright {
      position: absolute; bottom: 20px; width: 100%;
      text-align: center; font-size: 12px; color: #0a0;
    }
    .menu-options { display: flex; flex-direction: column; gap: 15px; width: 250px; }
    .menu-btn { 
      padding: 12px 20px; 
      background: linear-gradient(145deg, #002200, #001100); 
      border: 1px solid #0f0; 
      color: #afa; font-size: 16px; text-align: center; 
      cursor: pointer; border-radius: 5px; 
      transition: all 0.3s ease; 
    }
    .menu-btn:hover { 
      background: linear-gradient(145deg, #003300, #002200); 
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.5); 
    }
    
    /* End Game Screen */
    .end-game-screen {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.95); display: none;
      flex-direction: column; align-items: center; justify-content: center;
      z-index: 200; color: #0f0;
    }
    .end-game-title {
      font-size: 36px; margin-bottom: 20px; text-align: center;
      color: #0f0; text-shadow: 0 0 20px rgba(0, 255, 0, 0.8);
    }
    .end-game-stats {
      background: rgba(0, 20, 0, 0.8); padding: 15px;
      border: 2px solid #0f0; border-radius: 5px;
      width: 80%; max-width: 400px; margin-bottom: 20px;
    }
    .stat-row {
      display: flex; justify-content: space-between;
      margin: 8px 0; font-size: 14px;
    }
    .end-game-buttons {
      display: flex; gap: 15px;
    }
    .end-game-btn {
      padding: 10px 20px; background: linear-gradient(145deg, #002200, #001100);
      border: 1px solid #0f0; color: #afa; font-size: 14px;
      cursor: pointer; border-radius: 5px; transition: all 0.3s ease;
    }
    .end-game-btn:hover {
      background: linear-gradient(145deg, #003300, #002200);
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
    }
    
    @media (max-width: 768px) {
      .game-title { font-size: 36px; }
      .game-subtitle { font-size: 18px; }
      .menu-btn { padding: 10px 16px; font-size: 14px; }
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    
    <!-- Minimal HUD -->
    <div class="hud-container" id="hudContainer">
      WEAPON: <span id="weaponName">NEURO-GATLING</span> | 
      AMMO: <span id="ammoCount">∞</span> |
      SCORE: <span id="scoreCount">0</span>
    </div>
    
    <div class="wave-info">WAVE: <span id="waveCount">1</span>/100 | DRONES: <span id="droneCount">0</span></div>
    
    <!-- Core Health -->
    <div class="core-health">CORE DATA: <span id="coreHealthText">10000</span>/10000</div>
    
    <!-- UI Toggle Button -->
    <div class="ui-toggle" id="uiToggle">≡</div>
    
    <!-- Advanced Crosshair -->
    <div class="crosshair" id="crosshair">
      <div class="crosshair-inner"></div>
      <div class="crosshair-line crosshair-top"></div>
      <div class="crosshair-line crosshair-bottom"></div>
      <div class="crosshair-line crosshair-left"></div>
      <div class="crosshair-line crosshair-right"></div>
    </div>
    
    <!-- Console Messages -->
    <div class="console-message" id="consoleMessage"></div>
    
    <!-- End Game Screen -->
    <div class="end-game-screen" id="endGameScreen">
      <h2 class="end-game-title" id="endGameTitle">MISSION COMPLETE</h2>
      <div class="end-game-stats">
        <div class="stat-row"><span>Final Score:</span><span id="finalScore">0</span></div>
        <div class="stat-row"><span>Waves Survived:</span><span id="finalWaves">0</span></div>
        <div class="stat-row"><span>Drones Destroyed:</span><span id="finalKills">0</span></div>
        <div class="stat-row"><span>Core Data Remaining:</span><span id="finalCore">0</span></div>
      </div>
      <div class="end-game-buttons">
        <div class="end-game-btn" id="playAgainBtn">PLAY AGAIN</div>
        <div class="end-game-btn" id="mainMenuBtn">MAIN MENU</div>
      </div>
    </div>
    
    <!-- Main Menu -->
    <div class="main-menu" id="mainMenu">
      <h1 class="game-title">GALAXYCRAFT</h1>
      <h2 class="game-subtitle">TOWER DEFENSE</h2>
      <div class="menu-options">
        <div class="menu-btn" id="startBtn">DEFEND THE CORE</div>
        <div class="menu-btn" id="quitBtn">QUIT</div>
      </div>
      <div class="copyright">WEBXOS © 2025</div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Game state and configuration
    const GameState = { MENU: 0, PLAYING: 1, WAVE_BREAK: 2, ENDGAME: 3 };
    let currentState = GameState.MENU;
    let mouseSensitivity = 0.002;
    let isPointerLocked = false;
    let uiVisible = true;
    
    // Initialize Three.js
    let scene, camera, renderer;
    let player, drones = [], projectiles = [], tower = [], particles = [];
    let clock = new THREE.Clock();
    let fps = 0, frameCount = 0, lastFpsUpdate = 0;
    
    // Player controls state
    const controls = {
      moveForward: false, moveBackward: false, moveLeft: false, moveRight: false,
      jump: false, jetpack: false, fire: false, isGrounded: false,
      weapon: 0, // 0: Gatling, 1: Shotgun, 2: Homing
      reload: false
    };
    
    // Weapon system
    const weapons = {
      current: 0,
      list: [
        {
          name: "Neuro-Gatling",
          damage: 50,
          fireRate: 0.1,
          ammo: Infinity,
          maxAmmo: Infinity,
          reloadTime: 1.5,
          range: 100,
          projectileSize: 0.1,
          projectileSpeed: 50,
          model: null,
          homingFactor: 0.1 // Small homing correction for auto-fire
        },
        {
          name: "Shotgun Neurots",
          damage: 60,
          fireRate: 0.8,
          ammo: 30,
          maxAmmo: 30,
          reloadTime: 2.0,
          range: 50,
          projectileSize: 0.2,
          projectileSpeed: 40,
          model: null,
          spread: 0.15 // Tighter spread
        },
        {
          name: "Homing Neurot",
          damage: 100,
          fireRate: 0.5,
          ammo: 10,
          maxAmmo: 10,
          reloadTime: 2.5,
          range: 80,
          projectileSize: 0.3,
          projectileSpeed: 35, // Faster homing projectiles
          model: null,
          homingFactor: 0.3 // Stronger homing
        }
      ]
    };
    
    // Player stats
    const playerStats = {
      health: 100, 
      kills: 0, 
      score: 0, 
      speed: 8.0, 
      jetpackForce: 25.0, 
      jumpForce: 10.0, 
      gravity: 15.0,
      velocity: new THREE.Vector3(),
      weaponCooldown: 0, 
      lastFire: 0,
      isReloading: false,
      shotsFired: 0,
      shotsHit: 0
    };
    
    // Game stats
    const gameStats = {
      wave: 1,
      maxWaves: 100,
      dronesPerWave: 5,
      dronesAlive: 0,
      dronesKilledThisWave: 0,
      coreHealth: 10000,
      maxCoreHealth: 10000,
      waveBreakTime: 5,
      waveBreakTimer: 0,
      attachedDrones: 0
    };
    
    // Initialize the game
    function init() {
      // Set up scene with neon green Area 51 theme
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x001100);
      scene.fog = new THREE.Fog(0x002200, 50, 300);
      
      // Set up camera (first-person view)
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2, 0);
      camera.rotation.order = 'YXZ';
      
      // Set up renderer
      renderer = new THREE.WebGLRenderer({ 
        canvas: document.getElementById('gameCanvas'),
        antialias: false,
        powerPreference: "high-performance"
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1));
      
      // Add lighting with green tint
      const ambientLight = new THREE.AmbientLight(0x00ff00, 0.2);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0x00ff00, 0.5);
      directionalLight.position.set(5, 10, 5);
      scene.add(directionalLight);
      
      // Create game environment
      createArena();
      createTower();
      createPlayer();
      createWeaponModels();
      
      // Set up event listeners
      setupEventListeners();
      
      // Start animation loop with target 30 FPS
      setInterval(() => {
        animate();
      }, 33); // ~30 FPS
      
      showConsoleMessage("GALAXYCRAFT: TOWER DEFENSE initialized. Protect the data core!");
    }
    
    // Create arena with neon green theme
    function createArena() {
      const groundGeometry = new THREE.CircleGeometry(200, 32);
      const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x003300 });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      scene.add(ground);
      
      // Add grid pattern to ground
      const gridGeometry = new THREE.PlaneGeometry(400, 400, 20, 20);
      const gridMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x00ff00, 
        wireframe: true,
        transparent: true,
        opacity: 0.2
      });
      const grid = new THREE.Mesh(gridGeometry, gridMaterial);
      grid.rotation.x = -Math.PI / 2;
      grid.position.y = 0.1;
      scene.add(grid);
      
      const wallGeometry = new THREE.CylinderGeometry(202, 202, 10, 32, 1, true);
      const wallMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x00aa00, 
        transparent: true, 
        opacity: 0.7 
      });
      const wall = new THREE.Mesh(wallGeometry, wallMaterial);
      wall.position.y = 5;
      scene.add(wall);
    }
    
    // Create the data core to defend
    function createTower() {
      const towerGeometry = new THREE.CylinderGeometry(15, 20, 60, 16);
      const towerMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x00aa00,
        emissive: 0x004400
      });
      const mainTower = new THREE.Mesh(towerGeometry, towerMaterial);
      mainTower.position.set(0, 30, 0);
      scene.add(mainTower);
      tower.push(mainTower);
      
      const coreGeometry = new THREE.SphereGeometry(8, 32, 32);
      const coreMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x00ff00,
        emissive: 0x006600
      });
      const core = new THREE.Mesh(coreGeometry, coreMaterial);
      core.position.set(0, 65, 0);
      scene.add(core);
      tower.push(core);
    }
    
    // Create player
    function createPlayer() {
      player = camera;
      player.position.set(0, 5, -50);
      player.velocity = new THREE.Vector3();
    }
    
    // Create weapon models
    function createWeaponModels() {
      // Gatling Gun (Neuro-Gatling)
      const gatlingGroup = new THREE.Group();
      const gatlingBase = new THREE.CylinderGeometry(0.3, 0.3, 2, 8);
      const gatlingMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
      const gatlingMesh = new THREE.Mesh(gatlingBase, gatlingMaterial);
      gatlingMesh.rotation.x = Math.PI / 2;
      gatlingMesh.position.set(0.5, -0.5, -1.5);
      gatlingGroup.add(gatlingMesh);
      
      const gatlingBarrel = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 8);
      const barrelMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
      const barrelMesh = new THREE.Mesh(gatlingBarrel, barrelMaterial);
      barrelMesh.rotation.x = Math.PI / 2;
      barrelMesh.position.set(0.5, -0.5, -2.2);
      gatlingGroup.add(barrelMesh);
      
      weapons.list[0].model = gatlingGroup;
      
      // Shotgun (Shotgun Neurots)
      const shotgunGroup = new THREE.Group();
      const shotgunBase = new THREE.BoxGeometry(0.4, 0.4, 1.5);
      const shotgunMaterial = new THREE.MeshBasicMaterial({ color: 0x0066ff });
      const shotgunMesh = new THREE.Mesh(shotgunBase, shotgunMaterial);
      shotgunMesh.position.set(0.5, -0.5, -1.5);
      shotgunGroup.add(shotgunMesh);
      
      // Triple barrels
      const shotgunBarrel1 = new THREE.CylinderGeometry(0.08, 0.08, 1.2, 8);
      const shotgunBarrel2 = new THREE.CylinderGeometry(0.08, 0.08, 1.2, 8);
      const shotgunBarrel3 = new THREE.CylinderGeometry(0.08, 0.08, 1.2, 8);
      
      const barrel1Mesh = new THREE.Mesh(shotgunBarrel1, barrelMaterial);
      barrel1Mesh.rotation.x = Math.PI / 2;
      barrel1Mesh.position.set(0.4, -0.5, -2.2);
      
      const barrel2Mesh = new THREE.Mesh(shotgunBarrel2, barrelMaterial);
      barrel2Mesh.rotation.x = Math.PI / 2;
      barrel2Mesh.position.set(0.5, -0.5, -2.2);
      
      const barrel3Mesh = new THREE.Mesh(shotgunBarrel3, barrelMaterial);
      barrel3Mesh.rotation.x = Math.PI / 2;
      barrel3Mesh.position.set(0.6, -0.5, -2.2);
      
      shotgunGroup.add(barrel1Mesh);
      shotgunGroup.add(barrel2Mesh);
      shotgunGroup.add(barrel3Mesh);
      
      weapons.list[1].model = shotgunGroup;
      
      // Homing Launcher (Homing Neurot)
      const launcherGroup = new THREE.Group();
      const launcherBase = new THREE.CylinderGeometry(0.4, 0.4, 1.2, 8);
      const launcherMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff });
      const launcherMesh = new THREE.Mesh(launcherBase, launcherMaterial);
      launcherMesh.rotation.x = Math.PI / 2;
      launcherMesh.position.set(0.5, -0.5, -1.5);
      launcherGroup.add(launcherMesh);
      
      const launcherBarrel = new THREE.CylinderGeometry(0.25, 0.3, 1.0, 8);
      const launcherBarrelMesh = new THREE.Mesh(launcherBarrel, barrelMaterial);
      launcherBarrelMesh.rotation.x = Math.PI / 2;
      launcherBarrelMesh.position.set(0.5, -0.5, -2.0);
      launcherGroup.add(launcherBarrelMesh);
      
      weapons.list[2].model = launcherGroup;
      
      // Add current weapon to player
      player.add(weapons.list[0].model);
    }
    
    // Switch weapon model
    function switchWeaponModel(index) {
      player.remove(weapons.list[weapons.current].model);
      weapons.current = index;
      player.add(weapons.list[index].model);
      
      document.getElementById('weaponName').textContent = weapons.list[index].name;
      document.getElementById('ammoCount').textContent = weapons.list[index].ammo === Infinity ? "∞" : weapons.list[index].ammo;
    }
    
    // Create drone
    function createDrone() {
      const drone = new THREE.Object3D();
      
      // Red triangle drone
      const bodyGeometry = new THREE.ConeGeometry(2, 3, 3);
      const bodyMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xff3333,
        emissive: 0x990000
      });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.rotation.x = Math.PI / 2;
      drone.add(body);
      
      // Position drone randomly around the arena
      const angle = Math.random() * Math.PI * 2;
      const distance = 180 + Math.random() * 15;
      const height = 5 + Math.random() * 60;
      
      drone.position.set(
        Math.cos(angle) * distance,
        height,
        Math.sin(angle) * distance
      );
      
      // Set drone properties
      drone.health = 100;
      drone.speed = 3 + Math.random() * 2 + (gameStats.wave * 0.1);
      drone.attackRange = 20;
      drone.attackCooldown = 0;
      drone.attackDamage = 5 + (gameStats.wave * 0.5);
      drone.attached = false;
      drone.attachTime = 0;
      drone.siphonRate = 10 + (gameStats.wave * 0.2);
      drone.attackHeight = 20 + Math.random() * 45;
      
      scene.add(drone);
      drones.push(drone);
      gameStats.dronesAlive++;
      
      document.getElementById('droneCount').textContent = gameStats.dronesAlive;
    }
    
    // Create projectile
    function createProjectile(position, direction, isPlayerProjectile = true, weaponType = 0) {
      const geometry = new THREE.SphereGeometry(weapons.list[weaponType].projectileSize, 8, 8);
      let color, speed, damage;
      
      switch(weaponType) {
        case 0: // Gatling
          color = 0x00ffff;
          speed = weapons.list[weaponType].projectileSpeed;
          damage = weapons.list[weaponType].damage;
          break;
        case 1: // Shotgun
          color = 0xffff00;
          speed = weapons.list[weaponType].projectileSpeed;
          damage = weapons.list[weaponType].damage;
          break;
        case 2: // Homing
          color = 0xff00ff;
          speed = weapons.list[weaponType].projectileSpeed;
          damage = weapons.list[weaponType].damage;
          break;
        default:
          color = 0xffffff;
          speed = 30;
          damage = 10;
      }
      
      const material = new THREE.MeshBasicMaterial({ 
        color: color,
        emissive: color
      });
      const projectile = new THREE.Mesh(geometry, material);
      projectile.position.copy(position);
      
      // Set projectile properties
      projectile.direction = direction.clone().normalize();
      projectile.speed = speed;
      projectile.damage = damage;
      projectile.isPlayerProjectile = isPlayerProjectile;
      projectile.weaponType = weaponType;
      projectile.lifetime = 5.0;
      projectile.homingTarget = null;
      
      scene.add(projectile);
      projectiles.push(projectile);
      
      if (isPlayerProjectile) {
        playerStats.shotsFired++;
      }
      
      return projectile;
    }
    
    // Create explosion effect
    function createExplosion(position, color = 0xff5500, size = 2.0, count = 15) {
      for (let i = 0; i < count; i++) {
        const particleGeometry = new THREE.SphereGeometry(0.2, 4, 4);
        const particleMaterial = new THREE.MeshBasicMaterial({ color: color });
        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
        particle.position.copy(position);
        
        const angle1 = Math.random() * Math.PI * 2;
        const angle2 = Math.random() * Math.PI * 2;
        const speed = 5 + Math.random() * 10;
        
        particle.velocity = new THREE.Vector3(
          Math.sin(angle1) * Math.cos(angle2) * speed,
          Math.sin(angle1) * Math.sin(angle2) * speed,
          Math.cos(angle1) * speed
        );
        
        particle.lifetime = 1.0 + Math.random() * 0.5;
        
        scene.add(particle);
        particles.push(particle);
      }
    }
    
    // Set up event listeners
    function setupEventListeners() {
      // Pointer lock controls
      document.addEventListener('click', () => {
        if (currentState === GameState.PLAYING && !isPointerLocked) {
          document.body.requestPointerLock();
        }
      });
      
      document.addEventListener('pointerlockchange', () => {
        isPointerLocked = document.pointerLockElement === document.body;
      });
      
      // Keyboard controls
      document.addEventListener('keydown', (e) => {
        switch(e.code) {
          case 'KeyW': controls.moveForward = true; break;
          case 'KeyA': controls.moveLeft = true; break;
          case 'KeyS': controls.moveBackward = true; break;
          case 'KeyD': controls.moveRight = true; break;
          case 'Space': 
            controls.fire = true;
            switchWeaponModel(0);
            break;
          case 'ShiftLeft': 
            controls.jetpack = true;
            break;
          case 'KeyR': controls.reload = true; break;
          case 'Escape': 
            if (currentState === GameState.PLAYING) {
              document.exitPointerLock();
              showMainMenu();
            }
            break;
        }
      });
      
      document.addEventListener('keyup', (e) => {
        switch(e.code) {
          case 'KeyW': controls.moveForward = false; break;
          case 'KeyA': controls.moveLeft = false; break;
          case 'KeyS': controls.moveBackward = false; break;
          case 'KeyD': controls.moveRight = false; break;
          case 'Space': controls.fire = false; break;
          case 'ShiftLeft': controls.jetpack = false; break;
          case 'KeyR': controls.reload = false; break;
        }
      });
      
      // Mouse controls
      document.addEventListener('mousedown', (e) => {
        if (currentState === GameState.PLAYING) {
          if (e.button === 0) {
            switchWeaponModel(1);
            fireWeapon();
          } else if (e.button === 2) {
            switchWeaponModel(2);
            fireWeapon();
          }
        }
      });
      
      document.addEventListener('mousemove', (e) => {
        if (currentState === GameState.PLAYING && isPointerLocked) {
          const movementX = e.movementX || 0;
          const movementY = e.movementY || 0;
          
          player.rotation.y -= movementX * mouseSensitivity;
          player.rotation.x -= movementY * mouseSensitivity;
          
          player.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, player.rotation.x));
        }
      });
      
      // Window resize handler
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
      
      // UI event listeners
      document.getElementById('startBtn').addEventListener('click', startGame);
      document.getElementById('quitBtn').addEventListener('click', () => {
        alert("Thank you for playing GALAXYCRAFT: TOWER DEFENSE!");
      });
      
      document.getElementById('playAgainBtn').addEventListener('click', startGame);
      document.getElementById('mainMenuBtn').addEventListener('click', showMainMenu);
      
      document.getElementById('uiToggle').addEventListener('click', toggleUI);
      
      // Prevent context menu
      document.addEventListener('contextmenu', (e) => e.preventDefault());
    }
    
    // Toggle UI visibility
    function toggleUI() {
      uiVisible = !uiVisible;
      const hud = document.getElementById('hudContainer');
      const waveInfo = document.querySelector('.wave-info');
      const coreHealth = document.querySelector('.core-health');
      
      if (uiVisible) {
        hud.style.display = 'block';
        waveInfo.style.display = 'block';
        coreHealth.style.display = 'block';
      } else {
        hud.style.display = 'none';
        waveInfo.style.display = 'none';
        coreHealth.style.display = 'none';
      }
    }
    
    // Fire weapon
    function fireWeapon() {
      const weapon = weapons.list[weapons.current];
      const now = Date.now();
      
      if (now - playerStats.lastFire < weapon.fireRate * 1000) return;
      if (weapon.ammo <= 0) {
        if (!playerStats.isReloading) {
          reloadWeapon();
        }
        return;
      }
      
      playerStats.lastFire = now;
      
      const direction = new THREE.Vector3(0, 0, -1);
      direction.applyQuaternion(player.quaternion);
      
      switch(weapons.current) {
        case 0: // Gatling (single shot with slight homing)
          const projectile = createProjectile(
            player.position.clone().add(direction.clone().multiplyScalar(1.5)), 
            direction, true, weapons.current
          );
          
          // Add slight homing to gatling projectiles
          let nearestDrone = null;
          let nearestDistance = Infinity;
          
          for (const drone of drones) {
            const distance = projectile.position.distanceTo(drone.position);
            if (distance < nearestDistance && distance < 50) {
              nearestDistance = distance;
              nearestDrone = drone;
            }
          }
          
          if (nearestDrone) {
            projectile.homingTarget = nearestDrone;
            projectile.homingFactor = weapon.homingFactor;
          }
          
          weapon.ammo--;
          break;
          
        case 1: // Shotgun (tight spread)
          for (let i = 0; i < 8; i++) {
            const spreadDirection = direction.clone();
            spreadDirection.x += (Math.random() - 0.5) * weapon.spread;
            spreadDirection.y += (Math.random() - 0.5) * weapon.spread;
            spreadDirection.z += (Math.random() - 0.5) * weapon.spread;
            spreadDirection.normalize();
            
            createProjectile(
              player.position.clone().add(direction.clone().multiplyScalar(1.5)), 
              spreadDirection, true, weapons.current
            );
          }
          weapon.ammo--;
          break;
          
        case 2: // Homing (strong homing)
          const homingProjectile = createProjectile(
            player.position.clone().add(direction.clone().multiplyScalar(1.5)), 
            direction, true, weapons.current
          );
          
          // Find nearest drone for homing
          let nearestHomingDrone = null;
          let nearestHomingDistance = Infinity;
          
          for (const drone of drones) {
            const distance = homingProjectile.position.distanceTo(drone.position);
            if (distance < nearestHomingDistance && distance < 80) {
              nearestHomingDistance = distance;
              nearestHomingDrone = drone;
            }
          }
          
          if (nearestHomingDrone) {
            homingProjectile.homingTarget = nearestHomingDrone;
            homingProjectile.homingFactor = weapon.homingFactor;
          }
          
          weapon.ammo--;
          break;
      }
      
      document.getElementById('ammoCount').textContent = weapon.ammo === Infinity ? "∞" : weapon.ammo;
      
      if (weapon.ammo <= 0 && !playerStats.isReloading) {
        reloadWeapon();
      }
    }
    
    // Reload weapon
    function reloadWeapon() {
      const weapon = weapons.list[weapons.current];
      if (weapon.ammo === weapon.maxAmmo) return;
      
      playerStats.isReloading = true;
      showConsoleMessage("RELOADING " + weapon.name.toUpperCase() + "...");
      
      setTimeout(() => {
        weapon.ammo = weapon.maxAmmo;
        document.getElementById('ammoCount').textContent = weapon.ammo === Infinity ? "∞" : weapon.ammo;
        playerStats.isReloading = false;
        showConsoleMessage(weapon.name.toUpperCase() + " RELOADED");
      }, weapon.reloadTime * 1000);
    }
    
    // Start game
    function startGame() {
      // Reset game state
      gameStats.wave = 1;
      gameStats.coreHealth = gameStats.maxCoreHealth;
      gameStats.dronesAlive = 0;
      gameStats.dronesKilledThisWave = 0;
      gameStats.attachedDrones = 0;
      
      playerStats.kills = 0;
      playerStats.score = 0;
      playerStats.health = 100;
      playerStats.shotsFired = 0;
      playerStats.shotsHit = 0;
      
      // Reset weapons
      weapons.list[0].ammo = Infinity;
      weapons.list[1].ammo = weapons.list[1].maxAmmo;
      weapons.list[2].ammo = weapons.list[2].maxAmmo;
      
      // Clear existing entities
      for (const drone of drones) {
        scene.remove(drone);
      }
      drones = [];
      
      for (const projectile of projectiles) {
        scene.remove(projectile);
      }
      projectiles = [];
      
      for (const particle of particles) {
        scene.remove(particle);
      }
      particles = [];
      
      // Reset player position
      player.position.set(0, 5, -50);
      player.rotation.set(0, 0, 0);
      player.velocity.set(0, 0, 0);
      
      // Switch to default weapon
      switchWeaponModel(0);
      
      // Update UI
      document.getElementById('waveCount').textContent = gameStats.wave;
      document.getElementById('droneCount').textContent = gameStats.dronesAlive;
      document.getElementById('coreHealthText').textContent = gameStats.coreHealth;
      document.getElementById('scoreCount').textContent = playerStats.score;
      
      // Hide menus
      document.getElementById('mainMenu').style.display = 'none';
      document.getElementById('endGameScreen').style.display = 'none';
      
      // Start first wave
      startWave();
      
      // Request pointer lock
      document.body.requestPointerLock();
      
      // Set game state
      currentState = GameState.PLAYING;
      
      showConsoleMessage("WAVE " + gameStats.wave + " INCOMING! DEFEND THE CORE!");
    }
    
    // Start wave
    function startWave() {
      const dronesToSpawn = gameStats.dronesPerWave + Math.floor(gameStats.wave * 0.5);
      
      for (let i = 0; i < dronesToSpawn; i++) {
        setTimeout(() => {
          if (currentState === GameState.PLAYING) {
            createDrone();
          }
        }, i * 500);
      }
      
      document.getElementById('waveCount').textContent = gameStats.wave;
    }
    
    // Show console message
    function showConsoleMessage(message, duration = 3000) {
      const consoleElement = document.getElementById('consoleMessage');
      consoleElement.textContent = message;
      consoleElement.classList.add('active');
      
      setTimeout(() => {
        consoleElement.classList.remove('active');
      }, duration);
    }
    
    // Show main menu
    function showMainMenu() {
      document.exitPointerLock();
      document.getElementById('mainMenu').style.display = 'flex';
      currentState = GameState.MENU;
    }
    
    // Show end game screen
    function showEndGameScreen(victory) {
      document.exitPointerLock();
      
      const endGameScreen = document.getElementById('endGameScreen');
      const endGameTitle = document.getElementById('endGameTitle');
      
      if (victory) {
        endGameTitle.textContent = "MISSION COMPLETE";
        endGameTitle.style.color = "#0f0";
      } else {
        endGameTitle.textContent = "CORE BREACHED";
        endGameTitle.style.color = "#f00";
      }
      
      document.getElementById('finalScore').textContent = playerStats.score;
      document.getElementById('finalWaves').textContent = gameStats.wave - 1;
      document.getElementById('finalKills').textContent = playerStats.kills;
      document.getElementById('finalCore').textContent = gameStats.coreHealth;
      
      endGameScreen.style.display = 'flex';
      currentState = GameState.ENDGAME;
    }
    
    // Update game logic
    function update(deltaTime) {
      if (currentState !== GameState.PLAYING) return;
      
      // Update player movement
      updatePlayerMovement(deltaTime);
      
      // Handle firing
      if (controls.fire) {
        fireWeapon();
      }
      
      // Handle reloading
      if (controls.reload && !playerStats.isReloading) {
        reloadWeapon();
      }
      
      // Update drones
      updateDrones(deltaTime);
      
      // Update projectiles
      updateProjectiles(deltaTime);
      
      // Update particles
      updateParticles(deltaTime);
      
      // Check wave completion
      if (gameStats.dronesAlive === 0) {
        if (gameStats.wave < gameStats.maxWaves) {
          gameStats.wave++;
          showConsoleMessage("WAVE " + gameStats.wave + " INCOMING!");
          startWave();
        } else {
          // Player has won
          showEndGameScreen(true);
        }
      }
      
      // Check core health
      if (gameStats.coreHealth <= 0) {
        showEndGameScreen(false);
      }
      
      // Update UI
      document.getElementById('coreHealthText').textContent = gameStats.coreHealth;
      document.getElementById('scoreCount').textContent = playerStats.score;
      
      // Update FPS counter
      updateFPS(deltaTime);
    }
    
    // Update player movement
    function updatePlayerMovement(deltaTime) {
      const moveSpeed = playerStats.speed * deltaTime;
      const moveVector = new THREE.Vector3();
      
      if (controls.moveForward) moveVector.z -= moveSpeed;
      if (controls.moveBackward) moveVector.z += moveSpeed;
      if (controls.moveLeft) moveVector.x -= moveSpeed;
      if (controls.moveRight) moveVector.x += moveSpeed;
      
      moveVector.applyQuaternion(player.quaternion);
      moveVector.y = 0; // Keep movement horizontal
      
      player.position.add(moveVector);
      
      // Apply gravity
      if (!controls.jetpack || player.position.y > 100) {
        player.velocity.y -= playerStats.gravity * deltaTime;
      } else if (controls.jetpack) {
        player.velocity.y += playerStats.jetpackForce * deltaTime;
      }
      
      // Apply velocity
      player.position.y += player.velocity.y * deltaTime;
      
      // Ground collision
      if (player.position.y < 2) {
        player.position.y = 2;
        player.velocity.y = 0;
        controls.isGrounded = true;
      } else {
        controls.isGrounded = false;
      }
      
      // Ceiling collision
      if (player.position.y > 100) {
        player.position.y = 100;
        player.velocity.y = 0;
      }
      
      // Arena boundary collision
      const playerPos = new THREE.Vector2(player.position.x, player.position.z);
      if (playerPos.length() > 195) {
        playerPos.normalize().multiplyScalar(195);
        player.position.x = playerPos.x;
        player.position.z = playerPos.y;
      }
    }
    
    // Update drones
    function updateDrones(deltaTime) {
      for (let i = drones.length - 1; i >= 0; i--) {
        const drone = drones[i];
        
        // Move drone toward core if not attached
        if (!drone.attached) {
          const corePosition = new THREE.Vector3(0, 65, 0);
          const direction = corePosition.clone().sub(drone.position).normalize();
          
          // Add some vertical movement to reach attack height
          const verticalDirection = Math.sign(drone.attackHeight - drone.position.y);
          direction.y = verticalDirection * 0.3;
          
          drone.position.add(direction.multiplyScalar(drone.speed * deltaTime));
          drone.lookAt(corePosition);
          
          // Check if drone is close enough to attach to core
          if (drone.position.distanceTo(corePosition) < drone.attackRange) {
            drone.attached = true;
            gameStats.attachedDrones++;
            showConsoleMessage("DRONE ATTACHED TO CORE!", 2000);
          }
        } else {
          // Drone is attached, siphon data from core
          drone.attachTime += deltaTime;
          
          if (drone.attackCooldown <= 0) {
            gameStats.coreHealth -= drone.siphonRate;
            drone.attackCooldown = 1.0;
            
            // Create siphon effect
            createExplosion(drone.position, 0xff0000, 1.0, 3);
          } else {
            drone.attackCooldown -= deltaTime;
          }
        }
        
        // Check if drone is dead
        if (drone.health <= 0) {
          createExplosion(drone.position, 0xff5500, 3.0, 20);
          scene.remove(drone);
          drones.splice(i, 1);
          gameStats.dronesAlive--;
          playerStats.kills++;
          playerStats.score += 100;
          
          if (drone.attached) {
            gameStats.attachedDrones--;
          }
          
          document.getElementById('droneCount').textContent = gameStats.dronesAlive;
        }
      }
    }
    
    // Update projectiles
    function updateProjectiles(deltaTime) {
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const projectile = projectiles[i];
        
        // Apply homing if applicable
        if (projectile.homingTarget && projectile.homingTarget.health > 0) {
          const directionToTarget = projectile.homingTarget.position.clone().sub(projectile.position).normalize();
          projectile.direction.lerp(directionToTarget, projectile.homingFactor);
          projectile.direction.normalize();
        }
        
        // Move projectile
        projectile.position.add(projectile.direction.clone().multiplyScalar(projectile.speed * deltaTime));
        
        // Check lifetime
        projectile.lifetime -= deltaTime;
        if (projectile.lifetime <= 0) {
          scene.remove(projectile);
          projectiles.splice(i, 1);
          continue;
        }
        
        // Check collisions
        if (projectile.isPlayerProjectile) {
          // Player projectiles hit drones
          for (const drone of drones) {
            if (projectile.position.distanceTo(drone.position) < 3) {
              drone.health -= projectile.damage;
              createExplosion(projectile.position, 0x00ffff, 1.0, 5);
              scene.remove(projectile);
              projectiles.splice(i, 1);
              playerStats.shotsHit++;
              break;
            }
          }
        }
        
        // Check boundary collision
        if (projectile.position.length() > 200) {
          scene.remove(projectile);
          projectiles.splice(i, 1);
        }
      }
    }
    
    // Update particles
    function updateParticles(deltaTime) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        
        particle.position.add(particle.velocity.clone().multiplyScalar(deltaTime));
        particle.velocity.y -= playerStats.gravity * deltaTime * 0.5;
        
        particle.lifetime -= deltaTime;
        if (particle.lifetime <= 0) {
          scene.remove(particle);
          particles.splice(i, 1);
        }
      }
    }
    
    // Update FPS counter
    function updateFPS(deltaTime) {
      frameCount++;
      lastFpsUpdate += deltaTime;
      
      if (lastFpsUpdate >= 1.0) {
        fps = frameCount;
        frameCount = 0;
        lastFpsUpdate = 0;
      }
    }
    
    // Animation loop
    function animate() {
      const deltaTime = Math.min(clock.getDelta(), 0.1);
      
      if (currentState === GameState.PLAYING) {
        update(deltaTime);
      }
      
      renderer.render(scene, camera);
    }
    
    // Initialize the game when the page loads
    window.addEventListener('load', init);
  </script>
</body>
</html>
