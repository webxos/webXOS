<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WebXOS DepthSim ‚Äî Inline renderer (no external Three)</title>
  <style>
    :root{--neon:#39ff14;--bg:#0a0a0a;--panel:#111}
    *{box-sizing:border-box;margin:0;padding:0;font-family:Courier,monospace}
    html,body{height:100%}
    body{background:var(--bg);color:var(--neon);overflow:hidden}
    .wrap{display:grid;grid-template-columns:360px 1fr;height:100vh;gap:1px;background:var(--neon)}
    .panel{background:var(--panel);display:flex;flex-direction:column}
    .head{padding:12px;border-bottom:1px solid var(--neon);display:flex;justify-content:space-between;align-items:center}
    .head h1{font-size:1.05rem;text-shadow:0 0 6px var(--neon)}
    .left{padding:12px;display:flex;flex-direction:column;gap:10px}
    .note{font-size:0.9rem;color:#bbb}
    .controls{display:flex;flex-direction:column;gap:8px}
    .btn{padding:10px;border:1px solid var(--neon);background:transparent;color:var(--neon);cursor:pointer;border-radius:6px;text-align:left}
    .btn:hover{background:var(--neon);color:#000}
    .terminal{flex:1;overflow:auto;padding:8px;border:1px solid rgba(57,255,20,0.06);background:rgba(0,0,0,0.15)}
    .line{margin-bottom:8px;display:flex}
    .prompt{color:#8a2be2;margin-right:8px}
    .right{position:relative;display:flex;flex-direction:column}
    canvas#threeCanvas{width:100%;height:100%;display:block;background:#050505}
    .editor{position:absolute;top:16px;right:16px;background:rgba(6,6,6,0.92);padding:12px;border:1px solid var(--neon);border-radius:6px;width:340px;max-height:80vh;overflow:auto}
    .drop{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;border:2px dashed rgba(57,255,20,0.06);pointer-events:none;opacity:0;transition:opacity .18s}
    .drop.active{pointer-events:all;opacity:1;background:rgba(57,255,20,0.02)}
    .small{font-size:0.85rem;color:#bbb}
    @media(max-width:900px){ .wrap{grid-template-columns:1fr;grid-template-rows:auto 1fr} .editor{width:92%;right:4%;top:auto;bottom:16px} }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <div class="head"><h1>webXOS DepthSim ‚Äî Hero Scene</h1><div class="small">Inline canvas renderer (no external Three)</div></div>

      <div class="left">
        <div class="note">Upload a JPEG image or MP4 video (first frame) to generate a 3D-style hero scene rendered directly into the canvas. Drag & drop supported. No network required.</div>

        <div class="controls">
          <button id="uploadImageBtn" class="btn">üìÅ Upload JPEG Image</button>
          <button id="uploadVideoBtn" class="btn">üéû Upload MP4 Video</button>
          <button id="addSkyBtn" class="btn">üå§ Add Procedural Sky</button>
          <button id="resetBtn" class="btn">üîÅ Reset Scene</button>
        </div>

        <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
          <div class="small">Export scene:</div>
          <button id="exportBtn" class="btn" style="flex:1">Export JSON</button>
        </div>

        <div class="terminal" id="terminal" aria-live="polite"></div>

        <div class="small" style="margin-top:6px">Supported: JPEG only; MP4 only (first frame). This uses an inline renderer that mimics Three.js visuals without external libs.</div>
      </div>

    </div>

    <div class="panel right">
      <canvas id="threeCanvas" title="3D Scene Canvas"></canvas>

      <div class="editor" id="editor">
        <div style="font-weight:600;margin-bottom:8px">Hero Scene Editor</div>

        <div style="margin-bottom:8px">
          <label class="small">Point size</label><br/>
          <input id="pointSize" type="range" min="0.5" max="6" step="0.1" value="2" style="width:100%"/>
        </div>

        <div style="margin-bottom:8px">
          <label class="small">Depth scale</label><br/>
          <input id="depthScale" type="range" min="0" max="40" step="0.5" value="12" style="width:100%"/>
        </div>

        <div style="margin-bottom:8px">
          <label class="small">Auto-rotate</label><input id="autoRotate" type="checkbox" checked style="margin-left:8px"/>
        </div>

        <div style="margin-top:6px" class="small">Drag & drop JPEG/MP4 onto the canvas to generate the hero scene.</div>

        <div style="margin-top:10px;"><strong class="small">Scene Objects</strong></div>
        <div id="objectList" style="margin-top:6px"></div>
      </div>

      <div class="drop" id="dropZone"><div class="small">Drop JPEG or MP4 here</div></div>
    </div>
  </div>

  <script>
  (function(){

    // Programmatic file inputs
    const imageInput = document.createElement('input'); imageInput.type='file'; imageInput.accept='image/jpeg,image/jpg'; imageInput.style.display='none'; document.body.appendChild(imageInput);
    const videoInput = document.createElement('input'); videoInput.type='file'; videoInput.accept='video/mp4'; videoInput.style.display='none'; document.body.appendChild(videoInput);

    // UI refs
    const uploadImageBtn = document.getElementById('uploadImageBtn');
    const uploadVideoBtn = document.getElementById('uploadVideoBtn');
    const addSkyBtn = document.getElementById('addSkyBtn');
    const resetBtn = document.getElementById('resetBtn');
    const exportBtn = document.getElementById('exportBtn');
    const terminal = document.getElementById('terminal');
    const dropZone = document.getElementById('dropZone');
    const canvas = document.getElementById('threeCanvas');
    const ctx = canvas.getContext('2d');
    const pointSizeEl = document.getElementById('pointSize');
    const depthScaleEl = document.getElementById('depthScale');
    const autoRotateEl = document.getElementById('autoRotate');
    const objectListEl = document.getElementById('objectList');

    function log(msg, level){
      const row = document.createElement('div'); row.className='line';
      const p = document.createElement('span'); p.className='prompt'; p.textContent='webxos:~$';
      const t = document.createElement('span'); t.textContent=' ' + msg;
      if (level === 'error') t.style.color = '#ff6666';
      if (level === 'success') t.style.color = '#7fffb1';
      row.appendChild(p); row.appendChild(t); terminal.appendChild(row); terminal.scrollTop = terminal.scrollHeight;
    }

    // Scene data (inline renderer representation)
    let sceneState = {
      bgImage: null,
      skyCanvas: null,
      points: null, // { positions: Float32Array, colors: Float32Array, count }
      rotation: 0,
      lastTime: 0
    };

    // Resize canvas to fill container
    function resizeCanvas(){
      canvas.width = canvas.clientWidth * devicePixelRatio;
      canvas.height = canvas.clientHeight * devicePixelRatio;
      ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
      render();
    }
    window.addEventListener('resize', resizeCanvas);

    // Simple "3D-like" renderer:
    // - draws background image as plane
    // - draws point cloud by projecting 3D positions onto 2D screen using a simple camera transform and perspective
    // - supports rotation around Y axis (auto-rotate)
    function render(time){
      if (!time) time = performance.now();
      const dt = (time - (sceneState.lastTime || time)) / 1000;
      sceneState.lastTime = time;
      if (autoRotateEl.checked) sceneState.rotation += dt * 0.25;

      // clear
      ctx.clearRect(0,0,canvas.width,canvas.height);

      const w = canvas.clientWidth;
      const h = canvas.clientHeight;

      // draw sky if present (full-screen)
      if (sceneState.skyCanvas){
        ctx.drawImage(sceneState.skyCanvas, 0, 0, w, h);
      } else {
        // subtle dark gradient
        const g = ctx.createLinearGradient(0,0,0,h);
        g.addColorStop(0, '#071022');
        g.addColorStop(1, '#050505');
        ctx.fillStyle = g; ctx.fillRect(0,0,w,h);
      }

      // draw background plane (centered)
      if (sceneState.bgImage){
        const img = sceneState.bgImage;
        // fit to width with letterbox
        const ratio = img.width / img.height;
        let bw = w * 0.96;
        let bh = bw / ratio;
        if (bh > h * 0.85) { bh = h * 0.85; bw = bh * ratio; }
        const bx = (w - bw)/2, by = (h - bh)/2 - 20;
        ctx.save();
        ctx.globalAlpha = 1;
        ctx.drawImage(img, bx, by, bw, bh);
        ctx.restore();
      }

      // draw point cloud with simple perspective
      if (sceneState.points && sceneState.points.count > 0){
        const pts = sceneState.points;
        // simple camera parameters
        const cam = {
          fov: 65 * Math.PI/180,
          aspect: w / h,
          near: 0.1,
          far: 1000,
          z: 30
        };
        const f = 1 / Math.tan(cam.fov / 2);
        const cx = w/2, cy = h/2;
        const rot = sceneState.rotation;
        const cosR = Math.cos(rot), sinR = Math.sin(rot);
        const psize = parseFloat(pointSizeEl.value);

        // draw farther points first (painter's)
        const projected = [];
        for (let i=0;i<pts.count;i++){
          const xi = pts.positions[i*3 + 0];
          const yi = pts.positions[i*3 + 1];
          const zi = pts.positions[i*3 + 2];
          // rotate around Y
          const rx = xi * cosR - zi * sinR;
          const rz = xi * sinR + zi * cosR;
          const ry = yi;
          // camera at (0,0,cam.z) looking at origin
          const dz = cam.z - rz;
          const depthScale = parseFloat(depthScaleEl.value) || 12;
          const zcam = dz / (depthScale / 12);
          const clip = zcam > 0.1;
          if (!clip) continue;
          // perspective projection
          const px = (rx / zcam) * (f * cam.aspect) * cx + cx;
          const py = (ry / zcam) * f * cy + cy;
          projected.push({ px, py, zcam, r: pts.colors[i*3], g: pts.colors[i*3+1], b: pts.colors[i*3+2] });
        }
        projected.sort((a,b)=> b.zcam - a.zcam);
        // draw points
        for (let p of projected){
          ctx.beginPath();
          const size = Math.max(0.5, psize * (12 / Math.max(4, p.zcam)));
          ctx.fillStyle = `rgba(${Math.round(p.r*255)},${Math.round(p.g*255)},${Math.round(p.b*255)},0.95)`;
          ctx.arc(p.px, p.py, size, 0, Math.PI*2);
          ctx.fill();
        }
      }

      requestAnimationFrame(render);
    }

    // Depth estimator (brightness + radial center bias), returns depth array and builds 3D point positions
    function estimateDepthAndPoints(image, options = {}){
      const maxDim = 700;
      let w = image.naturalWidth || image.width, h = image.naturalHeight || image.height;
      const scale = Math.min(1, maxDim / Math.max(w,h));
      w = Math.max(1, Math.floor(w * scale)); h = Math.max(1, Math.floor(h * scale));
      const c = document.createElement('canvas'); c.width = w; c.height = h;
      const gctx = c.getContext('2d'); gctx.drawImage(image, 0, 0, w, h);
      const data = gctx.getImageData(0,0,w,h).data;
      const depth = new Float32Array(w*h);
      for (let y=0;y<h;y++){
        for (let x=0;x<w;x++){
          const i = (y*w + x)*4;
          const r = data[i]/255, g = data[i+1]/255, b = data[i+2]/255;
          const bright = 0.2126*r + 0.7152*g + 0.0722*b;
          const cx = (x/w - 0.5)*2, cy = (y/h - 0.5)*2;
          const radial = Math.exp(-(cx*cx + cy*cy) * 0.9);
          depth[y*w + x] = bright * 0.9 + radial * 0.5;
        }
      }
      // normalize
      let min = Infinity, max = -Infinity;
      for (let i=0;i<depth.length;i++){ if (depth[i]<min) min=depth[i]; if (depth[i]>max) max=depth[i]; }
      const range = (max - min) || 1;
      for (let i=0;i<depth.length;i++) depth[i] = (depth[i] - min) / range;

      // build positions and colors, sample with step
      const maxPoints = 12000;
      const step = Math.max(1, Math.floor(Math.sqrt((w*h)/maxPoints)));
      const positions = [];
      const colors = [];
      for (let y=0;y<h;y+=step){
        for (let x=0;x<w;x+=step){
          const idx = y*w + x;
          const px = idx*4;
          const r = data[px]/255, g = data[px+1]/255, b = data[px+2]/255;
          const d = depth[idx];
          // map to 3D space: X right, Y up, Z forward
          const X = (x / w - 0.5) * 16;
          const Y = (0.5 - y / h) * 9;
          const Z = (d - 0.5) * (parseFloat(depthScaleEl.value) || 12);
          positions.push(X, Y, Z);
          colors.push(r, g, b);
        }
      }
      return { positions: new Float32Array(positions), colors: new Float32Array(colors), count: positions.length / 3 };
    }

    // Create background plane (store image)
    function createBackground(image){
      sceneState.bgImage = image;
      refreshObjectList();
      log('Background added', 'success');
    }

    // Create point cloud and store in sceneState
    function createPointCloudFromImage(image){
      const p = estimateDepthAndPoints(image);
      sceneState.points = p;
      refreshObjectList();
      log('Point cloud generated (' + p.count + ' points)', 'success');
    }

    // Procedural sky
    function addProceduralSky(){
      const c = document.createElement('canvas'); c.width=1024; c.height=512; const s = c.getContext('2d');
      const g = s.createLinearGradient(0,0,0,c.height); g.addColorStop(0,'#0b2a5b'); g.addColorStop(0.5,'#1e90ff'); g.addColorStop(1,'#ffe6b3');
      s.fillStyle = g; s.fillRect(0,0,c.width,c.height);
      for (let i=0;i<200;i++){ s.fillStyle = 'rgba(255,255,255,'+Math.random()*0.6+')'; s.fillRect(Math.random()*c.width, Math.random()*c.height, Math.random()*2, Math.random()*2); }
      sceneState.skyCanvas = c;
      refreshObjectList();
      log('Procedural sky added', 'success');
    }

    function clearScene(){
      sceneState.bgImage = null; sceneState.points = null; sceneState.skyCanvas = null; sceneState.rotation = 0;
      refreshObjectList();
      log('Scene cleared', 'info');
    }

    function refreshObjectList(){
      objectListEl.innerHTML = '';
      const list = [];
      if (sceneState.bgImage) list.push('Background Plane');
      if (sceneState.points) list.push('Image Point Cloud');
      if (sceneState.skyCanvas) list.push('Procedural Sky');
      list.forEach(n=>{
        const el = document.createElement('div'); el.textContent = n; el.style.padding='6px'; el.style.border='1px solid rgba(57,255,20,0.04)';
        objectListEl.appendChild(el);
      });
    }

    // Extract first frame from MP4 file
    function extractFirstFrameFromVideo(file){
      return new Promise((resolve,reject)=>{
        const url = URL.createObjectURL(file);
        const v = document.createElement('video');
        v.muted = true; v.crossOrigin = 'anonymous'; v.preload = 'auto'; v.src = url;
        let done = false;
        const timeout = setTimeout(()=> {
          if (!done) { URL.revokeObjectURL(url); reject(new Error('Video load timeout')); }
        }, 10000);
        v.addEventListener('loadeddata', ()=>{
          try { v.currentTime = 0.02; } catch(e){ /* ignore */ }
        });
        v.addEventListener('seeked', ()=>{
          if (done) return;
          const c = document.createElement('canvas'); c.width = v.videoWidth; c.height = v.videoHeight;
          const g = c.getContext('2d'); g.drawImage(v,0,0,c.width,c.height);
          const img = new Image();
          img.onload = ()=> { done = true; clearTimeout(timeout); URL.revokeObjectURL(url); resolve(img); };
          img.onerror = ()=> { done = true; clearTimeout(timeout); URL.revokeObjectURL(url); reject(new Error('Frame capture failed')); };
          img.src = c.toDataURL('image/jpeg');
        });
        v.addEventListener('error', ()=> { clearTimeout(timeout); URL.revokeObjectURL(url); reject(new Error('Video load error')); });
      });
    }

    // File handling
    function handleImageFile(file){
      if (!file) return log('No file', 'error');
      const t = (file.type || '').toLowerCase();
      if (!t.includes('jpeg') && !t.includes('jpg')) return log('Only JPEG supported', 'error');
      const reader = new FileReader();
      reader.onerror = ()=> log('File read error', 'error');
      reader.onload = (ev)=>{
        const img = new Image();
        img.onload = ()=> { createBackground(img); createPointCloudFromImage(img); };
        img.onerror = ()=> log('Invalid image', 'error');
        img.src = ev.target.result;
      };
      reader.readAsDataURL(file);
    }

    function handleVideoFile(file){
      if (!file) return log('No file', 'error');
      const t = (file.type || '').toLowerCase();
      if (!t.includes('mp4')) return log('Only MP4 supported', 'error');
      extractFirstFrameFromVideo(file).then(img=>{
        createBackground(img); createPointCloudFromImage(img);
      }).catch(err=> log('Video frame error: ' + err.message, 'error'));
    }

    // Drag & drop
    function preventDefaults(e){ e.preventDefault(); e.stopPropagation(); }
    ['dragenter','dragover','dragleave','drop'].forEach(ev => canvas.addEventListener(ev, preventDefaults));
    canvas.addEventListener('dragover', ()=> dropZone.classList.add('active'));
    canvas.addEventListener('dragleave', ()=> dropZone.classList.remove('active'));
    canvas.addEventListener('drop', (e)=>{
      dropZone.classList.remove('active');
      const f = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
      if (!f) return log('No file dropped', 'error');
      const t = (f.type || '').toLowerCase();
      if (t.includes('jpeg') || t.includes('jpg')) handleImageFile(f);
      else if (t.includes('mp4')) handleVideoFile(f);
      else log('Unsupported file type. Use JPEG or MP4', 'error');
    });

    // UI wiring
    uploadImageBtn.addEventListener('click', ()=> imageInput.click());
    uploadVideoBtn.addEventListener('click', ()=> videoInput.click());
    addSkyBtn.addEventListener('click', ()=> addProceduralSky());
    resetBtn.addEventListener('click', ()=> clearScene());
    exportBtn.addEventListener('click', ()=>{
      const payload = { bg: !!sceneState.bgImage, points: sceneState.points ? sceneState.points.count : 0, sky: !!sceneState.skyCanvas, depthScale: depthScaleEl.value };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type:'application/json' });
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'hero_scene.json'; document.body.appendChild(a); a.click(); a.remove();
      log('Scene exported', 'success');
    });

    imageInput.addEventListener('change', (e)=> { const f = e.target.files && e.target.files[0]; if (!f) return; handleImageFile(f); imageInput.value=''; });
    videoInput.addEventListener('change', (e)=> { const f = e.target.files && e.target.files[0]; if (!f) return; handleVideoFile(f); videoInput.value=''; });

    pointSizeEl.addEventListener('input', ()=> { /* size applied in render loop */ });
    depthScaleEl.addEventListener('input', ()=> { log('Changed depth scale ‚Äî re-upload image to regenerate depth with new scale', 'info'); });

    // Initialize canvas size and start renderer
    function start(){
      resizeCanvas();
      requestAnimationFrame(render);
      log('Inline renderer ready. Upload JPEG or MP4 (first frame) or drag & drop on the canvas.', 'success');
    }

    start();

  })();
  </script>
</body>
</html>
