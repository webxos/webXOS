<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PERSONAL MIRROR</title>
    <meta name="theme-color" content="#000000">
    <link rel="manifest" href="data:application/manifest+json,{
        \"name\": \"PERSONAL MIRROR\",
        \"short_name\": \"Mirror AR\",
        \"description\": \"Webcam-based AR object tagging with AutoCAD scene\",
        \"start_url\": \"./\",
        \"display\": \"fullscreen\",
        \"background_color\": \"#000000\",
        \"theme_color\": \"#000000\",
        \"icons\": [
            {
                \"src\": \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkyIiBoZWlnaHQ9IjE5MiIgdmlld0JveD0iMCAwIDE5MiAxOTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxOTIiIGhlaWdodD0iMTkyIiBmaWxsPSIjMDAwMDAwIi8+CjxwYXRoIGQ9Ik05NiAxMjhMMTI4IDk2SDY0TDEyOCA2NEw5NiAzMkw2NCA2NEgxMjhMNjQgOTZIMTI4LDk2IDEyOFoiIGZpbGw9IiMwMGZmMDAiLz4KPC9zdmc+Cg==\",
                \"sizes\": \"192x192\",
                \"type\": \"image/svg+xml\"
            }
        ]
    }">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1640029074/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1620248257/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/face_mesh.js"></script>
    <style>
        *{margin:0;padding:0;box-sizing:border-box;font-family:'Press Start 2P',cursive;image-rendering:pixelated}
        body{background:#000;color:#0f0;overflow:hidden;height:100vh;user-select:none;-webkit-tap-highlight-color:transparent}
        #appContainer{position:relative;width:100%;height:100vh;overflow:hidden}
        .matrix-grid{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(rgba(0,255,0,0.1)1px,transparent 1px),linear-gradient(90deg,rgba(0,255,0,0.1)1px,transparent 1px);background-size:16px 16px;opacity:0.3}
        .crt-overlay{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(to bottom,transparent 50%,rgba(0,20,0,0.1)50%);background-size:100% 4px;z-index:5;pointer-events:none;animation:scanline 8s linear infinite}
        @keyframes scanline{0%{background-position:0 0}100%{background-position:0 100%}}
        #visualizationContainer{position:absolute;top:0;left:0;width:100%;height:100%;z-index:2}
        #visualizationCanvas{width:100%;height:100%;display:block}
        #webcamCanvas{position:absolute;top:0;left:0;width:100%;height:100%;z-index:2}
        .top-banner{position:absolute;top:0;left:0;width:100%;height:40px;background:rgba(255,0,255,0.9);border-bottom:2px solid #f0f;display:flex;align-items:center;justify-content:center;z-index:12;animation:glitch 3s infinite}
        @keyframes glitch{0%,100%{transform:translateX(0)}5%{transform:translateX(-2px)}10%{transform:translateX(2px)}15%{transform:translateX(-1px)}20%{transform:translateX(1px)}25%,75%{transform:translateX(0)}55%{transform:translateX(-1px) skewX(-2deg)}60%{transform:translateX(1px) skewX(2deg)}65%{transform: translateX(-1px) skewX(-1deg)}70%{transform: translateX(1px) skewX(1deg)}}
        .top-banner::before{content:'';position:absolute;top:0;left:-10%;width:120%;height:100%;background:linear-gradient(90deg,transparent,rgba(255,255,255,0.2),transparent);animation:shimmer 2s infinite}
        @keyframes shimmer{0%{transform:translateX(-100%)}100%{transform:translateX(100%)}}
        .top-banner-text{font-size:12px;color:#000;text-shadow:1px 1px 0 #fff;letter-spacing:1px}
        .ctrl-btn{width:48px;height:48px;background:#000;border:2px solid #0f0;color:#0f0;font-size:6px;display:flex;align-items:center;justify-content:center;cursor:pointer;box-shadow:2px 2px 0 #000;transform:skew(-2deg);transition:background 0.1s,color 0.1s;touch-action:none;position:absolute;z-index:11}
        .ctrl-btn:hover,.ctrl-btn:active{background:#0f0;color:#000}
        .ctrl-btn.active{background:#0f0;color:#000}
        #webcamBtn{top:33%;left:16px;transform:translateY(-50%);border-color:#0f0;color:#0f0}
        #objectBtn{top:50%;left:16px;transform:translateY(-50%);border-color:#ff0;color:#ff0}
        #wallsBtn{top:66%;left:16px;transform:translateY(-50%);border-color:#0ff;color:#0ff}
        .popup{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,10,0,0.98);border:none;padding:0;z-index:100;font-size:8px;color:#0f0}
        .popup.minimized{width:200px;height:150px;top:16px;left:16px}
        .popup-close{position:absolute;top:4px;right:4px;width:24px;height:24px;background:#000;border:2px solid #f00;color:#f00;font-size:6px;cursor:pointer;display:flex;align-items:center;justify-content:center;touch-action:none}
        .popup-close:hover,.popup-close:active{background:#f00;color:#000}
        .popup-btn{width:48px;height:48px;margin:8px;padding:8px;background:#000;font-size:6px;cursor:pointer;text-align:center;touch-action:none;position:absolute;bottom:16px}
        .popup-btn:hover,.popup-btn:active{color:#000}
        #minimizeWebcam{left:calc(50% - 56px);border:2px solid #f00;color:#f00}
        #minimizeWebcam:hover,#minimizeWebcam:active{background:#f00}
        #liveArBtn{left:50%;border:2px solid #f0f;color:#f0f}
        #liveArBtn:hover,#liveArBtn:active{background:#f0f}
        .webcam-mesh-container{width:100%;height:100%;background:#000;border:none;position:relative;overflow:hidden}
        .webcam-grid{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(rgba(0,255,0,0.1)1px,transparent 1px),linear-gradient(90deg,rgba(0,255,0,0.1)1px,transparent 1px);background-size:20px 20px;z-index:1}
        #calibStatus{font-size:6px;color:#ff0;margin:8px 16px;position:absolute;bottom:0;left:0}
        #levelStatus{font-size:6px;color:#0ff;margin:8px 16px;position:absolute;bottom:16px;left:0}
        #hudWarning{position:absolute;top:20%;left:50%;transform:translate(-50%,-50%);color:#f00;font-size:12px;text-shadow:1px 1px 0 #000;z-index:11;display:none}
        .terminal{position:absolute;bottom:16px;left:50%;transform:translateX(-50%);width:90%;max-width:600px;height:120px;background:rgba(0,10,0,0.9);border:2px solid #0f0;padding:8px;font-size:8px;color:#0f0;overflow-y:auto;z-index:10}
        .terminal-line{margin-bottom:4px}
        .terminal-link{cursor:pointer;color:#0ff;text-decoration:underline}
        .terminal-link:hover{color:#ff0}
        #radarCanvas{position:absolute;bottom:16px;right:16px;width:100px;height:100px;border:2px solid #0f0;background:#000;z-index:3}
        @media (min-width:768px){.ctrl-btn,.popup-btn{width:56px;height:56px;font-size:8px}.popup-close{width:32px;height:32px;font-size:8px}}
        .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
        .ctrl-btn:focus,.popup-btn:focus{outline:2px solid #0ff;outline-offset:2px}
    </style>
</head>
<body>
<div id="appContainer">
    <div class="matrix-grid"></div>
    <div class="crt-overlay"></div>
    <div class="top-banner">
        <div class="top-banner-text">PERSONAL MIRROR</div>
    </div>
    <div id="visualizationContainer">
        <canvas id="visualizationCanvas"></canvas>
    </div>
    <canvas id="webcamCanvas"></canvas>
    <div id="ideInterface">
        <button id="webcamBtn" class="ctrl-btn" aria-label="Toggle Webcam">MIRROR</button>
        <button id="objectBtn" class="ctrl-btn" aria-label="Detect Objects">OBJECT</button>
        <button id="wallsBtn" class="ctrl-btn" aria-label="Toggle Walls">WALLS</button>
        <div id="hudWarning">USER MISSING</div>
        <div class="terminal" id="terminal"></div>
    </div>
    <div class="popup" id="webcamPopup">
        <div class="popup-close" aria-label="Close Webcam">X</div>
        <div class="webcam-mesh-container" id="webcamMeshContainer">
            <canvas id="webcamCanvasPopup"></canvas>
            <div class="webcam-grid"></div>
            <canvas id="radarCanvas"></canvas>
        </div>
        <div id="calibStatus">IDLE</div>
        <div id="levelStatus">LEVEL: CENTERED</div>
        <button class="popup-btn" id="minimizeWebcam" aria-label="Minimize Webcam">MIN</button>
        <button class="popup-btn" id="liveArBtn" aria-label="Toggle LIVE/AR">LIVE</button>
    </div>
</div>

<script>
    let scene, cam, ren, clock, raycaster, mouse;
    let userObj, objects = [], walls = [], faceObj;
    let userDetected = false, wallsVisible = true, isLiveMode = true;
    let stream, faceMesh, camera;
    let animationId = null, objectId = 1, terminalLines = [];
    let levelAngle = 0, isCentered = true, faceYaw = 0;
    let selectedObject = null, isDragging = false;
    const user = new THREE.Vector3(0, 1, 0);

    const $ = s => document.querySelector(s);
    const $$ = s => document.querySelectorAll(s);

    function init() {
        if (!THREE || !FaceMesh || !Camera) {
            console.error('Dependencies missing: THREE, FaceMesh, or Camera');
            logToTerminal('Error: Dependencies not loaded');
            return;
        }
        init3D();
        setupFaceDetection();
        setupServiceWorker();
        setupEventListeners();
        animate();
        logToTerminal('System initialized');
    }

    function init3D() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        cam.position.set(0, 2, 5);
        const canvas = $('#visualizationCanvas');
        if (!canvas) {
            console.error('Canvas not found');
            logToTerminal('Error: Canvas not found');
            return;
        }
        ren = new THREE.WebGLRenderer({ canvas, antialias: false, powerPreference: "low-power" });
        ren.setSize(window.innerWidth, window.innerHeight);
        ren.setPixelRatio(1);
        ren.domElement.style.width = '100%';
        ren.domElement.style.height = '100%';
        clock = new THREE.Clock();
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();
        scene.add(new THREE.AmbientLight(0x003300));
        const dir = new THREE.DirectionalLight(0x00ff00, 0.4);
        dir.position.set(5, 10, 5);
        scene.add(dir);
        const gridSize = 20, gridDiv = 20;
        const gridMat = new THREE.LineBasicMaterial({ color: 0x004400 });
        const gridGeo = new THREE.BufferGeometry();
        const positions = [];
        for (let i = -gridSize / 2; i <= gridSize / 2; i += gridSize / gridDiv) {
            positions.push(i, 0, -gridSize / 2, i, 0, gridSize / 2);
            positions.push(-gridSize / 2, 0, i, gridSize / 2, 0, i);
        }
        gridGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        scene.add(new THREE.LineSegments(gridGeo, gridMat));
        userObj = new THREE.Mesh(
            new THREE.SphereGeometry(0.2, 3, 3),
            new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true })
        );
        userObj.position.copy(user);
        userObj.userData = { id: 'USER', type: 'user', label: 'UserFace' };
        scene.add(userObj);
        faceObj = userObj;
        const arrowGeo = new THREE.ConeGeometry(0.1, 0.3, 3);
        const arrowMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const arrow = new THREE.Mesh(arrowGeo, arrowMat);
        arrow.position.set(0, 0.3, 0);
        arrow.rotation.x = Math.PI / 2;
        userObj.add(arrow);
        initRoom();
        cam.lookAt(user);
        try {
            ren.render(scene, cam);
        } catch (e) {
            console.error('Rendering failed:', e);
            logToTerminal('Error: Rendering failed');
        }
    }

    function initRoom() {
        const wallMat = new THREE.MeshBasicMaterial({ color: 0x00b7eb, wireframe: true, transparent: true, opacity: 0.5 });
        const wallGeo = new THREE.PlaneGeometry(10, 5);
        const wallPositions = [
            { pos: [0, 2.5, -5], rot: [0, 0, 0] },
            { pos: [-5, 2.5, 0], rot: [0, Math.PI / 2, 0] },
            { pos: [5, 2.5, 0], rot: [0, -Math.PI / 2, 0] },
            { pos: [0, 0, 0], rot: [Math.PI / 2, 0, 0] }
        ];
        wallPositions.forEach(({ pos, rot }) => {
            const wall = new THREE.Mesh(wallGeo, wallMat);
            wall.position.set(...pos);
            wall.rotation.set(...rot);
            wall.visible = wallsVisible;
            scene.add(wall);
            walls.push(wall);
        });
    }

    function toggleWalls() {
        wallsVisible = !wallsVisible;
        walls.forEach(wall => wall.visible = wallsVisible);
        $('#wallsBtn').classList.toggle('active');
        logToTerminal(`Walls ${wallsVisible ? 'enabled' : 'disabled'}`);
    }

    function setupFaceDetection() {
        try {
            faceMesh = new FaceMesh({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/${file}`
            });
            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            faceMesh.onResults(onFaceMeshResults);
        } catch (e) {
            console.error('FaceMesh setup failed:', e);
            logToTerminal('Error: FaceMesh setup failed');
        }
    }

    function onFaceMeshResults(results) {
        userDetected = results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0;
        $('#hudWarning').style.display = userDetected ? 'none' : 'block';
        const canvas = $('#webcamCanvasPopup');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (userDetected && isLiveMode) {
            if (results.image) {
                ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
            }
            const landmarks = results.multiFaceLandmarks[0];
            try {
                drawConnectors(ctx, landmarks, FACEMESH_TESSELATION, { color: '#C0C0C070', lineWidth: 1 });
                drawConnectors(ctx, landmarks, FACEMESH_RIGHT_EYE, { color: '#FF3030', lineWidth: 1 });
                drawConnectors(ctx, landmarks, FACEMESH_LEFT_EYE, { color: '#30FF30', lineWidth: 1 });
                drawConnectors(ctx, landmarks, FACEMESH_FACE_OVAL, { color: '#E0E0E0', lineWidth: 1 });
            } catch (e) {
                console.error('FaceMesh drawing failed:', e);
            }
            const center = landmarks[1];
            const cx = center.x * canvas.width;
            const cy = center.y * canvas.height;
            ctx.strokeStyle = '#00FF00';
            ctx.lineWidth = 1;
            for (let i = -40; i <= 40; i += 20) {
                ctx.beginPath();
                ctx.moveTo(cx - 40, cy + i);
                ctx.lineTo(cx + 40, cy + i);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(cx + i, cy - 40);
                ctx.lineTo(cx + i, cy + 40);
                ctx.stroke();
            }
            const leftCheek = landmarks[234];
            const rightCheek = landmarks[454];
            faceYaw = Math.atan2(
                (rightCheek.x - leftCheek.x) * canvas.width,
                (rightCheek.z - leftCheek.z) * 1000
            ) * 180 / Math.PI;
            updateLevel(landmarks);
        } else if (!isLiveMode) {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            objects.forEach(obj => {
                const pos = new THREE.Vector3().copy(obj.position).sub(user);
                const dist = pos.length();
                if (dist < 5) {
                    const size = obj.userData.size * 50;
                    const screenX = canvas.width / 2 + (pos.x / dist) * 100;
                    const screenY = canvas.height / 2 - (pos.y / dist) * 100;
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(screenX - size / 2, screenY - size / 2, size, size);
                }
            });
        }
        updateRadar();
        $('#calibStatus').textContent = `LIVE - OBJECTS: ${objects.length}`;
        if (userDetected) {
            userObj.position.set(0, 1, 0);
            userObj.children[0].rotation.y = -faceYaw * Math.PI / 180;
        }
    }

    function updateLevel(landmarks) {
        const leftEye = landmarks[33];
        const rightEye = landmarks[263];
        levelAngle = Math.atan2(rightEye.y - leftEye.y, rightEye.x - leftEye.x) * 180 / Math.PI;
        isCentered = Math.abs(levelAngle) < 5;
        $('#levelStatus').textContent = `LEVEL: ${isCentered ? 'CENTERED' : `${levelAngle.toFixed(1)}Â°`}`;
    }

    function detectObjects() {
        if (objects.length >= 300) {
            logToTerminal('Max 300 objects reached');
            return;
        }
        const types = ['phone', 'cup', 'book', 'pen'];
        const type = types[Math.floor(Math.random() * types.length)];
        const id = String(objectId++).padStart(3, '0');
        const angle = (Math.random() * 360) * Math.PI / 180;
        const distance = 1 + Math.random() * 2;
        const size = 0.1 + Math.random() * 0.2;
        const pos = new THREE.Vector3(
            user.x + Math.sin(angle) * distance,
            user.y - 0.5,
            user.z + Math.cos(angle) * distance
        );
        const geometry = new THREE.BoxGeometry(size, size, size, 3, 3, 3);
        const material = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
        const obj = new THREE.Mesh(geometry, material);
        obj.position.copy(pos);
        obj.userData = { id, type, distance, size, label: `${type}${id}`, lastPos: pos.clone(), redTime: Date.now() };
        scene.add(obj);
        objects.push(obj);
        logToTerminal(`Detected ${obj.userData.label} [ID:${id}] at ${distance.toFixed(1)}m, size ${size.toFixed(2)}m`, id);
        if (navigator.serviceWorker?.controller) {
            navigator.serviceWorker.controller.postMessage({
                type: 'store_object',
                object: { id, type, position: pos, size, label: obj.userData.label }
            });
        }
        setTimeout(() => {
            if (obj.material) obj.material.color.set(0x00ff00);
        }, 3000);
    }

    function trackObjects() {
        objects.forEach(obj => {
            const currentPos = obj.position.clone();
            if (currentPos.distanceTo(obj.userData.lastPos) > 0.1) {
                obj.material.color.set(0xff0000);
                obj.userData.lastPos = currentPos.clone();
                obj.userData.redTime = Date.now();
                logToTerminal(`Object [ID:${obj.userData.id}] moved`);
                if (navigator.serviceWorker?.controller) {
                    navigator.serviceWorker.controller.postMessage({
                        type: 'store_object',
                        object: { id: obj.userData.id, type: obj.userData.type, position: currentPos, size: obj.userData.size, label: obj.userData.label }
                    });
                }
                setTimeout(() => {
                    if (obj.material && Date.now() - obj.userData.redTime >= 3000) {
                        obj.material.color.set(0x00ff00);
                    }
                }, 3000);
            }
        });
    }

    function editObjectLabel(id) {
        const obj = objects.find(o => o.userData.id === id) || (id === 'USER' ? userObj : null);
        if (!obj) return;
        const newLabel = prompt(`Enter new label for ${obj.userData.label}:`, obj.userData.label);
        if (newLabel) {
            obj.userData.label = newLabel;
            logToTerminal(`Updated ${obj.userData.label} [ID:${id}]`, id);
            if (navigator.serviceWorker?.controller && id !== 'USER') {
                navigator.serviceWorker.controller.postMessage({
                    type: 'store_object',
                    object: { id, type: obj.userData.type, position: obj.position, size: obj.userData.size, label: newLabel }
                });
            }
        }
        selectedObject = obj;
        objects.forEach(o => o.material.color.set(o.userData.redTime ? 0xff0000 : 0x00ff00));
        if (obj !== userObj) obj.material.color.set(0xffff00);
    }

    function handleWebcam() {
        if (stream) {
            stopWebcam();
        }
        $('#calibStatus').textContent = 'REQUESTING CAMERA ACCESS...';
        navigator.mediaDevices.getUserMedia({ 
            video: { facingMode: 'user', width: { ideal: 480 }, height: { ideal: 360 } } 
        })
        .then(s => {
            stream = s;
            const video = document.createElement('video');
            video.id = 'webcamVideo';
            video.srcObject = stream;
            video.autoplay = true;
            video.playsInline = true;
            video.style.display = 'none';
            document.body.appendChild(video);
            camera = new Camera(video, {
                onFrame: async () => await faceMesh.send({ image: video }),
                width: 480,
                height: 360
            });
            camera.start();
            const canvas = $('#webcamCanvas');
            const canvasPopup = $('#webcamCanvasPopup');
            canvas.width = 480;
            canvas.height = 360;
            canvasPopup.width = window.innerWidth;
            canvasPopup.height = window.innerHeight;
            $('#calibStatus').textContent = 'LIVE - OBJECT DETECTION ACTIVE';
            $('#webcamBtn').classList.add('active');
            openPopup('webcamPopup');
            logToTerminal('Webcam initialized');
        })
        .catch(error => {
            const msg = error.name === 'NotAllowedError' ? 'CAMERA ACCESS DENIED' :
                        error.name === 'NotFoundError' ? 'NO CAMERA FOUND' :
                        error.name === 'OverconstrainedError' ? 'CAMERA NOT SUPPORTED' : 'CAMERA ERROR';
            $('#calibStatus').textContent = msg;
            $('#webcamBtn').classList.remove('active');
            logToTerminal(`Webcam error: ${msg}`);
        });
    }

    function minimizeWebcam() {
        $('#webcamPopup').classList.toggle('minimized');
        $('#minimizeWebcam').textContent = $('#webcamPopup').classList.contains('minimized') ? 'MAX' : 'MIN';
        logToTerminal('Webcam minimized/maximized');
    }

    function stopWebcam() {
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            stream = null;
            if (camera) camera.stop();
            const video = $('#webcamVideo');
            if (video) video.remove();
            $('#webcamBtn').classList.remove('active');
            $('#calibStatus').textContent = 'WEBCAM STOPPED';
            $('#webcamPopup').style.display = 'none';
            logToTerminal('Webcam stopped');
        }
    }

    function toggleLiveAr() {
        isLiveMode = !isLiveMode;
        $('#liveArBtn').textContent = isLiveMode ? 'LIVE' : 'AR';
        $('#liveArBtn').classList.toggle('active');
        logToTerminal(`Switched to ${isLiveMode ? 'LIVE' : 'AR'} mode`);
    }

    function updateRadar() {
        const canvas = $('#radarCanvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, width, height);
        ctx.strokeStyle = '#0f0';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(width/2, height/2, 40, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(width/2, height/2, 20, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(width/2, 10);
        ctx.lineTo(width/2, height - 10);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(10, height/2);
        ctx.lineTo(width - 10, height/2);
        ctx.stroke();
        const pulseAngle = (Date.now() % 4000) / 4000 * Math.PI * 2;
        ctx.strokeStyle = '#ff0000';
        ctx.beginPath();
        ctx.moveTo(width/2, height/2);
        ctx.lineTo(width/2 + Math.cos(pulseAngle) * 40, height/2 + Math.sin(pulseAngle) * 40);
        ctx.stroke();
        objects.forEach(obj => {
            const dx = obj.position.x - user.x;
            const dz = obj.position.z - user.z;
            const distance = Math.hypot(dx, dz);
            if (distance < 5) {
                const angle = Math.atan2(dx, dz) - faceYaw * Math.PI / 180;
                const radarX = width/2 + Math.sin(angle) * (distance / 5) * 40;
                const radarY = height/2 - Math.cos(angle) * (distance / 5) * 40;
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(radarX, radarY, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        });
        ctx.fillStyle = '#0ff';
        ctx.beginPath();
        ctx.arc(width/2, height/2, 2, 0, Math.PI * 2);
        ctx.fill();
    }

    function logToTerminal(message, id = null) {
        const timestamp = new Date().toLocaleTimeString();
        const line = id ? `<span class="terminal-link" data-id="${id}">[${timestamp}] ${message}</span>` : `[${timestamp}] ${message}`;
        terminalLines.push(line);
        if (terminalLines.length > 10) terminalLines.shift();
        const terminal = $('#terminal');
        terminal.innerHTML = terminalLines.map(l => `<div class="terminal-line">${l}</div>`).join('');
        terminal.scrollTop = terminal.scrollHeight;
        if (id) {
            const link = terminal.querySelector(`[data-id="${id}"]`);
            if (link) link.addEventListener('click', () => editObjectLabel(id));
        }
    }

    function setupServiceWorker() {
        if ('serviceWorker' in navigator) {
            const swScript = `
                const CACHE_NAME = 'personal-mirror-v1';
                const urlsToCache = [
                    '/',
                    'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js',
                    'https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1640029074/camera_utils.js',
                    'https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1620248257/drawing_utils.js',
                    'https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/face_mesh.js',
                    'https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap'
                ];
                let objects = [];
                self.addEventListener('install', event => {
                    self.skipWaiting();
                    event.waitUntil(
                        caches.open(CACHE_NAME).then(cache => cache.addAll(urlsToCache))
                    );
                });
                self.addEventListener('activate', event => self.clients.claim());
                self.addEventListener('fetch', event => {
                    event.respondWith(
                        caches.match(event.request).then(response => response || fetch(event.request))
                    );
                });
                self.addEventListener('message', event => {
                    if (event.data.type === 'store_object') {
                        objects = objects.filter(obj => obj.id !== event.data.object.id);
                        objects.push(event.data.object);
                        if (objects.length > 300) objects.shift();
                    } else if (event.data.type === 'get_objects') {
                        self.clients.matchAll().then(clients => {
                            clients.forEach(client => client.postMessage({ type: 'objects', objects }));
                        });
                    }
                });
            `;
            const swBlob = new Blob([swScript], { type: 'application/javascript' });
            const swUrl = URL.createObjectURL(swBlob);
            navigator.serviceWorker.register(swUrl).then(() => {
                navigator.serviceWorker.addEventListener('message', event => {
                    if (event.data.type === 'objects') {
                        event.data.objects.forEach(obj => {
                            if (objects.length >= 300) return;
                            const geometry = new THREE.BoxGeometry(obj.size, obj.size, obj.size, 3, 3, 3);
                            const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
                            const mesh = new THREE.Mesh(geometry, material);
                            mesh.position.set(obj.position.x, obj.position.y, obj.position.z);
                            mesh.userData = { id: obj.id, type: obj.type, distance: obj.distance, size: obj.size, label: obj.label, lastPos: mesh.position.clone() };
                            scene.add(mesh);
                            objects.push(mesh);
                            logToTerminal(`Loaded ${obj.label} [ID:${obj.id}] from cache`, obj.id);
                        });
                    }
                });
                navigator.serviceWorker.controller?.postMessage({ type: 'get_objects' });
            }).catch(e => {
                console.error('ServiceWorker registration failed:', e);
                logToTerminal('Error: ServiceWorker registration failed');
            });
        }
    }

    function setupEventListeners() {
        $('#webcamBtn').addEventListener('click', handleWebcam);
        $('#objectBtn').addEventListener('click', detectObjects);
        $('#wallsBtn').addEventListener('click', toggleWalls);
        $('#minimizeWebcam').addEventListener('click', minimizeWebcam);
        $('#liveArBtn').addEventListener('click', toggleLiveAr);
        $('#visualizationCanvas').addEventListener('mousedown', onCanvasMouseDown);
        $('#visualizationCanvas').addEventListener('mousemove', onCanvasMouseMove);
        $('#visualizationCanvas').addEventListener('mouseup', () => isDragging = false);
        $('#appContainer').addEventListener('click', (e) => {
            if ($('#webcamPopup').classList.contains('minimized') && !e.target.closest('#webcamPopup')) {
                $('#webcamPopup').style.display = 'none';
                $('#visualizationContainer').style.display = 'block';
                $('#ideInterface').style.display = 'block';
                logToTerminal('Returned to 3D scene');
            }
        });
        $$('.popup-close').forEach(button => {
            button.addEventListener('click', stopWebcam);
        });
        window.addEventListener('resize', () => {
            cam.aspect = window.innerWidth / window.innerHeight;
            cam.updateProjectionMatrix();
            ren.setSize(window.innerWidth, window.innerHeight);
            const canvasPopup = $('#webcamCanvasPopup');
            const aspect = 480 / 360;
            canvasPopup.width = window.innerWidth;
            canvasPopup.height = window.innerWidth / aspect;
            if (canvasPopup.height > window.innerHeight) {
                canvasPopup.height = window.innerHeight;
                canvasPopup.width = window.innerHeight * aspect;
            }
        }, { passive: true });
        window.addEventListener('beforeunload', cleanup);
    }

    function onCanvasMouseDown(event) {
        event.preventDefault();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, cam);
        const intersects = raycaster.intersectObjects([...objects, userObj]);
        if (intersects.length > 0) {
            selectedObject = intersects[0].object;
            isDragging = true;
            if (!isDragging) editObjectLabel(selectedObject.userData.id);
        } else {
            selectedObject = null;
            objects.forEach(obj => obj.material.color.set(obj.userData.redTime ? 0xff0000 : 0x00ff00));
        }
    }

    function onCanvasMouseMove(event) {
        if (isDragging && selectedObject) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, cam);
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -1);
            const intersect = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, intersect);
            selectedObject.position.copy(intersect);
            logToTerminal(`Moved ${selectedObject.userData.label} [ID:${selectedObject.userData.id}]`);
        }
    }

    function cleanup() {
        if (animationId) ren.setAnimationLoop(null);
        if (stream) stopWebcam();
        if (scene) {
            scene.traverse(object => {
                if (object.geometry) object.geometry.dispose();
                if (object.material) {
                    if (Array.isArray(object.material)) {
                        object.material.forEach(mat => mat.dispose());
                    } else {
                        object.material.dispose();
                    }
                }
            });
        }
    }

    function animate() {
        trackObjects();
        objects.forEach(obj => {
            if (obj.userData.type === 'phone') {
                obj.rotation.y += clock.getDelta() * 0.3;
            }
        });
        cam.position.set(user.x, user.y + 2, user.z + 5);
        cam.lookAt(user);
        ren.render(scene, cam);
    }

    function openPopup(id) {
        $$('.popup').forEach(popup => popup.style.display = 'none');
        $('#' + id).style.display = 'block';
        $('#' + id).classList.remove('minimized');
        $('#minimizeWebcam').textContent = 'MIN';
    }

    window.addEventListener('load', () => {
        try {
            init();
            ren.setAnimationLoop(animate);
        } catch (e) {
            console.error('Initialization failed:', e);
            logToTerminal('Error: Initialization failed');
        }
    });
</script>
</body>
</html>
