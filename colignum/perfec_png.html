<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#000000">
  <title>COLIGNUM ¬∑ 8K export ¬∑ comfy prompt studio</title>
  <style>
    * {
      box-sizing: border-box;
      user-select: none;
      font-family: 'Courier New', Courier, monospace;
    }
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #fff;
      color: #000;
      transition: background-color 0.1s, color 0.1s;
    }
    body.inverted {
      background: #000;
      color: #fff;
    }
    body.inverted .toolbar {
      background: #111;
      border-bottom: 2px solid #fff;
    }
    body.inverted .toolbar button {
      background: #000;
      color: #fff;
      border: 2px solid #fff;
    }
    body.inverted .toolbar button:hover {
      background: #333;
    }
    body.inverted .toolbar button.active {
      background: #444;
      transform: translate(2px, 2px);
      box-shadow: 2px 2px 0 #fff;
    }
    body.inverted .toolbar input {
      background: #000;
      color: #fff;
      border: 2px solid #fff;
    }
    body.inverted .canvas-container {
      background: #000;
    }
    body.inverted .node {
      background: #000;
      color: #fff;
      border-color: #fff;
      box-shadow: 8px 8px 0 #fff;
    }
    body.inverted .node .drag-bar {
      background: #333;
      border-bottom: 1px solid #fff;
    }
    body.inverted .node .delete-btn {
      background: #fff;
      color: #000;
      border: 1px solid #000;
    }
    body.inverted .node .resize-handle {
      background: #fff;
      border-color: #000;
    }
    body.inverted .text-label {
      background: #000;
      color: #fff;
      border-color: #fff;
      box-shadow: 4px 4px 0 #fff;
    }
    body.inverted .text-label .text-drag {
      background: #333;
      border-bottom: 1px solid #fff;
    }
    body.inverted .text-label .delete-btn {
      background: #fff;
      color: #000;
      border: 1px solid #000;
    }
    body.inverted .grid-bg {
      background-image: 
        linear-gradient(#333 1px, transparent 1px),
        linear-gradient(90deg, #333 1px, transparent 1px);
    }
    .grid-bg {
      background-image: 
        linear-gradient(#ccc 1px, transparent 1px),
        linear-gradient(90deg, #ccc 1px, transparent 1px);
      background-size: 40px 40px;
    }

    #app {
      display: flex;
      flex-direction: column;
      height: 100vh;
      width: 100vw;
    }

    .toolbar {
      padding: 12px 16px;
      background: #f0f0f0;
      border-bottom: 2px solid #000;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      flex-shrink: 0;
    }
    .toolbar button {
      background: #fff;
      border: 2px solid #000;
      color: #000;
      padding: 8px 18px;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      border-radius: 0px;
      box-shadow: 4px 4px 0 #000;
      transition: 0.05s linear;
      font-family: inherit;
    }
    .toolbar button:active {
      transform: translate(2px, 2px);
      box-shadow: 2px 2px 0 #000;
    }
    .toolbar button.active {
      background: #ccc;
      transform: translate(2px, 2px);
      box-shadow: 2px 2px 0 #000;
    }
    .toolbar input {
      width: 70px;
      padding: 6px;
      border: 2px solid #000;
      background: #fff;
      color: #000;
      font-weight: bold;
      text-align: center;
      box-shadow: 2px 2px 0 #000;
    }
    .toolbar span {
      margin-left: auto;
      font-size: 1.2rem;
      font-weight: bold;
      letter-spacing: 1px;
    }
    .toolbar .brand {
      font-size: 1.4rem;
      margin-right: 10px;
      border-right: 2px solid #000;
      padding-right: 20px;
    }
    body.inverted .brand {
      border-color: #fff;
    }

    .canvas-wrapper {
      flex: 1;
      overflow: auto;
      position: relative;
      background: #fff;
    }
    .canvas-container {
      position: relative;
      width: 2500px;
      height: 2000px;
      background: #fff;
      cursor: default;
    }
    .canvas-container.drawing-mode {
      cursor: crosshair;
    }
    .canvas-container.text-mode {
      cursor: cell;
    }

    #lineOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
    }
    #lineOverlay svg {
      width: 100%;
      height: 100%;
    }

    /* prompt nodes (resizable, auto-height capable) */
    .node {
      position: absolute;
      min-width: 180px;
      min-height: 100px;
      background: #fff;
      border: 3px solid #000;
      box-shadow: 8px 8px 0 #000;
      color: #000;
      z-index: 10;
      display: flex;
      flex-direction: column;
      font-size: 15px;
      line-height: 1.4;
    }
    .node .drag-bar {
      height: 28px;
      background: #ddd;
      border-bottom: 2px solid #000;
      cursor: grab;
      display: flex;
      align-items: center;
      padding-left: 10px;
      font-size: 14px;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      flex-shrink: 0;
    }
    .node .drag-bar:active {
      cursor: grabbing;
    }
    .node .node-text {
      padding: 10px 8px;
      outline: none;
      background: transparent;
      color: inherit;
      word-break: break-word;
      white-space: pre-wrap;
      cursor: text;
      font-size: 15px;
      border: none;
      resize: none;
      font-family: 'Courier New', monospace;
      flex: 1;
    }
    .node .delete-btn {
      position: absolute;
      top: -12px;
      right: -12px;
      width: 28px;
      height: 28px;
      background: #000;
      border: 2px solid #fff;
      color: #fff;
      font-weight: bold;
      font-size: 16px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 20;
      box-shadow: 2px 2px 0 #000;
    }
    .node .delete-btn:hover {
      background: #333;
    }
    /* resize handle */
    .node .resize-handle {
      position: absolute;
      bottom: 0;
      right: 0;
      width: 20px;
      height: 20px;
      background: #000;
      border: 2px solid #fff;
      cursor: nwse-resize;
      z-index: 25;
      box-shadow: -2px -2px 0 #000;
    }
    .node .resize-handle:hover {
      background: #333;
    }

    /* text labels (simple annotations, adjustable font size) */
    .text-label {
      position: absolute;
      min-width: 100px;
      min-height: 30px;
      background: #fff;
      border: 2px solid #000;
      box-shadow: 4px 4px 0 #000;
      color: #000;
      z-index: 15;
      display: flex;
      flex-direction: column;
      font-family: Arial, Helvetica, sans-serif;
      font-size: 16px;  /* default, overridden by inline style */
      line-height: 1.3;
    }
    .text-label .text-drag {
      height: 14px;
      background: #eee;
      border-bottom: 1px solid #000;
      cursor: grab;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      color: #333;
      flex-shrink: 0;
    }
    .text-label .text-drag:active {
      cursor: grabbing;
    }
    .text-label .text-content {
      padding: 6px 8px;
      outline: none;
      background: transparent;
      color: inherit;
      word-break: break-word;
      white-space: pre-wrap;
      cursor: text;
      font-family: Arial, Helvetica, sans-serif;
      font-size: inherit;
      border: none;
      resize: none;
      min-height: 30px;
    }
    .text-label .delete-btn {
      position: absolute;
      top: -10px;
      right: -10px;
      width: 22px;
      height: 22px;
      background: #000;
      border: 2px solid #fff;
      color: #fff;
      font-weight: bold;
      font-size: 12px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 25;
      box-shadow: 2px 2px 0 #000;
    }
    .text-label .delete-btn:hover {
      background: #333;
    }
  </style>
</head>
<body>
<div id="app">
  <div class="toolbar">
    <span class="brand">COLIGNUM‚ö´</span>
    <button id="addNodeBtn">‚ûï ADD BOX</button>
    <button id="exportPngBtn">‚¨áÔ∏è EXPORT 8K PNG</button>
    <button id="fullscreenBtn">‚õ∂ FULLSCREEN</button>
    <button id="invertBtn">‚óë INVERT B/W</button>
    <button id="drawBtn">‚úèÔ∏è DRAW</button>
    <button id="textBtn">üî§ TEXT</button>
    <div style="display: flex; align-items: center; gap: 4px;">
      <span style="font-weight: bold;">üî§ SIZE</span>
      <input type="number" id="fontSizeInput" min="10" max="30" value="16" step="1">
    </div>
    <button id="undoBtn">‚Ü© UNDO</button>
    <button id="redoBtn">‚Ü™ REDO</button>
    <span style="opacity:0.7;">‚Äî paste text ‚Üí auto‚Äëgrow ‚Äî</span>
  </div>
  <div class="canvas-wrapper" id="canvasWrapper">
    <div class="canvas-container grid-bg" id="canvasContainer">
      <div id="lineOverlay"><svg id="lineSvg"></svg></div>
    </div>
  </div>
</div>

<script>
  (function() {
    // ---------- data state ----------
    let nodes = [];               // { id, x, y, width, height, text, autoHeight, element }
    let strokes = [];             // { points: [{x,y}] }
    let textLabels = [];           // { id, x, y, text, element }
    let nextId = 1000;
    let textFontSize = 16;         // current font size for text labels

    // ---------- undo/redo stacks ----------
    let history = [];
    let redoStack = [];
    const MAX_HISTORY = 50;

    // record current state (deep copy) to history
    function saveState() {
      const state = {
        nodes: nodes.map(n => ({ 
          id: n.id, x: n.x, y: n.y, width: n.width, height: n.height, 
          text: n.text, autoHeight: n.autoHeight 
        })),
        strokes: strokes.map(s => ({ points: s.points.map(p => ({ x: p.x, y: p.y })) })),
        textLabels: textLabels.map(t => ({ id: t.id, x: t.x, y: t.y, text: t.text }))
      };
      return state;
    }

    function pushHistory() {
      const state = saveState();
      history.push(JSON.parse(JSON.stringify(state)));
      if (history.length > MAX_HISTORY) history.shift();
      redoStack = [];
    }

    function undo() {
      if (history.length === 0) return;
      const current = saveState();
      redoStack.push(JSON.parse(JSON.stringify(current)));
      const prev = history.pop();
      loadState(prev);
    }

    function redo() {
      if (redoStack.length === 0) return;
      const current = saveState();
      history.push(JSON.parse(JSON.stringify(current)));
      const next = redoStack.pop();
      loadState(next);
    }

    // load state: clear DOM and rebuild from data
    function loadState(state) {
      document.querySelectorAll('.node, .text-label').forEach(el => el.remove());

      nodes = state.nodes.map(n => ({ ...n, autoHeight: n.autoHeight ?? true }));
      strokes = state.strokes.map(s => ({ points: s.points.map(p => ({ x: p.x, y: p.y })) }));
      textLabels = state.textLabels.map(t => ({ ...t }));

      renderAll();
      // reapply current font size to text labels
      updateAllTextFontSize();
    }

    // ---------- rendering ----------
    function renderAll() {
      nodes.forEach(n => {
        const el = createNodeElement(n.id, n.x, n.y, n.width, n.height, n.text, n.autoHeight);
        canvas.appendChild(el);
        n.element = el;
      });

      textLabels.forEach(t => {
        const el = createTextElement(t.id, t.x, t.y, t.text);
        canvas.appendChild(el);
        t.element = el;
      });

      redrawOverlay();
    }

    // --- node DOM creation (with autoHeight support) ---
    function createNodeElement(id, x, y, width, height, textContent, autoHeight = true) {
      const div = document.createElement('div');
      div.className = 'node';
      div.style.left = x + 'px';
      div.style.top = y + 'px';
      div.style.width = width + 'px';
      div.style.height = height + 'px';
      div.setAttribute('data-id', id);

      const dragBar = document.createElement('div');
      dragBar.className = 'drag-bar';
      dragBar.innerText = '‚£ø COMMAND ‚£ø';
      dragBar.setAttribute('data-drag', 'true');

      const textDiv = document.createElement('div');
      textDiv.className = 'node-text';
      textDiv.setAttribute('contenteditable', 'true');
      textDiv.innerText = textContent;

      const delBtn = document.createElement('div');
      delBtn.className = 'delete-btn';
      delBtn.innerText = '‚úï';
      delBtn.setAttribute('data-delete', 'true');

      const resizeHandle = document.createElement('div');
      resizeHandle.className = 'resize-handle';
      resizeHandle.setAttribute('data-resize', 'true');

      div.appendChild(dragBar);
      div.appendChild(textDiv);
      div.appendChild(delBtn);
      div.appendChild(resizeHandle);

      // event listeners
      dragBar.addEventListener('mousedown', (e) => onNodeDragStart(e, id));
      delBtn.addEventListener('click', (e) => { e.stopPropagation(); deleteNode(id); });
      resizeHandle.addEventListener('mousedown', (e) => onResizeStart(e, id));

      textDiv.addEventListener('input', (e) => {
        const node = nodes.find(n => n.id === id);
        if (!node) return;
        node.text = e.target.innerText;
        // auto‚Äëheight if enabled
        if (node.autoHeight) {
          // temporarily set height to auto to get natural height
          node.element.style.height = 'auto';
          const newHeight = Math.max(100, node.element.offsetHeight); // min 100px
          node.height = newHeight;
          node.element.style.height = newHeight + 'px';
        }
        redrawOverlay();
      });

      textDiv.addEventListener('blur', () => {
        pushHistory(); // record text edit
      });

      return div;
    }

    // --- text label DOM creation (with current font size) ---
    function createTextElement(id, x, y, initialText) {
      const div = document.createElement('div');
      div.className = 'text-label';
      div.style.left = x + 'px';
      div.style.top = y + 'px';
      div.style.fontSize = textFontSize + 'px';
      div.setAttribute('data-textid', id);

      const dragHandle = document.createElement('div');
      dragHandle.className = 'text-drag';
      dragHandle.innerText = '‚£ø‚£ø';
      dragHandle.setAttribute('data-textdrag', 'true');

      const textDiv = document.createElement('div');
      textDiv.className = 'text-content';
      textDiv.setAttribute('contenteditable', 'true');
      textDiv.innerText = initialText;

      const delBtn = document.createElement('div');
      delBtn.className = 'delete-btn';
      delBtn.innerText = '‚úï';
      delBtn.setAttribute('data-textdelete', 'true');

      div.appendChild(dragHandle);
      div.appendChild(textDiv);
      div.appendChild(delBtn);

      dragHandle.addEventListener('mousedown', (e) => onTextDragStart(e, id));
      delBtn.addEventListener('click', (e) => { e.stopPropagation(); deleteTextLabel(id); });
      textDiv.addEventListener('blur', () => {
        const lbl = textLabels.find(t => t.id === id);
        if (lbl) lbl.text = textDiv.innerText;
        pushHistory();
      });

      return div;
    }

    // update font size of all text labels
    function updateAllTextFontSize() {
      textLabels.forEach(t => {
        if (t.element) {
          t.element.style.fontSize = textFontSize + 'px';
        }
      });
    }

    // ---------- helper: redraw overlay (connectors + strokes) with theme awareness ----------
    function redrawOverlay() {
      const lineSvg = document.getElementById('lineSvg');
      lineSvg.innerHTML = '';

      const isInverted = document.body.classList.contains('inverted');
      const connectorColor = isInverted ? '#fff' : '#000';
      const strokeColor = isInverted ? '#fff' : '#000'; // strokes also invert for visibility

      // connectors
      for (let i = 0; i < nodes.length - 1; i++) {
        const a = nodes[i];
        const b = nodes[i + 1];
        if (!a.element || !b.element) continue;

        const aW = a.element.offsetWidth;
        const aH = a.element.offsetHeight;
        const bW = b.element.offsetWidth;
        const bH = b.element.offsetHeight;

        const startX = a.x + aW/2;
        const startY = a.y + aH;
        const endX = b.x + bW/2;
        const endY = b.y;

        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", startX);
        line.setAttribute("y1", startY);
        line.setAttribute("x2", endX);
        line.setAttribute("y2", endY);
        line.setAttribute("stroke", connectorColor);
        line.setAttribute("stroke-width", "3");
        line.setAttribute("stroke-linecap", "round");
        lineSvg.appendChild(line);
      }

      // freehand strokes (theme‚Äëaware for screen)
      strokes.forEach(stroke => {
        if (stroke.points.length < 2) return;
        const pointsStr = stroke.points.map(p => `${p.x},${p.y}`).join(' ');
        const polyline = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
        polyline.setAttribute("points", pointsStr);
        polyline.setAttribute("fill", "none");
        polyline.setAttribute("stroke", strokeColor);
        polyline.setAttribute("stroke-width", "4");
        polyline.setAttribute("stroke-linecap", "round");
        polyline.setAttribute("stroke-linejoin", "round");
        lineSvg.appendChild(polyline);
      });
    }

    // ---------- CRUD operations with history ----------
    function addNode(x, y, initialText = 'prompt idea...') {
      const id = nextId++;
      const width = 250;
      const height = 130;
      const nodeObj = { id, x, y, width, height, text: initialText, autoHeight: true };
      nodes.push(nodeObj);
      const el = createNodeElement(id, x, y, width, height, initialText, true);
      canvas.appendChild(el);
      nodeObj.element = el;
      pushHistory();
      redrawOverlay();
    }

    function deleteNode(id) {
      const idx = nodes.findIndex(n => n.id === id);
      if (idx !== -1) {
        nodes[idx].element.remove();
        nodes.splice(idx, 1);
        pushHistory();
        redrawOverlay();
      }
    }

    function addTextLabel(x, y, initialText = 'annotation') {
      const id = nextId++;
      const textObj = { id, x, y, text: initialText };
      textLabels.push(textObj);
      const el = createTextElement(id, x, y, initialText);
      canvas.appendChild(el);
      textObj.element = el;
      pushHistory();
    }

    function deleteTextLabel(id) {
      const idx = textLabels.findIndex(t => t.id === id);
      if (idx !== -1) {
        textLabels[idx].element.remove();
        textLabels.splice(idx, 1);
        pushHistory();
      }
    }

    // ---------- drag / resize logic ----------
    let draggedNode = null;
    let dragOffsetX, dragOffsetY;
    let resizingNode = null;
    let resizeStartX, resizeStartY, resizeStartWidth, resizeStartHeight;
    let draggedText = null;
    let textDragOffsetX, textDragOffsetY;

    const canvas = document.getElementById('canvasContainer');

    function onNodeDragStart(e, id) {
      e.preventDefault();
      const node = nodes.find(n => n.id === id);
      if (!node) return;
      draggedNode = node;
      dragOffsetX = e.clientX - node.x;
      dragOffsetY = e.clientY - node.y;

      function onDragMove(e) {
        if (!draggedNode) return;
        e.preventDefault();
        draggedNode.x = Math.max(0, e.clientX - dragOffsetX);
        draggedNode.y = Math.max(0, e.clientY - dragOffsetY);
        draggedNode.element.style.left = draggedNode.x + 'px';
        draggedNode.element.style.top = draggedNode.y + 'px';
        redrawOverlay();
      }
      function onDragEnd() {
        if (draggedNode) pushHistory();
        draggedNode = null;
        window.removeEventListener('mousemove', onDragMove);
        window.removeEventListener('mouseup', onDragEnd);
      }
      window.addEventListener('mousemove', onDragMove);
      window.addEventListener('mouseup', onDragEnd);
    }

    function onResizeStart(e, id) {
      e.preventDefault();
      const node = nodes.find(n => n.id === id);
      if (!node) return;
      // mark as manually resized (disable autoHeight)
      node.autoHeight = false;
      resizingNode = node;
      resizeStartX = e.clientX;
      resizeStartY = e.clientY;
      resizeStartWidth = node.width;
      resizeStartHeight = node.height;

      function onResizeMove(e) {
        if (!resizingNode) return;
        e.preventDefault();
        const dx = e.clientX - resizeStartX;
        const dy = e.clientY - resizeStartY;
        let newWidth = Math.max(180, resizeStartWidth + dx);
        let newHeight = Math.max(100, resizeStartHeight + dy);
        resizingNode.width = newWidth;
        resizingNode.height = newHeight;
        resizingNode.element.style.width = newWidth + 'px';
        resizingNode.element.style.height = newHeight + 'px';
        redrawOverlay();
      }
      function onResizeEnd() {
        if (resizingNode) pushHistory();
        resizingNode = null;
        window.removeEventListener('mousemove', onResizeMove);
        window.removeEventListener('mouseup', onResizeEnd);
      }
      window.addEventListener('mousemove', onResizeMove);
      window.addEventListener('mouseup', onResizeEnd);
    }

    function onTextDragStart(e, id) {
      e.preventDefault();
      const txt = textLabels.find(t => t.id === id);
      if (!txt) return;
      draggedText = txt;
      textDragOffsetX = e.clientX - txt.x;
      textDragOffsetY = e.clientY - txt.y;

      function onDragMove(e) {
        if (!draggedText) return;
        e.preventDefault();
        draggedText.x = Math.max(0, e.clientX - textDragOffsetX);
        draggedText.y = Math.max(0, e.clientY - textDragOffsetY);
        draggedText.element.style.left = draggedText.x + 'px';
        draggedText.element.style.top = draggedText.y + 'px';
      }
      function onDragEnd() {
        if (draggedText) pushHistory();
        draggedText = null;
        window.removeEventListener('mousemove', onDragMove);
        window.removeEventListener('mouseup', onDragEnd);
      }
      window.addEventListener('mousemove', onDragMove);
      window.addEventListener('mouseup', onDragEnd);
    }

    // ---------- drawing / text mode ----------
    let drawingMode = false;
    let textMode = false;
    let activeStroke = null;

    const drawBtn = document.getElementById('drawBtn');
    const textBtn = document.getElementById('textBtn');
    const fontSizeInput = document.getElementById('fontSizeInput');

    function setDrawingMode(active) {
      drawingMode = active;
      textMode = false;
      canvas.classList.toggle('drawing-mode', active);
      canvas.classList.remove('text-mode');
      drawBtn.classList.toggle('active', active);
      textBtn.classList.remove('active');
    }

    function setTextMode(active) {
      textMode = active;
      drawingMode = false;
      canvas.classList.toggle('text-mode', active);
      canvas.classList.remove('drawing-mode');
      textBtn.classList.toggle('active', active);
      drawBtn.classList.remove('active');
    }

    drawBtn.addEventListener('click', () => setDrawingMode(!drawingMode));
    textBtn.addEventListener('click', () => setTextMode(!textMode));

    // font size control
    fontSizeInput.addEventListener('input', (e) => {
      textFontSize = parseInt(e.target.value, 10) || 16;
      updateAllTextFontSize();
    });

    // canvas mouse events for drawing / text insertion
    function getCanvasCoords(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      };
    }

    canvas.addEventListener('mousedown', (e) => {
      if (e.target.closest('.node') || e.target.closest('.text-label')) return;

      if (drawingMode) {
        e.preventDefault();
        const { x, y } = getCanvasCoords(e);
        activeStroke = { points: [{ x, y }] };
        strokes.push(activeStroke);
        redrawOverlay();

        function onMouseMove(e) {
          if (!drawingMode || !activeStroke) return;
          e.preventDefault();
          const { x, y } = getCanvasCoords(e);
          activeStroke.points.push({ x, y });
          redrawOverlay();
        }
        function onMouseUp() {
          if (activeStroke) {
            pushHistory();
            activeStroke = null;
          }
          window.removeEventListener('mousemove', onMouseMove);
          window.removeEventListener('mouseup', onMouseUp);
        }
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);
      }
      else if (textMode) {
        e.preventDefault();
        const { x, y } = getCanvasCoords(e);
        addTextLabel(x, y, 'text');
      }
    });

    // ---------- export PNG (8K resolution) ----------
    function generateSVGString() {
      if (nodes.length === 0 && strokes.length === 0 && textLabels.length === 0) return null;

      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

      nodes.forEach(n => {
        minX = Math.min(minX, n.x);
        minY = Math.min(minY, n.y);
        maxX = Math.max(maxX, n.x + n.width + 8);
        maxY = Math.max(maxY, n.y + n.height + 8);
      });

      textLabels.forEach(t => {
        if (!t.element) return;
        const w = t.element.offsetWidth;
        const h = t.element.offsetHeight;
        minX = Math.min(minX, t.x);
        minY = Math.min(minY, t.y);
        maxX = Math.max(maxX, t.x + w);
        maxY = Math.max(maxY, t.y + h);
      });

      strokes.forEach(s => {
        s.points.forEach(p => {
          minX = Math.min(minX, p.x);
          minY = Math.min(minY, p.y);
          maxX = Math.max(maxX, p.x);
          maxY = Math.max(maxY, p.y);
        });
      });

      const pad = 100;
      minX -= pad;
      minY -= pad;
      maxX += pad;
      maxY += pad;

      const width = maxX - minX;
      const height = maxY - minY;

      let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${minX} ${minY} ${width} ${height}" width="${width}" height="${height}" style="background:#fff;">\n`;
      svg += `<rect width="100%" height="100%" fill="#fff"/>\n`;

      // connectors (black)
      for (let i = 0; i < nodes.length - 1; i++) {
        const a = nodes[i];
        const b = nodes[i + 1];
        const x1 = a.x + a.width/2, y1 = a.y + a.height;
        const x2 = b.x + b.width/2, y2 = b.y;
        svg += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="#000" stroke-width="3" stroke-linecap="round" />\n`;
      }

      // strokes (always black in export)
      strokes.forEach(s => {
        if (s.points.length < 2) return;
        const pointsStr = s.points.map(p => `${p.x},${p.y}`).join(' ');
        svg += `<polyline points="${pointsStr}" fill="none" stroke="#000" stroke-width="4" stroke-linecap="round" stroke-linejoin="round" />\n`;
      });

      // text labels (with current font size, but fixed black)
      textLabels.forEach(t => {
        if (!t.element) return;
        const w = t.element.offsetWidth;
        const h = t.element.offsetHeight;
        const text = t.text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\n/g, '<br/>');
        svg += `<foreignObject x="${t.x}" y="${t.y}" width="${w}" height="${h}">\n`;
        svg += `<div xmlns="http://www.w3.org/1999/xhtml" style="font-family: Arial, sans-serif; font-size: ${textFontSize}px; color: #000; line-height:1.3; background: transparent; padding: 4px; word-break: break-word; white-space: pre-wrap;">${text}</div>\n`;
        svg += `</foreignObject>\n`;
      });

      // nodes (styled boxes)
      const styleText = `
        .export-node {
          background: #fff;
          border: 3px solid #000;
          box-shadow: 8px 8px 0 #000;
          font-family: 'Courier New', monospace;
          font-size: 15px;
          width: 100%;
          height: 100%;
          display: flex;
          flex-direction: column;
          box-sizing: border-box;
        }
        .export-drag {
          height: 28px;
          background: #ddd;
          border-bottom: 2px solid #000;
          padding-left: 10px;
          line-height: 26px;
          font-weight: bold;
          text-transform: uppercase;
          font-size: 14px;
          letter-spacing: 0.5px;
          box-sizing: border-box;
        }
        .export-text {
          padding: 10px 8px;
          white-space: pre-wrap;
          word-break: break-word;
          font-size: 15px;
          line-height: 1.4;
          box-sizing: border-box;
          flex: 1;
        }
      `;
      nodes.forEach(n => {
        const text = n.text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\n/g, '<br/>');
        svg += `<foreignObject x="${n.x}" y="${n.y}" width="${n.width}" height="${n.height}">\n`;
        svg += `<div xmlns="http://www.w3.org/1999/xhtml"><style>${styleText}</style><div class="export-node"><div class="export-drag">‚£ø COMMAND ‚£ø</div><div class="export-text">${text}</div></div></div>\n`;
        svg += `</foreignObject>\n`;
      });

      svg += `</svg>`;
      return svg;
    }

    async function exportPNG() {
      const svgStr = generateSVGString();
      if (!svgStr) return alert('No content to export.');

      const viewBoxMatch = svgStr.match(/viewBox="([^"]+)"/);
      if (!viewBoxMatch) return;
      const [, viewBox] = viewBoxMatch;
      const [minX, minY, vbWidth, vbHeight] = viewBox.split(' ').map(Number);

      // 8K export: target long edge 8192 pixels
      const targetLong = 8192;
      const scale = targetLong / Math.max(vbWidth, vbHeight);
      const canvasWidth = Math.round(vbWidth * scale);
      const canvasHeight = Math.round(vbHeight * scale);

      const canvas = document.createElement('canvas');
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      const ctx = canvas.getContext('2d', { alpha: false });

      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);

      const blob = new Blob([svgStr], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      const img = new Image();
      await new Promise((resolve, reject) => {
        img.onload = resolve;
        img.onerror = reject;
        img.src = url;
      });
      ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);
      URL.revokeObjectURL(url);

      canvas.toBlob((b) => {
        const u = URL.createObjectURL(b);
        const a = document.createElement('a');
        a.href = u;
        a.download = 'colignum_8k.png';
        a.click();
        URL.revokeObjectURL(u);
      }, 'image/png');
    }

    // ---------- UI helpers ----------
    function toggleFullscreen() {
      if (!document.fullscreenElement) document.documentElement.requestFullscreen();
      else document.exitFullscreen();
    }
    function invertUI() {
      document.body.classList.toggle('inverted');
      redrawOverlay(); // updates connector & stroke colors
    }

    // ---------- initialisation ----------
    function initDefault() {
      addNode(200, 200, 'concept: mystical forest\n#fantasy #moody');
      addNode(520, 320, 'lighting: volumetric fog\ngolden hour');
      addNode(840, 440, 'camera: 50mm\ncinematic depth');
      addNode(1160, 560, 'details: floating particles\nbutterflies');
      addTextLabel(300, 550, 'warm light');
      addTextLabel(900, 300, 'depth effect');
      pushHistory();
    }

    // event listeners
    document.getElementById('addNodeBtn').addEventListener('click', () => {
      let x = 200, y = 200;
      if (nodes.length) {
        const last = nodes[nodes.length - 1];
        x = last.x + 280;
        y = last.y + 30;
        if (x > 2300) x = 200;
        if (y > 1800) y = 200;
      }
      addNode(x, y, 'new prompt...');
    });

    document.getElementById('exportPngBtn').addEventListener('click', exportPNG);
    document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);
    document.getElementById('invertBtn').addEventListener('click', invertUI);
    document.getElementById('undoBtn').addEventListener('click', undo);
    document.getElementById('redoBtn').addEventListener('click', redo);

    initDefault();
  })();
</script>
</body>
</html>