<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>COLIGNUM EDITOR DEMO</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        /* --- GLOBAL MONOCHROME RESET --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none; /* for draw mode, but we'll enable text selection in write mode */
        }

        body {
            font-family: 'Segoe UI', 'Arial', sans-serif;
            background: #fff;
            color: #000;
            height: 100vh;
            overflow: hidden;
            transition: background-color 0.2s, color 0.2s;
        }

        body.inverted {
            background: #000;
            color: #fff;
        }

        /* --- HEADER (monochrome, with subtle borders) --- */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 16px;
            background: #f0f0f0;
            border-bottom: 2px solid #888;
        }
        body.inverted .header {
            background: #222;
            border-bottom-color: #666;
        }

        .logo {
            font-weight: bold;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .logo i {
            color: #000;
        }
        body.inverted .logo i {
            color: #fff;
        }

        .mode-switch {
            display: flex;
            gap: 4px;
            background: #ccc;
            padding: 4px;
            border: 1px solid #888;
        }
        body.inverted .mode-switch {
            background: #333;
            border-color: #666;
        }
        .mode-btn {
            padding: 6px 16px;
            border: none;
            background: #e0e0e0;
            cursor: pointer;
            font-weight: 500;
            border: 1px solid #aaa;
        }
        .mode-btn.active {
            background: #000;
            color: #fff;
            border-color: #000;
        }
        body.inverted .mode-btn {
            background: #444;
            color: #fff;
            border-color: #666;
        }
        body.inverted .mode-btn.active {
            background: #fff;
            color: #000;
            border-color: #fff;
        }

        .header-controls {
            display: flex;
            gap: 8px;
        }
        .btn {
            background: #e0e0e0;
            border: 2px outset #fff;
            padding: 6px 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9rem;
            color: #000;
        }
        .btn:active {
            border-style: inset;
        }
        body.inverted .btn {
            background: #333;
            border-color: #555;
            color: #fff;
        }
        .btn-primary {
            background: #000;
            color: #fff;
            border-color: #333;
        }
        body.inverted .btn-primary {
            background: #fff;
            color: #000;
            border-color: #ccc;
        }

        /* --- MAIN LAYOUT --- */
        .main {
            display: flex;
            height: calc(100vh - 60px);
        }

        /* --- SIDEBAR (statistics) --- */
        .sidebar {
            width: 200px;
            background: #f8f8f8;
            border-right: 2px solid #888;
            padding: 16px;
            overflow-y: auto;
        }
        body.inverted .sidebar {
            background: #222;
            border-right-color: #666;
        }
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            padding-bottom: 6px;
            border-bottom: 1px solid #aaa;
        }
        body.inverted .stat-item {
            border-bottom-color: #555;
        }

        /* --- CONTENT AREA (write/draw) --- */
        .content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: #fff;
        }
        body.inverted .content {
            background: #000;
        }

        /* --- WRITE MODE --- */
        .write-mode {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        .write-toolbar {
            background: #f0f0f0;
            border-bottom: 2px solid #888;
            padding: 8px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        body.inverted .write-toolbar {
            background: #222;
            border-bottom-color: #666;
        }
        .write-toolbar select, .write-toolbar input[type="color"] {
            background: #fff;
            border: 1px solid #888;
            padding: 4px;
            color: #000;
        }
        body.inverted .write-toolbar select,
        body.inverted .write-toolbar input[type="color"] {
            background: #333;
            color: #fff;
            border-color: #666;
        }
        .editor-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        .editor-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            border-right: 2px solid #888;
        }
        .editor-panel:last-child { border-right: none; }
        body.inverted .editor-panel {
            border-right-color: #666;
        }
        .panel-header {
            background: #e0e0e0;
            padding: 8px;
            border-bottom: 2px solid #888;
            display: flex;
            justify-content: space-between;
        }
        body.inverted .panel-header {
            background: #333;
            border-bottom-color: #666;
        }
        .editor-body {
            flex: 1;
            padding: 8px;
            overflow: auto;
        }
        #markdownEditor {
            width: 100%;
            height: 100%;
            border: none;
            outline: none;
            resize: none;
            background: transparent;
            color: inherit;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        .preview {
            font-family: 'Segoe UI', sans-serif;
            line-height: 1.5;
        }
        .preview h1, .preview h2 { border-bottom: 1px solid #888; }
        .preview code { background: #f0f0f0; }
        body.inverted .preview code { background: #333; }
        .preview a { color: #000; text-decoration: underline; }
        body.inverted .preview a { color: #fff; }

        /* --- DRAW MODE --- */
        .draw-mode {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        .draw-toolbar {
            background: #f0f0f0;
            border-bottom: 2px solid #888;
            padding: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }
        body.inverted .draw-toolbar {
            background: #222;
            border-bottom-color: #666;
        }
        .tool-group {
            display: flex;
            gap: 2px;
            background: #ccc;
            padding: 4px;
            border: 1px solid #888;
        }
        body.inverted .tool-group {
            background: #333;
            border-color: #666;
        }
        .draw-btn {
            width: 36px;
            height: 36px;
            background: #e0e0e0;
            border: 2px outset #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
            color: #000;
        }
        .draw-btn:active { border-style: inset; }
        .draw-btn.active {
            background: #000;
            color: #fff;
            border-color: #333;
        }
        body.inverted .draw-btn {
            background: #444;
            color: #fff;
            border-color: #666;
        }
        body.inverted .draw-btn.active {
            background: #fff;
            color: #000;
            border-color: #ccc;
        }
        .color-swatch {
            width: 32px;
            height: 32px;
            border: 2px solid #fff;
            cursor: pointer;
            background: #000;
        }
        .color-swatch.white { background: #fff; }
        .canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #aaa;
            padding: 16px;
            position: relative;
        }
        body.inverted .canvas-container {
            background: #555;
        }
        #drawCanvas {
            background: #fff;
            border: 2px solid #000;
            cursor: crosshair;
            width: 800px;
            height: 600px;
            box-shadow: 4px 4px 0 #888;
        }
        .grid-overlay {
            display: none;
            position: absolute;
            top: 16px; left: 16px; /* align with canvas position */
            width: 800px;
            height: 600px;
            pointer-events: none;
            background-image: linear-gradient(rgba(0,0,0,0.15) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(0,0,0,0.15) 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .status-bar {
            background: #e0e0e0;
            border-top: 2px solid #888;
            padding: 4px 12px;
            display: flex;
            gap: 24px;
            font-size: 12px;
        }
        body.inverted .status-bar {
            background: #333;
            border-top-color: #666;
        }

        /* --- MODAL (simple export) --- */
        .modal {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background: #f0f0f0;
            border: 4px outset #fff;
            padding: 24px;
            min-width: 300px;
        }
        body.inverted .modal-content {
            background: #222;
            border-color: #444;
            color: #fff;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="logo">
            <i class="fas fa-pen-fancy"></i> COLIGNUM EDITOR (DEMO)
        </div>
        <div class="mode-switch">
            <button class="mode-btn active" id="modeWrite">âœŽ Write</button>
            <button class="mode-btn" id="modeDraw">ðŸŽ¨ Draw</button>
        </div>
        <div class="header-controls">
            <button class="btn" id="invertBtn"><i class="fas fa-adjust"></i> Invert</button>
            <button class="btn" id="exportBtn"><i class="fas fa-download"></i> Export</button>
        </div>
    </div>

    <div class="main">
        <!-- Sidebar stats (shared) -->
        <div class="sidebar">
            <h3 style="margin-bottom: 16px;">Document Stats</h3>
            <div class="stat-item"><span>Words</span><span id="wordCount">0</span></div>
            <div class="stat-item"><span>Chars</span><span id="charCount">0</span></div>
            <div class="stat-item"><span>Lines</span><span id="lineCount">0</span></div>
            <div class="stat-item"><span>Reading time</span><span id="readingTime">0 min</span></div>
            <hr style="margin: 16px 0; border-color:#888;">
            <div id="drawStats" style="display:none;">
                <div class="stat-item"><span>Tool</span><span id="currentTool">Pencil</span></div>
                <div class="stat-item"><span>Size</span><span id="currentSize">3</span></div>
            </div>
        </div>

        <!-- Content area (write/draw) -->
        <div class="content">
            <!-- WRITE MODE (visible by default) -->
            <div class="write-mode" id="writeMode">
                <div class="write-toolbar">
                    <select id="fontFamily">
                        <option value="monospace">Monospace</option>
                        <option value="serif">Serif</option>
                        <option value="sans">Sans-serif</option>
                    </select>
                    <select id="fontSize">
                        <option value="12">12px</option>
                        <option value="14">14px</option>
                        <option value="16" selected>16px</option>
                        <option value="18">18px</option>
                    </select>
                    <input type="color" id="textColor" value="#000000" title="Text color (only black/white)">
                    <button class="btn" id="boldBtn"><b>B</b></button>
                    <button class="btn" id="italicBtn"><i>I</i></button>
                    <button class="btn" id="headingBtn">H1</button>
                </div>
                <div class="editor-container">
                    <div class="editor-panel">
                        <div class="panel-header">Editor <button class="btn" id="clearEditor">Clear</button></div>
                        <div class="editor-body">
                            <textarea id="markdownEditor" spellcheck="false"># Welcome

Start writing in **Markdown**...

- item 1
- item 2</textarea>
                        </div>
                    </div>
                    <div class="editor-panel">
                        <div class="panel-header">Preview</div>
                        <div class="editor-body">
                            <div class="preview" id="markdownPreview"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- DRAW MODE (hidden initially) -->
            <div class="draw-mode" id="drawMode" style="display:none;">
                <div class="draw-toolbar">
                    <div class="tool-group">
                        <div class="draw-btn active" data-tool="pencil" title="Pencil (P)">âœŽ</div>
                        <div class="draw-btn" data-tool="line" title="Line (L)">â•±</div>
                        <div class="draw-btn" data-tool="rectangle" title="Rectangle (R)">â–¡</div>
                        <div class="draw-btn" data-tool="ellipse" title="Ellipse (E)">â—¯</div>
                        <div class="draw-btn" data-tool="eraser" title="Eraser (X)">âŒ«</div>
                        <div class="draw-btn" data-tool="fill" title="Fill (F)">â—¼</div>
                    </div>
                    <div class="tool-group">
                        <div class="draw-btn size-btn" data-size="1">â€¢</div>
                        <div class="draw-btn size-btn active" data-size="3">â—‰</div>
                        <div class="draw-btn size-btn" data-size="5">â¬¤</div>
                    </div>
                    <div class="tool-group">
                        <div class="color-swatch" id="fgSwatch" style="background:#000;" title="Foreground (black)"></div>
                        <div class="color-swatch white" id="bgSwatch" style="background:#fff;" title="Background (white)"></div>
                    </div>
                    <div class="tool-group">
                        <div class="draw-btn" id="gridToggle" title="Grid (G)">âŒ—</div>
                        <div class="draw-btn" id="undoDraw" title="Undo (Ctrl+Z)">â†©</div>
                        <div class="draw-btn" id="redoDraw" title="Redo (Ctrl+Y)">â†ª</div>
                        <div class="draw-btn" id="clearCanvas" title="Clear Canvas">ðŸ—‘</div>
                    </div>
                </div>
                <div class="canvas-container">
                    <canvas id="drawCanvas" width="800" height="600"></canvas>
                    <div class="grid-overlay" id="gridOverlay"></div>
                </div>
                <div class="status-bar">
                    <span id="drawToolStatus">Tool: Pencil</span>
                    <span id="drawCoord">X:0 Y:0</span>
                    <span id="drawSizeStatus">Size: 3</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Simple export modal -->
    <div class="modal" id="exportModal">
        <div class="modal-content">
            <h3>Export</h3>
            <p>In a full version you could export Markdown/PNG.</p>
            <button class="btn" id="closeModal">Close</button>
        </div>
    </div>

    <script>
        // --- GLOBAL ---
        const body = document.body;
        const invertBtn = document.getElementById('invertBtn');
        invertBtn.addEventListener('click', () => body.classList.toggle('inverted'));

        // Mode switching
        const writeMode = document.getElementById('writeMode');
        const drawMode = document.getElementById('drawMode');
        const modeWrite = document.getElementById('modeWrite');
        const modeDraw = document.getElementById('modeDraw');
        const drawStats = document.getElementById('drawStats');

        modeWrite.addEventListener('click', () => {
            modeWrite.classList.add('active');
            modeDraw.classList.remove('active');
            writeMode.style.display = 'flex';
            drawMode.style.display = 'none';
            drawStats.style.display = 'none';
        });
        modeDraw.addEventListener('click', () => {
            modeDraw.classList.add('active');
            modeWrite.classList.remove('active');
            drawMode.style.display = 'flex';
            writeMode.style.display = 'none';
            drawStats.style.display = 'block';
        });

        // --- WRITE MODE (Markdown) ---
        const mdEditor = document.getElementById('markdownEditor');
        const mdPreview = document.getElementById('markdownPreview');
        const wordCount = document.getElementById('wordCount');
        const charCount = document.getElementById('charCount');
        const lineCount = document.getElementById('lineCount');
        const readingTime = document.getElementById('readingTime');

        function updateStats() {
            const text = mdEditor.value;
            const words = text.match(/\b\w+\b/g)?.length || 0;
            const chars = text.length;
            const lines = text.split('\n').length;
            wordCount.textContent = words;
            charCount.textContent = chars;
            lineCount.textContent = lines;
            readingTime.textContent = Math.ceil(words / 200) + ' min';
        }

        function renderPreview() {
            mdPreview.innerHTML = marked.parse(mdEditor.value);
        }

        mdEditor.addEventListener('input', () => {
            renderPreview();
            updateStats();
        });

        // Format buttons (simple insert)
        document.getElementById('boldBtn').addEventListener('click', () => insertText('**', '**'));
        document.getElementById('italicBtn').addEventListener('click', () => insertText('*', '*'));
        document.getElementById('headingBtn').addEventListener('click', () => insertText('# ', ''));
        document.getElementById('clearEditor').addEventListener('click', () => {
            mdEditor.value = '';
            renderPreview();
            updateStats();
        });

        function insertText(before, after) {
            const start = mdEditor.selectionStart;
            const end = mdEditor.selectionEnd;
            const text = mdEditor.value;
            mdEditor.value = text.substring(0, start) + before + text.substring(start, end) + after + text.substring(end);
            mdEditor.focus();
            mdEditor.selectionStart = start + before.length;
            mdEditor.selectionEnd = end + before.length;
            renderPreview();
            updateStats();
        }

        // Font customization
        document.getElementById('fontFamily').addEventListener('change', (e) => {
            const val = e.target.value;
            mdEditor.style.fontFamily = val === 'monospace' ? 'Courier New' : (val === 'serif' ? 'Times New Roman' : 'Arial');
        });
        document.getElementById('fontSize').addEventListener('change', (e) => {
            mdEditor.style.fontSize = e.target.value + 'px';
        });
        document.getElementById('textColor').addEventListener('input', (e) => {
            mdEditor.style.color = e.target.value;
        });

        // Initial render
        renderPreview();
        updateStats();

        // --- DRAW MODE (fully functional) ---
        const canvas = document.getElementById('drawCanvas');
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // State
        let drawing = false;
        let currentTool = 'pencil';
        let brushSize = 3;
        let fgColor = '#000000';
        let bgColor = '#ffffff';
        let startX, startY, lastX, lastY;
        let history = [];
        let historyIndex = -1;
        const maxHistory = 30;

        function saveState() {
            if (historyIndex < history.length - 1) history = history.slice(0, historyIndex + 1);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            history.push(imageData);
            if (history.length > maxHistory) history.shift();
            historyIndex = history.length - 1;
        }

        function restoreState(index) {
            if (index >= 0 && index < history.length) {
                ctx.putImageData(history[index], 0, 0);
                historyIndex = index;
            }
        }

        saveState(); // initial

        // UI elements
        const drawBtns = document.querySelectorAll('.draw-btn[data-tool]');
        const sizeBtns = document.querySelectorAll('.size-btn');
        const fgSwatch = document.getElementById('fgSwatch');
        const bgSwatch = document.getElementById('bgSwatch');
        const gridToggle = document.getElementById('gridToggle');
        const gridOverlay = document.getElementById('gridOverlay');
        const undoDraw = document.getElementById('undoDraw');
        const redoDraw = document.getElementById('redoDraw');
        const clearCanvas = document.getElementById('clearCanvas');
        const drawToolStatus = document.getElementById('drawToolStatus');
        const drawCoord = document.getElementById('drawCoord');
        const drawSizeStatus = document.getElementById('drawSizeStatus');
        const currentToolSpan = document.getElementById('currentTool');
        const currentSizeSpan = document.getElementById('currentSize');

        // Tool activation
        drawBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                drawBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentTool = btn.dataset.tool;
                drawToolStatus.innerText = `Tool: ${currentTool.charAt(0).toUpperCase() + currentTool.slice(1)}`;
                currentToolSpan.innerText = currentTool;
            });
        });

        sizeBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                sizeBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                brushSize = parseInt(btn.dataset.size, 10);
                drawSizeStatus.innerText = `Size: ${brushSize}`;
                currentSizeSpan.innerText = brushSize;
            });
        });

        // Color swatch click toggles (swap fg/bg)
        fgSwatch.addEventListener('click', () => {
            [fgColor, bgColor] = [bgColor, fgColor];
            fgSwatch.style.background = fgColor;
            bgSwatch.style.background = bgColor;
        });
        bgSwatch.addEventListener('click', () => {
            [fgColor, bgColor] = [bgColor, fgColor];
            fgSwatch.style.background = fgColor;
            bgSwatch.style.background = bgColor;
        });

        // Grid toggle
        gridToggle.addEventListener('click', () => {
            if (gridOverlay.style.display === 'block') gridOverlay.style.display = 'none';
            else gridOverlay.style.display = 'block';
        });

        // Undo/Redo
        undoDraw.addEventListener('click', () => { if (historyIndex > 0) restoreState(historyIndex - 1); });
        redoDraw.addEventListener('click', () => { if (historyIndex < history.length - 1) restoreState(historyIndex + 1); });

        // Clear canvas
        clearCanvas.addEventListener('click', () => {
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            saveState();
        });

        // Helper: color to RGB array for fill
        function colorToRgb(color) {
            return color === '#000000' ? [0,0,0,255] : [255,255,255,255];
        }

        // Flood fill (4-way)
        function floodFill(x, y, fillRgb) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const idx = (y * canvas.width + x) * 4;
            const targetR = data[idx], targetG = data[idx+1], targetB = data[idx+2], targetA = data[idx+3];
            if (targetR === fillRgb[0] && targetG === fillRgb[1] && targetB === fillRgb[2]) return;
            const stack = [[x, y]];
            while (stack.length) {
                const [cx, cy] = stack.pop();
                if (cx < 0 || cx >= canvas.width || cy < 0 || cy >= canvas.height) continue;
                const i = (cy * canvas.width + cx) * 4;
                if (data[i] === targetR && data[i+1] === targetG && data[i+2] === targetB && data[i+3] === targetA) {
                    data[i] = fillRgb[0]; data[i+1] = fillRgb[1]; data[i+2] = fillRgb[2]; data[i+3] = 255;
                    stack.push([cx+1, cy], [cx-1, cy], [cx, cy+1], [cx, cy-1]);
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        // Mouse events
        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = Math.floor((e.clientX - rect.left) * scaleX);
            const y = Math.floor((e.clientY - rect.top) * scaleY);
            startX = x; startY = y; lastX = x; lastY = y;

            if (currentTool === 'fill') {
                floodFill(x, y, colorToRgb(fgColor));
                saveState();
                return;
            }

            drawing = true;
            if (currentTool === 'pencil' || currentTool === 'eraser') {
                ctx.fillStyle = (currentTool === 'eraser') ? bgColor : fgColor;
                ctx.fillRect(x, y, brushSize, brushSize);
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = Math.floor((e.clientX - rect.left) * scaleX);
            const y = Math.floor((e.clientY - rect.top) * scaleY);
            drawCoord.innerText = `X:${x} Y:${y}`;

            if (!drawing) return;

            if (currentTool === 'pencil' || currentTool === 'eraser') {
                ctx.strokeStyle = (currentTool === 'eraser') ? bgColor : fgColor;
                ctx.lineWidth = brushSize;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(x, y);
                ctx.stroke();
                lastX = x; lastY = y;
            } else if (['line', 'rectangle', 'ellipse'].includes(currentTool)) {
                // Preview: restore then draw shape (will be finalized on mouseup)
                restoreState(historyIndex);
                ctx.save();
                ctx.strokeStyle = fgColor;
                ctx.lineWidth = brushSize;
                if (currentTool === 'line') {
                    ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(x, y); ctx.stroke();
                } else if (currentTool === 'rectangle') {
                    ctx.strokeRect(startX, startY, x - startX, y - startY);
                } else if (currentTool === 'ellipse') {
                    ctx.beginPath();
                    ctx.ellipse(startX + (x-startX)/2, startY + (y-startY)/2, Math.abs(x-startX)/2, Math.abs(y-startY)/2, 0, 0, 2*Math.PI);
                    ctx.stroke();
                }
                ctx.restore();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (!drawing) return;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = Math.floor((e.clientX - rect.left) * scaleX);
            const y = Math.floor((e.clientY - rect.top) * scaleY);

            if (!['pencil', 'eraser'].includes(currentTool)) {
                // Finalize shape
                restoreState(historyIndex); // clear preview
                ctx.save();
                ctx.strokeStyle = fgColor;
                ctx.lineWidth = brushSize;
                if (currentTool === 'line') {
                    ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(x, y); ctx.stroke();
                } else if (currentTool === 'rectangle') {
                    ctx.strokeRect(startX, startY, x - startX, y - startY);
                } else if (currentTool === 'ellipse') {
                    ctx.beginPath();
                    ctx.ellipse(startX + (x-startX)/2, startY + (y-startY)/2, Math.abs(x-startX)/2, Math.abs(y-startY)/2, 0, 0, 2*Math.PI);
                    ctx.stroke();
                }
                ctx.restore();
            }
            drawing = false;
            saveState();
        });

        canvas.addEventListener('mouseleave', () => { drawing = false; });

        // Keyboard shortcuts
        window.addEventListener('keydown', (e) => {
            if (drawMode.style.display !== 'flex') return;
            const key = e.key.toLowerCase();
            if (key === 'p') document.querySelector('[data-tool="pencil"]').click();
            if (key === 'l') document.querySelector('[data-tool="line"]').click();
            if (key === 'r') document.querySelector('[data-tool="rectangle"]').click();
            if (key === 'e') document.querySelector('[data-tool="ellipse"]').click();
            if (key === 'x') document.querySelector('[data-tool="eraser"]').click();
            if (key === 'f') document.querySelector('[data-tool="fill"]').click();
            if (key === 'g') gridToggle.click();
            if (e.ctrlKey && key === 'z') { undoDraw.click(); e.preventDefault(); }
            if (e.ctrlKey && key === 'y') { redoDraw.click(); e.preventDefault(); }
        });

        // Export modal dummy
        document.getElementById('exportBtn').addEventListener('click', () => {
            document.getElementById('exportModal').style.display = 'flex';
        });
        document.getElementById('closeModal').addEventListener('click', () => {
            document.getElementById('exportModal').style.display = 'none';
        });
    </script>
</body>
</html>
