<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#000000">
  <title>COLIGNUM · perfect PNG · comfy prompt studio</title>
  <style>
    * {
      box-sizing: border-box;
      user-select: none;
      font-family: 'Courier New', Courier, monospace;
    }
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #fff;
      color: #000;
      transition: background-color 0.1s, color 0.1s;
    }
    body.inverted {
      background: #000;
      color: #fff;
    }
    body.inverted .toolbar {
      background: #111;
      border-bottom: 2px solid #fff;
    }
    body.inverted .toolbar button {
      background: #000;
      color: #fff;
      border: 2px solid #fff;
    }
    body.inverted .toolbar button:hover {
      background: #333;
    }
    body.inverted .canvas-container {
      background: #000;
    }
    body.inverted .node {
      background: #000;
      color: #fff;
      border-color: #fff;
      box-shadow: 8px 8px 0 #fff; /* inverted shadow */
    }
    body.inverted .node .drag-bar {
      background: #333;
      border-bottom: 1px solid #fff;
    }
    body.inverted .node .delete-btn {
      background: #fff;
      color: #000;
      border: 1px solid #000;
    }
    body.inverted .grid-bg {
      background-image: 
        linear-gradient(#333 1px, transparent 1px),
        linear-gradient(90deg, #333 1px, transparent 1px);
    }
    .grid-bg {
      background-image: 
        linear-gradient(#ccc 1px, transparent 1px),
        linear-gradient(90deg, #ccc 1px, transparent 1px);
      background-size: 40px 40px;
    }

    #app {
      display: flex;
      flex-direction: column;
      height: 100vh;
      width: 100vw;
    }

    .toolbar {
      padding: 12px 16px;
      background: #f0f0f0;
      border-bottom: 2px solid #000;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      flex-shrink: 0;
    }
    .toolbar button {
      background: #fff;
      border: 2px solid #000;
      color: #000;
      padding: 8px 18px;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      border-radius: 0px;
      box-shadow: 4px 4px 0 #000;
      transition: 0.05s linear;
      font-family: inherit;
    }
    .toolbar button:active {
      transform: translate(2px, 2px);
      box-shadow: 2px 2px 0 #000;
    }
    .toolbar span {
      margin-left: auto;
      font-size: 1.2rem;
      font-weight: bold;
      letter-spacing: 1px;
    }
    .toolbar .brand {
      font-size: 1.4rem;
      margin-right: 10px;
      border-right: 2px solid #000;
      padding-right: 20px;
    }
    body.inverted .brand {
      border-color: #fff;
    }

    .canvas-wrapper {
      flex: 1;
      overflow: auto;
      position: relative;
      background: #fff;
    }
    .canvas-container {
      position: relative;
      width: 2500px;
      height: 2000px;
      background: #fff;
    }

    #lineOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
    }
    #lineOverlay svg {
      width: 100%;
      height: 100%;
    }

    .node {
      position: absolute;
      width: 250px;
      min-height: 130px;
      background: #fff;
      border: 3px solid #000;
      box-shadow: 8px 8px 0 #000;
      color: #000;
      z-index: 10;
      cursor: default;
      display: flex;
      flex-direction: column;
      font-size: 15px;
      line-height: 1.4;
    }
    .node .drag-bar {
      height: 28px;
      background: #ddd;
      border-bottom: 2px solid #000;
      cursor: grab;
      display: flex;
      align-items: center;
      padding-left: 10px;
      font-size: 14px;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .node .drag-bar:active {
      cursor: grabbing;
    }
    .node .node-text {
      padding: 10px 8px;
      min-height: 90px;
      outline: none;
      background: transparent;
      color: inherit;
      word-break: break-word;
      white-space: pre-wrap;
      cursor: text;
      font-size: 15px;
      border: none;
      resize: none;
      font-family: 'Courier New', monospace;
    }
    .node .delete-btn {
      position: absolute;
      top: -12px;
      right: -12px;
      width: 28px;
      height: 28px;
      background: #000;
      border: 2px solid #fff;
      color: #fff;
      font-weight: bold;
      font-size: 16px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 20;
      box-shadow: 2px 2px 0 #000;
    }
    .node .delete-btn:hover {
      background: #333;
    }
  </style>
</head>
<body>
<div id="app">
  <div class="toolbar">
    <span class="brand">COLIGNUM | PERFECT PNG</span>
    <button id="addNodeBtn">➕ ADD BOX</button>
    <button id="exportPngBtn">⬇️ EXPORT 4K PNG</button>
    <button id="fullscreenBtn">⛶ FULLSCREEN</button>
    <button id="invertBtn">◑ INVERT B/W</button>
    <span style="opacity:0.7;">— drag bars • edit text —</span>
  </div>
  <div class="canvas-wrapper" id="canvasWrapper">
    <div class="canvas-container grid-bg" id="canvasContainer">
      <div id="lineOverlay"><svg id="lineSvg"></svg></div>
    </div>
  </div>
</div>

<script>
  (function() {
    // --- state ---
    const nodes = [];
    let nextId = 100;
    let draggedNode = null;
    let dragOffsetX, dragOffsetY;

    const canvas = document.getElementById('canvasContainer');
    const lineSvg = document.getElementById('lineSvg');
    const wrapper = document.getElementById('canvasWrapper');

    // --- helper: update lines (black/white theme aware) ---
    function updateLines() {
      lineSvg.innerHTML = '';
      if (nodes.length < 2) return;

      for (let i = 0; i < nodes.length - 1; i++) {
        const a = nodes[i];
        const b = nodes[i + 1];
        if (!a.element || !b.element) continue;

        const aX = a.x;
        const aY = a.y;
        const aW = a.element.offsetWidth;
        const aH = a.element.offsetHeight;
        const bX = b.x;
        const bY = b.y;
        const bW = b.element.offsetWidth;
        const bH = b.element.offsetHeight;

        const startX = aX + aW/2;
        const startY = aY + aH;
        const endX = bX + bW/2;
        const endY = bY;

        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", startX);
        line.setAttribute("y1", startY);
        line.setAttribute("x2", endX);
        line.setAttribute("y2", endY);
        line.setAttribute("stroke", "#000");
        line.setAttribute("stroke-width", "3");
        line.setAttribute("stroke-linecap", "round");
        lineSvg.appendChild(line);
      }
      applyLineColorByTheme();
    }

    function applyLineColorByTheme() {
      const isInverted = document.body.classList.contains('inverted');
      document.querySelectorAll('#lineSvg line').forEach(l => l.setAttribute('stroke', isInverted ? '#fff' : '#000'));
    }

    // --- create node DOM ---
    function createNodeElement(id, x, y, textContent = 'edit prompt...') {
      const div = document.createElement('div');
      div.className = 'node';
      div.style.left = x + 'px';
      div.style.top = y + 'px';
      div.setAttribute('data-id', id);

      const dragBar = document.createElement('div');
      dragBar.className = 'drag-bar';
      dragBar.innerText = '⣿ COMMAND ⣿';
      dragBar.setAttribute('data-drag', 'true');

      const textDiv = document.createElement('div');
      textDiv.className = 'node-text';
      textDiv.setAttribute('contenteditable', 'true');
      textDiv.innerText = textContent;

      const delBtn = document.createElement('div');
      delBtn.className = 'delete-btn';
      delBtn.innerText = '✕';
      delBtn.setAttribute('data-delete', 'true');

      div.appendChild(dragBar);
      div.appendChild(textDiv);
      div.appendChild(delBtn);

      dragBar.addEventListener('mousedown', (e) => onDragStart(e, id));
      delBtn.addEventListener('click', (e) => { e.stopPropagation(); deleteNode(id); });
      textDiv.addEventListener('input', (e) => {
        const node = nodes.find(n => n.id === id);
        if (node) node.text = e.target.innerText;
        updateLines();
      });
      textDiv.addEventListener('blur', () => updateLines());

      return div;
    }

    function addNode(x = 200, y = 200, initialText = 'prompt idea...') {
      const id = nextId++;
      const nodeEl = createNodeElement(id, x, y, initialText);
      canvas.appendChild(nodeEl);
      const nodeObj = { id, x, y, text: initialText, element: nodeEl };
      nodes.push(nodeObj);
      updateLines();
      return nodeObj;
    }

    function deleteNode(id) {
      const idx = nodes.findIndex(n => n.id === id);
      if (idx !== -1) {
        nodes[idx].element.remove();
        nodes.splice(idx, 1);
        updateLines();
      }
    }

    // --- drag logic ---
    function onDragStart(e, id) {
      e.preventDefault();
      const node = nodes.find(n => n.id === id);
      if (!node) return;
      draggedNode = node;
      dragOffsetX = e.clientX - node.x;
      dragOffsetY = e.clientY - node.y;

      function onDragMove(e) {
        if (!draggedNode) return;
        e.preventDefault();
        draggedNode.x = Math.max(0, e.clientX - dragOffsetX);
        draggedNode.y = Math.max(0, e.clientY - dragOffsetY);
        draggedNode.element.style.left = draggedNode.x + 'px';
        draggedNode.element.style.top = draggedNode.y + 'px';
        updateLines();
      }
      function onDragEnd() {
        draggedNode = null;
        window.removeEventListener('mousemove', onDragMove);
        window.removeEventListener('mouseup', onDragEnd);
      }
      window.addEventListener('mousemove', onDragMove);
      window.addEventListener('mouseup', onDragEnd);
    }

    // --- EXPORT FIX: perfect SVG generation with exact node styles and lines ---
    function generateSVGString() {
      if (nodes.length === 0) return null;

      // 1. compute bounding box including shadows (8px) and generous padding
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      nodes.forEach(n => {
        const w = n.element.offsetWidth;
        const h = n.element.offsetHeight;
        minX = Math.min(minX, n.x);
        minY = Math.min(minY, n.y);
        maxX = Math.max(maxX, n.x + w + 8);   // shadow right
        maxY = Math.max(maxY, n.y + h + 8);   // shadow down
      });

      // extra padding to ensure lines, caps, and any floating parts are not clipped
      const pad = 100;
      minX -= pad;
      minY -= pad;
      maxX += pad;
      maxY += pad;

      const width = maxX - minX;
      const height = maxY - minY;

      // 2. start SVG with white background
      let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${minX} ${minY} ${width} ${height}" width="${width}" height="${height}" style="background:#fff;">\n`;
      svg += `<rect width="100%" height="100%" fill="#fff"/>\n`;

      // 3. draw lines between consecutive nodes (black, 3px) using same coordinates as overlay
      for (let i = 0; i < nodes.length - 1; i++) {
        const a = nodes[i];
        const b = nodes[i + 1];
        const aW = a.element.offsetWidth;
        const aH = a.element.offsetHeight;
        const bW = b.element.offsetWidth;
        const bH = b.element.offsetHeight;
        const x1 = a.x + aW/2, y1 = a.y + aH;
        const x2 = b.x + bW/2, y2 = b.y;
        svg += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="#000" stroke-width="3" stroke-linecap="round" />\n`;
      }

      // 4. embed styles for exact node replication (mirroring editor .node, .drag-bar, .node-text)
      const styleText = `
        .export-node {
          background: #fff;
          border: 3px solid #000;
          box-shadow: 8px 8px 0 #000;
          font-family: 'Courier New', Courier, monospace;
          font-size: 15px;
          width: 100%;
          height: 100%;
          display: flex;
          flex-direction: column;
          box-sizing: border-box;
        }
        .export-drag {
          height: 28px;
          background: #ddd;
          border-bottom: 2px solid #000;
          padding-left: 10px;
          line-height: 26px;          /* 28px - border-bottom (2px) = 26px content height */
          font-weight: bold;
          text-transform: uppercase;
          font-size: 14px;
          letter-spacing: 0.5px;
          box-sizing: border-box;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
        }
        .export-text {
          padding: 10px 8px;
          min-height: 90px;
          white-space: pre-wrap;
          word-break: break-word;
          font-size: 15px;
          line-height: 1.4;
          box-sizing: border-box;
          flex: 1;                    /* fills remaining height, respects min-height via parent flex */
        }
      `;

      // 5. add each node as foreignObject with exact dimensions
      nodes.forEach(n => {
        const w = n.element.offsetWidth;
        const h = n.element.offsetHeight;
        const text = n.text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\n/g, '<br/>');

        svg += `<foreignObject x="${n.x}" y="${n.y}" width="${w}" height="${h}">\n`;
        svg += `<div xmlns="http://www.w3.org/1999/xhtml">\n`;
        svg += `<style>${styleText}</style>\n`;
        svg += `<div class="export-node">\n`;
        svg += `<div class="export-drag">⣿ COMMAND ⣿</div>\n`;
        svg += `<div class="export-text">${text}</div>\n`;
        svg += `</div>\n`;
        svg += `</div>\n`;
        svg += `</foreignObject>\n`;
      });

      svg += `</svg>`;
      return svg;
    }

    // --- export high‑resolution PNG (4K) with perfect recreation ---
    async function exportPNG() {
      const svgStr = generateSVGString();
      if (!svgStr) return alert('No nodes to export.');

      // extract viewBox dimensions
      const viewBoxMatch = svgStr.match(/viewBox="([^"]+)"/);
      if (!viewBoxMatch) return;
      const [, viewBox] = viewBoxMatch;
      const [minX, minY, vbWidth, vbHeight] = viewBox.split(' ').map(Number);

      // target long edge 4096 pixels (4K)
      const targetLong = 4096;
      const scale = targetLong / Math.max(vbWidth, vbHeight);
      const canvasWidth = Math.round(vbWidth * scale);
      const canvasHeight = Math.round(vbHeight * scale);

      const canvas = document.createElement('canvas');
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      const ctx = canvas.getContext('2d', { alpha: false });

      // fill white background
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);

      // render SVG to canvas
      const blob = new Blob([svgStr], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      const img = new Image();
      await new Promise((resolve, reject) => {
        img.onload = resolve;
        img.onerror = reject;
        img.src = url;
      });
      ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);
      URL.revokeObjectURL(url);

      // download as PNG
      canvas.toBlob((b) => {
        const u = URL.createObjectURL(b);
        const a = document.createElement('a');
        a.href = u;
        a.download = 'colignum_4k.png';
        a.click();
        URL.revokeObjectURL(u);
      }, 'image/png');
    }

    // --- UI: fullscreen, invert ---
    function toggleFullscreen() {
      if (!document.fullscreenElement) document.documentElement.requestFullscreen();
      else document.exitFullscreen();
    }
    function invertUI() {
      document.body.classList.toggle('inverted');
      applyLineColorByTheme();
    }

    // --- initialize with some nodes ---
    function initDefault() {
      addNode(200, 200, 'concept: mystical forest\n#fantasy #moody');
      addNode(520, 320, 'lighting: volumetric fog\ngolden hour');
      addNode(840, 440, 'camera: 50mm\ncinematic depth');
      addNode(1160, 560, 'details: floating particles\nbutterflies');
      setTimeout(updateLines, 50);
    }

    // --- attach event listeners ---
    document.getElementById('addNodeBtn').addEventListener('click', () => {
      let x = 200, y = 200;
      if (nodes.length) {
        const last = nodes[nodes.length - 1];
        x = last.x + 280;
        y = last.y + 30;
        if (x > 2300) x = 200;
        if (y > 1800) y = 200;
      }
      addNode(x, y, 'new prompt...');
    });

    document.getElementById('exportPngBtn').addEventListener('click', exportPNG);
    document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);
    document.getElementById('invertBtn').addEventListener('click', invertUI);

    initDefault();
  })();
</script>
</body>
</html>
