<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Radar Scene</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #000;
            color: white;
        }
        
        #scene-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #ar-face-view {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 180px;
            height: 135px;
            z-index: 2;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            overflow: hidden;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        #face-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        #radar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 200px;
            border-radius: 50%;
            border: 2px solid rgba(0, 255, 0, 0.5);
            z-index: 2;
            background-color: rgba(0, 0, 0, 0.3);
        }
        
        .dot {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        
        .green-dot {
            background-color: #0f0;
            box-shadow: 0 0 8px #0f0;
        }
        
        .red-dot {
            background-color: #f00;
            box-shadow: 0 0 8px #f00;
        }
        
        #info-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 2;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            font-size: 14px;
        }
        
        #instructions {
            position: fixed;
            bottom: 230px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 2;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="scene-container"></div>
    
    <div id="ar-face-view">
        <canvas id="face-canvas"></canvas>
    </div>
    
    <div id="radar"></div>
    
    <div id="info-panel">
        <div>Objects Detected: <span id="object-count">0</span></div>
        <div>FPS: <span id="fps-counter">60</span></div>
    </div>
    
    <div id="instructions">
        Move your device to detect objects. Green = Large surfaces, Red = Small objects
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Limit for performance
        document.getElementById('scene-container').appendChild(renderer.domElement);
        
        // User position (origin)
        const userPosition = new THREE.Vector3(0, 0, 0);
        
        // Object storage
        const detectedObjects = [];
        let objectCount = 0;
        
        // Performance monitoring
        let frameCount = 0;
        let lastFpsUpdate = 0;
        const fpsUpdateInterval = 1000; // Update FPS counter every second
        
        // Create a simple grid floor for reference
        const gridHelper = new THREE.GridHelper(20, 20, 0x00ff00, 0x004400);
        scene.add(gridHelper);
        
        // Create a simple wireframe cube to represent user
        const userGeometry = new THREE.BoxGeometry(0.5, 1.7, 0.5);
        const userMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x00ffff, 
            wireframe: true 
        });
        const userMesh = new THREE.Mesh(userGeometry, userMaterial);
        scene.add(userMesh);
        
        // Position camera at user's eye level
        camera.position.set(0, 1.6, 0);
        
        // Set up face detection canvas
        const faceCanvas = document.getElementById('face-canvas');
        const faceCtx = faceCanvas.getContext('2d');
        faceCanvas.width = 180;
        faceCanvas.height = 135;
        
        // Draw wireframe face overlay
        function drawFaceWireframe() {
            faceCtx.clearRect(0, 0, faceCanvas.width, faceCanvas.height);
            
            // Draw face oval
            faceCtx.beginPath();
            faceCtx.ellipse(faceCanvas.width/2, faceCanvas.height/2, 60, 80, 0, 0, Math.PI * 2);
            faceCtx.strokeStyle = '#00ffff';
            faceCtx.lineWidth = 2;
            faceCtx.stroke();
            
            // Draw eyes
            faceCtx.beginPath();
            faceCtx.arc(faceCanvas.width/2 - 25, faceCanvas.height/2 - 10, 10, 0, Math.PI * 2);
            faceCtx.arc(faceCanvas.width/2 + 25, faceCanvas.height/2 - 10, 10, 0, Math.PI * 2);
            faceCtx.stroke();
            
            // Draw mouth
            faceCtx.beginPath();
            faceCtx.arc(faceCanvas.width/2, faceCanvas.height/2 + 20, 20, 0, Math.PI);
            faceCtx.stroke();
            
            // Draw detection points
            for (let i = 0; i < 10; i++) {
                const x = Math.random() * faceCanvas.width;
                const y = Math.random() * faceCanvas.height;
                faceCtx.beginPath();
                faceCtx.arc(x, y, 2, 0, Math.PI * 2);
                faceCtx.fillStyle = Math.random() > 0.5 ? '#0f0' : '#f00';
                faceCtx.fill();
            }
        }
        
        // Simulate object detection
        function simulateObjectDetection() {
            // In a real app, this would use actual AR object detection
            // For simulation, we randomly add objects around the user
            
            if (Math.random() < 0.05 && detectedObjects.length < 200) { // Limit objects for performance
                const distance = 2 + Math.random() * 8;
                const angle = Math.random() * Math.PI * 2;
                
                const x = Math.cos(angle) * distance;
                const z = Math.sin(angle) * distance;
                const y = Math.random() * 3; // Vary height
                
                // Randomly decide if it's a green (large) or red (small) object
                const isLargeObject = Math.random() > 0.5;
                const color = isLargeObject ? 0x00ff00 : 0xff0000;
                
                addDetectedObject(x, y, z, color);
                
                // Also add to radar view
                addRadarDot(x, z, isLargeObject);
            }
        }
        
        // Add a detected object to the 3D scene
        function addDetectedObject(x, y, z, color) {
            // Use very lightweight geometry
            const geometry = new THREE.SphereGeometry(0.1, 6, 6); // Low poly sphere
            const material = new THREE.MeshBasicMaterial({ color: color });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(x, y, z);
            scene.add(sphere);
            
            detectedObjects.push(sphere);
            objectCount++;
            document.getElementById('object-count').textContent = objectCount;
        }
        
        // Add a dot to the radar display
        function addRadarDot(x, z, isLarge) {
            const radar = document.getElementById('radar');
            const dot = document.createElement('div');
            dot.className = `dot ${isLarge ? 'green-dot' : 'red-dot'}`;
            
            // Convert 3D coordinates to radar coordinates
            const radarX = (x / 10) * 100 + 50; // Scale to radar size
            const radarY = (z / 10) * 100 + 50;
            
            dot.style.left = `${radarX}%`;
            dot.style.top = `${radarY}%`;
            
            radar.appendChild(dot);
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        window.addEventListener('resize', onWindowResize);
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Simulate object detection
            simulateObjectDetection();
            
            // Update face wireframe occasionally
            if (frameCount % 30 === 0) {
                drawFaceWireframe();
            }
            
            // Rotate camera based on device orientation (simulated)
            if (frameCount % 60 === 0) {
                camera.rotation.y += 0.01;
            }
            
            // Update FPS counter
            const now = performance.now();
            if (now - lastFpsUpdate > fpsUpdateInterval) {
                const fps = Math.round((frameCount * 1000) / (now - lastFpsUpdate));
                document.getElementById('fps-counter').textContent = fps;
                frameCount = 0;
                lastFpsUpdate = now;
            }
            
            frameCount++;
            renderer.render(scene, camera);
        }
        
        // Initialize
        drawFaceWireframe();
        animate();
    </script>
</body>
</html>