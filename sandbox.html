<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Galaxycraft - BETA</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
    }
    body {
      background: #000;
      color: #fff;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    #cosmicCanvas {
      flex: 1;
      width: 100%;
      touch-action: none;
      position: relative;
    }
    .controls {
      position: fixed;
      bottom: 0;
      width: 100%;
      background: rgba(20, 20, 50, 0.9);
      padding: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      backdrop-filter: blur(5px);
      z-index: 10;
    }
    .control-item {
      flex: 1;
      min-width: 80px;
      text-align: center;
    }
    button {
      background: #4a90e2;
      border: none;
      padding: 10px 20px;
      color: white;
      border-radius: 20px;
      cursor: pointer;
      font-size: 16px;
      transition: transform 0.2s, background 0.2s;
    }
    button:hover {
      background: #357abd;
    }
    button.active {
      background: #ff4444;
    }
    button:active {
      transform: scale(0.95);
    }
    .prompt {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 10px;
      font-size: 14px;
      max-width: 90%;
      text-align: center;
      opacity: 0;
      transition: opacity 0.5s;
      z-index: 5;
    }
    .prompt.active {
      opacity: 1;
    }
    .hud {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      opacity: 0.4;
      z-index: 1;
    }
    .hud::before {
      content: '';
      position: absolute;
      top: 10%;
      left: 10%;
      right: 10%;
      bottom: 10%;
      border: 2px solid rgba(74, 144, 226, 0);
      border-radius: 20px;
      box-shadow: none;
    }
    .hud::after {
      content: '+';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #4a90e2;
      font-size: 24px;
    }
    .throttle-indicator {
      position: absolute;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      color: #4a90e2;
      font-size: 12px;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 5;
    }
    .throttle-indicator.active {
      opacity: 1;
    }
    .status-overlay {
      position: absolute;
      top: 0;
      width: 100%;
      background: rgba(0, 0, 0, 0.3);
      padding: 5px 10px;
      font-size: 12px;
      text-align: left;
      color: #fff;
      text-shadow: 0 0 2px #000;
      z-index: 5;
      pointer-events: none;
    }
    .console {
      position: absolute;
      bottom: 60px;
      width: 100%;
      height: 25%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      flex-direction: column;
      z-index: 5;
      padding: 5px;
    }
    .console-log {
      flex: 1;
      overflow-y: auto;
      font-size: 12px;
      color: #fff;
      text-shadow: 0 0 2px #000;
      padding: 5px;
    }
    .console-log p {
      margin: 2px 0;
    }
    .console-input {
      width: 100%;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid #4a90e2;
      color: #fff;
      padding: 5px;
      font-size: 12px;
      outline: none;
    }
    .console-input::placeholder {
      color: #aaa;
    }
    .console::-webkit-scrollbar {
      width: 8px;
    }
    .console::-webkit-scrollbar-thumb {
      background: #4a90e2;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div id="cosmicCanvas">
    <div class="hud"></div>
    <div id="statusOverlay" class="status-overlay"></div>
    <div id="throttleIndicator" class="throttle-indicator"></div>
    <div id="console" class="console">
      <div id="consoleLog" class="console-log"></div>
      <input id="consoleInput" class="console-input" type="text" placeholder="Type /help for commands..." autocomplete="off">
    </div>
  </div>
  <div class="controls">
    <div class="control-item">
      <button id="throttleBtn">Full Throttle</button>
    </div>
    <div class="control-item">
      <button id="addComet">Add Comet</button>
    </div>
    <div class="control-item">
      <button id="addSystem">Add System</button>
    </div>
    <div class="control-item">
      <button id="addGalaxy">Add Galaxy</button>
    </div>
    <div class="control-item">
      <button id="addNode">Add Node</button>
    </div>
    <div class="control-item">
      <button id="autopilotBtn">Autopilot</button>
    </div>
    <div class="control-item">
      <button id="shootBtn">Shoot</button>
    </div>
    <div class="control-item">
      <button id="resetBtn">Reset</button>
    </div>
  </div>
  <div id="prompt" class="prompt"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
    window.onload = () => {
      try {
        // Scene setup
        if (!window.THREE) throw new Error('Three.js not loaded');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 1);
        const canvas = document.getElementById('cosmicCanvas');
        if (!canvas) throw new Error('Canvas element not found');
        canvas.appendChild(renderer.domElement);

        camera.position.set(0, 0, 0);
        const frustum = new THREE.Frustum();
        const cameraMatrix = new THREE.Matrix4();

        // Shared resources
        const sharedMaterials = {
          glow: new THREE.MeshBasicMaterial({ color: 0xffffff }),
          star: new THREE.MeshBasicMaterial({ color: 0xffff99 }),
          planet: new THREE.MeshBasicMaterial({ color: 0x3399ff }),
          node: new THREE.MeshBasicMaterial({ color: 0xff33cc }),
          line: new THREE.LineBasicMaterial({ color: 0x00ff00 })
        };
        const sharedGeometries = {
          comet: new THREE.SphereGeometry(5, 8, 8),
          star: new THREE.SphereGeometry(100, 16, 16),
          planet: new THREE.SphereGeometry(20, 12, 12),
          galaxyStar: new THREE.SphereGeometry(10, 8, 8),
          projectile: new THREE.SphereGeometry(5, 8, 8),
          node: new THREE.BoxGeometry(10, 10, 10)
        };

        // Entities
        let comets = [];
        let systems = [];
        let galaxies = [];
        let projectiles = [];
        let nodes = [];
        let nodeLines = [];
        let cometInstances = null;
        let projectileInstances = null;
        let cometCount = 0;
        let projectileCount = 0;
        let throttle = 0;
        let rotation = { pitch: 0, yaw: 0 };
        let rotationVelocity = { pitch: 0, yaw: 0 };
        let velocity = new THREE.Vector3(0, 0, 0);
        let lastTime = performance.now();
        let entityCount = 0;
        let autopilotActive = false;
        let currentNodeIndex = 0;

        // Gravity parameters
        const G = 100; // Scaled gravitational constant
        const softening = 10; // Prevent singularities
        const maxGravityDistance = 2000; // Optimize by ignoring far objects

        // Console and status
        const statusOverlay = document.getElementById('statusOverlay');
        const consoleLog = document.getElementById('consoleLog');
        const consoleInput = document.getElementById('consoleInput');
        const maxLogMessages = 50;
        let logMessages = [];

        function addConsoleMessage(message) {
          const timestamp = new Date().toLocaleTimeString();
          logMessages.push(`[${timestamp}] ${message}`);
          if (logMessages.length > maxLogMessages) {
            logMessages.shift();
          }
          consoleLog.innerHTML = logMessages.map(msg => `<p>${msg}</p>`).join('');
          consoleLog.scrollTop = consoleLog.scrollHeight;
        }

        function updateStatusOverlay() {
          statusOverlay.textContent = `Entities: ${entityCount} | Throttle: ${throttle} | Autopilot: ${autopilotActive ? 'On' : 'Off'} | Nodes: ${nodes.length}`;
        }

        // Keyboard controls
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        window.addEventListener('keydown', e => {
          if (e.key in keys) {
            keys[e.key] = true;
            e.preventDefault();
          }
        });
        window.addEventListener('keyup', e => {
          if (e.key in keys) keys[e.key] = false;
        });

        // Console commands
        function handleCommand(input) {
          const cmd = input.trim().toLowerCase();
          if (!cmd.startsWith('/')) {
            addConsoleMessage('Commands must start with "/". Type /help for commands.');
            return;
          }
          const parts = cmd.slice(1).split(' ');
          const command = parts[0];
          const args = parts.slice(1);

          switch (command) {
            case 'help':
              addConsoleMessage('Commands: /add comet, /add system, /add galaxy, /add node, /shoot, /reset, /throttle, /autopilot');
              break;
            case 'add':
              if (args[0] === 'comet') {
                addComet();
              } else if (args[0] === 'system') {
                addPlanetarySystem();
              } else if (args[0] === 'galaxy') {
                addGalaxy();
              } else if (args[0] === 'node') {
                addNode();
              } else {
                addConsoleMessage('Invalid add command. Use: comet, system, galaxy, node');
              }
              break;
            case 'shoot':
              shoot();
              break;
            case 'reset':
              reset();
              break;
            case 'throttle':
              if (autopilotActive) {
                addConsoleMessage('Cannot toggle throttle during autopilot.');
              } else {
                toggleThrottle();
              }
              break;
            case 'autopilot':
              toggleAutopilot();
              break;
            default:
              addConsoleMessage('Unknown command. Type /help for commands.');
          }
        }

        consoleInput.addEventListener('keydown', e => {
          if (e.key === 'Enter') {
            const input = consoleInput.value;
            if (input) {
              addConsoleMessage(`> ${input}`);
              handleCommand(input);
              consoleInput.value = '';
            }
          }
        });

        // Object pools
        const cometPool = [];
        const projectilePool = [];
        const nodePool = [];
        function getCometFromPool() {
          if (cometPool.length > 0) {
            const comet = cometPool.pop();
            comet.visible = true;
            return comet;
          }
          return new THREE.Mesh(sharedGeometries.comet, sharedMaterials.glow);
        }
        function getProjectileFromPool() {
          if (projectilePool.length > 0) {
            const projectile = projectilePool.pop();
            projectile.visible = true;
            return projectile;
          }
          return new THREE.Mesh(sharedGeometries.projectile, sharedMaterials.glow);
        }
        function getNodeFromPool() {
          if (nodePool.length > 0) {
            const node = nodePool.pop();
            node.visible = true;
            return node;
          }
          return new THREE.Mesh(sharedGeometries.node, sharedMaterials.node);
        }

        // Simulated data
        const trainingData = {
          comets: Array(100).fill().map(() => ({
            semiMajorAxis: Math.random() * 50 + 20,
            eccentricity: Math.random() * 0.8,
            velocity: Math.random() * 3 + 1
          })),
          systems: Array(50).fill().map(() => ({
            planets: Math.floor(Math.random() * 3) + 1,
            orbitalRadius: Math.random() * 100 + 50
          })),
          galaxies: Array(20).fill().map(() => ({
            radius: Math.random() * 300 + 150,
            type: ['spiral', 'elliptical'][Math.floor(Math.random() * 2)]
          }))
        };

        // Add entities
        function addComet() {
          const params = trainingData.comets[Math.floor(Math.random() * trainingData.comets.length)];
          const comet = getCometFromPool();
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          const offset = new THREE.Vector3(
            (Math.random() - 0.5) * 50,
            (Math.random() - 0.5) * 50,
            (Math.random() - 0.5) * 50
          );
          comet.position.copy(camera.position).add(forward.multiplyScalar(500)).add(offset);
          comet.userData = {
            type: 'comet',
            mass: 1,
            velocity: new THREE.Vector3((Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5),
            created: Date.now(),
            instanceId: cometCount
          };
          scene.add(comet);
          comets.push(comet);
          cometCount++;
          entityCount++;
          updateCometInstances();
          if (entityCount > 500) showPrompt(8);
          showPrompt(1);
          addConsoleMessage('Comet added to your galaxy.');
          updateStatusOverlay();
        }

        function updateCometInstances() {
          if (cometInstances) scene.remove(cometInstances);
          cometInstances = new THREE.InstancedMesh(sharedGeometries.comet, sharedMaterials.glow, cometCount);
          const matrix = new THREE.Matrix4();
          comets.forEach((comet, i) => {
            matrix.setPosition(comet.position);
            cometInstances.setMatrixAt(i, matrix);
          });
          scene.add(cometInstances);
        }

        function addPlanetarySystem() {
          const params = trainingData.systems[Math.floor(Math.random() * trainingData.systems.length)];
          const systemGroup = new THREE.Group();
          const star = new THREE.Mesh(sharedGeometries.star, sharedMaterials.star);
          star.userData = { type: 'star', mass: 1000, velocity: new THREE.Vector3(0, 0, 0) };
          systemGroup.add(star);
          for (let i = 0; i < params.planets; i++) {
            const planet = new THREE.Mesh(sharedGeometries.planet, sharedMaterials.planet);
            const orbitalRadius = (i + 1) * params.orbitalRadius / params.planets;
            planet.position.set(orbitalRadius, 0, 0);
            // Set initial tangential velocity for stable orbit
            const v = Math.sqrt(G * star.userData.mass / orbitalRadius);
            planet.userData = {
              type: 'planet',
              mass: 10,
              velocity: new THREE.Vector3(0, 0, v),
              orbitalRadius
            };
            systemGroup.add(planet);
          }
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          const offset = new THREE.Vector3(
            (Math.random() - 0.5) * 100,
            (Math.random() - 0.5) * 100,
            (Math.random() - 0.5) * 100
          );
          systemGroup.position.copy(camera.position).add(forward.multiplyScalar(1000)).add(offset);
          systemGroup.userData = { created: Date.now() };
          scene.add(systemGroup);
          systems.push(systemGroup);
          entityCount += 1 + params.planets;
          if (entityCount > 500) showPrompt(8);
          showPrompt(2);
          addConsoleMessage('Planetary system created ahead.');
          updateStatusOverlay();
        }

        function addGalaxy() {
          const params = trainingData.galaxies[Math.floor(Math.random() * trainingData.galaxies.length)];
          const galaxyGroup = new THREE.Group();
          const starCount = params.type === 'spiral' ? 10 : 5;
          for (let i = 0; i < starCount; i++) {
            const star = new THREE.Mesh(sharedGeometries.galaxyStar, sharedMaterials.glow);
            const r = Math.random() * params.radius;
            const theta = Math.random() * Math.PI * 2;
            const phi = params.type === 'spiral' ? Math.random() * 0.2 : Math.random() * Math.PI;
            star.position.set(
              r * Math.sin(phi) * Math.cos(theta),
              r * Math.sin(phi) * Math.sin(theta),
              r * Math.cos(phi)
            );
            // Set initial circular velocity
            const v = Math.sqrt(G * 50 / r); // Assume central mass equivalent
            const pos = star.position.clone();
            const tangent = new THREE.Vector3(-pos.y, pos.x, 0).normalize();
            star.userData = {
              type: 'star',
              mass: 50,
              velocity: tangent.multiplyScalar(v),
              angle: theta
            };
            galaxyGroup.add(star);
          }
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          const offset = new THREE.Vector3(
            (Math.random() - 0.5) * 200,
            (Math.random() - 0.5) * 200,
            (Math.random() - 0.5) * 200
          );
          galaxyGroup.position.copy(camera.position).add(forward.multiplyScalar(2000)).add(offset);
          galaxyGroup.userData = { radius: params.radius, created: Date.now() };
          scene.add(galaxyGroup);
          galaxies.push(galaxyGroup);
          entityCount += starCount;
          if (entityCount > 500) showPrompt(8);
          showPrompt(3);
          addConsoleMessage('Galaxy spawned with stars.');
          updateStatusOverlay();
        }

        function addNode() {
          const node = getNodeFromPool();
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          const offset = new THREE.Vector3(
            (Math.random() - 0.5) * 100,
            (Math.random() - 0.5) * 100,
            (Math.random() - 0.5) * 100
          );
          node.position.copy(camera.position).add(forward.multiplyScalar(300)).add(offset);
          node.userData = { type: 'node', created: Date.now() };
          scene.add(node);
          nodes.push(node);
          entityCount++;

          if (nodes.length > 1) {
            const prevNode = nodes[nodes.length - 2];
            const geometry = new THREE.BufferGeometry().setFromPoints([
              prevNode.position,
              node.position
            ]);
            const line = new THREE.Line(geometry, sharedMaterials.line);
            scene.add(line);
            nodeLines.push(line);
          }

          if (entityCount > 500) showPrompt(8);
          showPrompt(4);
          addConsoleMessage('Satellite node deployed.');
          updateStatusOverlay();
        }

        function shoot() {
          const projectile = getProjectileFromPool();
          const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          projectile.position.copy(camera.position).add(forward.multiplyScalar(10));
          projectile.userData = {
            type: 'projectile',
            velocity: forward.multiplyScalar(20),
            remove: false,
            instanceId: projectileCount
          };
          scene.add(projectile);
          projectiles.push(projectile);
          projectileCount++;
          updateProjectileInstances();
          showPrompt(5);
          addConsoleMessage('Projectile fired!');
          updateStatusOverlay();
        }

        function updateProjectileInstances() {
          if (projectileInstances) scene.remove(projectileInstances);
          projectileInstances = new THREE.InstancedMesh(sharedGeometries.projectile, sharedMaterials.glow, projectileCount);
          const matrix = new THREE.Matrix4();
          projectiles.forEach((projectile, i) => {
            matrix.setPosition(projectile.position);
            projectileInstances.setMatrixAt(i, matrix);
          });
          scene.add(projectileInstances);
        }

        function reset() {
          comets.forEach(comet => {
            comet.visible = false;
            cometPool.push(comet);
            scene.remove(comet);
          });
          comets = [];
          systems.forEach(system => scene.remove(system));
          systems = [];
          galaxies.forEach(galaxy => scene.remove(galaxy));
          galaxies = [];
          projectiles.forEach(projectile => {
            projectile.visible = false;
            projectilePool.push(projectile);
            scene.remove(projectile);
          });
          projectiles = [];
          nodes.forEach(node => {
            node.visible = false;
            nodePool.push(node);
            scene.remove(node);
          });
          nodes = [];
          nodeLines.forEach(line => scene.remove(line));
          nodeLines = [];
          if (cometInstances) {
            scene.remove(cometInstances);
            cometInstances = null;
          }
          if (projectileInstances) {
            scene.remove(projectileInstances);
            projectileInstances = null;
          }
          cometCount = 0;
          projectileCount = 0;
          entityCount = 0;
          autopilotActive = false;
          currentNodeIndex = 0;
          throttle = 0;
          const autopilotBtn = document.getElementById('autopilotBtn');
          if (autopilotBtn) autopilotBtn.classList.remove('active');
          const throttleBtn = document.getElementById('throttleBtn');
          if (throttleBtn) throttleBtn.classList.remove('active');
          const throttleIndicator = document.getElementById('throttleIndicator');
          if (throttleIndicator) {
            throttleIndicator.textContent = '';
            throttleIndicator.classList.remove('active');
          }
          showPrompt(6);
          addConsoleMessage('Galaxy reset to blank slate.');
          updateStatusOverlay();
        }

        // Throttle toggle for command
        function toggleThrottle() {
          throttle = throttle === 0 ? 150 : 0;
          const throttleBtn = document.getElementById('throttleBtn');
          if (throttleBtn) throttleBtn.classList.toggle('active', throttle > 0);
          const throttleIndicator = document.getElementById('throttleIndicator');
          if (throttleIndicator) {
            throttleIndicator.textContent = throttle > 0 ? `Thrust: ${throttle}` : '';
            throttleIndicator.classList.toggle('active', throttle > 0);
          }
          showPrompt(0);
          addConsoleMessage(throttle > 0 ? 'Manual throttle engaged!' : 'Throttle disengaged.');
          updateStatusOverlay();
        }

        // Autopilot
        function toggleAutopilot() {
          if (nodes.length < 2) {
            showPrompt(7);
            addConsoleMessage('Need at least 2 nodes for autopilot.');
            return;
          }
          autopilotActive = !autopilotActive;
          const autopilotBtn = document.getElementById('autopilotBtn');
          if (autopilotBtn) autopilotBtn.classList.toggle('active', autopilotActive);
          if (autopilotActive) {
            throttle = 0;
            const throttleBtn = document.getElementById('throttleBtn');
            if (throttleBtn) throttleBtn.classList.remove('active');
            const throttleIndicator = document.getElementById('throttleIndicator');
            if (throttleIndicator) {
              throttleIndicator.textContent = '';
              throttleIndicator.classList.remove('active');
            }
            currentNodeIndex = 0;
            showPrompt(9);
            addConsoleMessage('Autopilot engaged! Navigating nodes.');
          } else {
            showPrompt(0);
            addConsoleMessage('Autopilot disengaged.');
          }
          updateStatusOverlay();
        }

        function updateAutopilot(deltaTime) {
          if (!autopilotActive || nodes.length === 0) return;

          const targetNode = nodes[currentNodeIndex];
          const direction = targetNode.position.clone().sub(camera.position);
          const distance = direction.length();

          if (distance < 50) {
            currentNodeIndex = (currentNodeIndex + 1) % nodes.length;
            addConsoleMessage(`Reached node ${currentNodeIndex + 1}. Heading to next node.`);
          }

          // Move straight toward the node
          direction.normalize();
          const speed = 150;
          velocity.copy(direction.multiplyScalar(speed));
          camera.position.add(velocity.clone().multiplyScalar(deltaTime));

          // Align camera directly with the node
          camera.lookAt(targetNode.position);
        }

        // Viewing controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        function updateRotation(deltaX, deltaY) {
          if (autopilotActive) return;
          rotationVelocity.yaw -= deltaX * 0.01;
          rotationVelocity.pitch -= deltaY * 0.01;
        }

        renderer.domElement.addEventListener('mousedown', e => {
          if (autopilotActive) return;
          isDragging = true;
          previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        renderer.domElement.addEventListener('mousemove', e => {
          if (isDragging && !autopilotActive) {
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;
            updateRotation(deltaX, deltaY);
            previousMousePosition = { x: e.clientX, y: e.clientY };
          }
        });

        renderer.domElement.addEventListener('mouseup', () => {
          isDragging = false;
        });

        renderer.domElement.addEventListener('touchstart', e => {
          if (autopilotActive) return;
          e.preventDefault();
          previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });

        renderer.domElement.addEventListener('touchmove', e => {
          if (autopilotActive) return;
          e.preventDefault();
          const deltaX = e.touches[0].clientX - previousMousePosition.x;
          const deltaY = e.touches[0].clientY - previousMousePosition.y;
          updateRotation(deltaX, deltaY);
          previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });

        // Gravity simulation
        function computeGravity() {
          const allObjects = [];
          comets.forEach(comet => allObjects.push({ obj: comet, pos: comet.position, mass: comet.userData.mass, vel: comet.userData.velocity }));
          systems.forEach(system => {
            system.children.forEach(child => {
              if (child.userData.type === 'star' || child.userData.type === 'planet') {
                const worldPos = new THREE.Vector3();
                child.getWorldPosition(worldPos);
                allObjects.push({ obj: child, pos: worldPos, mass: child.userData.mass, vel: child.userData.velocity });
              }
            });
          });
          galaxies.forEach(galaxy => {
            galaxy.children.forEach(star => {
              const worldPos = new THREE.Vector3();
              star.getWorldPosition(worldPos);
              allObjects.push({ obj: star, pos: worldPos, mass: star.userData.mass, vel: star.userData.velocity });
            });
          });

          allObjects.forEach((a, i) => {
            let acc = new THREE.Vector3();
            for (let j = i + 1; j < allObjects.length; j++) {
              const b = allObjects[j];
              const delta = b.pos.clone().sub(a.pos);
              const distSq = delta.lengthSq() + softening * softening;
              if (delta.length() > maxGravityDistance) continue;
              const forceMag = (G * a.mass * b.mass) / distSq;
              const force = delta.normalize().multiplyScalar(forceMag);
              acc.add(force.divideScalar(a.mass));
              b.vel.sub(force.divideScalar(b.mass).multiplyScalar(0.5)); // Half to avoid double-counting
            }
            a.vel.add(acc);
          });
        }

        // Animation loop
        function animate() {
          requestAnimationFrame(animate);

          const now = performance.now();
          const deltaTime = Math.min((now - lastTime) / 1000, 0.1);
          lastTime = now;

          if (!autopilotActive) {
            if (keys.ArrowLeft) rotationVelocity.yaw += 0.05;
            if (keys.ArrowRight) rotationVelocity.yaw -= 0.05;
            if (keys.ArrowUp) rotationVelocity.pitch -= 0.05;
            if (keys.ArrowDown) rotationVelocity.pitch += 0.05;

            rotation.pitch += rotationVelocity.pitch * deltaTime;
            rotation.yaw += rotationVelocity.yaw * deltaTime;
            rotation.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotation.pitch));
            rotationVelocity.pitch *= 0.95;
            rotationVelocity.yaw *= 0.95;

            camera.quaternion.setFromEuler(new THREE.Euler(rotation.pitch, rotation.yaw, 0, 'YXZ'));
          }

          if (!autopilotActive) {
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            velocity.copy(forward.multiplyScalar(throttle));
            camera.position.add(velocity.clone().multiplyScalar(deltaTime));
          } else {
            updateAutopilot(deltaTime);
          }

          // Apply gravity
          computeGravity();

          cameraMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
          frustum.setFromProjectionMatrix(cameraMatrix);

          const matrix = new THREE.Matrix4();
          comets.forEach((comet, i) => {
            if (!frustum.containsPoint(comet.position)) {
              comet.visible = false;
              return;
            }
            comet.visible = true;
            comet.position.add(comet.userData.velocity.clone().multiplyScalar(deltaTime));
            matrix.setPosition(comet.position);
            cometInstances.setMatrixAt(i, matrix);
          });
          if (cometInstances) cometInstances.instanceMatrix.needsUpdate = true;

          systems.forEach(system => {
            if (!frustum.containsPoint(system.position)) return;
            system.children.forEach(child => {
              if (child.userData.mass) {
                const worldPos = new THREE.Vector3();
                child.getWorldPosition(worldPos);
                worldPos.add(child.userData.velocity.clone().multiplyScalar(deltaTime));
                const localPos = worldPos.sub(system.position);
                child.position.copy(localPos);
              }
            });
          });

          galaxies.forEach(galaxy => {
            if (!frustum.containsPoint(galaxy.position)) return;
            galaxy.children.forEach(star => {
              const worldPos = new THREE.Vector3();
              star.getWorldPosition(worldPos);
              worldPos.add(star.userData.velocity.clone().multiplyScalar(deltaTime));
              const localPos = worldPos.sub(galaxy.position);
              star.position.copy(localPos);
            });
          });

          nodeLines.forEach((line, i) => {
            if (i < nodes.length - 1) {
              const geometry = new THREE.BufferGeometry().setFromPoints([
                nodes[i].position,
                nodes[i + 1].position
              ]);
              line.geometry.dispose();
              line.geometry = geometry;
            }
          });

          let projectilesToRemove = [];
          projectiles.forEach((projectile, pIndex) => {
            if (projectile.userData.remove) return;

            projectile.position.add(projectile.userData.velocity.clone().multiplyScalar(deltaTime));
            if (projectile.position.length() > 2000) {
              projectile.userData.remove = true;
              projectilesToRemove.push(pIndex);
              return;
            }
            matrix.setPosition(projectile.position);
            projectileInstances.setMatrixAt(pIndex, matrix);

            if (!frustum.containsPoint(projectile.position)) return;

            let hits = [];
            const now = Date.now();
            const relativePos = projectile.position.clone();

            comets.forEach((comet, index) => {
              if (!comet.visible) return;
              const age = (now - comet.userData.created) / 1000;
              const distance = relativePos.distanceTo(comet.position);
              if (distance < 20) {
                hits.push({ type: 'comet', obj: comet, index, age });
              }
            });

            systems.forEach((system, index) => {
              if (!frustum.containsPoint(system.position)) return;
              const age = (now - system.userData.created) / 1000;
              if (relativePos.distanceTo(system.position) < 100) {
                hits.push({ type: 'system', obj: system, index, age });
                return;
              }
              for (let child of system.children) {
                if (child.userData.type === 'star' || child.userData.type === 'planet') {
                  const worldPos = new THREE.Vector3();
                  child.getWorldPosition(worldPos);
                  const distance = relativePos.distanceTo(worldPos);
                  const threshold = child.userData.type === 'star' ? 100 : 50;
                  if (distance < threshold) {
                    hits.push({ type: 'system', obj: system, index, age });
                    break;
                  }
                }
              }
            });

            galaxies.forEach((galaxy, index) => {
              if (!frustum.containsPoint(galaxy.position)) return;
              const age = (now - galaxy.userData.created) / 1000;
              if (relativePos.distanceTo(galaxy.position) < 200) {
                hits.push({ type: 'galaxy', obj: galaxy, index, age });
                return;
              }
              for (let star of galaxy.children) {
                const worldPos = new THREE.Vector3();
                star.getWorldPosition(worldPos);
                const distance = relativePos.distanceTo(worldPos);
                if (distance < 50) {
                  hits.push({ type: 'galaxy', obj: galaxy, index, age });
                  break;
                }
              }
            });

            nodes.forEach((node, index) => {
              if (!frustum.containsPoint(node.position)) return;
              const age = (now - node.userData.created) / 1000;
              const distance = relativePos.distanceTo(node.position);
              if (distance < 20) {
                hits.push({ type: 'node', obj: node, index, age });
              }
            });

            if (hits.length > 0) {
              hits.sort((a, b) => a.age - b.age);
              for (let hit of hits) {
                scene.remove(hit.obj);
                if (hit.type === 'comet') {
                  comets.splice(hit.index, 1);
                  cometPool.push(hit.obj);
                  cometCount--;
                  entityCount--;
                  updateCometInstances();
                  addConsoleMessage('Comet destroyed.');
                } else if (hit.type === 'system') {
                  systems.splice(hit.index, 1);
                  entityCount -= hit.obj.children.length;
                  addConsoleMessage('Planetary system destroyed.');
                } else if (hit.type === 'galaxy') {
                  galaxies.splice(hit.index, 1);
                  entityCount -= hit.obj.children.length;
                  addConsoleMessage('Galaxy destroyed.');
                } else if (hit.type === 'node') {
                  nodes.splice(hit.index, 1);
                  nodePool.push(hit.obj);
                  entityCount--;
                  nodeLines.forEach(line => scene.remove(line));
                  nodeLines = [];
                  for (let i = 0; i < nodes.length - 1; i++) {
                    const geometry = new THREE.BufferGeometry().setFromPoints([
                      nodes[i].position,
                      nodes[i + 1].position
                    ]);
                    const line = new THREE.Line(geometry, sharedMaterials.line);
                    scene.add(line);
                    nodeLines.push(line);
                  }
                  addConsoleMessage('Node destroyed.');
                }
                updateStatusOverlay();
              }
              projectile.userData.remove = true;
              projectilesToRemove.push(pIndex);
            }
          });

          if (projectileInstances) projectileInstances.instanceMatrix.needsUpdate = true;

          projectilesToRemove.sort((a, b) => b - a);
          projectilesToRemove.forEach(idx => {
            const projectile = projectiles[idx];
            projectile.visible = false;
            projectilePool.push(projectile);
            scene.remove(projectile);
            projectiles.splice(idx, 1);
            projectileCount--;
            updateProjectileInstances();
          });

          renderer.render(scene, camera);
        }

        // Controls
        try {
          const throttleBtn = document.getElementById('throttleBtn');
          const addCometBtn = document.getElementById('addComet');
          const addSystemBtn = document.getElementById('addSystem');
          const addGalaxyBtn = document.getElementById('addGalaxy');
          const addNodeBtn = document.getElementById('addNode');
          const autopilotBtn = document.getElementById('autopilotBtn');
          const shootBtn = document.getElementById('shootBtn');
          const resetBtn = document.getElementById('resetBtn');
          const throttleIndicator = document.getElementById('throttleIndicator');
          const prompt = document.getElementById('prompt');

          if (!throttleBtn || !addCometBtn || !addSystemBtn || !addGalaxyBtn || !addNodeBtn || !autopilotBtn || !shootBtn || !resetBtn || !prompt || !throttleIndicator) {
            throw new Error('One or more control elements not found');
          }

          throttleBtn.addEventListener('click', () => {
            if (autopilotActive) return;
            toggleThrottle();
          });

          addCometBtn.addEventListener('click', addComet);
          addSystemBtn.addEventListener('click', addPlanetarySystem);
          addGalaxyBtn.addEventListener('click', addGalaxy);
          addNodeBtn.addEventListener('click', addNode);
          autopilotBtn.addEventListener('click', toggleAutopilot);
          shootBtn.addEventListener('click', shoot);
          resetBtn.addEventListener('click', reset);

          const prompts = [
            "Manual throttle engaged!",
            "Comet added to your galaxy.",
            "Planetary system created ahead.",
            "Galaxy spawned with stars.",
            "Satellite node deployed.",
            "Projectile fired!",
            "Galaxy reset to blank slate.",
            "Need at least 2 nodes for autopilot!",
            "Warning: Adding more may slow performance!",
            "Autopilot engaged! Navigating nodes."
          ];

          function showPrompt(index) {
            prompt.textContent = prompts[index];
            prompt.classList.add('active');
            setTimeout(() => prompt.classList.remove('active'), 2000);
          }
        } catch (e) {
          console.error('Control setup error:', e);
        }

        // Initialize
        try {
          addConsoleMessage('Galaxycraft initialized. Type /help for commands.');
          updateStatusOverlay();
          animate();
        } catch (e) {
          console.error('Initialization error:', e);
        }

        // Resize
        window.addEventListener('resize', () => {
          try {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
          } catch (e) {
            console.error('Resize error:', e);
          }
        });
      } catch (e) {
        console.error('Main script error:', e);
      }
    };
  </script>
</body>
</html>
