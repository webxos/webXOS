<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vial MCP Controller</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABTSURBVFhH7c6xDYAwDAR7QID/f2XCWGRjI0oF8S6J+wzMdtu2bdu2bdu2bdu2bdu2bdu2bdu2bdu2bdu2bdu2bdu2bdu2bdu2bdu2bdu2bdu2bdu2bdu2bdv+Dv8A2cQ8+LEAAAAASUVORK5CYII=">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet" onerror="logError('Font Load Error', 'Using fallback font', 'No stack', 'LOW')">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: monospace, sans-serif; }
        html, body { height: 100vh; overflow: hidden; background: #000 !important; color: #0f0 !important; display: flex; flex-direction: column; align-items: center; -webkit-tap-highlight-color: transparent; touch-action: manipulation; }
        body.glow { background: rgba(255, 0, 0, 0.1) !important; box-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000 inset; }
        body.train-glow { background: rgba(255, 255, 0, 0.1) !important; box-shadow: 0 0 20px #ff0, 0 0 40px #ff0 inset; }
        h1 { font-size: 1.6rem; text-align: center; margin: 0.8rem 0; text-transform: uppercase; letter-spacing: 1px; text-shadow: 0 0 5px #0f0; color: #0f0 !important; }
        #console { width: 90%; max-width: 900px; background: rgba(0, 255, 0, 0.1) !important; border: 1px solid #0f0; padding: 0.6rem; flex: 1; max-height: calc(100vh - 300px); overflow-y: auto; margin: 0.5rem 0; border-radius: 5px; font-size: 0.8rem; -webkit-overflow-scrolling: touch; white-space: pre-wrap; word-wrap: break-word; }
        #console.active-monitor { border-color: #ff0000 !important; box-shadow: 0 0 10px #ff0000; }
        #console.active-train { border-color: #ff0 !important; box-shadow: 0 0 10px #ff0; }
        #console p { margin: 0.2rem 0; color: #0f0 !important; }
        #console .command { font-family: 'Orbitron', monospace; font-weight: 700; text-shadow: 0 0 3px #0f0; }
        #console .error { color: #ff0000 !important; text-shadow: 0 0 3px #ff0000; }
        .button-group { display: flex; gap: 0.5rem; margin: 0.5rem 0; padding: 0.5rem; flex-wrap: wrap; justify-content: center; width: 90%; max-width: 900px; }
        button { background: #0f0 !important; color: #000 !important; border: none; padding: 0.6rem 1.2rem; font-size: 0.9rem; cursor: pointer; border-radius: 3px; min-width: 90px; text-align: center; touch-action: manipulation; -webkit-user-select: none; user-select: none; }
        button:hover, button:focus, button:active { background: #0c0 !important; outline: 2px solid #0f0; }
        button.active-monitor { background: #ff0000 !important; box-shadow: 0 0 10px #ff0000; }
        button.active-train { background: #ff0 !important; color: #000 !important; box-shadow: 0 0 10px #ff0; }
        button:disabled { background: #666 !important; cursor: not-allowed; }
        #vial-stats, #wallet-stats { width: 90%; max-width: 900px; margin: 0.5rem 0; display: flex; flex-direction: column; gap: 0.2rem; }
        .progress-container { display: flex; align-items: center; gap: 0.4rem; }
        .progress-label { width: 90px; font-size: 0.75rem; color: #0f0 !important; }
        .progress-bar { flex: 1; height: 8px; background: #333 !important; border: 1px solid #0f0; border-radius: 3px; overflow: hidden; }
        .progress-fill { height: 100%; background: #0f0 !important; transition: width 0.5s; }
        #input-container { width: 90%; max-width: 900px; margin: 0.5rem 0; display: flex; flex-direction: column; gap: 0.5rem; }
        #file-input { width: 100%; padding: 0.5rem; background: #000 !important; color: #0f0 !important; border: 1px solid #0f0; border-radius: 3px; font-size: 0.8rem; }
        #input-results { margin-top: 0.5rem; max-height: 100px; overflow-y: auto; font-size: 0.8rem; color: #0f0 !important; }
        #input-results .error { color: #ff0000 !important; }
        footer { width: 100%; padding: 0.4rem; font-size: 9pt; text-align: center; color: #0f0 !important; background: rgba(0, 0, 0, 0.8) !important; line-height: 1.2; }
        @media (max-width: 600px) {
            h1 { font-size: 1.1rem; margin: 0.5rem 0; }
            #console { font-size: 0.75rem; padding: 0.5rem; max-height: calc(100vh - 320px); }
            button { padding: 0.5rem 1rem; font-size: 0.85rem; min-width: 80px; }
            #file-input { font-size: 0.75rem; }
            footer { padding: 0.3rem; }
            .progress-label { width: 70px; font-size: 0.7rem; }
            .progress-bar { height: 7px; }
        }
        @media (max-width: 400px) {
            .button-group { flex-direction: column; align-items: center; }
            button { width: 100%; max-width: 160px; }
            #console { max-height: calc(100vh - 280px); }
            #vial-stats, #wallet-stats { gap: 0.15rem; }
        }
    </style>
    <script src="/static/dexie.min.js" defer onload="logEvent('system', 'Dexie loaded from local', {}, 'INFO')" onerror="loadDexieFallback()"></script>
    <script src="/static/tensorflow.min.js" defer onload="logEvent('system', 'TensorFlow.js loaded from local', {}, 'INFO')" onerror="loadTensorFlowFallback()"></script>
    <script src="/static/skulpt.min.js" defer onload="logEvent('system', 'Skulpt loaded from local', {}, 'INFO')" onerror="logError('Skulpt Load Error', 'Check /static/skulpt.min.js', 'No stack', 'HIGH')"></script>
    <script src="/static/skulpt-stdlib.js" defer onload="logEvent('system', 'Skulpt Stdlib loaded from local', {}, 'INFO')" onerror="logError('Skulpt Stdlib Load Error', 'Check /static/skulpt-stdlib.js', 'No stack', 'HIGH')"></script>
    <script src="/static/mcp-use.min.js" defer onload="logEvent('system', 'MCP-use loaded from local', {}, 'INFO')" onerror="logError('MCP-use Load Error', 'Check /static/mcp-use.min.js', 'No stack', 'HIGH')"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.min.js" defer onload="logEvent('system', 'SQL.js loaded from CDN', {}, 'INFO')" onerror="logError('sql-wasm Load Error', 'Check CDN', 'No stack', 'CRITICAL')"></script>
</head>
<body>
    <h1>Vial MCP Controller</h1>
    <div id="console"></div>
    <div class="button-group">
        <button id="create-btn">Create</button>
        <button id="monitor-btn">Monitor</button>
        <button id="train-btn">Train</button>
        <button id="void-btn">VOID</button>
        <button id="export-btn">Export</button>
        <button id="wallet-btn">Wallet</button>
        <button id="mine-btn">Mine</button>
        <button id="balance-btn">Balance</button>
        <button id="export-wallet-btn">Export Wallet</button>
        <button id="troubleshoot-btn">Troubleshoot</button>
    </div>
    <div id="vial-stats"></div>
    <div id="wallet-stats"></div>
    <div id="input-container">
        <input type="file" id="file-input" accept=".js,.py" onchange="logEvent('file', 'File selected', {}, 'INFO')">
        <div id="input-results"></div>
    </div>
    <footer>WebXOS Vial MCP Controller | Offline Mode | 2025</footer>
    <script>
        // Global state
        let isOnline = navigator.onLine, monitorActive = false, trainActive = false, isMining = false, isLocked = false;
        let vials = Array(4).fill().map((_, i) => ({ id: `vial${i+1}`, latencyHistory: [], status: 'stopped', code: '', filePath: '', createdAt: '', codeLength: 0, trainingData: null, isPython: false }));
        let wallet = { address: null, balance: 0, privateKey: null, passwords: [], miningLog: [], trainingRewards: [] };
        let db = null, worker = null, oauthToken = 'anonymous', isAuthenticated = false, isVialFolderAvailable = false;
        let deviceId = generateUUID(), sessionId = generateUUID(), ipHash = 'offline_placeholder';
        let errorLog = [], logQueue = ['<p>Vial MCP Controller initialized</p>'];
        let lastErrorTime = 0, isLoggingError = false;
        const ERROR_THROTTLE_MS = 100;
        let mcpAgent = null;
        let dexieLoaded = false, tensorflowLoaded = false;

        // UUID generator
        function generateUUID() {
            try {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
                    const r = Math.random() * 16 | 0;
                    const v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            } catch (err) {
                logError(`UUID Generation Error: ${err.message}`, 'Check Math.random', err.stack, 'HIGH');
                return '';
            }
        }

        // Fallback loaders
        function loadDexieFallback() {
            try {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/dexie/3.2.4/dexie.min.js';
                script.onload = () => {
                    dexieLoaded = true;
                    logEvent('system', 'Dexie loaded from CDN fallback', {}, 'INFO');
                    initDexie();
                };
                script.onerror = () => logError('Dexie CDN Fallback Load Error', 'Check CDN or network', 'No stack', 'HIGH');
                document.head.appendChild(script);
            } catch (err) {
                logError(`Dexie Fallback Error: ${err.message}`, 'Check script injection', err.stack, 'HIGH');
            }
        }

        function loadTensorFlowFallback() {
            try {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0/dist/tf.min.js';
                script.onload = () => {
                    tensorflowLoaded = true;
                    logEvent('system', 'TensorFlow.js loaded from CDN fallback', {}, 'INFO');
                };
                script.onerror = () => logError('TensorFlow.js CDN Fallback Load Error', 'Check CDN or network', 'No stack', 'HIGH');
                document.head.appendChild(script);
            } catch (err) {
                logError(`TensorFlow Fallback Error: ${err.message}`, 'Check script injection', err.stack, 'HIGH');
            }
        }

        // Lockdown system
        function lockdownSystem() {
            try {
                isLocked = true;
                logError('System Lockdown', 'Critical error detected. All operations disabled.', 'No stack', 'CRITICAL');
                document.querySelectorAll('button:not(#troubleshoot-btn):not(#void-btn)').forEach(btn => btn.disabled = true);
            } catch (err) {
                logError(`Lockdown Error: ${err.message}`, 'Check button selectors', err.stack, 'CRITICAL');
            }
        }

        // Error logging
        function logError(message, analysis, stack, urgency) {
            if (isLoggingError) return;
            const now = Date.now();
            if (now - lastErrorTime < ERROR_THROTTLE_MS) return;
            lastErrorTime = now;
            isLoggingError = true;
            try {
                const timestamp = new Date().toISOString();
                const errorMessage = `[${timestamp}] ERROR: ${message}\nAnalysis: ${analysis}\nTraceback: ${stack || 'No stack'}`;
                errorLog.push(errorMessage);
                logQueue.push(`<p class="error">${errorMessage}</p>`);
                if (logQueue.length > 50) logQueue.shift();
                debouncedUpdateConsole();
                if (db) {
                    db.errors.add({ timestamp, message, analysis, stack, urgency }).catch(err => console.error('Error saving to DB:', err));
                } else {
                    localStorage.setItem('errorLog', JSON.stringify(errorLog));
                }
                if (worker) worker.postMessage({ action: 'saveErrorLog', content: errorLog.join('\n---\n') });
                if (urgency === 'CRITICAL') {
                    lockdownSystem();
                    exportDiagnosticsReport([{ name: 'Critical Error', status: 'FAIL', message, analysis, stack, urgency }]);
                }
            } catch (err) {
                console.error('Log Error Failure:', err);
            } finally {
                isLoggingError = false;
            }
        }

        // Event logging
        async function logEvent(event_type, message, metadata, urgency) {
            if (isLocked) return;
            try {
                const timestamp = new Date().toISOString();
                const logData = { timestamp, event_type, message: sanitizeInput(message), metadata, urgency };
                logQueue.push(`<p class="${event_type === 'error' ? 'error' : 'command'}">[${timestamp}] ${message}</p>`);
                if (logQueue.length > 50) logQueue.shift();
                debouncedUpdateConsole();
                if (db && dexieLoaded) {
                    try {
                        await db.logs.add(logData);
                    } catch (err) {
                        if (err.name === 'QuotaExceededError') {
                            await db.logs.orderBy('id').limit(100).delete();
                            await db.logs.add(logData);
                        } else {
                            logError(`Log Save Error: ${err.message}`, 'Check IndexedDB or MongoDB', err.stack, 'HIGH');
                        }
                    }
                } else {
                    let logs = JSON.parse(localStorage.getItem('logs') || '[]');
                    logs.push(logData);
                    if (logs.length > 50) logs.shift();
                    localStorage.setItem('logs', JSON.stringify(logs));
                }
                if (isOnline && isVialFolderAvailable) {
                    await syncLogsToMongoDB([logData]);
                }
            } catch (err) {
                logError(`Log Event Error: ${err.message}`, 'Check logEvent function', err.stack, 'HIGH');
            }
        }

        // Sync logs to MongoDB with retry
        async function syncLogsToMongoDB(logs) {
            const maxRetries = 3;
            let attempt = 0;
            while (attempt < maxRetries) {
                try {
                    const response = await fetch('/api/mongo/logs', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(logs)
                    });
                    if (!response.ok) throw new Error(`MongoDB sync failed: ${response.status}`);
                    logEvent('system', 'Logs synced to MongoDB', { count: logs.length }, 'INFO');
                    return;
                } catch (err) {
                    attempt++;
                    if (attempt === maxRetries) {
                        logError(`MongoDB Sync Error: ${err.message}`, `Check MongoDB connection after ${maxRetries} attempts`, err.stack, 'HIGH');
                    } else {
                        await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                    }
                }
            }
        }

        // Debounce utility
        function debounce(func, wait) {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func(...args), wait);
            };
        }

        function debounceButton(func, id) {
            let timeout;
            return (...args) => {
                if (timeout) return;
                timeout = setTimeout(() => { func(...args); timeout = null; }, 300);
                document.getElementById(id).disabled = true;
                setTimeout(() => document.getElementById(id).disabled = false, 300);
            };
        }

        const debouncedUpdateConsole = debounce(() => {
            try {
                const consoleDiv = document.getElementById('console');
                if (consoleDiv) {
                    consoleDiv.innerHTML = logQueue.join('');
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                } else {
                    logError('Console Div Missing', 'Check HTML structure', 'No stack', 'CRITICAL');
                }
            } catch (err) {
                logError(`Update Console Error: ${err.message}`, 'Check console update', err.stack, 'HIGH');
            }
        }, 100);

        // Security utilities
        async function sha256(message) {
            try {
                if (!crypto.subtle) throw new Error('Web Crypto API not supported');
                const msgBuffer = new TextEncoder().encode(message);
                const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
                return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
            } catch (err) {
                logError(`SHA-256 Error: ${err.message}`, 'Check browser support', err.stack, 'CRITICAL');
                return '';
            }
        }

        async function aesEncrypt(data, key) {
            try {
                const keyBuffer = await crypto.subtle.importKey('raw', new TextEncoder().encode(key), 'AES-GCM', false, ['encrypt']);
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const encrypted = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, keyBuffer, new TextEncoder().encode(data));
                return { iv: Array.from(iv), encrypted: Array.from(new Uint8Array(encrypted)) };
            } catch (err) {
                logError(`AES Encrypt Error: ${err.message}`, 'Check crypto.subtle', err.stack, 'HIGH');
                return null;
            }
        }

        async function aesDecrypt(encryptedData, key, iv) {
            try {
                const keyBuffer = await crypto.subtle.importKey('raw', new TextEncoder().encode(key), 'AES-GCM', false, ['decrypt']);
                const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: new Uint8Array(iv) }, keyBuffer, new Uint8Array(encryptedData));
                return new TextDecoder().decode(decrypted);
            } catch (err) {
                logError(`AES Decrypt Error: ${err.message}`, 'Check crypto.subtle', err.stack, 'HIGH');
                return null;
            }
        }

        function sanitizeInput(input) {
            return input.replace(/[<>{}&"]/g, '').trim().slice(0, 1000);
        }

        // Mining lock
        function acquireMiningLock() {
            try {
                if (localStorage.getItem('mining_lock')) {
                    logError('Mining Lock Error', 'Mining already active', 'No stack', 'HIGH');
                    return false;
                }
                localStorage.setItem('mining_lock', Date.now().toString());
                return true;
            } catch (err) {
                logError(`Mining Lock Error: ${err.message}`, 'Check localStorage', err.stack, 'HIGH');
                return false;
            }
        }

        function releaseMiningLock() {
            try {
                localStorage.removeItem('mining_lock');
            } catch (err) {
                logError(`Release Mining Lock Error: ${err.message}`, 'Check localStorage', err.stack, 'HIGH');
            }
        }

        // Initialize Dexie with MongoDB fallback
        function initDexie() {
            try {
                if (!window.indexedDB) {
                    logError('IndexedDB Not Supported', 'Falling back to MongoDB/localStorage', 'No stack', 'HIGH');
                    return;
                }
                if (typeof Dexie === 'undefined' || !dexieLoaded) {
                    logError('Dexie Not Loaded', 'Falling back to MongoDB/localStorage. Check /static/dexie.min.js or CDN', 'No stack', 'HIGH');
                    return;
                }
                db = new Dexie('WebXOS');
                db.version(1).stores({
                    logs: '++id,timestamp,event_type,message,metadata,urgency',
                    vials: 'id,latencyHistory,status,code,filePath,createdAt,codeLength,trainingData,isPython',
                    wallets: 'address,balance,privateKey,passwords,miningLog,trainingRewards',
                    errors: '++id,timestamp,message,analysis,stack,urgency'
                });
                db.open().catch(err => logError(`Dexie Open Error: ${err.message}`, 'Check IndexedDB or MongoDB', err.stack, 'HIGH'));
                logEvent('system', 'Dexie initialized', {}, 'LOW');
            } catch (err) {
                logError(`Dexie Init Error: ${err.message}`, 'Falling back to MongoDB/localStorage. Check IndexedDB support', err.stack, 'HIGH');
                db = null;
            }
        }

        // Initialize MCP-use
        async function initMcpUse() {
            try {
                if (typeof MCPAgent === 'undefined') {
                    logError('MCP-use Not Loaded', 'Check /static/mcp-use.min.js', 'No stack', 'HIGH');
                    return;
                }
                mcpAgent = new MCPAgent({
                    llm: 'anonymous',
                    client: new MCPClient({ mcpServers: { torch: { endpoint: '/api/torch' } } }),
                    max_steps: 30
                });
                logEvent('system', 'MCP-use initialized', {}, 'LOW');
            } catch (err) {
                logError(`MCP-use Init Error: ${err.message}`, 'Check MCP-use library', err.stack, 'HIGH');
                mcpAgent = null;
            }
        }

        // Inline worker
        const workerScript = `
            let db;
            self.onmessage = async (e) => {
                try {
                    const { action, data, content } = e.data;
                    if (action === 'init') {
                        importScripts('https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.min.js');
                        if (typeof SQL === 'undefined') throw new Error('SQL.js not loaded');
                        db = await SQL.Database();
                        db.run('CREATE TABLE IF NOT EXISTS logs (id INTEGER PRIMARY KEY, timestamp TEXT, event_type TEXT, message TEXT, metadata TEXT, urgency TEXT)');
                        db.run('CREATE TABLE IF NOT EXISTS wallet (address TEXT PRIMARY KEY, balance REAL, privateKey TEXT, passwords TEXT, miningLog TEXT, trainingRewards TEXT)');
                        self.postMessage({ status: 'initialized' });
                    } else if (action === 'saveErrorLog') {
                        self.postMessage({ status: 'saved', content });
                    } else if (action === 'saveWallet') {
                        if (!db) throw new Error('Database not initialized');
                        db.run('INSERT OR REPLACE INTO wallet (address, balance, privateKey, passwords, miningLog, trainingRewards) VALUES (?, ?, ?, ?, ?, ?)',
                            [data.address, data.balance, data.privateKey, JSON.stringify(data.passwords), JSON.stringify(data.miningLog), JSON.stringify(data.trainingRewards)]);
                        self.postMessage({ status: 'walletSaved' });
                    }
                } catch (err) {
                    self.postMessage({ status: 'error', message: err.message, stack: err.stack || 'No stack' });
                }
            };
        `;
        const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(workerBlob);

        function initWorker() {
            try {
                if (!window.Worker) {
                    logError('Worker Not Supported', 'Web Workers not supported in this browser', 'No stack', 'CRITICAL');
                    worker = null;
                    return;
                }
                worker = new Worker(workerUrl);
                worker.onmessage = (e) => {
                    const { status, message, stack, content } = e.data;
                    if (status === 'initialized') {
                        logEvent('system', 'Worker initialized', {}, 'LOW');
                    } else if (status === 'saved') {
                        logEvent('system', 'Error log saved', { content }, 'INFO');
                    } else if (status === 'walletSaved') {
                        logEvent('wallet', 'Wallet saved to worker', {}, 'INFO');
                    } else if (status === 'error') {
                        logError(`Worker Error: ${message}`, 'Check worker script syntax or execution', stack, 'HIGH');
                    }
                };
                worker.onerror = (err) => {
                    logError(`Worker Runtime Error: ${err.message}`, 'Check worker script for syntax errors', `File: ${err.filename}, Line: ${err.lineno}, Column: ${err.colno}`, 'CRITICAL');
                };
                worker.postMessage({ action: 'init' });
            } catch (err) {
                logError(`Worker Init Error: ${err.message}`, 'Check browser support or worker script', err.stack, 'CRITICAL');
                worker = null;
            }
        }

        // System diagnostics
        async function systemDiagnostics() {
            const diagnosticResults = [];
            let hasCriticalIssue = false;

            const logDiagnostic = (name, status, message, analysis = '', stack = 'No stack', urgency = 'INFO') => {
                diagnosticResults.push({ name, status, message, analysis, stack, urgency });
                if (status === 'PASS') {
                    logEvent('diagnostics', `${name} check passed: ${message}`, {}, urgency);
                } else {
                    logError(`${name} Failure: ${message}`, analysis, stack, urgency);
                    if (urgency === 'CRITICAL') hasCriticalIssue = true;
                }
            };

            try {
                logEvent('diagnostics', 'Starting diagnostics', {}, 'INFO');

                // Browser Compatibility
                const features = [
                    { name: 'Web Crypto API', check: () => window.crypto?.subtle, urgency: 'CRITICAL' },
                    { name: 'IndexedDB', check: () => window.indexedDB, urgency: 'HIGH' },
                    { name: 'Worker', check: () => window.Worker, urgency: 'CRITICAL' },
                    { name: 'Blob', check: () => window.Blob, urgency: 'CRITICAL' },
                    { name: 'URL', check: () => window.URL?.createObjectURL, urgency: 'CRITICAL' },
                    { name: 'TensorFlow.js', check: () => typeof tf !== 'undefined' && tensorflowLoaded, urgency: 'HIGH' },
                    { name: 'Skulpt', check: () => typeof Sk !== 'undefined', urgency: 'HIGH' },
                    { name: 'MCP-use', check: () => typeof MCPAgent !== 'undefined', urgency: 'HIGH' }
                ];
                for (const { name, check, urgency } of features) {
                    try {
                        const isSupported = check();
                        logDiagnostic(
                            name,
                            isSupported ? 'PASS' : 'FAIL',
                            isSupported ? `${name} supported` : `${name} not supported`,
                            isSupported ? '' : 'Use modern browser or check /static/',
                            'No stack',
                            urgency
                        );
                    } catch (err) {
                        logDiagnostic(name, 'FAIL', `Error checking ${name}: ${err.message}`, 'Check browser', err.stack, urgency);
                    }
                }

                // Network Status
                try {
                    logDiagnostic('Network', isOnline ? 'PASS' : 'FAIL', isOnline ? 'Online' : 'Offline', isOnline ? '' : 'Using offline mode', 'No stack', 'HIGH');
                } catch (err) {
                    logDiagnostic('Network', 'FAIL', `Network check failed: ${err.message}`, 'Check connectivity', err.stack, 'HIGH');
                }

                // Dexie/IndexedDB
                try {
                    if (db && dexieLoaded && window.indexedDB) {
                        await db.logs.count();
                        logDiagnostic('IndexedDB', 'PASS', 'IndexedDB functional');
                    } else {
                        logDiagnostic('IndexedDB', 'FAIL', 'IndexedDB or Dexie not available', 'Check Dexie or browser', 'No stack', 'HIGH');
                    }
                } catch (err) {
                    logDiagnostic('IndexedDB', 'FAIL', `IndexedDB check failed: ${err.message}`, 'Check storage permissions', err.stack, 'HIGH');
                }

                // MongoDB with retry
                try {
                    const response = await fetch('/api/mongo/ping', { timeout: 5000 });
                    if (response.ok) {
                        logDiagnostic('MongoDB', 'PASS', 'MongoDB connected');
                    } else {
                        throw new Error(`MongoDB ping failed: ${response.status}`);
                    }
                } catch (err) {
                    logDiagnostic('MongoDB', 'FAIL', `MongoDB check failed: ${err.message}`, 'Check MongoDB service or network', err.stack, 'HIGH');
                }

                // PyTorch Server with retry
                try {
                    const response = await fetch('/api/torch/ping', { timeout: 5000 });
                    if (response.ok) {
                        logDiagnostic('PyTorch Server', 'PASS', 'PyTorch server connected');
                    } else {
                        throw new Error(`PyTorch server ping failed: ${response.status}`);
                    }
                } catch (err) {
                    logDiagnostic('PyTorch Server', 'FAIL', `PyTorch server check failed: ${err.message}`, 'Check torch_server.py or network', err.stack, 'HIGH');
                }

                // Local Storage
                try {
                    localStorage.setItem('test_key', 'test_value');
                    if (localStorage.getItem('test_key') === 'test_value') {
                        localStorage.removeItem('test_key');
                        logDiagnostic('Local Storage', 'PASS', 'Local storage accessible');
                    } else {
                        throw new Error('Local storage test failed');
                    }
                } catch (err) {
                    logDiagnostic('Local Storage', 'FAIL', `Local storage check failed: ${err.message}`, 'Check storage permissions', err.stack, 'HIGH');
                }

                // Worker Status
                try {
                    if (worker) {
                        logDiagnostic('Worker', 'PASS', 'Worker initialized');
                    } else {
                        logDiagnostic('Worker', 'FAIL', 'Worker not initialized', 'Check worker script', 'No stack', 'CRITICAL');
                    }
                } catch (err) {
                    logDiagnostic('Worker', 'FAIL', `Worker check failed: ${err.message}`, 'Check worker script', err.stack, 'CRITICAL');
                }

                // Vial Folder
                try {
                    logDiagnostic('Vial Folder', isVialFolderAvailable ? 'PASS' : 'FAIL', isVialFolderAvailable ? 'Vial folder verified' : 'Vial folder not available', isVialFolderAvailable ? '' : 'Check /vial/ directory', 'No stack', 'HIGH');
                } catch (err) {
                    logDiagnostic('Vial Folder', 'FAIL', `Vial folder check failed: ${err.message}`, 'Check /vial/ directory', err.stack, 'HIGH');
                }

                await exportDiagnosticsReport(diagnosticResults);
                logEvent('diagnostics', `Diagnostics complete: ${diagnosticResults.filter(r => r.status === 'PASS').length}/${diagnosticResults.length} passed`, { critical: hasCriticalIssue }, 'INFO');
                if (hasCriticalIssue) lockdownSystem();
            } catch (err) {
                logError(`Diagnostics Error: ${err.message}`, 'Check diagnostics function', err.stack, 'CRITICAL');
            }
        }

        // Export diagnostics report
        async function exportDiagnosticsReport(results) {
            try {
                const content = `
# WebXOS Diagnostics Report
Generated: ${new Date().toISOString()}

## Summary
- Total Checks: ${results.length}
- Passed: ${results.filter(r => r.status === 'PASS').length}
- Failed: ${results.filter(r => r.status === 'FAIL').length}
- Critical Issues: ${results.filter(r => r.urgency === 'CRITICAL').length}

## Details
| Check | Status | Message | Analysis | Urgency |
|-------|--------|---------|----------|---------|
${results.map(r => `| ${r.name} | ${r.status} | ${r.message} | ${r.analysis} | ${r.urgency} |`).join('\n')}

## Next Steps
- Address CRITICAL and HIGH urgency issues.
- Re-run diagnostics after fixes.
- Save this report for debugging.
                `;
                const blob = new Blob([content], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `diagnostics_report_${new Date().toISOString().replace(/[:.]/g, '-')}.md`;
                a.click();
                URL.revokeObjectURL(url);
                logEvent('diagnostics', 'Diagnostics report exported', { checks: results.length }, 'INFO');
            } catch (err) {
                logError(`Report Export Error: ${err.message}`, 'Check Blob API', err.stack, 'HIGH');
            }
        }

        // Vial Folder Check
        async function checkVialFolder() {
            try {
                if (!isOnline) {
                    logEvent('system', 'Offline: Skipping /vial/ folder check', {}, 'INFO');
                    isVialFolderAvailable = false;
                    return;
                }
                const response = await fetch('/vial/mcp.json', { timeout: 5000 });
                if (!response.ok) throw new Error(`mcp.json fetch failed: ${response.status}`);
                let mcpConfig;
                try {
                    mcpConfig = await response.json();
                } catch (err) {
                    throw new Error(`mcp.json parse error: ${err.message}`);
                }
                const requiredFiles = [
                    { path: '/vial/server.js', hash: mcpConfig.files?.server },
                    { path: '/vial/torch_server.py', hash: mcpConfig.files?.torchServer },
                    { path: '/vial/schemas/vial.schema.json', hash: mcpConfig.files?.vialSchema },
                    { path: '/vial/schemas/log.schema.json', hash: mcpConfig.files?.logSchema },
                    { path: '/vial/schemas/wallet.schema.json', hash: mcpConfig.files?.walletSchema }
                ].filter(file => file.hash); // Filter out missing hashes
                for (const file of requiredFiles) {
                    try {
                        const fileResponse = await fetch(file.path, { timeout: 5000 });
                        if (!fileResponse.ok) {
                            logError(`File Check Error: ${file.path}`, `File fetch failed: ${fileResponse.status}`, 'No stack', 'HIGH');
                            continue;
                        }
                        const fileContent = await fileResponse.text();
                        const computedHash = await sha256(fileContent);
                        if (computedHash !== file.hash) {
                            logError(`File Integrity Error: ${file.path}`, `Expected hash ${file.hash}, got ${computedHash}`, 'No stack', 'CRITICAL');
                            return;
                        }
                    } catch (err) {
                        logError(`File Check Error: ${file.path}`, `Error fetching file: ${err.message}`, err.stack, 'HIGH');
                    }
                }
                isVialFolderAvailable = true;
                logEvent('system', '/vial/ folder verified', {}, 'INFO');
                await syncWithServer();
            } catch (err) {
                logError(`Vial Folder Check Error: ${err.message}`, 'Check /vial/ directory or mcp.json format', err.stack, 'HIGH');
                isVialFolderAvailable = false;
            }
        }

        async function syncWithServer() {
            if (!isOnline || !isVialFolderAvailable || !isAuthenticated) {
                logEvent('system', 'Skipping server sync: Offline or no vial folder or not authenticated', {}, 'INFO');
                return;
            }
            try {
                const logs = db && dexieLoaded ? await db.logs.toArray() : JSON.parse(localStorage.getItem('logs') || '[]');
                const vialsData = db && dexieLoaded ? await db.vials.toArray() : vials;
                const walletData = db && dexieLoaded ? await db.wallets.toArray() : [wallet];
                const response = await fetch('/vial/server.js', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${oauthToken}` },
                    body: JSON.stringify({ logs, vials: vialsData, wallet: walletData[0] })
                });
                if (!response.ok) throw new Error(`Server sync failed: ${response.status}`);
                logEvent('system', 'Data synced with server', {}, 'INFO');
            } catch (err) {
                logError(`Server Sync Error: ${err.message}`, 'Check server.js or network', err.stack, 'HIGH');
            }
        }

        // Vial operations
        async function createVial() {
            try {
                const activeVials = vials.filter(v => v.status === 'running').length;
                if (activeVials >= 4) {
                    logError('Create Vial Error', 'Maximum 4 vials', 'Use VOID to clear', 'HIGH');
                    return;
                }
                const vialIndex = vials.findIndex(v => v.status === 'stopped');
                const vialId = `vial_${generateUUID()}`;
                const fileInput = document.getElementById('file-input');
                let code = 'console.log("Hello, Vial!");';
                let isPython = false;
                if (fileInput?.files?.length) {
                    const file = fileInput.files[0];
                    if (!['.js', '.py'].includes(file.name.slice(-3))) {
                        logError('File Error', 'Only .js or .py files allowed', 'No stack', 'HIGH');
                        return;
                    }
                    if (file.size > 1024 * 1024) {
                        logError('File Error', 'File size exceeds 1MB', 'No stack', 'HIGH');
                        return;
                    }
                    code = await file.text();
                    isPython = file.name.endsWith('.py');
                }
                code = sanitizeInput(code);
                if (isPython) {
                    code = await compilePythonVial(code, vialId);
                }
                vials[vialIndex] = {
                    id: vialId,
                    latencyHistory: [Math.random() * 100],
                    status: 'running',
                    code,
                    filePath: `vial_${vialId}.${isPython ? 'py' : 'js'}`,
                    createdAt: new Date().toISOString(),
                    codeLength: code.length,
                    trainingData: null,
                    isPython
                };
                if (db && dexieLoaded) {
                    await db.vials.put(vials[vialIndex]);
                } else {
                    localStorage.setItem('vials', JSON.stringify(vials));
                }
                logEvent('vial', `Created vial ${vialId} (${isPython ? 'Python' : 'JavaScript'})`, { latency: vials[vialIndex].latencyHistory[0], codeLength: code.length }, 'INFO');
                updateVialStatsUI();
                listVials();
            } catch (err) {
                logError(`Create Vial Error: ${err.message}`, 'Check vial creation', err.stack, 'HIGH');
            }
        }

        // Compile Python vial
        async function compilePythonVial(code, vialId) {
            try {
                if (typeof Sk === 'undefined') {
                    logError('Skulpt Not Loaded', 'Cannot compile Python vial', 'No stack', 'HIGH');
                    return code;
                }
                Sk.configure({
                    output: (text) => logEvent('vial', `Python Output: ${text}`, { vialId }, 'INFO'),
                    error: (err) => logError(`Python Compile Error: ${err.message}`, 'Check Python syntax', err.stack, 'HIGH')
                });
                const compiled = await Sk.misceval.asyncToPromise(() => Sk.importMainWithBody("<stdin>", false, code, true));
                const jsCode = compiled.$d.__main__.toString();
                const response = await fetch('/api/torch/validate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ code: jsCode, vialId })
                });
                if (!response.ok) throw new Error(`Vial validation failed: ${response.status}`);
                return jsCode;
            } catch (err) {
                logError(`Python Compilation Error: ${err.message}`, 'Check Skulpt or PyTorch server', err.stack, 'HIGH');
                return code;
            }
        }

        async function listVials() {
            try {
                const vialList = vials.map(v => `${v.id} (${v.status}, ${v.latencyHistory.length ? v.latencyHistory[v.latencyHistory.length - 1].toFixed(2) : 0}ms, ${v.trainingData ? 'Trained' : 'Untrained'}, ${v.isPython ? 'Python' : 'JavaScript'})`).join(', ');
                logEvent('vials', `Vials: ${vialList || 'None'}`, {}, 'INFO');
            } catch (err) {
                logError(`List Vials Error: ${err.message}`, 'Check vial listing', err.stack, 'HIGH');
            }
        }

        async function toggleMonitor() {
            try {
                monitorActive = !monitorActive;
                const monitorBtn = document.getElementById('monitor-btn');
                const consoleDiv = document.getElementById('console');
                if (monitorBtn && consoleDiv) {
                    monitorBtn.classList.toggle('active-monitor', monitorActive);
                    consoleDiv.classList.toggle('active-monitor', monitorActive);
                    document.body.classList.toggle('glow', monitorActive);
                    logEvent('monitor', monitorActive ? 'Monitoring started' : 'Monitoring stopped', {}, 'INFO');
                    if (monitorActive) {
                        setInterval(() => {
                            vials.filter(v => v.status === 'running').forEach(async v => {
                                v.latencyHistory.push(Math.random() * 100);
                                if (v.trainingData && tensorflowLoaded) {
                                    await runInference(v);
                                }
                                if (db && dexieLoaded) {
                                    db.vials.put(v);
                                } else {
                                    localStorage.setItem('vials', JSON.stringify(vials));
                                }
                            });
                            listVials();
                            updateVialStatsUI();
                        }, 5000);
                    }
                } else {
                    logError('Monitor UI Error', 'Check HTML structure', 'No stack', 'CRITICAL');
                }
            } catch (err) {
                logError(`Monitor Error: ${err.message}`, 'Check monitor function', err.stack, 'HIGH');
            }
        }

        // Run TensorFlow.js inference
        async function runInference(vial) {
            try {
                if (typeof tf === 'undefined' || !tensorflowLoaded) {
                    logError('TensorFlow.js Not Loaded', 'Cannot run inference', 'No stack', 'HIGH');
                    return;
                }
                const model = await tf.loadLayersModel('/api/torch/model/' + vial.id);
                const inputTensor = tf.tensor2d([vial.latencyHistory], [1, vial.latencyHistory.length]);
                const output = model.predict(inputTensor);
                const result = await output.data();
                logEvent('inference', `Inference on vial ${vial.id}: ${result[0].toFixed(2)}`, { vialId: vial.id }, 'INFO');
                inputTensor.dispose();
                output.dispose();
            } catch (err) {
                logError(`Inference Error: ${err.message}`, 'Check TensorFlow.js or model', err.stack, 'HIGH');
            }
        }

        async function trainVials() {
            try {
                if (trainActive) {
                    logError('Train Error', 'Training already in progress', 'No stack', 'HIGH');
                    return;
                }
                trainActive = true;
                const trainBtn = document.getElementById('train-btn');
                const consoleDiv = document.getElementById('console');
                if (trainBtn && consoleDiv) {
                    trainBtn.classList.add('active-train');
                    consoleDiv.classList.add('active-train');
                    document.body.classList.add('train-glow');
                    logEvent('training', 'Training started', {}, 'INFO');
                    const fileInput = document.getElementById('file-input');
                    let inputData = 'console.log("Training data");';
                    let isPython = false;
                    if (fileInput?.files?.length) {
                        const file = fileInput.files[0];
                        if (!['.js', '.py'].includes(file.name.slice(-3))) {
                            logError('File Error', 'Only .js or .py files allowed', 'No stack', 'HIGH');
                            resetTrainingUI(trainBtn, consoleDiv);
                            return;
                        }
                        if (file.size > 1024 * 1024) {
                            logError('File Error', 'File size exceeds 1MB', 'No stack', 'HIGH');
                            resetTrainingUI(trainBtn, consoleDiv);
                            return;
                        }
                        inputData = await file.text();
                        isPython = file.name.endsWith('.py');
                    }
                    inputData = sanitizeInput(inputData);
                    for (const vial of vials.filter(v => v.status === 'running')) {
                        const trainingData = await trainOnPyTorchServer(vial, inputData, isPython);
                        if (trainingData) {
                            vial.latencyHistory.push(Math.random() * 100);
                            vial.code = inputData;
                            vial.codeLength = inputData.length;
                            vial.trainingData = trainingData;
                            vial.isPython = isPython;
                            if (db && dexieLoaded) {
                                await db.vials.put(vial);
                            } else {
                                localStorage.setItem('vials', JSON.stringify(vials));
                            }
                            logEvent('training', `Trained vial ${vial.id}`, { latency: vial.latencyHistory[vial.latencyHistory.length - 1], trainingData }, 'INFO');
                            await rewardTraining(vial.id);
                        }
                    }
                    resetTrainingUI(trainBtn, consoleDiv);
                    logEvent('training', 'Training completed', {}, 'INFO');
                } else {
                    logError('Train UI Error', 'Check HTML structure', 'No stack', 'CRITICAL');
                    resetTrainingUI(trainBtn, consoleDiv);
                }
            } catch (err) {
                logError(`Train Error: ${err.message}`, 'Check training function', err.stack, 'HIGH');
                resetTrainingUI(document.getElementById('train-btn'), document.getElementById('console'));
            }
        }

        function resetTrainingUI(trainBtn, consoleDiv) {
            trainActive = false;
            if (trainBtn) trainBtn.classList.remove('active-train');
            if (consoleDiv) consoleDiv.classList.remove('active-train');
            document.body.classList.remove('train-glow');
        }

        // Train on PyTorch server
        async function trainOnPyTorchServer(vial, inputData, isPython) {
            const maxRetries = 3;
            let attempt = 0;
            while (attempt < maxRetries) {
                try {
                    const response = await fetch('/api/torch/train', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ vialId: vial.id, code: inputData, isPython })
                    });
                    if (!response.ok) throw new Error(`Training failed: ${response.status}`);
                    const result = await response.json();
                    return result.trainingData;
                } catch (err) {
                    attempt++;
                    if (attempt === maxRetries) {
                        logError(`PyTorch Training Error: ${err.message}`, `Check torch_server.py after ${maxRetries} attempts`, err.stack, 'HIGH');
                        return null;
                    }
                    await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                }
            }
        }

        // Reward training with $WEBXOS tokens
        async function rewardTraining(vialId) {
            try {
                if (!wallet.address) {
                    logError('Training Reward Error', 'No wallet', 'Create wallet first', 'No stack', 'HIGH');
                    return;
                }
                const reward = 0.01; // Example reward
                wallet.balance += reward;
                wallet.trainingRewards.push({
                    timestamp: new Date().toISOString(),
                    vialId,
                    reward
                });
                if (db && dexieLoaded) {
                    await db.wallets.put(wallet);
                } else {
                    localStorage.setItem('wallet', JSON.stringify(wallet));
                }
                if (worker) worker.postMessage({ action: 'saveWallet', data: wallet });
                logEvent('wallet', `Training reward: ${reward} $WEBXOS for vial ${vialId}`, { balance: wallet.balance }, 'INFO');
                updateWalletStatsUI();
            } catch (err) {
                logError(`Training Reward Error: ${err.message}`, 'Check wallet update', err.stack, 'HIGH');
            }
        }

        async function voidVials() {
            try {
                logEvent('void', 'Destroying all vials', {}, 'INFO');
                vials = Array(4).fill().map((_, i) => ({ id: `vial${i+1}`, latencyHistory: [], status: 'stopped', code: '', filePath: '', createdAt: '', codeLength: 0, trainingData: null, isPython: false }));
                if (db && dexieLoaded) {
                    await db.vials.clear().then(() => db.vials.bulkPut(vials));
                } else {
                    localStorage.setItem('vials', JSON.stringify(vials));
                }
                logQueue = ['<p>Vial MCP Controller initialized</p>'];
                updateVialStatsUI();
                debouncedUpdateConsole();
                logEvent('void', 'All vials destroyed', {}, 'HIGH');
                listVials();
            } catch (err) {
                logError(`Void Error: ${err.message}`, 'Check void function', err.stack, 'HIGH');
            }
        }

        async function saveVialAsMarkdown() {
            try {
                logEvent('export', 'Exporting vials as Markdown', {}, 'INFO');
                const content = vials.map(vial => `
# Vial Agent: ${vial.id}

- Status: ${vial.status}
- Created: ${vial.createdAt}
- Language: ${vial.isPython ? 'Python' : 'JavaScript'}
- Code:
\`\`\`${vial.isPython ? 'python' : 'javascript'}
${vial.code}
\`\`\`
- Latency: ${vial.latencyHistory.join(', ')} ms
- Training Data: ${vial.trainingData ? JSON.stringify(vial.trainingData) : 'None'}
                `).join('---\n\n');
                const blob = new Blob([content], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `vial_export_${new Date().toISOString().replace(/[:.]/g, '-')}.md`;
                a.click();
                URL.revokeObjectURL(url);
                logEvent('export', 'Exported vials as Markdown', {}, 'INFO');
            } catch (err) {
                logError(`Export Error: ${err.message}`, 'Check export function', err.stack, 'HIGH');
            }
        }

        // Wallet operations
        async function createWallet() {
            try {
                logEvent('wallet', 'Creating wallet', {}, 'INFO');
                const privateKey = Array.from(crypto.getRandomValues(new Uint8Array(32))).map(b => b.toString(16).padStart(2, '0')).join('');
                const address = await sha256(privateKey);
                const encryptedKey = await aesEncrypt(privateKey, address);
                if (!encryptedKey) throw new Error('Encryption failed');
                const passwords = Array(3).fill().map(() => Array.from(crypto.getRandomValues(new Uint8Array(16))).map(b => b.toString(16).padStart(2, '0')).join(''));
                const encryptedPasswords = await Promise.all(passwords.map(pwd => aesEncrypt(pwd, address)));
                wallet = {
                    address,
                    balance: 0,
                    privateKey: JSON.stringify(encryptedKey),
                    passwords: encryptedPasswords.map(pwd => ({ iv: pwd.iv, encrypted: pwd.encrypted })),
                    miningLog: [],
                    trainingRewards: []
                };
                if (db && dexieLoaded) {
                    await db.wallets.put(wallet);
                } else {
                    localStorage.setItem('wallet', JSON.stringify(wallet));
                }
                if (worker) worker.postMessage({ action: 'saveWallet', data: wallet });
                logEvent('wallet', `Created wallet ${address.slice(0, 10)}...`, { balance: 0 }, 'INFO');
                updateWalletStatsUI();
                updateButtonStates();
            } catch (err) {
                logError(`Create Wallet Error: ${err.message}`, 'Check wallet creation', err.stack, 'HIGH');
            }
        }

        async function mineTokens() {
            if (!monitorActive) {
                logError('Mine Error', 'Monitor must be active', 'No stack', 'HIGH');
                return;
            }
            if (!wallet.address) {
                logError('Mine Error', 'No wallet', 'Create wallet first', 'No stack', 'HIGH');
                return;
            }
            if (!acquireMiningLock()) return;
            try {
                logEvent('wallet', 'Starting mining', {}, 'INFO');
                isMining = true;
                const mineBtn = document.getElementById('mine-btn');
                if (mineBtn) mineBtn.textContent = 'Stop Mining';
                const startTime = Date.now();
                let hashCount = 0;
                const nonce = Math.floor(Math.random() * 1000000);
                const hash = await sha256(`${wallet.address}:${nonce}:${startTime}`);
                const tokenKey = await sha256(`${deviceId}:${sessionId}:${hash}`);
                const encryptedTokenKey = await aesEncrypt(tokenKey, wallet.address);
                for (let i = 0; i < 1000; i++) {
                    await sha256(`${wallet.address}:${nonce}:${i}`);
                    hashCount++;
                }
                const duration = (Date.now() - startTime) / 1000;
                const hashRate = hashCount / duration;
                wallet.balance += 0.01;
                wallet.miningLog.push({
                    timestamp: new Date().toISOString(),
                    duration,
                    hashRate,
                    tokenCount: 0.01,
                    tokenKey: { iv: encryptedTokenKey.iv, encrypted: encryptedTokenKey.encrypted },
                    hash
                });
                if (db && dexieLoaded) {
                    await db.wallets.put(wallet);
                } else {
                    localStorage.setItem('wallet', JSON.stringify(wallet));
                }
                if (worker) worker.postMessage({ action: 'saveWallet', data: wallet });
                logEvent('wallet', `Mined $WEBXOS token`, { balance: wallet.balance, hashRate: hashRate.toFixed(2) }, 'INFO');
                updateWalletStatsUI();
                isMining = false;
                releaseMiningLock();
                if (mineBtn) mineBtn.textContent = 'Mine';
            } catch (err) {
                releaseMiningLock();
                isMining = false;
                logError(`Mine Error: ${err.message}`, 'Check mining function', err.stack, 'HIGH');
                if (document.getElementById('mine-btn')) document.getElementById('mine-btn').textContent = 'Mine';
            }
        }

        async function checkBalance() {
            if (!wallet.address) {
                logError('Balance Error', 'No wallet', 'Create wallet first', 'No stack', 'HIGH');
                return;
            }
            try {
                logEvent('wallet', `Checking balance for ${wallet.address.slice(0, 10)}...`, {}, 'INFO');
                logEvent('wallet', `Balance: ${wallet.balance} $WEBXOS`, {}, 'INFO');
                updateWalletStatsUI();
            } catch (err) {
                logError(`Balance Error: ${err.message}`, 'Check balance function', err.stack, 'HIGH');
            }
        }

        // Helper function to format passwords for export
        function formatPasswords(passwords) {
            return passwords.map(pwd => `  - IV: [${pwd.iv}]\n    Encrypted: [${pwd.encrypted}]`).join('\n');
        }

        async function exportWallet() {
            if (!wallet.address) {
                logError('Export Wallet Error', 'No wallet', 'Create wallet first', 'No stack', 'HIGH');
                return;
            }
            try {
                logEvent('wallet', 'Exporting wallet as Markdown', {}, 'INFO');
                const totalMiningTime = wallet.miningLog.reduce((sum, log) => sum + log.duration, 0);
                const totalTokens = wallet.miningLog.reduce((sum, log) => sum + log.tokenCount, 0);
                const avgHashRate = wallet.miningLog.length ? wallet.miningLog.reduce((sum, log) => sum + log.hashRate, 0) / wallet.miningLog.length : 0;
                const totalTrainingRewards = wallet.trainingRewards.reduce((sum, reward) => sum + reward.reward, 0);
                const passwordLines = formatPasswords(wallet.passwords);
                const content = `
# $WEBXOS Wallet Export

## Wallet Information
- Address: ${wallet.address}
- Balance: ${wallet.balance.toFixed(2)} $WEBXOS
- Private Key (Encrypted):
  \`\`\`
  IV: [${JSON.parse(wallet.privateKey).iv}]
  Encrypted: [${JSON.parse(wallet.privateKey).encrypted}]
  \`\`\`
- Device ID: ${deviceId}
- Session ID: ${sessionId}
- IP Hash: ${ipHash}

## Security Credentials
- Passwords (Encrypted):
${passwordLines}

## Mining Performance
- Total Mining Time: ${totalMiningTime.toFixed(2)} seconds
- Total Tokens Mined: ${totalTokens.toFixed(2)} $WEBXOS
- Average Hash Rate: ${avgHashRate.toFixed(2)} hashes/second

## Training Rewards
- Total Rewards: ${totalTrainingRewards.toFixed(2)} $WEBXOS
${wallet.trainingRewards.map(r => `- ${r.timestamp}: ${r.reward.toFixed(2)} $WEBXOS for vial ${r.vialId}`).join('\n')}

## Mining Log
| Timestamp | Duration (s) | Hash Rate (h/s) | Tokens Mined | Token Key (Encrypted) | Hash |
|-----------|--------------|-----------------|--------------|-----------------------|------|
${wallet.miningLog.map(log => `| ${log.timestamp} | ${log.duration.toFixed(2)} | ${log.hashRate.toFixed(2)} | ${log.tokenCount.toFixed(2)} | IV: [${log.tokenKey.iv}]<br>Encrypted: [${log.tokenKey.encrypted}] | ${log.hash.slice(0, 10)}... |`).join('\n')}
                `;
                const blob = new Blob([content], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `wallet_export_${new Date().toISOString().replace(/[:.]/g, '-')}.md`;
                a.click();
                URL.revokeObjectURL(url);
                logEvent('wallet', 'Exported wallet as Markdown', {}, 'INFO');
            } catch (err) {
                logError(`Export Wallet Error: ${err.message}`, 'Check export wallet', err.stack, 'HIGH');
            }
        }

        // UI updates
        function updateVialStatsUI() {
            try {
                const vialStatsDiv = document.getElementById('vial-stats');
                if (!vialStatsDiv) {
                    logError('Vial Stats Div Missing', 'Check HTML structure', 'No stack', 'CRITICAL');
                    return;
                }
                vialStatsDiv.innerHTML = vials.map((vial, index) => {
                    const lastLatency = Array.isArray(vial.latencyHistory) && vial.latencyHistory.length > 0 ? vial.latencyHistory[vial.latencyHistory.length - 1] : 0;
                    const width = lastLatency > 0 ? Math.min(100, lastLatency / 2) : 0;
                    const trainingStatus = vial.trainingData ? 'Trained' : 'Untrained';
                    const language = vial.isPython ? 'Python' : 'JavaScript';
                    return `
                        <div class="progress-container">
                            <span class="progress-label">Vial ${index + 1}:</span>
                            <div class="progress-bar"><div class="progress-fill" id="vial${index + 1}-bar" style="width: ${width}%"></div></div>
                            <span id="vial${index + 1}-value">${lastLatency.toFixed(2)} ms | ${trainingStatus} | ${language}</span>
                        </div>
                    `;
                }).join('');
            } catch (err) {
                logError(`Update Vial Stats Error: ${err.message}`, 'Check UI update', err.stack, 'HIGH');
            }
        }

        function updateWalletStatsUI() {
            try {
                const walletStatsDiv = document.getElementById('wallet-stats');
                if (!walletStatsDiv) {
                    logError('Wallet Stats Div Missing', 'Check HTML structure', 'No stack', 'CRITICAL');
                    return;
                }
                const width = wallet.balance * 10;
                const trainingRewards = wallet.trainingRewards.reduce((sum, r) => sum + r.reward, 0);
                walletStatsDiv.innerHTML = `
                    <div class="progress-container">
                        <span class="progress-label">Wallet:</span>
                        <div class="progress-bar"><div class="progress-fill" id="wallet-bar" style="width: ${width}%"></div></div>
                        <span id="wallet-value">${wallet.address ? wallet.address.slice(0, 10) + '...' : 'No wallet'} | ${wallet.balance.toFixed(2)} $WEBXOS | Rewards: ${trainingRewards.toFixed(2)}</span>
                    </div>
                `;
            } catch (err) {
                logError(`Update Wallet Stats Error: ${err.message}`, 'Check UI update', err.stack, 'HIGH');
            }
        }

        function updateButtonStates() {
            try {
                document.getElementById('mine-btn').disabled = !wallet.address || isLocked;
                document.getElementById('balance-btn').disabled = !wallet.address || isLocked;
                document.getElementById('export-wallet-btn').disabled = !wallet.address || isLocked;
            } catch (err) {
                logError(`Update Button States Error: ${err.message}`, 'Check button state update', err.stack, 'HIGH');
            }
        }

        // Event listeners
        function setupEventListeners() {
            try {
                document.getElementById('create-btn').addEventListener('click', debounceButton(createVial, 'create-btn'));
                document.getElementById('monitor-btn').addEventListener('click', debounceButton(toggleMonitor, 'monitor-btn'));
                document.getElementById('train-btn').addEventListener('click', debounceButton(trainVials, 'train-btn'));
                document.getElementById('void-btn').addEventListener('click', debounceButton(voidVials, 'void-btn'));
                document.getElementById('export-btn').addEventListener('click', debounceButton(saveVialAsMarkdown, 'export-btn'));
                document.getElementById('wallet-btn').addEventListener('click', debounceButton(createWallet, 'wallet-btn'));
                document.getElementById('mine-btn').addEventListener('click', debounceButton(mineTokens, 'mine-btn'));
                document.getElementById('balance-btn').addEventListener('click', debounceButton(checkBalance, 'balance-btn'));
                document.getElementById('export-wallet-btn').addEventListener('click', debounceButton(exportWallet, 'export-wallet-btn'));
                document.getElementById('troubleshoot-btn').addEventListener('click', debounceButton(systemDiagnostics, 'troubleshoot-btn'));
                window.addEventListener('online', () => {
                    isOnline = true;
                    logEvent('system', 'Network online', {}, 'INFO');
                    checkVialFolder();
                });
                window.addEventListener('offline', () => {
                    isOnline = false;
                    logEvent('system', 'Network offline', {}, 'INFO');
                });
            } catch (err) {
                logError(`Event Listener Error: ${err.message}`, 'Check event listeners', err.stack, 'CRITICAL');
            }
        }

        // Initialization
        async function init() {
            try {
                initWorker();
                await initMcpUse();
                await checkVialFolder();
                if (typeof Dexie !== 'undefined') {
                    dexieLoaded = true;
                    initDexie();
                } else {
                    loadDexieFallback();
                }
                if (typeof tf !== 'undefined') {
                    tensorflowLoaded = true;
                    logEvent('system', 'TensorFlow.js loaded', {}, 'INFO');
                } else {
                    loadTensorFlowFallback();
                }
                updateVialStatsUI();
                updateWalletStatsUI();
                updateButtonStates();
                setupEventListeners();
                logEvent('system', 'System initialized', {}, 'INFO');
            } catch (err) {
                logError(`Init Error: ${err.message}`, 'Check init function', err.stack, 'CRITICAL');
            }
        }

        // Start application
        window.onload = init;
    </script>
</body>
</html>
