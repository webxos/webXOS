<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vial MCP Controller</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABTSURBVFhH7c6xDYAwDAR7QID/f2XCWGRjI0oF8S6J+wzMdtu2bdu2bdu2bdu2bdu2bdu2bdu2bdu2bdu2bdu2bdu2bdu2bdu2bdu2bdu2bdu2bdu2bdu2bdv+Dv8A2cQ8+LEAAAAASUVORK5CYII=">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet" onerror="logError('Font Load Error', 'Using fallback font', 'No stack', 'LOW')">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: monospace, sans-serif; }
        html, body { height: 100vh; overflow: hidden; background: #000 !important; color: #0f0 !important; display: flex; flex-direction: column; align-items: center; -webkit-tap-highlight-color: transparent; touch-action: manipulation; }
        body.glow { background: rgba(255, 0, 0, 0.1) !important; box-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000 inset; }
        body.train-glow { background: rgba(255, 255, 0, 0.1) !important; box-shadow: 0 0 20px #ff0, 0 0 40px #ff0 inset; }
        h1 { font-size: 1.6rem; text-align: center; margin: 0.8rem 0; text-transform: uppercase; letter-spacing: 1px; text-shadow: 0 0 5px #0f0; color: #0f0 !important; }
        #console { width: 90%; max-width: 900px; background: rgba(0, 255, 0, 0.1) !important; border: 1px solid #0f0; padding: 0.6rem; flex: 1; max-height: calc(100vh - 300px); overflow-y: auto; margin: 0.5rem 0; border-radius: 5px; font-size: 0.8rem; -webkit-overflow-scrolling: touch; white-space: pre-wrap; word-wrap: break-word; }
        #console.active-monitor { border-color: #ff0000 !important; box-shadow: 0 0 10px #ff0000; }
        #console.active-train { border-color: #ff0 !important; box-shadow: 0 0 10px #ff0; }
        #console p { margin: 0.2rem 0; color: #0f0 !important; }
        #console .command { font-family: 'Orbitron', monospace; font-weight: 700; text-shadow: 0 0 3px #0f0; }
        #console .error { color: #ff0000 !important; text-shadow: 0 0 3px #ff0000; }
        #error-notification { display: none; position: fixed; top: 10px; right: 10px; background: rgba(255, 0, 0, 0.8) !important; color: #fff !important; padding: 0.5rem; border-radius: 3px; font-size: 0.8rem; max-width: 300px; z-index: 1000; box-shadow: 0 0 10px #ff0000; }
        #error-notification.visible { display: block; }
        .button-group { display: flex; gap: 0.5rem; margin: 0.5rem 0; padding: 0.5rem; flex-wrap: wrap; justify-content: center; width: 90%; max-width: 900px; }
        button { background: #0f0 !important; color: #000 !important; border: none; padding: 0.6rem 1.2rem; font-size: 0.9rem; cursor: pointer; border-radius: 3px; min-width: 90px; text-align: center; touch-action: manipulation; -webkit-user-select: none; user-select: none; }
        button:hover, button:focus, button:active { background: #0c0 !important; outline: 2px solid #0f0; }
        button.active-monitor { background: #ff0000 !important; box-shadow: 0 0 10px #ff0000; }
        button.active-train { background: #ff0 !important; color: #000 !important; box-shadow: 0 0 10px #ff0; }
        button:disabled { background: #666 !important; cursor: not-allowed; }
        #vial-stats, #wallet-stats { width: 90%; max-width: 900px; margin: 0.5rem 0; display: flex; flex-direction: column; gap: 0.2rem; }
        .progress-container { display: flex; align-items: center; gap: 0.4rem; }
        .progress-label { width: 90px; font-size: 0.75rem; color: #0f0 !important; }
        .progress-bar { flex: 1; height: 8px; background: #333 !important; border: 1px solid #0f0; border-radius: 3px; overflow: hidden; }
        .progress-fill { height: 100%; background: #0f0 !important; transition: width 0.5s; }
        #input-container { width: 90%; max-width: 900px; margin: 0.5rem 0; display: flex; flex-direction: column; gap: 0.5rem; }
        #file-input { width: 100%; padding: 0.5rem; background: #000 !important; color: #0f0 !important; border: 1px solid #0f0; border-radius: 3px; font-size: 0.8rem; }
        #input-results { margin-top: 0.5rem; max-height: 100px; overflow-y: auto; font-size: 0.8rem; color: #0f0 !important; }
        #input-results .error { color: #ff0000 !important; }
        #browser-popup { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 80%; max-width: 600px; height: 80%; background: #000 !important; border: 1px solid #0f0; border-radius: 5px; z-index: 2000; padding: 1rem; color: #0f0 !important; }
        #browser-popup.visible { display: block; }
        #browser-url { width: 100%; padding: 0.5rem; background: #000 !important; color: #0f0 !important; border: 1px solid #0f0; border-radius: 3px; font-size: 0.8rem; margin-bottom: 0.5rem; }
        #browser-content { width: 100%; height: calc(100% - 80px); background: rgba(0, 255, 0, 0.1) !important; border: 1px solid #0f0; padding: 0.5rem; overflow-y: auto; font-size: 0.8rem; white-space: pre-wrap; }
        #browser-actions { display: flex; gap: 0.5rem; margin-top: 0.5rem; }
        footer { width: 100%; padding: 0.4rem; font-size: 9pt; text-align: center; color: #0f0 !important; background: rgba(0, 0, 0, 0.8) !important; line-height: 1.2; }
        @media (max-width: 600px) {
            h1 { font-size: 1.1rem; margin: 0.5rem 0; }
            #console, #browser-content { font-size: 0.75rem; padding: 0.5rem; max-height: calc(100vh - 320px); }
            button { padding: 0.5rem 1rem; font-size: 0.85rem; min-width: 80px; }
            #file-input, #browser-url { font-size: 0.75rem; }
            footer { padding: 0.3rem; }
            .progress-label { width: 70px; font-size: 0.7rem; }
            .progress-bar { height: 7px; }
            #error-notification { font-size: 0.7rem; max-width: 250px; }
            #browser-popup { width: 90%; height: 90%; }
        }
        @media (max-width: 400px) {
            .button-group, #browser-actions { flex-direction: column; align-items: center; }
            button { width: 100%; max-width: 160px; }
            #console { max-height: calc(100vh - 280px); }
            #vial-stats, #wallet-stats { gap: 0.15rem; }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dexie/3.2.7/dexie.min.js" defer onload="logEvent('system', 'Dexie loaded from CDN', {}, 'INFO')" onerror="loadDexieFallback()"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0/dist/tf.min.js" defer onload="logEvent('system', 'TensorFlow.js loaded from CDN', {}, 'INFO')" onerror="loadTensorFlowFallback()"></script>
    <script src="https://cdn.jsdelivr.net/npm/skulpt@1.2.0/dist/skulpt.min.js" defer onload="logEvent('system', 'Skulpt loaded from CDN', {}, 'INFO')" onerror="logError('Skulpt Load Error', 'Check CDN', 'No stack', 'HIGH')"></script>
    <script src="https://cdn.jsdelivr.net/npm/skulpt@1.2.0/dist/skulpt-stdlib.js" defer onload="logEvent('system', 'Skulpt Stdlib loaded from CDN', {}, 'INFO')" onerror="logError('Skulpt Stdlib Load Error', 'Check CDN', 'No stack', 'HIGH')"></script>
    <script src="https://cdn.jsdelivr.net/npm/mcp-use@1.0.0/mcp-use.min.js" defer onload="logEvent('system', 'MCP-use loaded from CDN', {}, 'INFO')" onerror="loadMcpUseFallback()"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.min.js" defer onload="logEvent('system', 'SQL.js loaded from CDN', {}, 'INFO')" onerror="logError('sql-wasm Load Error', 'Check CDN', 'No stack', 'CRITICAL')"></script>
</head>
<body>
    <h1>Vial MCP Controller</h1>
    <div id="console"></div>
    <div id="error-notification"></div>
    <div class="button-group">
        <button id="authButton" class="button">Authenticate</button>
        <button id="voidButton" class="button">Void</button>
        <button id="troubleshootButton" class="button">Troubleshoot</button>
        <button id="trainButton" class="button" disabled>Train Vials</button>
        <button id="balanceButton" class="button" disabled>Check Balance</button>
        <button id="exportButton" class="button" disabled>Export</button>
        <button id="importButton" class="button" disabled>Import</button>
        <button id="apiButton" class="button" disabled>Configure API</button>
        <button id="browserButton" class="button" disabled>.md Browser</button>
    </div>
    <div id="vial-stats"></div>
    <div id="wallet-stats"></div>
    <div id="input-container">
        <input type="file" id="file-input" accept=".js,.py,.txt" onchange="logEvent('file', 'File selected', {}, 'INFO')">
        <div id="input-results"></div>
    </div>
    <div id="browser-popup">
        <input type="text" id="browser-url" placeholder="Enter URL (e.g., https://example.com)">
        <div id="browser-content"></div>
        <div id="browser-actions">
            <button id="browser-visit" class="button">Visit</button>
            <button id="browser-train" class="button" disabled>Train</button>
            <button id="browser-close" class="button">Close</button>
        </div>
    </div>
    <footer>WebXOS Vial MCP Controller | Offline Mode | 2025</footer>
    <script>
        // Global state
        let isOnline = navigator.onLine;
        let isAuthenticated = false;
        let masterKey = null;
        let browserMasterKey = null;
        let vials = Array(4).fill().map((_, i) => ({ id: `vial${i+1}`, latencyHistory: [], status: 'stopped', code: '', filePath: '', createdAt: '', codeLength: 0, trainingData: null, isPython: false }));
        let wallet = { address: null, balance: 0, privateKey: null, passwords: [], trainingRewards: [] };
        let db = null;
        let worker = null;
        let oauthToken = 'anonymous';
        let deviceId = generateUUID();
        let sessionId = generateUUID();
        let errorLog = [];
        let logQueue = ['<p>Vial MCP Controller initialized</p>'];
        let errorCache = new Map();
        let isLoggingError = false;
        const ERROR_THROTTLE_MS = 1000;
        const ERROR_DEDUPE_WINDOW_MS = 60000;
        const MAX_LOG_QUEUE_SIZE = 50;
        let dexieLoaded = false;
        let tensorflowLoaded = false;
        let mcpUseLoaded = false;
        const serverUrls = ['/mcp/ping', 'https://webxos.netlify.app', 'https://fallback.webxos.com'];
        let lastConnectionErrorTime = 0;
        const CONNECTION_ERROR_THROTTLE_MS = 300000;
        let currentBrowserContent = '';
        let currentBrowserUrl = '';

        // UUID generator
        function generateUUID() {
            try {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
                    const r = Math.random() * 16 | 0;
                    const v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            } catch (err) {
                logError(`UUID Generation Error: ${err.message}`, 'Check Math.random', err.stack, 'HIGH');
                return '';
            }
        }

        // Fallback loaders
        function loadDexieFallback() {
            try {
                const script = document.createElement('script');
                script.src = '/static/dexie.min.js';
                script.onload = () => {
                    dexieLoaded = true;
                    logEvent('system', 'Dexie loaded from local fallback', {}, 'INFO');
                    initDexie();
                };
                script.onerror = () => logError('Dexie Fallback Load Error', 'Check /static/dexie.min.js', 'No stack', 'HIGH');
                document.head.appendChild(script);
            } catch (err) {
                logError(`Dexie Fallback Error: ${err.message}`, 'Check script injection', err.stack, 'HIGH');
            }
        }

        function loadTensorFlowFallback() {
            try {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0/dist/tf.min.js';
                script.onload = () => {
                    tensorflowLoaded = true;
                    logEvent('system', 'TensorFlow.js loaded from CDN fallback', {}, 'INFO');
                };
                script.onerror = () => logError('TensorFlow.js CDN Fallback Load Error', 'Check CDN or network', 'No stack', 'HIGH');
                document.head.appendChild(script);
            } catch (err) {
                logError(`TensorFlow Fallback Error: ${err.message}`, 'Check script injection', err.stack, 'HIGH');
            }
        }

        function loadMcpUseFallback() {
            try {
                const script = document.createElement('script');
                script.src = '/static/mcp-use.min.js';
                script.onload = () => {
                    mcpUseLoaded = true;
                    logEvent('system', 'MCP-use loaded from local fallback', {}, 'INFO');
                };
                script.onerror = () => {
                    mcpUseLoaded = false;
                    logError('MCP-use Fallback Load Error', 'Check /static/mcp-use.min.js. Falling back to offline mode.', 'No stack', 'HIGH');
                };
                document.head.appendChild(script);
            } catch (err) {
                logError(`MCP-use Fallback Error: ${err.message}`, 'Check script injection', err.stack, 'HIGH');
            }
        }

        // Show error notification
        function showErrorNotification(message, count = 1) {
            try {
                const notification = document.getElementById('error-notification');
                if (notification) {
                    notification.textContent = count > 1 ? `Error: ${message} (${count} times)` : `Error: ${message}`;
                    notification.classList.add('visible');
                    setTimeout(() => notification.classList.remove('visible'), 5000);
                }
            } catch (err) {
                console.error('Error notification failed:', err);
            }
        }

        // Error logging with deduplication
        function logError(message, analysis, stack, urgency) {
            if (isLoggingError) return;
            const now = Date.now();
            const errorKey = `${message}:${analysis}`;
            const cachedError = errorCache.get(errorKey);

            if (cachedError && now - cachedError.timestamp < ERROR_DEDUPE_WINDOW_MS) {
                cachedError.count++;
                if (cachedError.count % 5 === 0) {
                    showErrorNotification(message, cachedError.count);
                }
                return;
            }

            isLoggingError = true;
            try {
                const timestamp = new Date().toISOString();
                const errorMessage = `[${timestamp}] ERROR: ${message}\nAnalysis: ${analysis}\nTraceback: ${stack || 'No stack'}`;
                errorLog.push(errorMessage);
                if (errorLog.length > MAX_LOG_QUEUE_SIZE) errorLog.shift();
                logQueue.push(`<p class="error">${errorMessage}</p>`);
                if (logQueue.length > MAX_LOG_QUEUE_SIZE) logQueue.shift();
                debouncedUpdateConsole();

                errorCache.set(errorKey, { timestamp: now, count: 1 });
                if (errorCache.size > 100) {
                    for (const [key, { timestamp }] of errorCache) {
                        if (now - timestamp > ERROR_DEDUPE_WINDOW_MS) errorCache.delete(key);
                    }
                }

                if (db && dexieLoaded) {
                    db.errors.add({ timestamp, message, analysis, stack, urgency }).catch(err => {
                        console.error('Error saving to IndexedDB:', err);
                        if (canUseLocalStorage()) {
                            try {
                                localStorage.setItem('errorLog', JSON.stringify(errorLog.slice(-50)));
                            } catch (lsErr) {
                                console.error('LocalStorage fallback failed:', lsErr);
                            }
                        }
                    });
                } else if (canUseLocalStorage()) {
                    try {
                        localStorage.setItem('errorLog', JSON.stringify(errorLog.slice(-50)));
                    } catch (lsErr) {
                        console.error('LocalStorage error:', lsErr);
                    }
                }

                if (worker && !worker.terminated) {
                    try {
                        worker.postMessage({ action: 'saveErrorLog', content: errorLog.slice(-50).join('\n---\n') });
                    } catch (workerErr) {
                        console.error('Worker postMessage error:', workerErr);
                    }
                }

                if (urgency === 'CRITICAL') {
                    lockdownSystem();
                }

                showErrorNotification(message);
            } catch (err) {
                console.error(`Log Error Failure: ${err.message}`, err.stack || 'No stack');
            } finally {
                isLoggingError = false;
            }
        }

        // Check if localStorage is available
        function canUseLocalStorage() {
            try {
                const testKey = '__test__';
                localStorage.setItem(testKey, 'test');
                localStorage.removeItem(testKey);
                return true;
            } catch (err) {
                return false;
            }
        }

        // Event logging
        async function logEvent(event_type, message, metadata, urgency) {
            try {
                const timestamp = new Date().toISOString();
                const logData = { timestamp, event_type, message: sanitizeInput(message), metadata, urgency };
                logQueue.push(`<p class="${event_type === 'error' ? 'error' : 'command'}">[${timestamp}] ${message}</p>`);
                if (logQueue.length > MAX_LOG_QUEUE_SIZE) logQueue.shift();
                debouncedUpdateConsole();

                if (db && dexieLoaded) {
                    try {
                        await db.logs.add(logData);
                    } catch (err) {
                        if (err.name === 'QuotaExceededError') {
                            await db.logs.orderBy('id').limit(100).delete();
                            await db.logs.add(logData);
                        } else {
                            logError(`Log Save Error: ${err.message}`, 'Check IndexedDB', err.stack, 'HIGH');
                        }
                    }
                } else if (canUseLocalStorage()) {
                    let logs = JSON.parse(localStorage.getItem('logs') || '[]');
                    logs.push(logData);
                    if (logs.length > MAX_LOG_QUEUE_SIZE) logs.shift();
                    try {
                        localStorage.setItem('logs', JSON.stringify(logs));
                    } catch (lsErr) {
                        console.error('LocalStorage error in logEvent:', lsErr);
                    }
                }

                if (isOnline && serverUrls[0] !== '/mcp/ping' && mcpUseLoaded) {
                    const serverUrl = serverUrls[0];
                    try {
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 15000);
                        const response = await fetch(`${serverUrl}/mcp/log`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(logData),
                            signal: controller.signal
                        });
                        clearTimeout(timeoutId);
                        if (!response.ok) throw new Error(`Log post failed: ${response.status} ${response.statusText}`);
                    } catch (err) {
                        logError(`Log Event Error: ${err.message}`, 'Check network or server', err.stack, 'HIGH');
                    }
                }
            } catch (err) {
                logError(`Log Event Error: ${err.message}`, 'Check logEvent function', err.stack, 'HIGH');
            }
        }

        // Debounce utility
        function debounce(func, wait) {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func(...args), wait);
            };
        }

        const debouncedUpdateConsole = debounce(() => {
            try {
                const consoleDiv = document.getElementById('console');
                if (consoleDiv) {
                    consoleDiv.innerHTML = logQueue.join('');
                    consoleDiv.scrollTop = consoleDiv.scrollHeight;
                } else {
                    logError('Console Div Missing', 'Check HTML structure', 'No stack', 'CRITICAL');
                }
            } catch (err) {
                logError(`Update Console Error: ${err.message}`, 'Check console update', err.stack, 'HIGH');
            }
        }, 100);

        // Security utilities
        async function sha256(message) {
            try {
                if (!crypto.subtle) throw new Error('Web Crypto API not supported');
                const msgBuffer = new TextEncoder().encode(message);
                const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
                return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
            } catch (err) {
                logError(`SHA-256 Error: ${err.message}`, 'Check browser support', err.stack, 'CRITICAL');
                return '';
            }
        }

        async function aesEncrypt(data, key) {
            try {
                const keyBuffer = await crypto.subtle.importKey('raw', new TextEncoder().encode(key.slice(0, 32)), 'AES-GCM', false, ['encrypt']);
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const encrypted = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, keyBuffer, new TextEncoder().encode(data));
                return { iv: Array.from(iv), encrypted: Array.from(new Uint8Array(encrypted)) };
            } catch (err) {
                logError(`AES Encrypt Error: ${err.message}`, 'Check crypto.subtle', err.stack, 'HIGH');
                return null;
            }
        }

        async function aesDecrypt(encryptedData, key, iv) {
            try {
                const keyBuffer = await crypto.subtle.importKey('raw', new TextEncoder().encode(key.slice(0, 32)), 'AES-GCM', false, ['decrypt']);
                const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: new Uint8Array(iv) }, keyBuffer, new Uint8Array(encryptedData));
                return new TextDecoder().decode(decrypted);
            } catch (err) {
                logError(`AES Decrypt Error: ${err.message}`, 'Check crypto.subtle', err.stack, 'HIGH');
                return null;
            }
        }

        function sanitizeInput(input) {
            return input.replace(/[<>{}&"]/g, '').trim().slice(0, 1000);
        }

        function sanitizeUrl(url) {
            try {
                const parsed = new URL(url);
                if (!['http:', 'https:'].includes(parsed.protocol)) {
                    throw new Error('Invalid protocol');
                }
                return parsed.toString();
            } catch (err) {
                logError(`URL Sanitization Error: ${err.message}`, 'Enter a valid HTTP/HTTPS URL', 'No stack', 'HIGH');
                return null;
            }
        }

        // Initialize Dexie
        function initDexie() {
            try {
                if (!window.indexedDB) {
                    logError('IndexedDB Not Supported', 'Falling back to localStorage', 'No stack', 'HIGH');
                    return;
                }
                if (typeof Dexie === 'undefined' || !dexieLoaded) {
                    logError('Dexie Not Loaded', 'Falling back to localStorage. Check CDN or /static/dexie.min.js', 'No stack', 'HIGH');
                    return;
                }
                db = new Dexie('WebXOSVial');
                db.version(1).stores({
                    logs: '++id,timestamp,event_type,message,metadata,urgency',
                    vials: 'id,latencyHistory,status,code,filePath,createdAt,codeLength,trainingData,isPython',
                    wallets: 'address,balance,privateKey,passwords,trainingRewards',
                    errors: '++id,timestamp,message,analysis,stack,urgency',
                    auth: 'key,token,timestamp',
                    browser: 'key,token,timestamp'
                });
                db.open().catch(err => logError(`Dexie Open Error: ${err.message}`, 'Check IndexedDB', err.stack, 'HIGH'));
                logEvent('system', 'Dexie initialized', {}, 'LOW');
            } catch (err) {
                logError(`Dexie Init Error: ${err.message}`, 'Falling back to localStorage. Check IndexedDB support', err.stack, 'HIGH');
                db = null;
            }
        }

        // Inline worker with retry logic
        const workerScript = `
            let db;
            let sqlJsLoaded = false;
            const maxRetries = 3;
            async function loadSqlJs(attempt = 0) {
                try {
                    importScripts('https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.min.js');
                    if (typeof SQL === 'undefined') throw new Error('SQL.js not loaded');
                    sqlJsLoaded = true;
                    db = await SQL.Database();
                    db.run('CREATE TABLE IF NOT EXISTS logs (id INTEGER PRIMARY KEY, timestamp TEXT, event_type TEXT, message TEXT, metadata TEXT, urgency TEXT)');
                    db.run('CREATE TABLE IF NOT EXISTS wallet (address TEXT PRIMARY KEY, balance REAL, privateKey TEXT, passwords TEXT, trainingRewards TEXT)');
                    db.run('CREATE TABLE IF NOT EXISTS browser (key TEXT PRIMARY KEY, token TEXT, timestamp TEXT)');
                    self.postMessage({ status: 'initialized' });
                } catch (err) {
                    if (attempt < maxRetries - 1) {
                        setTimeout(() => loadSqlJs(attempt + 1), 1000 * Math.pow(2, attempt));
                    } else {
                        self.postMessage({ status: 'error', message: 'SQL.js initialization failed: ' + err.message, stack: err.stack || 'No stack' });
                    }
                }
            }
            self.onmessage = async (e) => {
                try {
                    const { action, data, content } = e.data;
                    if (action === 'init') {
                        await loadSqlJs();
                    } else if (action === 'saveErrorLog') {
                        self.postMessage({ status: 'saved', content });
                    } else if (action === 'saveWallet') {
                        if (!sqlJsLoaded || !db) {
                            self.postMessage({ status: 'error', message: 'Database not initialized', stack: 'No stack' });
                            return;
                        }
                        db.run('INSERT OR REPLACE INTO wallet (address, balance, privateKey, passwords, trainingRewards) VALUES (?, ?, ?, ?, ?)',
                            [data.address, data.balance, data.privateKey, JSON.stringify(data.passwords), JSON.stringify(data.trainingRewards)]);
                        self.postMessage({ status: 'walletSaved' });
                    } else if (action === 'saveBrowserKey') {
                        if (!sqlJsLoaded || !db) {
                            self.postMessage({ status: 'error', message: 'Database not initialized', stack: 'No stack' });
                            return;
                        }
                        db.run('INSERT OR REPLACE INTO browser (key, token, timestamp) VALUES (?, ?, ?)',
                            [data.key, data.token, data.timestamp]);
                        self.postMessage({ status: 'browserKeySaved' });
                    }
                } catch (err) {
                    self.postMessage({ status: 'error', message: err.message, stack: err.stack || 'No stack' });
                }
            };
        `;
        const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(workerBlob);

        function initWorker() {
            try {
                if (!window.Worker) {
                    logError('Worker Not Supported', 'Web Workers not supported in this browser', 'No stack', 'CRITICAL');
                    worker = null;
                    return;
                }
                worker = new Worker(workerUrl);
                worker.onmessage = (e) => {
                    const { status, message, stack, content } = e.data;
                    if (status === 'initialized') {
                        logEvent('system', 'Worker initialized', {}, 'LOW');
                    } else if (status === 'saved') {
                        logEvent('system', 'Error log saved', { content }, 'INFO');
                    } else if (status === 'walletSaved') {
                        logEvent('wallet', 'Wallet saved to worker', {}, 'INFO');
                    } else if (status === 'browserKeySaved') {
                        logEvent('browser', 'Browser master key saved', {}, 'INFO');
                    } else if (status === 'error') {
                        logError(`Worker Error: ${message}`, 'Check worker script syntax or execution', stack, 'HIGH');
                    }
                };
                worker.onerror = (err) => {
                    logError(`Worker Runtime Error: ${err.message}`, 'Check worker script for syntax errors', `File: ${err.filename}, Line: ${err.lineno}, Column: ${err.colno}`, 'CRITICAL');
                };
                worker.postMessage({ action: 'init' });
            } catch (err) {
                logError(`Worker Init Error: ${err.message}`, 'Check browser support or worker script', err.stack, 'CRITICAL');
                worker = null;
            }
        }

        // Lockdown system
        function lockdownSystem() {
            try {
                isAuthenticated = false;
                masterKey = null;
                browserMasterKey = null;
                logError('System Lockdown', 'Critical error detected. All operations disabled.', 'No stack', 'CRITICAL');
                document.querySelectorAll('button:not(#authButton):not(#voidButton):not(#troubleshootButton)').forEach(btn => btn.disabled = true);
                document.getElementById('browser-popup').classList.remove('visible');
            } catch (err) {
                logError(`Lockdown Error: ${err.message}`, 'Check button selectors', err.stack, 'CRITICAL');
            }
        }

        // Check server connection
        async function checkServerConnection() {
            const maxRetries = 5;
            let attempt = 0;
            let lastError = null;

            for (const serverUrl of serverUrls) {
                while (attempt < maxRetries) {
                    try {
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 15000);
                        const response = await fetch(serverUrl === '/mcp/ping' ? serverUrl : `${serverUrl}/mcp/ping`, {
                            signal: controller.signal,
                            headers: { 'Accept': 'application/json' }
                        });
                        clearTimeout(timeoutId);
                        if (response.ok) {
                            logEvent('system', `Server ping successful: ${serverUrl}`, { status: response.status, headers: JSON.stringify([...response.headers]) }, 'INFO');
                            return { success: true, serverUrl };
                        }
                        throw new Error(`Server ping failed: ${response.status} ${response.statusText}`);
                    } catch (error) {
                        attempt++;
                        lastError = error;
                        if (attempt === maxRetries) {
                            logError(`Connection error: ${error.message} on ${serverUrl} after ${maxRetries} attempts`, 'Check network, server, or CORS configuration', error.stack, 'HIGH');
                        }
                        await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, attempt)));
                    }
                }
                attempt = 0;
            }
            logError(`Connection error: All servers failed. Last error: ${lastError.message}`, 'Check network, server availability, or CORS', lastError.stack, 'HIGH');
            return { success: false, serverUrl: null };
        }

        // Verify master link
        async function verifyMasterLink() {
            const now = Date.now();
            if (now - lastConnectionErrorTime < CONNECTION_ERROR_THROTTLE_MS) {
                return false;
            }
            const { success, serverUrl } = await checkServerConnection();
            if (!success || !isAuthenticated) {
                isAuthenticated = false;
                masterKey = null;
                browserMasterKey = null;
                oauthToken = 'anonymous';
                document.getElementById('authButton').classList.remove('active-monitor');
                ['trainButton', 'balanceButton', 'exportButton', 'importButton', 'apiButton', 'browserButton'].forEach(id => {
                    document.getElementById(id).disabled = true;
                });
                document.getElementById('browser-popup').classList.remove('visible');
                lastConnectionErrorTime = now;
                logError('Master link verification failed or authentication lost', 'Re-authenticate to continue', 'No stack', 'CRITICAL');
                return false;
            }
            return true;
        }

        // Browser master key
        async function generateBrowserMasterKey() {
            try {
                const rawKey = Array.from(crypto.getRandomValues(new Uint8Array(32))).map(b => b.toString(16).padStart(2, '0')).join('');
                const token = await sha256(rawKey);
                browserMasterKey = token;
                if (db && dexieLoaded) {
                    await db.browser.put({ key: 'browser', token, timestamp: Date.now() });
                }
                if (worker && !worker.terminated) {
                    worker.postMessage({ action: 'saveBrowserKey', data: { key: 'browser', token, timestamp: Date.now() } });
                }
                logEvent('browser', 'Browser master key generated', {}, 'INFO');
            } catch (err) {
                logError(`Browser Master Key Error: ${err.message}`, 'Check crypto API', err.stack, 'HIGH');
            }
        }

        // Authentication
        async function authenticate() {
            if (!mcpUseLoaded) {
                logError('Authentication Unavailable', 'MCP-use library not loaded. Using mock authentication.', 'No stack', 'HIGH');
                // Mock authentication for offline mode
                try {
                    masterKey = 'mock-token-' + generateUUID();
                    oauthToken = masterKey;
                    isAuthenticated = true;
                    await generateBrowserMasterKey();
                    if (db && dexieLoaded) {
                        await db.auth.put({ key: 'master', token: masterKey, timestamp: Date.now() });
                        await db.vials.clear().then(() => db.vials.bulkPut(vials));
                    }
                    document.getElementById('authButton').classList.add('active-monitor');
                    ['trainButton', 'balanceButton', 'exportButton', 'importButton', 'apiButton', 'browserButton'].forEach(id => {
                        document.getElementById(id).disabled = false;
                    });
                    logEvent('auth', 'Mock authentication successful. 4 vials allocated (offline mode).', {}, 'INFO');
                    updateVialStatsUI();
                } catch (err) {
                    logError(`Mock Authentication Error: ${err.message}`, 'Check mock auth logic', err.stack, 'HIGH');
                }
                return;
            }
            const { success, serverUrl } = await checkServerConnection();
            if (!success) {
                logError('Cannot authenticate: Server not reachable', 'Check network or server', 'No stack', 'HIGH');
                showErrorNotification('Server not reachable. Try again later.');
                return;
            }
            try {
                const response = await fetch(`${serverUrl}/mcp/auth`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ client: 'vial', deviceId, sessionId })
                });
                if (!response.ok) throw new Error(`Authentication failed: ${response.status} ${response.statusText}`);
                const { token } = await response.json();
                if (token) {
                    masterKey = token;
                    oauthToken = token;
                    isAuthenticated = true;
                    await generateBrowserMasterKey();
                    if (db && dexieLoaded) {
                        await db.auth.put({ key: 'master', token, timestamp: Date.now() });
                        await db.vials.clear().then(() => db.vials.bulkPut(vials));
                    }
                    document.getElementById('authButton').classList.add('active-monitor');
                    ['trainButton', 'balanceButton', 'exportButton', 'importButton', 'apiButton', 'browserButton'].forEach(id => {
                        document.getElementById(id).disabled = false;
                    });
                    logEvent('auth', 'Authentication successful. 4 vials allocated.', {}, 'INFO');
                    updateVialStatsUI();
                }
            } catch (error) {
                logError(`Authentication failed: ${error.message}`, 'Check OAuth configuration', error.stack, 'HIGH');
                showErrorNotification('Authentication failed. Check network or server.');
            }
        }

        // Void
        async function voidVials() {
            try {
                isAuthenticated = false;
                masterKey = null;
                browserMasterKey = null;
                oauthToken = 'anonymous';
                wallet = { address: null, balance: 0, privateKey: null, passwords: [], trainingRewards: [] };
                vials = Array(4).fill().map((_, i) => ({
                    id: `vial${i+1}`,
                    latencyHistory: [],
                    status: 'stopped',
                    code: '',
                    filePath: '',
                    createdAt: '',
                    codeLength: 0,
                    trainingData: null,
                    isPython: false
                }));
                if (db && dexieLoaded) {
                    await db.vials.clear();
                    await db.auth.clear();
                    await db.wallets.clear();
                    await db.browser.clear();
                }
                if (canUseLocalStorage()) {
                    try {
                        localStorage.removeItem('logs');
                        localStorage.removeItem('errorLog');
                        localStorage.removeItem('browserHistory');
                    } catch (err) {
                        logError(`LocalStorage Clear Error: ${err.message}`, 'Check localStorage access', err.stack, 'HIGH');
                    }
                }
                document.getElementById('authButton').classList.remove('active-monitor');
                ['trainButton', 'balanceButton', 'exportButton', 'importButton', 'apiButton', 'browserButton'].forEach(id => {
                    document.getElementById(id).disabled = true;
                });
                document.getElementById('browser-popup').classList.remove('visible');
                logQueue = ['<p>Vial MCP Controller initialized</p>'];
                debouncedUpdateConsole();
                updateVialStatsUI();
                updateWalletStatsUI();
                logEvent('void', 'All data voided', {}, 'INFO');
            } catch (err) {
                logError(`Void Error: ${err.message}`, 'Check void function', err.stack, 'HIGH');
            }
        }

        // Troubleshoot
        async function troubleshoot() {
            try {
                const { success, serverUrl } = await checkServerConnection();
                const authRecord = db && dexieLoaded ? await db.auth.get('master') : null;
                const browserRecord = db && dexieLoaded ? await db.browser.get('browser') : null;
                const vialsCount = db && dexieLoaded ? await db.vials.count() : 0;
                const workerStatus = worker && !worker.terminated ? 'active' : 'inactive';
                const mcpUseStatus = mcpUseLoaded ? 'loaded' : 'unavailable';
                logEvent('diagnostics', `Troubleshoot: Server ${success ? 'online' : 'offline'}, Auth ${authRecord ? 'present' : 'missing'}, Browser Key ${browserRecord ? 'present' : 'missing'}, Vials: ${vialsCount}, Worker: ${workerStatus}, MCP-use: ${mcpUseStatus}`, {}, 'INFO');
                if (!mcpUseLoaded) {
                    logError('Troubleshoot Warning', 'MCP-use unavailable. Diagnostics limited to offline mode.', 'No stack', 'HIGH');
                    showErrorNotification('MCP-use unavailable. Diagnostics limited.');
                }
                if (!worker || worker.terminated) {
                    logError('Troubleshoot Warning', 'Worker unavailable. Skipping worker-based diagnostics.', 'No stack', 'HIGH');
                    showErrorNotification('Worker unavailable. Diagnostics limited.');
                }
                await systemDiagnostics();
            } catch (err) {
                logError(`Troubleshoot Error: ${err.message}`, 'Check diagnostics function', err.stack, 'HIGH');
                showErrorNotification('Troubleshoot failed. Check logs.');
            }
        }

        // Convert HTML to Markdown
        function htmlToMarkdown(html, url) {
            try {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                let markdown = `# Webpage: ${url}\n\n`;
                
                // Extract title
                const title = doc.querySelector('title')?.textContent || 'No Title';
                markdown += `## Title\n${title}\n\n`;
                
                // Extract main content (simplified)
                const mainContent = doc.querySelector('main, article, body')?.textContent || '';
                if (!mainContent.trim()) {
                    throw new Error('No meaningful content found');
                }
                markdown += `## Content\n${mainContent.trim().slice(0, 10000)}\n\n`;
                
                // Extract scripts (for training)
                const scripts = Array.from(doc.querySelectorAll('script')).map(s => s.textContent).filter(s => s?.trim());
                if (scripts.length > 0) {
                    markdown += `## Scripts\n\`\`\`javascript\n${scripts.join('\n\n').slice(0, 5000)}\n\`\`\`\n`;
                }
                
                // Validate Markdown
                if (markdown.length < 50) {
                    throw new Error('Generated Markdown is too short or corrupted');
                }
                
                return markdown;
            } catch (err) {
                logError(`HTML to Markdown Error: ${err.message}`, 'Check webpage structure', err.stack, 'HIGH');
                return null;
            }
        }

        // Open browser popup
        async function openBrowser() {
            if (!(await verifyMasterLink()) || !browserMasterKey) {
                logError('Browser Access Denied', 'Authenticate to use .md Browser', 'No stack', 'HIGH');
                return;
            }
            try {
                const popup = document.getElementById('browser-popup');
                const content = document.getElementById('browser-content');
                const urlInput = document.getElementById('browser-url');
                content.textContent = 'Enter a URL and click Visit to load content.';
                urlInput.value = '';
                currentBrowserContent = '';
                currentBrowserUrl = '';
                document.getElementById('browser-train').disabled = true;
                popup.classList.add('visible');
                logEvent('browser', 'Opened .md Browser', {}, 'INFO');
            } catch (err) {
                logError(`Open Browser Error: ${err.message}`, 'Check browser popup', err.stack, 'HIGH');
            }
        }

        // Fetch and display webpage as Markdown
        async function visitUrl() {
            if (!(await verifyMasterLink()) || !browserMasterKey) return;
            const urlInput = document.getElementById('browser-url');
            const url = sanitizeUrl(urlInput.value);
            if (!url) return;
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 15000);
                const response = await fetch(url, { signal: controller.signal });
                clearTimeout(timeoutId);
                if (!response.ok) throw new Error(`Fetch failed: ${response.status} ${response.statusText}`);
                const html = await response.text();
                const markdown = htmlToMarkdown(html, url);
                if (!markdown) {
                    logError('Markdown Conversion Failed', 'Invalid or corrupted webpage data', 'No stack', 'HIGH');
                    showErrorNotification('Warning: Corrupted webpage data detected');
                    return;
                }
                currentBrowserContent = markdown;
                currentBrowserUrl = url;
                document.getElementById('browser-content').textContent = markdown;
                document.getElementById('browser-train').disabled = false;
                logEvent('browser', `Loaded ${url} as Markdown`, {}, 'INFO');
                
                // Save to localStorage
                if (canUseLocalStorage()) {
                    try {
                        let browserHistory = JSON.parse(localStorage.getItem('browserHistory') || '[]');
                        browserHistory.push({ url, markdown, timestamp: new Date().toISOString() });
                        if (browserHistory.length > 50) browserHistory.shift();
                        localStorage.setItem('browserHistory', JSON.stringify(browserHistory));
                    } catch (err) {
                        logError(`Browser History Save Error: ${err.message}`, 'Check localStorage', err.stack, 'HIGH');
                    }
                }
            } catch (err) {
                logError(`Visit URL Error: ${err.message}`, 'Check URL or network', err.stack, 'HIGH');
                showErrorNotification('Failed to load URL');
            }
        }

        // Train from browser content
        async function trainFromBrowser() {
            if (!(await verifyMasterLink()) || !browserMasterKey) return;
            if (!currentBrowserContent) {
                logError('Browser Train Error', 'No content loaded in .md Browser', 'No stack', 'HIGH');
                return;
            }
            try {
                document.getElementById('trainButton').classList.add('active-train');
                document.getElementById('console').classList.add('active-train');
                document.body.classList.add('train-glow');
                logEvent('training', `Training started from .md Browser: ${currentBrowserUrl}`, {}, 'INFO');
                const serverUrl = serverUrls[0];
                const startTime = Date.now();
                for (const vial of vials.filter(v => v.status === 'stopped')) {
                    const trainingData = await trainOnPyTorchServer(vial, currentBrowserContent, false, serverUrl);
                    if (trainingData) {
                        vial.latencyHistory.push(Math.random() * 100);
                        vial.code = currentBrowserContent;
                        vial.codeLength = currentBrowserContent.length;
                        vial.trainingData = trainingData;
                        vial.isPython = false; // .md treated as JavaScript
                        vial.status = 'running';
                        if (db && dexieLoaded) await db.vials.put(vial);
                        logEvent('training', `Trained vial ${vial.id} from .md Browser`, { latency: vial.latencyHistory[vial.latencyHistory.length - 1], trainingData }, 'INFO');
                    }
                }
                const trainingDuration = (Date.now() - startTime) / 1000; // Seconds
                await rewardTraining(trainingDuration);
                document.getElementById('trainButton').classList.remove('active-train');
                document.getElementById('console').classList.remove('active-train');
                document.body.classList.remove('train-glow');
                document.getElementById('browser-popup').classList.remove('visible');
                logEvent('training', `Training completed from .md Browser. Duration: ${trainingDuration.toFixed(2)}s`, {}, 'INFO');
                updateVialStatsUI();
            } catch (err) {
                document.getElementById('trainButton').classList.remove('active-train');
                document.getElementById('console').classList.remove('active-train');
                document.body.classList.remove('train-glow');
                logError(`Browser Train Error: ${err.message}`, 'Check training function', err.stack, 'HIGH');
            }
        }

        // Train Vials and Earn $WEBXOS
        async function trainVials() {
            if (!(await verifyMasterLink()) || !browserMasterKey) return;
            try {
                const fileInput = document.getElementById('file-input');
                let inputData = 'console.log("Training data");';
                let isPython = false;
                if (fileInput?.files?.length) {
                    const file = fileInput.files[0];
                    if (!['.js', '.py', '.txt'].includes(file.name.slice(-4))) {
                        logError('File Error', 'Only .js, .py, or .txt files allowed', 'No stack', 'HIGH');
                        return;
                    }
                    if (file.size > 1024 * 1024) {
                        logError('File Error', 'File size exceeds 1MB', 'No stack', 'HIGH');
                        return;
                    }
                    inputData = await file.text();
                    isPython = file.name.endsWith('.py');
                }
                inputData = sanitizeInput(inputData);
                document.getElementById('trainButton').classList.add('active-train');
                document.getElementById('console').classList.add('active-train');
                document.body.classList.add('train-glow');
                logEvent('training', 'Training started from file', {}, 'INFO');
                const serverUrl = serverUrls[0];
                const startTime = Date.now();
                for (const vial of vials.filter(v => v.status === 'stopped')) {
                    const trainingData = await trainOnPyTorchServer(vial, inputData, isPython, serverUrl);
                    if (trainingData) {
                        vial.latencyHistory.push(Math.random() * 100);
                        vial.code = inputData;
                        vial.codeLength = inputData.length;
                        vial.trainingData = trainingData;
                        vial.isPython = isPython;
                        vial.status = 'running';
                        if (db && dexieLoaded) await db.vials.put(vial);
                        logEvent('training', `Trained vial ${vial.id} from file`, { latency: vial.latencyHistory[vial.latencyHistory.length - 1], trainingData }, 'INFO');
                    }
                }
                const trainingDuration = (Date.now() - startTime) / 1000; // Seconds
                await rewardTraining(trainingDuration);
                document.getElementById('trainButton').classList.remove('active-train');
                document.getElementById('console').classList.remove('active-train');
                document.body.classList.remove('train-glow');
                logEvent('training', `Training completed from file. Duration: ${trainingDuration.toFixed(2)}s`, {}, 'INFO');
                updateVialStatsUI();
            } catch (err) {
                document.getElementById('trainButton').classList.remove('active-train');
                document.getElementById('console').classList.remove('active-train');
                document.body.classList.remove('train-glow');
                logError(`Train Error: ${err.message}`, 'Check training function', err.stack, 'HIGH');
            }
        }

        // Train on PyTorch server
        async function trainOnPyTorchServer(vial, inputData, isPython, serverUrl) {
            if (!mcpUseLoaded) {
                logError('Training Unavailable', 'MCP-use library not loaded. Skipping server training.', 'No stack', 'HIGH');
                return { mock: true, data: 'Mock training data' };
            }
            const maxRetries = 5;
            let attempt = 0;
            while (attempt < maxRetries) {
                try {
                    const response = await fetch(`${serverUrl}/mcp/train`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${masterKey}` },
                        body: JSON.stringify({ vialId: vial.id, code: inputData, isPython })
                    });
                    if (!response.ok) throw new Error(`Training failed: ${response.status} ${response.statusText}`);
                    const result = await response.json();
                    return result.trainingData;
                } catch (err) {
                    attempt++;
                    if (attempt === maxRetries) {
                        logError(`Training Error: ${err.message}`, `Check server after ${maxRetries} attempts`, err.stack, 'HIGH');
                        return null;
                    }
                    await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, attempt)));
                }
            }
        }

        // Reward training
        async function rewardTraining(trainingDuration) {
            try {
                if (!wallet.address) {
                    logError('Training Reward Error', 'No wallet', 'Create wallet first', 'No stack', 'HIGH');
                    return;
                }
                const reward = trainingDuration; // 1 $WEBXOS per second (1 SHA hash per second)
                wallet.balance += reward;
                wallet.trainingRewards.push({
                    timestamp: new Date().toISOString(),
                    duration: trainingDuration,
                    reward,
                    note: 'Hypothetical $WEBXOS token; no markets currently accept'
                });
                if (db && dexieLoaded) await db.wallets.put(wallet);
                if (worker && !worker.terminated) {
                    worker.postMessage({ action: 'saveWallet', data: wallet });
                } else if (canUseLocalStorage()) {
                    try {
                        localStorage.setItem('wallet', JSON.stringify(wallet));
                    } catch (err) {
                        logError(`Wallet Save Error: ${err.message}`, 'Check localStorage', err.stack, 'HIGH');
                    }
                }
                logEvent('wallet', `Training reward: ${reward.toFixed(2)} $WEBXOS for ${trainingDuration.toFixed(2)}s (1 SHA/s, hypothetical)`, { balance: wallet.balance }, 'INFO');
                updateWalletStatsUI();
            } catch (err) {
                logError(`Training Reward Error: ${err.message}`, 'Check wallet update', err.stack, 'HIGH');
            }
        }

        // Check balance
        async function checkBalance() {
            if (!(await verifyMasterLink()) || !browserMasterKey) return;
            if (!wallet.address) {
                logError('Balance Error', 'No wallet', 'Create wallet first', 'No stack', 'HIGH');
                return;
            }
            if (!mcpUseLoaded) {
                logError('Balance Check Unavailable', 'MCP-use library not loaded. Using cached balance.', 'No stack', 'HIGH');
                logEvent('wallet', `Cached balance: ${wallet.balance.toFixed(2)} $WEBXOS (hypothetical)`, {}, 'INFO');
                updateWalletStatsUI();
                return;
            }
            try {
                const serverUrl = serverUrls[0];
                const response = await fetch(`${serverUrl}/mcp/wallet/${wallet.address}`, {
                    headers: { 'Authorization': `Bearer ${masterKey}` }
                });
                if (!response.ok) throw new Error(`Balance check failed: ${response.status} ${response.statusText}`);
                const { balance } = await response.json();
                wallet.balance = balance;
                if (db && dexieLoaded) await db.wallets.put(wallet);
                logEvent('wallet', `Balance: ${wallet.balance.toFixed(2)} $WEBXOS (hypothetical)`, {}, 'INFO');
                updateWalletStatsUI();
            } catch (err) {
                logError(`Balance Error: ${err.message}`, 'Check balance function', err.stack, 'HIGH');
            }
        }

        // Export vials
        async function exportVials() {
            if (!(await verifyMasterLink()) || !browserMasterKey) return;
            try {
                logEvent('export', 'Exporting vials as Markdown', {}, 'INFO');
                const content = vials.map(vial => `
# Vial Agent: ${vial.id}

- Status: ${vial.status}
- Created: ${vial.createdAt}
- Language: ${vial.isPython ? 'Python' : 'JavaScript'}
- Code:
\`\`\`${vial.isPython ? 'python' : 'javascript'}
${vial.code}
\`\`\`
- Latency: ${vial.latencyHistory.join(', ')} ms
- Training Data: ${vial.trainingData ? JSON.stringify(vial.trainingData) : 'None'}
                `).join('---\n\n');
                const blob = new Blob([content], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `vial_export_${new Date().toISOString().replace(/[:.]/g, '-')}.md`;
                a.click();
                URL.revokeObjectURL(url);
                logEvent('export', 'Exported vials as Markdown', {}, 'INFO');
            } catch (err) {
                logError(`Export Error: ${err.message}`, 'Check export function', err.stack, 'HIGH');
            }
        }

        // Import vials
        async function importVials() {
            if (!(await verifyMasterLink()) || !browserMasterKey) return;
            try {
                const fileInput = document.getElementById('file-input');
                if (!fileInput?.files?.length) {
                    logError('Import Error', 'No file selected', 'No stack', 'HIGH');
                    return;
                }
                const file = fileInput.files[0];
                if (!file.name.endsWith('.txt')) {
                    logError('Import Error', 'Only .txt files allowed', 'No stack', 'HIGH');
                    return;
                }
                const text = await file.text();
                const importedVials = JSON.parse(text);
                if (!Array.isArray(importedVials) || importedVials.length > 4) {
                    logError('Import Error', 'Invalid vial data or exceeds 4 vials', 'No stack', 'HIGH');
                    return;
                }
                if (db && dexieLoaded) {
                    await db.vials.clear();
                    await db.vials.bulkPut(importedVials);
                }
                vials = importedVials;
                logEvent('import', 'Vials imported', {}, 'INFO');
                updateVialStatsUI();
            } catch (err) {
                logError(`Import Error: ${err.message}`, 'Check import function', err.stack, 'HIGH');
            }
        }

        // Configure API (with Stripe placeholder)
        async function configureAPI() {
            if (!(await verifyMasterLink()) || !browserMasterKey) return;
            if (!mcpUseLoaded) {
                logError('API Config Unavailable', 'MCP-use library not loaded. Skipping API configuration.', 'No stack', 'HIGH');
                return;
            }
            try {
                const fileInput = document.getElementById('file-input');
                if (!fileInput?.files?.length) {
                    logError('API Config Error', 'No API key file selected', 'No stack', 'HIGH');
                    return;
                }
                const file = fileInput.files[0];
                if (!file.name.endsWith('.txt')) {
                    logError('API Config Error', 'Only .txt files allowed', 'No stack', 'HIGH');
                    return;
                }
                const apiKey = await file.text();
                const serverUrl = serverUrls[0];
                const response = await fetch(`${serverUrl}/mcp/api-config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${masterKey}` },
                    body: JSON.stringify({ apiKey: sanitizeInput(apiKey) })
                });
                if (!response.ok) throw new Error(`API config failed: ${response.status} ${response.statusText}`);
                // Stripe placeholder: simulate storing Stripe key
                const stripeResponse = await fetch(`${serverUrl}/mcp/stripe-config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${masterKey}` },
                    body: JSON.stringify({ stripeKey: sanitizeInput(apiKey) })
                });
                if (!stripeResponse.ok) throw new Error('Stripe configuration failed (placeholder)');
                logEvent('api', 'API and Stripe keys configured (placeholder)', {}, 'INFO');
            } catch (err) {
                logError(`API Config Error: ${err.message}`, 'Check API or Stripe configuration', err.stack, 'HIGH');
            }
        }

        // Create wallet
        async function createWallet() {
            if (!(await verifyMasterLink()) || !browserMasterKey) return;
            try {
                logEvent('wallet', 'Creating wallet', {}, 'INFO');
                const privateKey = Array.from(crypto.getRandomValues(new Uint8Array(32))).map(b => b.toString(16).padStart(2, '0')).join('');
                const address = await sha256(privateKey);
                const encryptedKey = await aesEncrypt(privateKey, address);
                if (!encryptedKey) throw new Error('Encryption failed');
                const passwords = Array(3).fill().map(() => Array.from(crypto.getRandomValues(new Uint8Array(16))).map(b => b.toString(16).padStart(2, '0')).join(''));
                const encryptedPasswords = await Promise.all(passwords.map(pwd => aesEncrypt(pwd, address)));
                wallet = {
                    address,
                    balance: 0,
                    privateKey: JSON.stringify(encryptedKey),
                    passwords: encryptedPasswords.map(pwd => ({ iv: pwd.iv, encrypted: pwd.encrypted })),
                    trainingRewards: []
                };
                if (db && dexieLoaded) await db.wallets.put(wallet);
                if (worker && !worker.terminated) {
                    worker.postMessage({ action: 'saveWallet', data: wallet });
                } else if (canUseLocalStorage()) {
                    try {
                        localStorage.setItem('wallet', JSON.stringify(wallet));
                    } catch (err) {
                        logError(`Wallet Save Error: ${err.message}`, 'Check localStorage', err.stack, 'HIGH');
                    }
                }
                logEvent('wallet', `Created wallet ${address.slice(0, 10)}...`, { balance: 0 }, 'INFO');
                updateWalletStatsUI();
            } catch (err) {
                logError(`Create Wallet Error: ${err.message}`, 'Check wallet creation', err.stack, 'HIGH');
            }
        }

        // System diagnostics
        async function systemDiagnostics() {
            const diagnosticResults = [];
            let hasCriticalIssue = false;

            const logDiagnostic = (name, status, message, analysis = '', stack = 'No stack', urgency = 'INFO') => {
                diagnosticResults.push({ name, status, message, analysis, stack, urgency });
                if (status === 'PASS') {
                    logEvent('diagnostics', `${name} check passed: ${message}`, {}, urgency);
                } else {
                    logError(`${name} Failure: ${message}`, analysis, stack, urgency);
                    if (urgency === 'CRITICAL') hasCriticalIssue = true;
                }
            };

            try {
                logEvent('diagnostics', 'Starting diagnostics', {}, 'INFO');

                // Browser Compatibility
                const features = [
                    { name: 'Web Crypto API', check: () => window.crypto?.subtle, urgency: 'CRITICAL' },
                    { name: 'IndexedDB', check: () => window.indexedDB, urgency: 'HIGH' },
                    { name: 'Worker', check: () => window.Worker, urgency: 'CRITICAL' },
                    { name: 'Blob', check: () => window.Blob, urgency: 'CRITICAL' },
                    { name: 'URL', check: () => window.URL?.createObjectURL, urgency: 'CRITICAL' },
                    { name: 'TensorFlow.js', check: () => typeof tf !== 'undefined' && tensorflowLoaded, urgency: 'HIGH' },
                    { name: 'Skulpt', check: () => typeof Sk !== 'undefined', urgency: 'HIGH' },
                    { name: 'MCP-use', check: () => mcpUseLoaded, urgency: 'HIGH' },
                    { name: 'DOMParser', check: () => window.DOMParser, urgency: 'HIGH' }
                ];
                for (const { name, check, urgency } of features) {
                    try {
                        const isSupported = check();
                        logDiagnostic(
                            name,
                            isSupported ? 'PASS' : 'FAIL',
                            isSupported ? `${name} supported` : `${name} not supported`,
                            isSupported ? '' : 'Use modern browser or check CDN/local fallback',
                            'No stack',
                            urgency
                        );
                    } catch (err) {
                        logDiagnostic(name, 'FAIL', `Error checking ${name}: ${err.message}`, 'Check browser', err.stack, urgency);
                    }
                }

                // Network Status
                try {
                    logDiagnostic('Network', isOnline ? 'PASS' : 'FAIL', isOnline ? 'Online' : 'Offline', isOnline ? '' : 'Using offline mode', 'No stack', 'HIGH');
                } catch (err) {
                    logDiagnostic('Network', 'FAIL', `Network check failed: ${err.message}`, 'Check connectivity', err.stack, 'HIGH');
                }

                // Dexie/IndexedDB
                try {
                    if (db && dexieLoaded && window.indexedDB) {
                        await db.logs.count();
                        logDiagnostic('IndexedDB', 'PASS', 'IndexedDB functional');
                    } else {
                        logDiagnostic('IndexedDB', 'FAIL', 'IndexedDB or Dexie not available', 'Check Dexie or browser', 'No stack', 'HIGH');
                    }
                } catch (err) {
                    logDiagnostic('IndexedDB', 'FAIL', `IndexedDB check failed: ${err.message}`, 'Check storage permissions', err.stack, 'HIGH');
                }

                // Worker Status
                try {
                    if (worker && !worker.terminated) {
                        logDiagnostic('Worker', 'PASS', 'Worker active');
                    } else {
                        logDiagnostic('Worker', 'FAIL', 'Worker inactive or failed to initialize', 'Check worker script or browser support', 'No stack', 'HIGH');
                    }
                } catch (err) {
                    logDiagnostic('Worker', 'FAIL', `Worker check failed: ${err.message}`, 'Check worker initialization', err.stack, 'HIGH');
                }

                // Server Connection
                try {
                    const { success, serverUrl } = await checkServerConnection();
                    logDiagnostic('Server', success ? 'PASS' : 'FAIL', success ? `Server connected: ${serverUrl}` : 'Server not reachable', success ? '' : 'Check network or server', 'No stack', 'HIGH');
                } catch (err) {
                    logDiagnostic('Server', 'FAIL', `Server check failed: ${err.message}`, 'Check network or server', err.stack, 'HIGH');
                }

                // Authentication Status
                try {
                    const authRecord = db && dexieLoaded ? await db.auth.get('master') : null;
                    logDiagnostic('Authentication', isAuthenticated && authRecord ? 'PASS' : 'FAIL', isAuthenticated && authRecord ? 'Authenticated' : 'Not authenticated', isAuthenticated && authRecord ? '' : 'Re-authenticate', 'No stack', 'HIGH');
                } catch (err) {
                    logDiagnostic('Authentication', 'FAIL', `Auth check failed: ${err.message}`, 'Check auth store', err.stack, 'HIGH');
                }

                // Browser Master Key
                try {
                    const browserRecord = db && dexieLoaded ? await db.browser.get('browser') : null;
                    logDiagnostic('Browser Key', browserMasterKey && browserRecord ? 'PASS' : 'FAIL', browserMasterKey && browserRecord ? 'Browser key present' : 'Browser key missing', browserMasterKey && browserRecord ? '' : 'Re-authenticate', 'No stack', 'HIGH');
                } catch (err) {
                    logDiagnostic('Browser Key', 'FAIL', `Browser key check failed: ${err.message}`, 'Check browser store', err.stack, 'HIGH');
                }

                await exportDiagnosticsReport(diagnosticResults);
                logEvent('diagnostics', `Diagnostics complete: ${diagnosticResults.filter(r => r.status === 'PASS').length}/${diagnosticResults.length} passed`, { critical: hasCriticalIssue }, 'INFO');
                if (hasCriticalIssue) lockdownSystem();
            } catch (err) {
                logError(`Diagnostics Error: ${err.message}`, 'Check diagnostics function', err.stack, 'CRITICAL');
            }
        }

        // Export diagnostics report
        async function exportDiagnosticsReport(results) {
            try {
                const content = `
# WebXOS Diagnostics Report
Generated: ${new Date().toISOString()}

## Summary
- Total
