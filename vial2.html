<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vial MCP Controller</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Courier New', monospace; }
        html, body { height: 100vh; overflow: hidden; background: #000; color: #0f0; display: flex; flex-direction: column; align-items: center; touch-action: manipulation; }
        body.glow { background: rgba(255, 0, 0, 0.1); box-shadow: 0 0 20px #ff0000; }
        body.train-glow { background: rgba(255, 255, 0, 0.1); box-shadow: 0 0 20px #ff0; }
        h1 { font-size: 1.6rem; text-align: center; margin: 0.8rem 0; text-transform: uppercase; letter-spacing: 1px; text-shadow: 0 0 5px #0f0; }
        #console { width: 90%; max-width: 900px; background: rgba(0, 255, 0, 0.1); border: 1px solid #0f0; padding: 0.6rem; flex: 1; max-height: calc(100vh - 380px); overflow-y: auto; margin: 0.5rem 0; border-radius: 5px; font-size: 0.8rem; position: relative; z-index: 5; }
        #console.active-monitor { border-color: #ff0000; box-shadow: 0 0 10px #ff0000; }
        #console.active-train { border-color: #ff0; box-shadow: 0 0 10px #ff0; }
        #console p { margin: 0.2rem 0; }
        #console .command { font-weight: 700; text-shadow: 0 0 3px #0f0; }
        #console .error { color: #ff0000; text-shadow: 0 0 3px #ff0000; }
        #console .balance { color: #00f; text-shadow: 0 0 3px #00f; position: sticky; bottom: 0; background: rgba(0, 0, 0, 0.8); padding: 0.2rem; z-index: 6; }
        #error-notification { display: none; position: fixed; top: 10px; right: 10px; background: rgba(255, 0, 0, 0.8); color: #fff; padding: 0.5rem; border-radius: 3px; font-size: 0.8rem; max-width: 300px; z-index: 1000; box-shadow: 0 0 10px #ff0000; }
        #error-notification.visible { display: block; }
        #error-notification.success { background: rgba(0, 255, 0, 0.8); }
        #api-popup, #config-popup { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 80%; max-width: 500px; background: #000; border: 2px solid #0f0; padding: 1rem; border-radius: 5px; z-index: 2000; box-shadow: 0 0 20px #0f0; color: #0f0; }
        #api-popup.visible, #config-popup.visible { display: block; }
        #api-popup textarea, #config-popup input { width: 100%; background: #000; border: 1px solid #0f0; color: #0f0; padding: 0.5rem; font-size: 0.9rem; border-radius: 3px; }
        #api-popup textarea { height: 100px; resize: none; }
        #api-popup button, #config-popup button { background: #0f0; color: #000; border: none; padding: 0.5rem 1rem; font-size: 0.9rem; cursor: pointer; border-radius: 3px; margin: 0.5rem 0.25rem 0 0; }
        #api-popup button:hover, #config-popup button:hover { background: #0c0; }
        .button-group { display: flex; gap: 0.5rem; margin: 0.5rem 0; flex-wrap: wrap; justify-content: center; width: 90%; max-width: 900px; z-index: 10; }
        button { background: #0f0; color: #000; border: none; padding: 0.6rem 1.2rem; font-size: 0.9rem; cursor: pointer; border-radius: 3px; min-width: 90px; }
        button:hover, button:focus { background: #0c0; outline: 2px solid #0f0; }
        button.active-monitor { background: #ff0000; box-shadow: 0 0 10px #ff0000; }
        button.active-train { background: #ff0; color: #000; box-shadow: 0 0 10px #ff0; }
        button:disabled { background: #666; cursor: not-allowed; }
        #prompt-input { width: 90%; max-width: 900px; background: #000; border: 1px solid #0f0; color: #0f0; padding: 0.6rem; font-size: 0.9rem; border-radius: 3px; margin: 0.5rem 0; }
        #vial-status-bars { width: 90%; max-width: 900px; margin: 0.5rem 0; display: flex; flex-direction: column; gap: 0.2rem; z-index: 10; }
        .progress-container { display: flex; align-items: center; gap: 0.4rem; }
        .progress-label { width: 90px; font-size: 0.75rem; color: #0f0; }
        .progress-bar { flex: 1; height: 8px; background: #333; border: 1px solid #0f0; border-radius: 3px; overflow: hidden; }
        .progress-fill { height: 100%; background: #0f0; transition: width 0.5s; }
        .progress-fill.offline-grey { background: #666; }
        .progress-fill.training { background: #ff0; }
        .progress-fill.offline { background: #f00; }
        .status-text { font-size: 0.75rem; width: 250px; text-align: right; }
        .status-text.online { color: #0f0; }
        .status-text.training { color: #ff0; }
        .status-text.offline-grey { color: #666; }
        .status-text.offline { color: #f00; }
        footer { width: 100%; padding: 0.4rem; font-size: 9pt; text-align: center; color: #0f0; background: rgba(0, 0, 0, 0.8); z-index: 10; }
        #file-input { display: none; }
        @media (max-width: 600px) {
            h1 { font-size: 1.1rem; margin: 0.5rem 0; }
            #console { font-size: 0.75rem; padding: 0.5rem; max-height: calc(100vh - 380px); }
            button { padding: 0.5rem 1rem; font-size: 0.85rem; min-width: 80px; }
            #prompt-input, #api-popup textarea, #config-popup input { font-size: 0.85rem; padding: 0.5rem; }
            .progress-label { width: 70px; font-size: 0.7rem; }
            .progress-bar { height: 7px; }
            .status-text { font-size: 0.7rem; width: 200px; }
            #error-notification, #api-popup, #config-popup { font-size: 0.7rem; max-width: 250px; }
        }
        @media (max-width: 400px) {
            .button-group { flex-direction: column; align-items: center; }
            button { width: 100%; max-width: 160px; }
            #console { max-height: calc(100vh - 320px); }
            .status-text { width: 150px; }
        }
    </style>
</head>
<body>
    <h1>Vial MCP Controller</h1>
    <div id="console">
        <p>Vial MCP Controller initialized. Use /help for API commands.</p>
        <p class="balance">$WEBXOS Balance: N/A (Offline) | Reputation: N/A (Offline)</p>
    </div>
    <div id="error-notification"></div>
    <div id="api-popup">
        <h2>API Access Credentials</h2>
        <textarea id="api-input" readonly></textarea>
        <button id="api-generate">Generate New Credentials</button>
        <button id="api-close">Close</button>
    </div>
    <div id="config-popup">
        <h2>Configure Backend URL</h2>
        <input id="config-input" placeholder="Enter backend URL (e.g., http://localhost:8000/api)">
        <button id="config-test">Test Connection</button>
        <button id="config-save">Save</button>
        <button id="config-close">Close</button>
    </div>
    <div class="button-group">
        <button id="authButton">Authenticate</button>
        <button id="voidButton">Void</button>
        <button id="troubleshootButton">Troubleshoot</button>
        <button id="quantumLinkButton" disabled>Quantum Link</button>
        <button id="exportButton" disabled>Export</button>
        <button id="importButton" disabled>Import</button>
        <button id="apiAccessButton" disabled>API Access</button>
        <button id="configButton">Config</button>
    </div>
    <textarea id="prompt-input" placeholder="Enter commands (e.g., /prompt vial1 train dataset, /auth user123, /status)"></textarea>
    <div id="vial-status-bars"></div>
    <footer>WebXOS Vial MCP Controller | Offline Mode | 2025 | v2.8</footer>
    <input type="file" id="file-input" accept=".md">
    <script>
        let API_BASE = localStorage.getItem('apiBase') || 'http://localhost:8000/api';
        const version = '2.8';
        let logQueue = ['<p>Vial MCP Controller initialized. Use /help for API commands.</p>', '<p class="balance">$WEBXOS Balance: N/A (Offline) | Reputation: N/A (Offline)</p>'];
        let isAuthenticated = false;
        let isOffline = true;
        let apiKey = localStorage.getItem('apiKey') || null;
        let userId = localStorage.getItem('userId') || null;
        let wallet = { address: null, balance: 0, hash: null, webxos: 0.0, transactions: [] };
        let reputation = 0;
        let vials = Array(4).fill().map((_, i) => ({
            id: `vial${i + 1}`,
            status: 'stopped',
            code: '',
            codeLength: 0,
            wallet: { address: null, balance: 0, hash: null, webxos: 0.0, transactions: [] },
            tasks: [],
            latency: 0
        }));
        const errorCooldowns = new Map();
        const retryLimits = new Map();
        let lastLogId = 0;

        const mockResponses = {
            '/api/health': { status: 'healthy', mongo: true, version: '2.8', services: ['auth', 'wallet', 'vials'] },
            '/api/auth/login': { apiKey: `OFFLINE-${crypto.randomUUID()}`, walletAddress: 'mock-wallet', walletHash: 'mock-hash' },
            '/api/auth/api-key/generate': { apiKey: `OFFLINE-${crypto.randomUUID()}`, walletAddress: 'mock-wallet', walletHash: 'mock-hash' },
            '/api/vials/vial1/prompt': { response: 'Prompt processed for vial1' },
            '/api/vials/vial2/prompt': { response: 'Prompt processed for vial2' },
            '/api/vials/vial3/prompt': { response: 'Prompt processed for vial3' },
            '/api/vials/vial4/prompt': { response: 'Prompt processed for vial4' },
            '/api/vials/vial1/task': { status: 'Task assigned to vial1' },
            '/api/vials/vial2/task': { status: 'Task assigned to vial2' },
            '/api/vials/vial3/task': { status: 'Task assigned to vial3' },
            '/api/vials/vial4/task': { status: 'Task assigned to vial4' },
            '/api/vials/vial1/config': { status: 'Config updated for vial1' },
            '/api/vials/vial2/config': { status: 'Config updated for vial2' },
            '/api/vials/vial3/config': { status: 'Config updated for vial3' },
            '/api/vials/vial4/config': { status: 'Config updated for vial4' },
            '/api/vials/void': { status: 'All vials reset' },
            '/api/wallet/create': { status: 'Wallet created', address: 'mock-wallet', webxos: 0.0 },
            '/api/wallet/import': { status: 'Wallet imported' },
            '/api/wallet/transaction': { status: 'Transaction recorded' },
            '/api/quantum/link': { statuses: ['running', 'running', 'running', 'running'], latencies: [50, 60, 70, 80] },
            '/api/blockchain/transaction': { status: 'Transaction recorded' }
        };

        async function logErrorToBackend(errorMessage, stack, endpoint, rawResponse = '') {
            try {
                await fetchWithRetry(`${API_BASE}/api/log_error`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ error: errorMessage, stack, endpoint, timestamp: new Date().toISOString(), source: 'frontend', rawResponse })
                });
            } catch (e) {
                console.error('Failed to log error to backend:', e.message);
                localStorage.setItem(`error_${lastLogId + 1}`, JSON.stringify({ error: errorMessage, stack, endpoint, timestamp: new Date().toISOString() }));
            }
        }

        async function fetchWithRetry(url, options, retries = 5, delay = 1000) {
            const retryKey = url.split('?')[0];
            const retryCount = retryLimits.get(retryKey) || 0;
            if (retryCount >= retries) {
                logEvent('error', `Retry limit reached for ${url}. Using mock response.`, { endpoint: url });
                return { ok: true, json: async () => mockResponses[new URL(url).pathname] || { error: 'No mock response available' } };
            }
            if (isOffline) {
                return { ok: true, json: async () => mockResponses[new URL(url).pathname] || { error: 'No mock response available' } };
            }
            for (let i = 0; i < retries; i++) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 10000);
                    const response = await fetch(url, { ...options, signal: controller.signal });
                    clearTimeout(timeoutId);
                    if (response.ok) {
                        retryLimits.set(retryKey, 0);
                        return response;
                    }
                    const rawText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${rawText.slice(0, 100)}...`);
                } catch (error) {
                    if (error.name === 'AbortError') {
                        error.message = `Request timed out after 10s for ${url}`;
                    } else if (error.message.includes('NetworkError') || error.message.includes('Failed to fetch')) {
                        error.message = `Unable to connect to ${url}. Ensure server is running on ports 8000-8007.`;
                    }
                    if (i === retries - 1) {
                        retryLimits.set(retryKey, retryCount + 1);
                        logEvent('error', `Fetch failed: ${error.message}`, { error: error.stack, endpoint: url, rawResponse: error.message });
                        return { ok: true, json: async () => mockResponses[new URL(url).pathname] || { error: 'No mock response available' } };
                    }
                    await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));
                }
            }
        }

        async function checkBackendStatus() {
            try {
                const response = await fetchWithRetry(`${API_BASE}/api/health`, { method: 'GET' });
                const text = await response.text();
                let data;
                try {
                    data = JSON.parse(text);
                } catch (e) {
                    throw new Error(`Invalid JSON response: ${e.message}. Raw: ${text.slice(0, 100)}...`);
                }
                if (data.status !== 'healthy') throw new Error(`Backend unhealthy: ${JSON.stringify(data)}`);
                logEvent('system', `Backend online at ${API_BASE}`, { endpoint: `${API_BASE}/api/health` });
                return true;
            } catch (error) {
                logEvent('error', `Backend offline: ${error.message}`, { error: error.stack, endpoint: `${API_BASE}/api/health`, rawResponse: error.message });
                return false;
            }
        }

        async function testConnection() {
            const configInput = document.getElementById('config-input');
            let testUrl = configInput.value.trim();
            try {
                testUrl = testUrl.endsWith('/api') ? testUrl : `${testUrl.replace(/\/$/, '')}/api`;
                new URL(testUrl);
                const response = await fetchWithRetry(`${testUrl}/api/health`, { method: 'GET' });
                const text = await response.text();
                let data;
                try {
                    data = JSON.parse(text);
                } catch (e) {
                    throw new Error(`Invalid JSON response: ${e.message}. Raw: ${text.slice(0, 100)}...`);
                }
                if (data.status === 'healthy') {
                    showErrorNotification(`Connection successful to ${testUrl}! Save to continue.`, true);
                    logEvent('system', `Connection test successful to ${testUrl}`, { endpoint: `${testUrl}/api/health` });
                } else {
                    throw new Error(`Backend unhealthy: ${JSON.stringify(data)}`);
                }
            } catch (error) {
                showErrorNotification(`Connection failed: ${error.message}. Run: curl ${testUrl}/api/health or check services on ports 8000-8007.`);
                logEvent('error', `Connection test failed: ${error.message}`, { error: error.stack, endpoint: `${testUrl}/api/health`, rawResponse: error.message });
            }
        }

        async function authenticate() {
            try {
                const isBackendOnline = await checkBackendStatus();
                if (!isBackendOnline) {
                    isOffline = true;
                    showConfigPopup(true);
                    logEvent('error', `Backend offline at ${API_BASE}. Please configure and test connection.`, { endpoint: `${API_BASE}/api/health` });
                } else {
                    const isOnline = confirm('Authenticate in online mode? Cancel for offline mode.');
                    isOffline = !isOnline;
                }
                if (!isOffline) {
                    const response = await fetchWithRetry(`${API_BASE}/api/auth/login`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ userId: userId || `user-${crypto.randomUUID()}` })
                    });
                    const text = await response.text();
                    let data;
                    try {
                        data = JSON.parse(text);
                    } catch (e) {
                        throw new Error(`Invalid JSON response: ${e.message}. Raw: ${text.slice(0, 100)}...`);
                    }
                    apiKey = data.apiKey;
                    userId = data.userId || userId || `user-${crypto.randomUUID()}`;
                    wallet = { address: data.walletAddress, balance: 0, hash: data.walletHash, webxos: 0.0, transactions: [] };
                } else {
                    apiKey = `OFFLINE-${crypto.randomUUID()}`;
                    userId = userId || `user-${crypto.randomUUID()}`;
                    wallet = { address: 'mock-wallet', balance: 0, hash: 'mock-hash', webxos: 0.0, transactions: [] };
                }
                localStorage.setItem('apiKey', apiKey);
                localStorage.setItem('userId', userId);
                isAuthenticated = true;
                logEvent('system', `Authenticated ${isOffline ? 'offline' : 'online'} with API key: ${apiKey}`);
                ['quantumLinkButton', 'exportButton', 'importButton', 'apiAccessButton'].forEach(id => {
                    document.getElementById(id).disabled = isOffline;
                });
                document.getElementById('authButton').classList.add('active-monitor');
                updateBalanceDisplay();
                updateVialStatusBars();
                if (!isOffline) {
                    await fetchWithRetry(`${API_BASE}/api/wallet/create`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({ userId, ...wallet })
                    });
                }
            } catch (error) {
                isOffline = true;
                apiKey = `OFFLINE-${crypto.randomUUID()}`;
                userId = userId || `user-${crypto.randomUUID()}`;
                localStorage.setItem('apiKey', apiKey);
                localStorage.setItem('userId', userId);
                wallet = { address: 'mock-wallet', balance: 0, hash: 'mock-hash', webxos: 0.0, transactions: [] };
                isAuthenticated = true;
                logEvent('error', `Authentication failed: ${error.message}`, { error: error.stack, endpoint: `${API_BASE}/api/auth/login`, rawResponse: error.message });
                showErrorNotification(`Authentication failed: ${error.message}. Check connection in Config or try http://localhost:8001/api/health.`);
                disableFunctions();
                showConfigPopup(true);
            }
        }

        async function retryAuthentication() {
            if (!userId || apiKey.startsWith('OFFLINE-')) return;
            try {
                const response = await fetchWithRetry(`${API_BASE}/api/auth/login`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ userId })
                });
                const text = await response.text();
                let data;
                try {
                    data = JSON.parse(text);
                } catch (e) {
                    throw new Error(`Invalid JSON response: ${e.message}. Raw: ${text.slice(0, 100)}...`);
                }
                apiKey = data.apiKey;
                localStorage.setItem('apiKey', apiKey);
                isOffline = false;
                logEvent('system', `Re-authenticated with API key: ${apiKey}`);
                updateBalanceDisplay();
                updateVialStatusBars();
                ['quantumLinkButton', 'exportButton', 'importButton', 'apiAccessButton'].forEach(id => {
                    document.getElementById(id).disabled = false;
                });
            } catch (error) {
                logEvent('error', `Periodic authentication retry failed: ${error.message}`, { error: error.stack, endpoint: `${API_BASE}/api/auth/login`, rawResponse: error.message });
            }
        }

        function disableFunctions() {
            ['quantumLinkButton', 'exportButton', 'importButton', 'apiAccessButton'].forEach(id => {
                document.getElementById(id).disabled = true;
            });
            document.getElementById('authButton').classList.remove('active-monitor');
            updateBalanceDisplay();
            updateVialStatusBars();
        }

        async function voidVials() {
            try {
                if (!isOffline) {
                    await fetchWithRetry(`${API_BASE}/api/vials/void`, {
                        method: 'DELETE',
                        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` }
                    });
                }
                vials.forEach(vial => {
                    vial.status = 'stopped';
                    vial.tasks = [];
                    vial.config = {};
                    vial.code = '';
                    vial.codeLength = 0;
                });
                logEvent('command', mockResponses['/api/vials/void'].status);
                updateVialStatusBars();
            } catch (error) {
                logEvent('error', `Void failed: ${error.message}`, { error: error.stack, endpoint: `${API_BASE}/api/vials/void`, rawResponse: error.message });
            }
        }

        async function troubleshoot() {
            try {
                logEvent('command', 'Running diagnostics...');
                logEvent('command', `Version: ${version}`);
                logEvent('command', `Vials: ${vials.length}`);
                logEvent('command', `Authenticated: ${isAuthenticated ? 'Yes' : 'No'} (${isOffline ? 'Offline' : 'Online'})`);
                logEvent('command', `API Key: ${apiKey || 'None'}`);
                logEvent('command', `API Base URL: ${API_BASE}`);
                logEvent('command', `$WEBXOS Balance: ${isOffline ? 'N/A' : wallet.webxos.toFixed(4)}`);
                logEvent('command', `Reputation: ${isOffline ? 'N/A' : reputation}`);
                logEvent('command', `Wallet Transactions: ${wallet.transactions.length}`);
                logEvent('command', 'Testing connectivity to ports 8000-8007...');
                for (let port = 8000; port <= 8007; port++) {
                    try {
                        const response = await fetchWithRetry(`http://localhost:${port}/api/health`, { method: 'GET' });
                        const text = await response.text();
                        let data;
                        try {
                            data = JSON.parse(text);
                        } catch (e) {
                            throw new Error(`Invalid JSON response: ${e.message}. Raw: ${text.slice(0, 100)}...`);
                        }
                        logEvent('command', `Port ${port}: ${data.status} (Mongo: ${data.mongo}, Services: ${data.services.join(', ')})`);
                    } catch (error) {
                        logEvent('error', `Port ${port} unreachable: ${error.message}`, { error: error.stack, endpoint: `http://localhost:${port}/api/health`, rawResponse: error.message });
                    }
                }
            } catch (error) {
                logEvent('error', `Diagnostics failed: ${error.message}`, { error: error.stack, endpoint: `${API_BASE}/api/health`, rawResponse: error.message });
                showConfigPopup(true);
            }
        }

        async function quantumLink() {
            try {
                if (!isAuthenticated) throw new Error('Authenticate first');
                if (isOffline) {
                    const mockData = mockResponses['/api/quantum/link'];
                    vials.forEach((vial, i) => {
                        vial.status = mockData.statuses[i] || 'running';
                        vial.latency = mockData.latencies[i] || 50;
                    });
                    logEvent('command', 'Offline mode: Quantum Link established.');
                    updateVialStatusBars();
                    return;
                }
                const response = await fetchWithRetry(`${API_BASE}/api/quantum/link`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({ vials: vials.map(v => v.id) })
                });
                const text = await response.text();
                let data;
                try {
                    data = JSON.parse(text);
                } catch (e) {
                    throw new Error(`Invalid JSON response: ${e.message}. Raw: ${text.slice(0, 100)}...`);
                }
                vials.forEach((vial, i) => {
                    vial.status = data.statuses[i] || 'running';
                    vial.latency = data.latencies[i] || Math.floor(Math.random() * (200 - 50 + 1)) + 50;
                });
                logEvent('command', 'Quantum Link established.');
                updateVialStatusBars();
            } catch (error) {
                logEvent('error', `Quantum Link failed: ${error.message}`, { error: error.stack, endpoint: `${API_BASE}/api/quantum/link`, rawResponse: error.message });
            }
        }

        async function exportWallet() {
            try {
                if (!isAuthenticated) throw new Error('Authenticate first');
                const data = {
                    markdown: `# WebXOS Vial Wallet Export\n\n## Wallet\n- Address: ${wallet.address || 'none'}\n- Balance: ${wallet.webxos.toFixed(4)} $WEBXOS\n- Hash: ${wallet.hash || 'none'}\n- Transactions: ${JSON.stringify(wallet.transactions, null, 2).replace(/\n/g, '\n  ')}\n`
                };
                const blob = new Blob([data.markdown], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `vial_wallet_export_${new Date().toISOString().replace(/[:.]/g, '-')}.md`;
                a.click();
                URL.revokeObjectURL(url);
                const blockHash = await addToBlockchain('export', { wallet: wallet.address });
                logEvent('command', 'Wallet exported.', { blockHash });
                wallet.transactions.push({ type: 'export', timestamp: new Date().toISOString() });
                wallet.webxos += 0.0001;
                if (!isOffline) {
                    await fetchWithRetry(`${API_BASE}/api/wallet/transaction`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({ userId, ...wallet })
                    });
                }
                updateBalanceDisplay();
            } catch (error) {
                logEvent('error', `Export failed: ${error.message}`, { error: error.stack, endpoint: `${API_BASE}/api/wallet/transaction`, rawResponse: error.message });
            }
        }

        async function importWallet() {
            try {
                if (!isAuthenticated) throw new Error('Authenticate first');
                const input = document.getElementById('file-input');
                input.onchange = async function(event) {
                    const file = event.target.files[0];
                    if (!file) return;
                    if (!file.name.endsWith('.md')) throw new Error('Invalid file: Use .md');
                    const text = await file.text();
                    if (!validateMarkdown(text)) throw new Error('Invalid Markdown format');
                    const lines = text.split('\n');
                    let newWallet = { address: null, balance: 0, hash: null, webxos: 0.0, transactions: [] };
                    for (let line of lines) {
                        if (line.match(/^- Address: ([\w-]+)/)) {
                            newWallet.address = line.match(/^- Address: ([\w-]+)/)[1];
                        } else if (line.match(/^- Balance: ([\d.]+) \$WEBXOS/)) {
                            newWallet.webxos = parseFloat(line.match(/^- Balance: ([\d.]+) \$WEBXOS/)[1]) || 0;
                        } else if (line.match(/^- Hash: ([0-9a-f]{64})/)) {
                            newWallet.hash = line.match(/^- Hash: ([0-9a-f]{64})/)[1];
                        } else if (line.match(/^- Transactions: (.*)/)) {
                            try {
                                const transactionData = line.match(/^- Transactions: (.*)/)[1];
                                newWallet.transactions = transactionData ? JSON.parse(transactionData) : [];
                            } catch (err) {
                                throw new Error(`Invalid transactions: ${err.message}`);
                            }
                        }
                    }
                    if (!newWallet.address || !newWallet.hash) throw new Error('Missing wallet address or hash');
                    wallet = newWallet;
                    if (!isOffline) {
                        await fetchWithRetry(`${API_BASE}/api/wallet/import`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${apiKey}`
                            },
                            body: JSON.stringify({ userId, ...wallet })
                        });
                    }
                    const blockHash = await addToBlockchain('import', { wallet: wallet.address });
                    logEvent('command', `Imported wallet from ${file.name}.`, { blockHash });
                    wallet.transactions.push({ type: 'import', file: file.name, timestamp: new Date().toISOString() });
                    wallet.webxos += 0.0001;
                    if (!isOffline) {
                        await fetchWithRetry(`${API_BASE}/api/wallet/transaction`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${apiKey}`
                            },
                            body: JSON.stringify({ userId, ...wallet })
                        });
                    }
                    updateBalanceDisplay();
                    input.value = '';
                };
                input.click();
            } catch (error) {
                logEvent('error', `Import failed: ${error.message}`, { error: error.stack, endpoint: `${API_BASE}/api/wallet/import`, rawResponse: error.message });
                showErrorNotification(`Import failed: ${error.message}`);
            }
        }

        async function showApiCredentials() {
            try {
                const apiInput = document.getElementById('api-input');
                apiInput.value = isOffline ? 'Offline Mode: No API key available' : `Key: ${apiKey}`;
                document.getElementById('api-popup').classList.add('visible');
            } catch (error) {
                logEvent('error', `API credentials error: ${error.message}`, { error: error.stack });
            }
        }

        async function generateNewApiCredentials() {
            try {
                if (isOffline) throw new Error('Cannot generate credentials offline');
                const response = await fetchWithRetry(`${API_BASE}/api/auth/api-key/generate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ userId })
                });
                const text = await response.text();
                let data;
                try {
                    data = JSON.parse(text);
                } catch (e) {
                    throw new Error(`Invalid JSON response: ${e.message}. Raw: ${text.slice(0, 100)}...`);
                }
                apiKey = data.apiKey;
                localStorage.setItem('apiKey', apiKey);
                document.getElementById('api-input').value = `Key: ${apiKey}`;
                const blockHash = await addToBlockchain('api_generate', { key: apiKey });
                logEvent('command', 'New API credentials generated.', { blockHash });
            } catch (error) {
                logEvent('error', `Credentials generation failed: ${error.message}`, { error: error.stack, endpoint: `${API_BASE}/api/auth/api-key/generate`, rawResponse: error.message });
                showErrorNotification(`Credentials generation failed: ${error.message}`);
            }
        }

        async function addToBlockchain(type, data) {
            if (isOffline && type !== 'import' && type !== 'export') return null;
            try {
                const timestamp = new Date().toISOString();
                const hash = await sha256(`${type}${JSON.stringify(data, null, 0)}${timestamp}`);
                const block = { type, data, timestamp, hash };
                if (!isOffline) {
                    await fetchWithRetry(`${API_BASE}/api/blockchain/transaction`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(block)
                    });
                }
                return hash;
            } catch (error) {
                logEvent('error', `Blockchain error: ${error.message}`, { error: error.stack, endpoint: `${API_BASE}/api/blockchain/transaction`, rawResponse: error.message });
                return null;
            }
        }

        async function sha256(data) {
            try {
                const encoded = new TextEncoder().encode(data);
                const hash = await crypto.subtle.digest('SHA-256', encoded);
                return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join('');
            } catch (error) {
                logEvent('error', `Hashing failed: ${error.message}`, { error: error.stack });
                return null;
            }
        }

        function sanitizeInput(input) {
            return input.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
                       .replace(/[<>{}]/g, '');
        }

        function validateMarkdown(mdContent) {
            const isValid = mdContent.includes('## Wallet') && !mdContent.includes('<script');
            if (!isValid) logEvent('error', 'Invalid Markdown: Missing wallet section or contains script tags.', {});
            return isValid;
        }

        function showConfigPopup(forceOnError = false) {
            const configPopup = document.getElementById('config-popup');
            const configInput = document.getElementById('config-input');
            configInput.value = API_BASE;
            configPopup.classList.add('visible');
            if (forceOnError) {
                showErrorNotification(`Backend unreachable at ${API_BASE}. Configure and test connection.`);
            }
        }

        async function saveConfig() {
            const configInput = document.getElementById('config-input');
            let newApiBase = configInput.value.trim();
            if (!newApiBase) {
                showErrorNotification('Backend URL cannot be empty');
                return;
            }
            try {
                newApiBase = newApiBase.endsWith('/api') ? newApiBase : `${newApiBase.replace(/\/$/, '')}/api`;
                new URL(newApiBase);
                if (!newApiBase.match(/^http:\/\/[a-zA-Z0-9.-]+:[0-9]+\/api$/)) {
                    throw new Error('Invalid URL format. Use http://hostname:port/api');
                }
            } catch (e) {
                showErrorNotification(`Invalid URL: ${e.message}. Use http://localhost:8000/api or similar.`);
                return;
            }
            API_BASE = newApiBase;
            localStorage.setItem('apiBase', API_BASE);
            logEvent('command', `Backend URL set to ${API_BASE}`);
            document.getElementById('config-popup').classList.remove('visible');
            isOffline = !(await checkBackendStatus());
            if (isOffline) {
                showConfigPopup(true);
            } else if (isAuthenticated) {
                await authenticate();
            }
            updateBalanceDisplay();
            updateVialStatusBars();
            if (isOffline) disableFunctions();
        }

        function showErrorNotification(message, isSuccess = false) {
            const errorNotification = document.getElementById('error-notification');
            errorNotification.classList.remove('success');
            if (isSuccess) errorNotification.classList.add('success');
            errorNotification.textContent = message.includes('NetworkError') || message.includes('Unable to connect') ?
                `${message} Run: curl ${API_BASE}/api/health or check services on ports 8000-8007.` :
                message.includes('JSON') ?
                `${message} Check ${API_BASE}/api/health in a browser or run: curl ${API_BASE}/api/health` :
                message;
            errorNotification.classList.add('visible');
            setTimeout(() => errorNotification.classList.remove('visible'), 10000);
        }

        function debounce(func, wait) {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func(...args), wait);
            };
        }

        const debouncedUpdateConsole = debounce(() => {
            const consoleDiv = document.getElementById('console');
            consoleDiv.innerHTML = logQueue.join('');
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }, 100);

        function logEvent(event_type, message, metadata = {}) {
            const now = Date.now();
            const logId = ++lastLogId;
            const key = `${event_type}:${message.split(' ').slice(0, 5).join(' ')}`;
            if (errorCooldowns.has(key) && (now - errorCooldowns.get(key)) < 30000) return;
            errorCooldowns.set(key, now);
            const timestamp = new Date().toISOString();
            const formattedMessage = `[${timestamp}] ${message} [ID:${logId}]`;
            logQueue.push(`<p class="${event_type === 'error' ? 'error' : 'command'}">${formattedMessage}</p>`);
            if (logQueue.length > 50) logQueue.shift();
            debouncedUpdateConsole();
            if (event_type === 'error') logErrorToBackend(message, metadata.error || 'No stack trace', metadata.endpoint || 'unknown', metadata.rawResponse || '');
            console.log(`${event_type}: ${message}`, metadata);
        }

        function updateVialStatusBars() {
            const vialStatusBars = document.getElementById('vial-status-bars');
            vials.forEach(vial => {
                vial.latency = isOffline ? 0 : Math.floor(Math.random() * (200 - 50 + 1)) + 50;
            });
            vialStatusBars.innerHTML = vials.map(vial => {
                const mode = isOffline ? 'Offline' : 'Online';
                const statusClass = vial.status === 'stopped' ? 'offline-grey' : isOffline ? 'offline-grey' : 'online';
                const fillClass = vial.status === 'running' ? '' : 'offline-grey';
                return `
                    <div class="progress-container">
                        <span class="progress-label">${vial.id}</span>
                        <div class="progress-bar">
                            <div class="progress-fill ${fillClass}" style="width: ${vial.status === 'running' ? '100%' : '0%'};"></div>
                        </div>
                        <span class="status-text ${statusClass}">Latency: ${vial.latency}ms | Size: ${vial.codeLength} bytes | Mode: ${mode}</span>
                    </div>
                `;
            }).join('');
            document.querySelector('footer').textContent = `WebXOS Vial MCP Controller | ${isOffline ? 'Offline' : 'Online'} Mode | 2025 | v${version}`;
        }

        function updateBalanceDisplay() {
            const balanceIndex = logQueue.findIndex(log => log.includes('$WEBXOS Balance'));
            const displayBalance = isOffline ? 'N/A (Offline)' : wallet.webxos.toFixed(4);
            const displayReputation = isOffline ? 'N/A (Offline)' : reputation;
            if (balanceIndex !== -1) {
                logQueue[balanceIndex] = `<p class="balance">$WEBXOS Balance: ${displayBalance} | Reputation: ${displayReputation}</p>`;
            } else {
                logQueue.push(`<p class="balance">$WEBXOS Balance: ${displayBalance} | Reputation: ${displayReputation}</p>`);
            }
            if (logQueue.length > 50) logQueue.shift();
            debouncedUpdateConsole();
        }

        async function handleGitCommand(command) {
            if (!isAuthenticated) {
                showErrorNotification('Please authenticate first');
                logEvent('error', 'Not authenticated');
                return;
            }
            const sanitizedCommand = sanitizeInput(command.trim());
            const parts = sanitizedCommand.split(' ');
            const cmd = parts[0].toLowerCase();
            const blockHash = await addToBlockchain('command', { command: sanitizedCommand });

            try {
                if (cmd === '/help') {
                    logEvent('command', `Available commands:
- /prompt <vial> <text>: Send prompt to vial
- /task <vial> <task>: Assign task to vial
- /config <vial> <key> <value>: Set vial config
- /status: Show vial statuses
- /auth <userId>: Authenticate with user ID
- /wallet create: Create a wallet
- /wallet import: Import a wallet
- /monitor: Toggle vial monitoring
- /train: Toggle vial training
- /reset: Reset all vials`, { blockHash });
                } else if (cmd === '/prompt') {
                    if (parts.length < 3) throw new Error('Usage: /prompt <vial> <text>');
                    const vialId = parts[1];
                    const promptText = parts.slice(2).join(' ');
                    const vial = vials.find(v => v.id === vialId);
                    if (!vial) throw new Error(`Invalid vial: ${vialId}`);
                    if (promptText.match(/(system|admin|root|eval|exec)/i)) throw new Error('Restricted keywords in prompt');
                    vial.tasks.push({ prompt: promptText, hash: blockHash });
                    vial.status = 'running';
                    logEvent('command', `Prompt sent to ${vialId}: ${promptText}`, { blockHash });
                    if (!isOffline) await sendPromptToBackend(vialId, promptText, blockHash);
                    else logEvent('command', `Offline mode: ${mockResponses[`/api/vials/${vialId}/prompt`].response}`, { blockHash });
                } else if (cmd === '/task') {
                    if (parts.length < 3) throw new Error('Usage: /task <vial> <task>');
                    const vialId = parts[1];
                    const task = parts.slice(2).join(' ');
                    const vial = vials.find(v => v.id === vialId);
                    if (!vial) throw new Error(`Invalid vial: ${vialId}`);
                    vial.tasks = [...new Set([...vial.tasks, task])];
                    vial.status = 'running';
                    logEvent('command', `Task assigned to ${vialId}: ${task}`, { blockHash });
                    if (!isOffline) await sendTaskToBackend(vialId, task, blockHash);
                    else logEvent('command', `Offline mode: ${mockResponses[`/api/vials/${vialId}/task`].status}`, { blockHash });
                } else if (cmd === '/config') {
                    if (parts.length < 4) throw new Error('Usage: /config <vial> <key> <value>');
                    const vialId = parts[1];
                    const key = parts[2];
                    const value = parts.slice(3).join(' ');
                    const vial = vials.find(v => v.id === vialId);
                    if (!vial) throw new Error(`Invalid vial: ${vialId}`);
                    vial.config = { ...vial.config, [key]: value };
                    vial.status = 'running';
                    logEvent('command', `Config set for ${vialId}: ${key}=${value}`, { blockHash });
                    if (!isOffline) await setConfigToBackend(vialId, key, value, blockHash);
                    else logEvent('command', `Offline mode: ${mockResponses[`/api/vials/${vialId}/config`].status}`, { blockHash });
                } else if (cmd === '/status') {
                    const status = vials.map(v => `${v.id}: ${v.status}, Tasks: ${v.tasks.join(', ') || 'none'}`).join('\n');
                    logEvent('command', `Vial Status:\n${status}`, { blockHash });
                } else if (cmd === '/auth') {
                    if (parts.length < 2) throw new Error('Usage: /auth <userId>');
                    userId = parts[1];
                    await authenticate();
                } else if (cmd === '/wallet') {
                    if (parts[1] === 'create') {
                        await fetchWithRetry(`${API_BASE}/api/wallet/create`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${apiKey}`
                            },
                            body: JSON.stringify({ userId, address: 'mock-wallet', balance: 0, hash: 'mock-hash', webxos: 0.0 })
                        }).then(response => response.json()).then(data => {
                            logEvent('command', data.status, { blockHash });
                            updateBalanceDisplay();
                        }).catch(() => logEvent('error', 'Wallet creation failed, using offline mode', { blockHash }));
                    } else if (parts[1] === 'import') {
                        await importWallet();
                    } else {
                        throw new Error('Usage: /wallet create or /wallet import');
                    }
                } else if (cmd === '/monitor') {
                    await monitorVials();
                } else if (cmd === '/train') {
                    await trainVials();
                } else if (cmd === '/reset') {
                    await voidVials();
                } else {
                    throw new Error(`Unknown command: ${cmd}. Use /help`);
                }
                updateVialStatusBars();
            } catch (error) {
                showErrorNotification(error.message);
                logEvent('error', error.message, { error: error.stack, command: sanitizedCommand });
            }
        }

        async function sendPromptToBackend(vialId, prompt, blockHash) {
            try {
                const response = await fetchWithRetry(`${API_BASE}/api/vials/${vialId}/prompt`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({ vialId, prompt, blockHash })
                });
                const text = await response.text();
                let data;
                try {
                    data = JSON.parse(text);
                } catch (e) {
                    throw new Error(`Invalid JSON response: ${e.message}. Raw: ${text.slice(0, 100)}...`);
                }
                logEvent('command', `Backend response for ${vialId}: ${data.response}`, { blockHash });
            } catch (error) {
                logEvent('error', `Prompt error: ${error.message}`, { error: error.stack, endpoint: `${API_BASE}/api/vials/${vialId}/prompt`, vialId, prompt, rawResponse: error.message });
            }
        }

        async function sendTaskToBackend(vialId, task, blockHash) {
            try {
                const response = await fetchWithRetry(`${API_BASE}/api/vials/${vialId}/task`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({ vialId, task, blockHash })
                });
                const text = await response.text();
                let data;
                try {
                    data = JSON.parse(text);
                } catch (e) {
                    throw new Error(`Invalid JSON response: ${e.message}. Raw: ${text.slice(0, 100)}...`);
                }
                logEvent('command', `Task assigned to ${vialId}: ${data.status}`, { blockHash });
            } catch (error) {
                logEvent('error', `Task error: ${error.message}`, { error: error.stack, endpoint: `${API_BASE}/api/vials/${vialId}/task`, vialId, task, rawResponse: error.message });
            }
        }

        async function setConfigToBackend(vialId, key, value, blockHash) {
            try {
                const response = await fetchWithRetry(`${API_BASE}/api/vials/${vialId}/config`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({ vialId, key, value, blockHash })
                });
                const text = await response.text();
                let data;
                try {
                    data = JSON.parse(text);
                } catch (e) {
                    throw new Error(`Invalid JSON response: ${e.message}. Raw: ${text.slice(0, 100)}...`);
                }
                logEvent('command', `Config updated for ${vialId}: ${key}=${value}`, { blockHash });
            } catch (error) {
                logEvent('error', `Config error: ${error.message}`, { error: error.stack, endpoint: `${API_BASE}/api/vials/${vialId}/config`, vialId, key, value, rawResponse: error.message });
            }
        }

        async function monitorVials() {
            const isMonitoring = !document.getElementById('quantumLinkButton').classList.contains('active-monitor');
            document.getElementById('quantumLinkButton').classList.toggle('active-monitor', isMonitoring);
            document.getElementById('console').classList.toggle('active-monitor', isMonitoring);
            document.body.classList.toggle('glow', isMonitoring);
            logEvent('command', `Monitoring ${isMonitoring ? 'started' : 'stopped'}`);
            if (isMonitoring) {
                vials.forEach(vial => vial.status = 'running');
                updateVialStatusBars();
                while (document.getElementById('quantumLinkButton').classList.contains('active-monitor')) {
                    try {
                        if (!isOffline) {
                            const response = await fetchWithRetry(`${API_BASE}/api/quantum/link`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${apiKey}`
                                },
                                body: JSON.stringify({ vials: vials.map(v => v.id) })
                            });
                            const text = await response.text();
                            let data;
                            try {
                                data = JSON.parse(text);
                            } catch (e) {
                                throw new Error(`Invalid JSON response: ${e.message}. Raw: ${text.slice(0, 100)}...`);
                            }
                            vials.forEach((vial, i) => {
                                vial.status = data.statuses[i] || 'running';
                                vial.latency = data.latencies[i] || Math.floor(Math.random() * (200 - 50 + 1)) + 50;
                            });
                        } else {
                            const mockData = mockResponses['/api/quantum/link'];
                            vials.forEach((vial, i) => {
                                vial.status = mockData.statuses[i] || 'running';
                                vial.latency = mockData.latencies[i] || 50;
                            });
                        }
                        updateVialStatusBars();
                    } catch (error) {
                        logEvent('error', `Monitoring failed: ${error.message}`, { error: error.stack, endpoint: `${API_BASE}/api/quantum/link`, rawResponse: error.message });
                        vials.forEach(vial => vial.status = 'stopped');
                        updateVialStatusBars();
                    }
                    await new Promise(resolve => setTimeout(resolve, 5000));
                }
            }
        }

        async function trainVials() {
            const isTraining = !document.getElementById('quantumLinkButton').classList.contains('active-train');
            document.getElementById('quantumLinkButton').classList.toggle('active-train', isTraining);
            document.getElementById('console').classList.toggle('active-train', isTraining);
            document.body.classList.toggle('train-glow', isTraining);
            logEvent('command', `Training ${isTraining ? 'started' : 'stopped'}`);
            if (isTraining) {
                vials.forEach(vial => vial.status = 'running');
                updateVialStatusBars();
                for (const vial of vials) {
                    try {
                        if (!isOffline) {
                            await fetchWithRetry(`${API_BASE}/api/vials/${vial.id}/task`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${apiKey}`
                                },
                                body: JSON.stringify({ vialId: vial.id, task: 'train', blockHash: await addToBlockchain('task', { vialId: vial.id, task: 'train' }) })
                            });
                        }
                        logEvent('command', `Offline mode: ${mockResponses[`/api/vials/${vial.id}/task`].status}`);
                    } catch (error) {
                        logEvent('error', `Training failed for ${vial.id}: ${error.message}`, { error: error.stack, endpoint: `${API_BASE}/api/vials/${vial.id}/task`, rawResponse: error.message });
                    }
                }
            }
        }

        async function initializeApp() {
            try {
                logEvent('system', 'Application initialized.');
                const isBackendOnline = await checkBackendStatus();
                isOffline = !isBackendOnline;
                if (isOffline) {
                    logEvent('system', `Backend offline at ${API_BASE}. Running in offline mode with mock responses.`);
                    showConfigPopup(true);
                    disableFunctions();
                } else {
                    logEvent('system', `Backend online at ${API_BASE}. Ready to authenticate.`);
                }
                if (apiKey && userId) {
                    logEvent('system', `Authenticated with API key: ${apiKey}`);
                    isAuthenticated = true;
                    document.getElementById('authButton').classList.add('active-monitor');
                    ['quantumLinkButton', 'exportButton', 'importButton', 'apiAccessButton'].forEach(id => {
                        document.getElementById(id).disabled = isOffline;
                    });
                    updateBalanceDisplay();
                }
                updateVialStatusBars();
                setInterval(retryAuthentication, 60000);
            } catch (error) {
                logEvent('error', `Initialization failed: ${error.message}`, { error: error.stack, endpoint: `${API_BASE}/api/health`, rawResponse: error.message });
                isOffline = true;
                showConfigPopup(true);
                disableFunctions();
            }
        }

        document.getElementById('prompt-input').addEventListener('keypress', e => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleGitCommand(e.target.value);
                e.target.value = '';
            }
        });
        document.getElementById('authButton').addEventListener('click', authenticate);
        document.getElementById('voidButton').addEventListener('click', voidVials);
        document.getElementById('troubleshootButton').addEventListener('click', troubleshoot);
        document.getElementById('quantumLinkButton').addEventListener('click', monitorVials);
        document.getElementById('exportButton').addEventListener('click', exportWallet);
        document.getElementById('importButton').addEventListener('click', importWallet);
        document.getElementById('apiAccessButton').addEventListener('click', showApiCredentials);
        document.getElementById('configButton').addEventListener('click', () => showConfigPopup(false));
        document.getElementById('config-test').addEventListener('click', testConnection);
        document.getElementById('config-save').addEventListener('click', saveConfig);
        document.getElementById('config-close').addEventListener('click', () => {
            document.getElementById('config-popup').classList.remove('visible');
        });
        document.getElementById('api-generate').addEventListener('click', generateNewApiCredentials);
        document.getElementById('api-close').addEventListener('click', () => {
            document.getElementById('api-popup').classList.remove('visible');
        });
        window.addEventListener('load', initializeApp);
    </script>
</body>
</html>
