<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>MIRROR IDE v3.0 - BT MESH FPV TRAIN</title>
    <meta name="theme-color" content="#000000">
    <link rel="manifest" href="data:application/manifest+json,{
        \"name\": \"MIRROR IDE v3.0\",
        \"short_name\": \"MIRROR IDE\",
        \"description\": \"BT MESH FPV Drone Training Platform\",
        \"start_url\": \"./\",
        \"display\": \"fullscreen\",
        \"background_color\": \"#000000\",
        \"theme_color\": \"#000000\",
        \"icons\": [
            {
                \"src\": \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkyIiBoZWlnaHQ9IjE5MiIgdmlld0JveD0iMCAwIDE5MiAxOTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxOTIiIGhlaWdodD0iMTkyIiBmaWxsPSIjMDAwMDAwIi8+CjxwYXRoIGQ9Ik05NiAxMjhMMTI4IDk2SDY0TDEyOCA2NEw5NiAzMkw2NCA2NEgxMjhMNjQgOTZIMTI4TDk2IDEyOFoiIGZpbGw9IiMwMGZmMDAiLz4KPC9zdmc+Cg==\",
                \"sizes\": \"192x192\",
                \"type\": \"image/svg+xml\"
            }
        ]
    }">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/face_detection.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <style>
        *{margin:0;padding:0;box-sizing:border-box;font-family:'Press Start 2P',cursive;image-rendering:pixelated}
        body{background:#000;color:#0f0;overflow:hidden;height:100vh;user-select:none;-webkit-tap-highlight-color:transparent}
        #appContainer{position:relative;width:100%;height:100vh;overflow:hidden}
        .matrix-grid{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(rgba(0,255,0,0.1)1px,transparent 1px),linear-gradient(90deg,rgba(0,255,0,0.1)1px,transparent 1px);background-size:16px 16px;z-index:1;opacity:0.3}
        .crt-overlay{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(to bottom,transparent 50%,rgba(0,20,0,0.1)50%);background-size:100% 4px;z-index:5;pointer-events:none;animation:scanline 8s linear infinite}
        @keyframes scanline{0%{background-position:0 0}100%{background-position:0 100%}}
        #visualizationContainer{position:absolute;top:0;left:0;width:100%;height:100%;z-index:2}
        #ideInterface{position:absolute;top:0;left:0;width:100%;height:100%;z-index:10}
        
        /* Control Buttons - Fixed for better touch targets */
        .ctrl-btn{
            width:52px;height:52px;background:#000;border:2px solid #0f0;color:#0f0;
            font-size:7px;display:flex;align-items:center;justify-content:center;cursor:pointer;
            box-shadow:2px 2px 0 #000;transform:skew(-2deg);transition:background 0.1s,color 0.1s;
            touch-action:none; /* Changed from manipulation */
            position:relative;z-index:11
        }
        .ctrl-btn:hover,.ctrl-btn:active{background:#0f0;color:#000}
        .ctrl-btn.active{background:#0f0;color:#000}
        .ctrl-btn:disabled{opacity:0.5;cursor:not-allowed}
        #meshBtn{border-color:#0ff;color:#0ff;background:#000}
        #meshBtn.active{background:#0ff;color:#000}
        #testModeBtn{border-color:#f0f;color:#f0f;background:#000}
        #testModeBtn.active{background:#f0f;color:#000}
        #liveModeBtn{border-color:#ff0;color:#ff0;background:#000}
        #liveModeBtn.active{background:#ff0;color:#000}
        #webcamBtn{border-color:#0af;color:#0af;background:#000}
        #webcamBtn.active{background:#0af;color:#000}
        #armBtn{border-color:#f50;color:#f50;background:#000}
        #armBtn.active{background:#f50;color:#000}
        
        /* Control Containers */
        .top-controls{position:absolute;top:8px;left:50%;transform:translateX(-50%);display:flex;gap:8px;z-index:11}
        .main-controls{position:absolute;bottom:16px;left:50%;transform:translateX(-50%);display:flex;gap:8px;z-index:11}
        .mode-controls{position:absolute;bottom:80px;left:50%;transform:translateX(-50%);display:flex;gap:8px;z-index:11}
        .zoom-controls{position:absolute;top:8px;right:8px;display:flex;gap:8px;z-index:11}
        .view-controls{position:absolute;top:8px;left:8px;display:flex;gap:8px;z-index:11}
        .view-controls .ctrl-btn{width:44px;height:44px;font-size:6px}
        
        /* Emergency Button - Fixed disabled state */
        #emergencyBtn{width:68px;height:68px;background:#f00;border:4px solid #800;border-radius:0;animation:pulse-red 2s infinite}
        @keyframes pulse-red{0%,100%{box-shadow:6px 6px 0 #000,inset 3px 3px 0 #f00}50%{box-shadow:6px 6px 0 #000,inset 3px 3px 0 #f00,0 0 30px #f00}}
        #emergencyBtn.active{background:#f00;color:#fff;animation:pulse-red-fast 0.5s infinite}
        @keyframes pulse-red-fast{0%,100%{box-shadow:6px 6px 0 #000,inset 3px 3px 0 #f00,0 0 20px #f00}50%{box-shadow:6px 6px 0 #000,inset 3px 3px 0 #f00,0 0 40px #f00}}
        #emergencyBtn:disabled{opacity:0.5;cursor:not-allowed;animation:none}
        
        /* Zoom Buttons */
        .zoom-btn{width:44px;height:44px;background:#000;border:2px solid #0ff;color:#0ff;font-size:7px;cursor:pointer;box-shadow:2px 2px 0 #000;border-radius:50%;display:flex;align-items:center;justify-content:center;touch-action:none;z-index:11}
        .zoom-btn:hover,.zoom-btn:active{background:#0ff;color:#000}
        
        /* Joysticks */
        #arcadeControls{position:absolute;bottom:0;width:100%;height:150px;display:flex;justify-content:space-between;padding:0 20px;z-index:9}
        .arcade-joystick{width:100px;height:100px;position:relative}
        .joystick-base{width:100%;height:100%;background:rgba(0,30,0,0.9);border:3px solid #0f0;border-radius:50%;position:relative;box-shadow:5px 5px 0 #000,inset 2px 2px 0 #0a0}
        .joystick-stick{width:32px;height:32px;background:#0f0;border:2px solid #0a0;border-radius:50%;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);box-shadow:2px 2px 0 #000}
        
        /* Popups */
        .popup{display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,10,0,0.98);border:3px solid #0f0;padding:12px;z-index:100;box-shadow:6px 6px 0 #000,inset 2px 2px 0 #0f0;width:90%;max-width:400px;max-height:85vh;overflow-y:auto;font-size:8px;color:#0f0}
        .popup-title{font-size:10px;margin-bottom:8px;text-align:center;text-shadow:1px 1px 0 #000;color:#0ff}
        .popup-close{position:absolute;top:6px;right:6px;width:24px;height:24px;background:#000;border:2px solid #f00;color:#f00;font-size:7px;cursor:pointer;display:flex;align-items:center;justify-content:center;touch-action:none}
        .popup-close:hover,.popup-close:active{background:#f00;color:#000}
        .popup-close:focus{outline:2px solid #0ff;outline-offset:2px}
        .popup-item{margin:4px 0;display:flex;justify-content:space-between}
        .popup-btn{width:100%;margin-top:8px;padding:6px;background:#000;border:2px solid #0f0;color:#0f0;font-size:7px;cursor:pointer;text-align:center;touch-action:none}
        .popup-btn:hover,.popup-btn:active{background:#0f0;color:#000}
        .popup-btn:focus{outline:2px solid #0ff;outline-offset:2px}
        .help-icon{position:absolute;top:6px;left:6px;width:24px;height:24px;background:#000;border:2px solid #ff0;color:#ff0;font-size:7px;cursor:pointer;display:flex;align-items:center;justify-content:center;touch-action:none}
        .help-icon:hover,.help-icon:active{background:#ff0;color:#000}
        .help-icon:focus{outline:2px solid #0ff;outline-offset:2px}
        
        /* Terminal */
        #terminalPopup{width:95%;max-width:95%;height:85%;}
        #terminalLines{height:calc(100% - 60px);overflow-y:auto;font-family:'Courier New',monospace;font-size:8px;line-height:1.3;margin-bottom:8px}
        .terminal-line{padding:2px 0;border-bottom:1px solid rgba(0,255,0,0.1)}
        .terminal-success{color:#0f0}
        .terminal-error{color:#f00}
        .terminal-warning{color:#ff0}
        .terminal-prompt{color:#0ff}
        .terminal-info{color:#fff}
        #terminalInput{width:100%;background:transparent;border:none;border-top:1px solid #0f0;color:#0f0;font-family:'Courier New';font-size:8px;outline:none;margin-top:4px;padding:4px 0}
        
        /* Status */
        .status-indicator{display:inline-block;width:6px;height:6px;border-radius:0;margin-right:4px;background:#0f0;box-shadow:1px 1px 0 #000}
        .disconnected{background:#f00}
        
        /* Badges */
        .beta-badge{position:absolute;top:45px;left:50%;transform:translateX(-50%);background:rgba(255,0,255,0.9);border:2px solid #f0f;padding:3px 7px;font-size:8px;color:#000;z-index:11}
        .copyright{position:absolute;bottom:3px;right:3px;font-size:5px;color:#0f0;opacity:0.7}
        
        /* Emergency Alert */
        @keyframes emergency-alert{0%,100%{background:#f00;color:#fff}50%{background:#800;color:#ff0}}
        .emergency-alert{animation:emergency-alert .5s infinite}
        
        canvas{display:block}
        #file-input{display:none}
        
        /* HUD Warning */
        #hudWarning{position:absolute;top:20%;left:50%;transform:translate(-50%,-50%);color:#f00;font-size:12px;text-shadow:1px 1px 0 #000;z-index:11;display:none}
        
        /* Desktop Override */
        @media (min-width:768px){
            .ctrl-btn{width:56px;height:56px;font-size:8px}
            #emergencyBtn{width:72px;height:72px}
            .arcade-joystick{width:120px;height:120px}
            .joystick-stick{width:40px;height:40px}
            .view-controls .ctrl-btn{width:44px;height:44px;font-size:7px}
        }
        
        /* Mobile Optimization - Fixed touch target sizes */
        @media (max-width:767px){
            .top-controls,.main-controls,.mode-controls{gap:6px}
            .ctrl-btn{width:48px;height:48px;font-size:6px}
            #emergencyBtn{width:60px;height:60px}
            .view-controls .ctrl-btn{width:44px;height:44px;font-size:6px}
        }
        
        /* Live Mode Scene */
        .live-scene{display:none;position:absolute;top:0;left:0;width:100%;height:100%;background:#000;z-index:1}
        .live-grid{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(rgba(255,255,0,0.1)1px,transparent 1px),linear-gradient(90deg,rgba(255,255,0,0.1)1px,transparent 1px);background-size:20px 20px;opacity:0.2}
        .live-center{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#ff0;font-size:12px;text-align:center}
        
        /* SDK Textarea */
        #codeInput{resize:none;margin-top:8px;width:100%;height:100px;font-family:'Courier New';font-size:8px;color:#0f0;background:#000;border:2px solid #0f0}
        
        /* Accessibility improvements */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        
        /* Focus styles for accessibility */
        .ctrl-btn:focus, .zoom-btn:focus, .popup-btn:focus {
            outline: 2px solid #0ff;
            outline-offset: 2px;
        }
    </style>
</head>
<body>
<div id="appContainer">
    <div class="matrix-grid"></div>
    <div class="crt-overlay"></div>
    
    <!-- TEST MODE SCENE -->
    <div id="visualizationContainer"><canvas id="visualizationCanvas"></canvas></div>
    
    <!-- LIVE MODE SCENE -->
    <div class="live-scene" id="liveScene">
        <div class="live-grid"></div>
        <div class="live-center">
            LIVE MODE<br>
            <span style="font-size:8px;color:#0ff">BT MESH NETWORK ACTIVE</span>
        </div>
    </div>
    
    <div id="ideInterface">
        <div class="beta-badge">MIRROR IDE v3.0</div>
        
        <!-- VIEW CONTROLS -->
        <div class="view-controls">
            <button id="fullscreenBtn" class="ctrl-btn" aria-label="Toggle Fullscreen">
                <span class="sr-only">Toggle Fullscreen</span>FS
            </button>
            <button id="viewToggleBtn" class="ctrl-btn" aria-label="Toggle View Mode">
                <span class="sr-only">Toggle View Mode</span>FPV
            </button>
            <button id="gimbalBtn" class="ctrl-btn" aria-label="Toggle Gimbal Mode">
                <span class="sr-only">Toggle Gimbal Mode</span>GIMBAL
            </button>
        </div>
        
        <!-- TOP CONTROLS -->
        <div class="top-controls">
            <button id="guideBtn" class="ctrl-btn" aria-label="Open Guide">GUIDE</button>
            <button id="termBtn" class="ctrl-btn" aria-label="Open Terminal">TERM</button>
            <button id="loginBtn" class="ctrl-btn" aria-label="Open Status">STAT</button>
            <button id="sdkBtn" class="ctrl-btn" aria-label="Open SDK Config">SDK</button>
        </div>
        
        <!-- MODE CONTROLS -->
        <div class="mode-controls">
            <button id="testModeBtn" class="ctrl-btn test-active active" aria-label="Switch to Test Mode">TEST</button>
            <button id="liveModeBtn" class="ctrl-btn" aria-label="Switch to Live Mode">LIVE</button>
        </div>
        
        <!-- MAIN CONTROLS -->
        <div class="main-controls">
            <button id="webcamBtn" class="ctrl-btn" aria-label="Toggle Webcam">WEBCAM</button>
            <button id="armBtn" class="ctrl-btn" aria-label="Arm/Disarm Drone">ARM</button>
            <button id="meshBtn" class="ctrl-btn" aria-label="Toggle Mesh Network">MESH</button>
            <button id="emergencyBtn" class="ctrl-btn" aria-label="Emergency Stop" disabled>EMERGENCY</button>
        </div>
        
        <!-- ZOOM CONTROLS -->
        <div class="zoom-controls">
            <button id="zoomInBtn" class="zoom-btn" aria-label="Zoom In">
                <span class="sr-only">Zoom In</span>+
            </button>
            <button id="zoomOutBtn" class="zoom-btn" aria-label="Zoom Out">
                <span class="sr-only">Zoom Out</span>-
            </button>
            <button id="resetZoomBtn" class="zoom-btn" aria-label="Reset Zoom">
                <span class="sr-only">Reset Zoom</span>R
            </button>
        </div>
        
        <!-- JOYSTICKS -->
        <div id="arcadeControls">
            <div class="arcade-joystick" id="leftJoystick" aria-label="Left Joystick - Control Throttle and Yaw">
                <div class="joystick-base"><div class="joystick-stick"></div></div>
            </div>
            <div class="arcade-joystick" id="rightJoystick" aria-label="Right Joystick - Control Pitch and Roll">
                <div class="joystick-base"><div class="joystick-stick"></div></div>
            </div>
        </div>
        
        <!-- HUD -->
        <div id="hudWarning">USER MISSING</div>
        
        <div class="copyright">Â© 2025 webXOS</div>
    </div>

    <!-- GUIDE POPUP -->
    <div class="popup" id="guidePopup">
        <div class="help-icon" data-help="guide" aria-label="Guide Help">?</div>
        <div class="popup-close" aria-label="Close Guide">X</div>
        <div class="popup-title">BT MESH FPV TRAIN GUIDE</div>
        <div class="popup-item">> TEST/LIVE = MODE TOGGLE</div>
        <div class="popup-item">> MESH = BT MESH NETWORK CONTROL</div>
        <div class="popup-item">> TERMINAL = FULL DRONE CONTROL</div>
        <div class="popup-item">> CLICK = MOVE ANY OBJECT</div>
        <div class="popup-item">> EMERGENCY = RTL + LAND</div>
        <div class="popup-item">> FPV/3PV = CAMERA VIEW</div>
        <div class="popup-item">> GIMBAL = FPV FILMING MODE</div>
        <div class="popup-item">> WEBCAM = USER DEVICE CAM</div>
        <div class="popup-item">> GREEN = FRIENDLY</div>
        <div class="popup-item">> RED = HOSTILE</div>
    </div>

    <!-- TERMINAL -->
    <div class="popup" id="terminalPopup">
        <div class="help-icon" data-help="terminal" aria-label="Terminal Help">?</div>
        <div class="popup-close" aria-label="Close Terminal">X</div>
        <div class="popup-title">TERMINAL - FULL DRONE CONTROL</div>
        <div id="terminalLines">
            <div class="terminal-line terminal-success">INIT OK - TEST MODE ACTIVE</div>
            <div class="terminal-line terminal-prompt">Type 'help' for available commands</div>
        </div>
        <input type="text" id="terminalInput" placeholder="$ Enter command..." autocomplete="off" aria-label="Terminal Command Input">
    </div>

    <!-- STATUS -->
    <div class="popup" id="statusPopup">
        <div class="help-icon" data-help="status" aria-label="Status Help">?</div>
        <div class="popup-close" aria-label="Close Status">X</div>
        <div class="popup-title">STATUS</div>
        <div class="popup-item">MODE: <span id="statusMode">TEST</span></div>
        <div class="popup-item">ALT: <span id="statusAlt">3.0m</span></div>
        <div class="popup-item">BAT: <span id="statusBat">98%</span></div>
        <div class="popup-item">ARM: <span id="statusArm">NO</span></div>
        <div class="popup-item">VIEW: <span id="statusView">3PV</span></div>
        <div class="popup-item">BT MESH: <span id="statusMesh">OFF</span></div>
        <div class="popup-item">DRONES: <span id="statusDrones">1</span></div>
        <button class="popup-btn" id="exportTrain" aria-label="Export Training Data">EXPORT JSON</button>
        <button class="popup-btn" id="importTrain" aria-label="Import Training Data">IMPORT JSON</button>
    </div>

    <!-- WEBCAM -->
    <div class="popup" id="webcamPopup">
        <div class="help-icon" data-help="webcam" aria-label="Webcam Help">?</div>
        <div class="popup-close" aria-label="Close Webcam">X</div>
        <div class="popup-title">WEBCAM SYNC</div>
        <video id="webcamFeed" autoplay playsinline style="width:100%;height:200px;background:#000;border:2px solid #0f0;" aria-label="Webcam Feed"></video>
        <div id="calibStatus" style="font-size:6px;color:#ff0;margin:4px 0;">IDLE</div>
        <button class="popup-btn" id="stopWebcam" aria-label="Stop Webcam">STOP WEBCAM</button>
    </div>

    <!-- BT MESH CONTROL -->
    <div class="popup" id="meshPopup">
        <div class="help-icon" data-help="mesh" aria-label="Mesh Help">?</div>
        <div class="popup-close" aria-label="Close Mesh Control">X</div>
        <div class="popup-title">BLUETOOTH MESH NETWORK</div>
        <div style="font-size:7px;margin:8px 0;">
            <div class="popup-item">NODES: <span id="meshNodes">0</span></div>
            <div class="popup-item">CONNECTED: <span id="meshConnected">0</span></div>
            <div class="popup-item">SIGNAL: <span id="meshSignal">--</span></div>
            <div class="popup-item">DATA RATE: <span id="meshRate">--</span></div>
            <div style="font-size:6px;color:#0ff;text-align:center;margin-top:8px;">BT MESH CONNECTS ALL DRONES, SENSORS, AND USER DEVICES</div>
        </div>
        <button class="popup-btn" id="scanMesh" aria-label="Scan Mesh Devices">SCAN DEVICES</button>
        <button class="popup-btn" id="connectMesh" aria-label="Connect to Mesh">CONNECT MESH</button>
        <button class="popup-btn" id="disconnectMesh" aria-label="Disconnect from Mesh">DISCONNECT</button>
    </div>

    <!-- SDK CONFIG -->
    <div class="popup" id="sdkPopup">
        <div class="help-icon" data-help="sdk" aria-label="SDK Help">?</div>
        <div class="popup-close" aria-label="Close SDK Config">X</div>
        <div class="popup-title">ESP32 SDK CONFIG</div>
        <div class="popup-item">LANGUAGE: <span>JavaScript</span></div>
        <div class="popup-item">STATUS: <span id="sdkStatus">DISCONNECTED</span></div>
        <div class="popup-item">ESP32: <span id="sdkESPStatus">NOT DETECTED</span></div>
        <button class="popup-btn" id="connectSDK" aria-label="Connect to ESP32">CONNECT ESP32</button>
        <button class="popup-btn" id="runCode" aria-label="Run JavaScript Code">RUN CODE</button>
        <textarea id="codeInput" placeholder="Enter JavaScript code" aria-label="JavaScript Code Input"></textarea>
    </div>

    <input type="file" id="file-input" accept=".json" aria-label="Import JSON File">
</div>

<script>
    // Enhanced Service Worker with better error handling
    const swScript = `
        const CACHE_NAME = 'mirror-ide-cache-v2';
        const MAP_DATA = { friendly: [], hostile: [] };

        self.addEventListener('install', (event) => {
            self.skipWaiting();
            console.log('Service Worker: Installed');
        });

        self.addEventListener('activate', (event) => {
            self.clients.claim();
            console.log('Service Worker: Activated');
        });

        self.addEventListener('message', (event) => {
            if (!event.data || !event.data.type) {
                console.warn('Service Worker: Received invalid message');
                return;
            }

            try {
                switch (event.data.type) {
                    case 'init':
                        if (event.data.map) {
                            MAP_DATA.friendly = event.data.map.friendly || [];
                            MAP_DATA.hostile = event.data.map.hostile || [];
                        }
                        break;
                    case 'update':
                        const drone = event.data.drone;
                        const user = event.data.user;
                        const objects = event.data.objects || [];
                        
                        if (drone) {
                            const newPos = { 
                                x: drone.x + (Math.random() * 0.1 - 0.05), 
                                y: drone.y, 
                                z: drone.z + (Math.random() * 0.1 - 0.05) 
                            };
                            
                            // Simple obstacle avoidance
                            objects.forEach(obj => {
                                const dist = Math.hypot(newPos.x - obj.x, newPos.z - obj.z);
                                if (dist < 3) newPos.y += 1;
                            });
                            
                            self.clients.matchAll().then(clients => {
                                clients.forEach(client => {
                                    client.postMessage({ 
                                        type: 'position', 
                                        drone: newPos,
                                        timestamp: Date.now()
                                    });
                                });
                            });
                        }
                        break;
                    case 'accel':
                        const accel = event.data.data;
                        if (accel && typeof accel.x === 'number' && typeof accel.z === 'number') {
                            // Acceleration data processing
                            self.clients.matchAll().then(clients => {
                                clients.forEach(client => {
                                    client.postMessage({
                                        type: 'accel_update',
                                        data: accel
                                    });
                                });
                            });
                        }
                        break;
                    default:
                        console.warn('Service Worker: Unknown message type:', event.data.type);
                }
            } catch (error) {
                console.error('Service Worker: Error processing message:', error);
            }
        });

        self.addEventListener('fetch', (event) => {
            event.respondWith(
                caches.match(event.request).then(response => {
                    return response || fetch(event.request);
                })
            );
        });
    `;

    // Main Application Script with Error Handling
    const State = { LIVE: 0, TEST: 1, EMERGENCY: 2, RTL: 3 };
    let cur = State.TEST;
    let left = { x: 0, y: 0 }, right = { x: 0, y: 0 }, armed = false, testMode = true;
    let drone = new THREE.Vector3(0, 3, 0), user = new THREE.Vector3(0, 0, 0), home = new THREE.Vector3();
    let trail = [], friendly = [], hostile = [], selectedObj = null, scene, cam, ren, droneObj, userObj, clock = new THREE.Clock(), tetherLine;
    let cameraZoom = 1.0, stream = null, isFullscreen = false, isFPV = false, isGimbal = false, userDetected = true;
    let faceDetection = null, accelData = { x: 0, y: 0, z: 0 };
    let btMeshActive = false, meshNodes = [], sdkConnected = false, esp32Detected = false;
    let drones = [{ id: 'DRONE_001', position: new THREE.Vector3(0, 3, 0), active: true }];
    let currentDroneIndex = 0;
    let emergencyActive = false;
    let webcamActive = false;
    let animationId = null;
    let activeTouchPoints = new Map();
    let serviceWorkerUrl = null;
    let rtlInterval = null;
    let connectMeshTimeout = null;
    let connectSDKTimeout = null;

    const $ = s => document.querySelector(s);
    const $$ = s => document.querySelectorAll(s);

    function init() {
        try {
            init3D();
            setup();
            animate();
            setHome();
            add("INIT OK - TEST MODE ACTIVE", "success");
            setupPopups();
            generateScene();
            setupFaceDetection();
            setupAccelerometer();
            setupServiceWorker();
            add("TERMINAL READY - TYPE 'help' FOR COMMANDS", "prompt");
            
            // Set initial active states
            $('#testModeBtn').classList.add('active');
            updateEmergencyButtonState();
            
            // Add cleanup on page unload
            window.addEventListener('beforeunload', cleanup);
            
        } catch (error) {
            console.error('Initialization error:', error);
            add(`INIT FAILED: ${error.message}`, "error");
        }
    }

    function cleanup() {
        // Stop animation loop
        if (animationId) {
            cancelAnimationFrame(animationId);
        }
        
        // Stop webcam
        if (stream) {
            stopWebcam();
        }
        
        // Clear any active intervals
        if (rtlInterval) {
            clearInterval(rtlInterval);
        }
        
        if (connectMeshTimeout) {
            clearTimeout(connectMeshTimeout);
        }
        
        if (connectSDKTimeout) {
            clearTimeout(connectSDKTimeout);
        }
        
        // Clean up Three.js resources
        if (scene) {
            scene.traverse(object => {
                if (object.geometry) object.geometry.dispose();
                if (object.material) {
                    if (Array.isArray(object.material)) {
                        object.material.forEach(material => material.dispose());
                    } else {
                        object.material.dispose();
                    }
                }
            });
        }
        
        // Revoke service worker URL
        if (serviceWorkerUrl) {
            URL.revokeObjectURL(serviceWorkerUrl);
        }
    }

    function init3D() {
        try {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            cam.position.set(0, 5, 10);
            
            const canvas = $('#visualizationCanvas');
            ren = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                antialias: false, 
                powerPreference: "high-performance" 
            });
            ren.setSize(window.innerWidth, window.innerHeight);
            ren.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
            
            // Lighting
            scene.add(new THREE.AmbientLight(0x003300));
            const dir = new THREE.DirectionalLight(0x00ff00, 0.4);
            dir.position.set(5, 10, 5);
            scene.add(dir);

            // Grid
            const gridSize = 60, gridDiv = 60;
            const gridMat = new THREE.LineBasicMaterial({ color: 0x004400 });
            const gridGeo = new THREE.BufferGeometry();
            const positions = [];
            for (let i = -gridSize / 2; i <= gridSize / 2; i += gridSize / gridDiv) {
                positions.push(i, 0, -gridSize / 2, i, 0, gridSize / 2);
                positions.push(-gridSize / 2, 0, i, gridSize / 2, 0, i);
            }
            gridGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            scene.add(new THREE.LineSegments(gridGeo, gridMat));

            // Bounding box
            const boxSize = 60;
            const boxMat = new THREE.MeshBasicMaterial({ color: 0x004400, wireframe: true, side: THREE.DoubleSide });
            const boxGeo = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
            scene.add(new THREE.Mesh(boxGeo, boxMat));

            // Drone model
            const droneGroup = new THREE.Group();
            const bodyGeo = new THREE.BoxGeometry(0.8, 0.1, 0.8);
            const bodyMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
            droneGroup.add(new THREE.Mesh(bodyGeo, bodyMat));

            const armGeo = new THREE.BoxGeometry(1.2, 0.05, 0.05);
            const armMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
            const arm1 = new THREE.Mesh(armGeo, armMat); arm1.position.set(0.6, 0, 0); droneGroup.add(arm1);
            const arm2 = new THREE.Mesh(armGeo, armMat); arm2.position.set(-0.6, 0, 0); droneGroup.add(arm2);
            const arm3 = new THREE.Mesh(armGeo, armMat); arm3.rotation.y = Math.PI / 2; arm3.position.set(0, 0, 0.6); droneGroup.add(arm3);
            const arm4 = new THREE.Mesh(armGeo, armMat); arm4.rotation.y = Math.PI / 2; arm4.position.set(0, 0, -0.6); droneGroup.add(arm4);

            const propGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.02, 8);
            const propMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
            const prop1 = new THREE.Mesh(propGeo, propMat); prop1.position.set(0.6, 0.05, 0); droneGroup.add(prop1);
            const prop2 = new THREE.Mesh(propGeo, propMat); prop2.position.set(-0.6, 0.05, 0); droneGroup.add(prop2);
            const prop3 = new THREE.Mesh(propGeo, propMat); prop3.position.set(0, 0.05, 0.6); droneGroup.add(prop3);
            const prop4 = new THREE.Mesh(propGeo, propMat); prop4.position.set(0, 0.05, -0.6); droneGroup.add(prop4);

            droneObj = droneGroup;
            droneObj.position.copy(drone);
            scene.add(droneObj);

            // User object
            userObj = new THREE.Mesh(
                new THREE.BoxGeometry(1, 1, 1), 
                new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.7 })
            );
            userObj.position.copy(user);
            scene.add(userObj);

            // Tether line
            const lineGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0), 
                new THREE.Vector3(0, 0, 0)
            ]);
            const lineMat = new THREE.LineDashedMaterial({ 
                color: 0x00ffff, 
                dashSize: 0.5, 
                gapSize: 0.5 
            });
            tetherLine = new THREE.Line(lineGeo, lineMat);
            tetherLine.computeLineDistances();
            scene.add(tetherLine);

            ren.render(scene, cam);
            
        } catch (error) {
            console.error('3D initialization error:', error);
            throw new Error(`3D setup failed: ${error.message}`);
        }
    }

    function setHome() {
        home.copy(user);
    }

    function generateScene() {
        try {
            // Properly dispose of old objects
            [...friendly, ...hostile].forEach(obj => {
                if (obj && obj.geometry) obj.geometry.dispose();
                if (obj && obj.material) {
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(m => m.dispose());
                    } else {
                        obj.material.dispose();
                    }
                }
                if (obj && scene) scene.remove(obj);
            });
            
            friendly = [];
            hostile = [];

            // Create friendly objects
            for (let i = 0; i < 5; i++) {
                const obj = new THREE.Mesh(
                    new THREE.SphereGeometry(0.6, 8, 6), 
                    new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true })
                );
                obj.position.set(
                    (Math.random() - 0.5) * 50, 
                    1 + (Math.random() * 2), 
                    (Math.random() - 0.5) * 50
                );
                obj.userData = { type: 'friend', id: i, originalColor: 0x00ff00 };
                scene.add(obj);
                friendly.push(obj);
            }

            // Create hostile objects
            for (let i = 0; i < 3; i++) {
                const obj = new THREE.Mesh(
                    new THREE.BoxGeometry(0.8, 0.8, 0.8), 
                    new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true })
                );
                obj.position.set(
                    (Math.random() - 0.5) * 50, 
                    1 + (Math.random() * 3), 
                    (Math.random() - 0.5) * 50
                );
                obj.userData = { type: 'hostile', id: i, speed: 0.5 + Math.random(), originalColor: 0xff0000 };
                scene.add(obj);
                hostile.push(obj);
            }

            add("SCENE GENERATED", "success");
        } catch (error) {
            console.error('Scene generation error:', error);
            add("SCENE GENERATION FAILED", "error");
        }
    }

    function setupPopups() {
        const buttonHandlers = {
            'guideBtn': () => openPopup('guidePopup'),
            'testModeBtn': () => switchToTestMode(),
            'liveModeBtn': () => switchToLiveMode(),
            'termBtn': () => openPopup('terminalPopup'),
            'loginBtn': () => openPopup('statusPopup'),
            'webcamBtn': () => handleWebcam(),
            'stopWebcam': () => stopWebcam(),
            'emergencyBtn': () => emergencySwitch(),
            'armBtn': () => toggleArm(),
            'meshBtn': () => toggleMesh(),
            'zoomInBtn': () => zoomIn(),
            'zoomOutBtn': () => zoomOut(),
            'resetZoomBtn': () => resetView(),
            'exportTrain': () => exportTrain(),
            'importTrain': () => $('#file-input').click(),
            'fullscreenBtn': () => toggleFullscreen(),
            'viewToggleBtn': () => toggleView(),
            'gimbalBtn': () => toggleGimbal(),
            'scanMesh': () => scanMeshDevices(),
            'connectMesh': () => connectMesh(),
            'disconnectMesh': () => disconnectMesh(),
            'sdkBtn': () => openPopup('sdkPopup'),
            'connectSDK': () => connectSDK(),
            'runCode': () => runCode()
        };

        // Add event listeners to buttons - Use only click events for consistency
        Object.keys(buttonHandlers).forEach(id => {
            const element = $('#' + id);
            if (element) {
                const handler = buttonHandlers[id];
                element.addEventListener('click', handler);
            }
        });

        // Close buttons
        $$('.popup-close').forEach(button => {
            button.addEventListener('click', (e) => {
                const popup = button.closest('.popup');
                if (popup) {
                    popup.style.display = 'none';
                    if (popup.id === 'webcamPopup' && stream) {
                        stopWebcam();
                    }
                }
            });
        });

        // Help icons
        $$('.help-icon').forEach(icon => {
            icon.addEventListener('click', (e) => {
                showHelp(icon.dataset.help);
            });
        });

        // Terminal input
        $('#terminalInput').addEventListener('keydown', termIn);
        
        // File input
        $('#file-input').addEventListener('change', handleFileImport);
        
        setupClickToMove();
    }

    function handleFileImport(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const data = JSON.parse(event.target.result);
                
                // Validate JSON structure
                if (typeof data !== 'object' || data === null) {
                    throw new Error('Invalid JSON structure');
                }
                
                // Clear existing objects
                [...friendly, ...hostile].forEach(obj => {
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) obj.material.dispose();
                    scene.remove(obj);
                });
                
                friendly = [];
                hostile = [];
                
                // Import objects with validation
                if (Array.isArray(data.friendly)) {
                    data.friendly.forEach((objData, index) => {
                        if (objData && typeof objData.x === 'number' && typeof objData.y === 'number' && typeof objData.z === 'number') {
                            const obj = new THREE.Mesh(
                                new THREE.SphereGeometry(0.6, 8, 6), 
                                new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true })
                            );
                            obj.position.set(objData.x, objData.y, objData.z);
                            obj.userData = { type: 'friend', id: index, originalColor: 0x00ff00 };
                            scene.add(obj);
                            friendly.push(obj);
                        }
                    });
                }
                
                if (Array.isArray(data.hostile)) {
                    data.hostile.forEach((objData, index) => {
                        if (objData && typeof objData.x === 'number' && typeof objData.y === 'number' && typeof objData.z === 'number') {
                            const obj = new THREE.Mesh(
                                new THREE.BoxGeometry(0.8, 0.8, 0.8), 
                                new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true })
                            );
                            obj.position.set(objData.x, objData.y, objData.z);
                            obj.userData = { type: 'hostile', id: index, speed: 0.5 + Math.random(), originalColor: 0xff0000 };
                            scene.add(obj);
                            hostile.push(obj);
                        }
                    });
                }
                
                add("SCENE IMPORTED SUCCESSFULLY", "success");
            } catch (error) {
                console.error('Import error:', error);
                add("IMPORT FAILED: Invalid file format", "error");
            }
        };
        
        reader.onerror = () => {
            add("IMPORT FAILED: Could not read file", "error");
        };
        
        reader.readAsText(file);
    }

    function showHelp(topic) {
        openPopup('terminalPopup');
        const suggestions = {
            guide: "Use TEST for simulation, LIVE for BT mesh. Terminal for full drone control.",
            terminal: "Type 'help' for commands. Use for debugging and drone control.",
            status: "Monitor mode, alt, bat. Export/Import JSON for scene data.",
            webcam: "Connect webcam for face detection and accel data.",
            mesh: "Bluetooth mesh connects drones, sensors, and user devices.",
            sdk: "JavaScript SDK for ESP32-based drone control."
        };
        add(`HELP: ${suggestions[topic] || 'No help available.'}`, "prompt");
    }

    function switchToTestMode() {
        testMode = true;
        $('#visualizationContainer').style.display = 'block';
        $('#liveScene').style.display = 'none';
        $('#testModeBtn').classList.add('active');
        $('#liveModeBtn').classList.remove('active');
        $('#statusMode').textContent = 'TEST';
        add("SWITCHED TO TEST MODE", "success");
        if (btMeshActive) disconnectMesh();
    }

    function switchToLiveMode() {
        openPopup('meshPopup');
        add("OPENED MESH CONFIG FOR LIVE MODE", "prompt");
    }

    function toggleMesh() {
        if (!btMeshActive) {
            openPopup('meshPopup');
        } else {
            disconnectMesh();
        }
    }

    function toggleGimbal() {
        isGimbal = !isGimbal;
        $('#gimbalBtn').classList.toggle('active');
        if (isGimbal && armed) {
            drone.set(user.x, user.y + 5, user.z - 10);
            droneObj.position.copy(drone);
            cam.position.copy(drone);
            cam.lookAt(user);
            add("GIMBAL MODE: FPV FILMING", "success");
        } else {
            add("GIMBAL MODE OFF", "success");
        }
        $('#statusView').textContent = isGimbal ? 'GIMBAL' : isFPV ? 'FPV' : '3PV';
    }

    function scanMeshDevices() {
        add("SCANNING FOR BT MESH DEVICES...", "prompt");
        setTimeout(() => {
            meshNodes = [
                { id: 'DRONE_001', type: 'drone', signal: -45, connected: false },
                { id: 'SENSOR_001', type: 'sensor', signal: -55, connected: false },
                { id: 'USER_001', type: 'user', signal: -35, connected: false }
            ];
            $('#meshNodes').textContent = meshNodes.length;
            add(`FOUND ${meshNodes.length} MESH NODES`, "success");
        }, 1500);
    }

    function connectMesh() {
        if (meshNodes.length === 0) {
            add("NO DEVICES FOUND", "error");
            return;
        }
        
        // Clear any existing timeout
        if (connectMeshTimeout) {
            clearTimeout(connectMeshTimeout);
        }
        
        add("CONNECTING TO BT MESH...", "prompt");
        connectMeshTimeout = setTimeout(() => {
            btMeshActive = true;
            meshNodes.forEach(node => node.connected = true);
            $('#meshConnected').textContent = meshNodes.length;
            $('#meshSignal').textContent = '-35 dBm';
            $('#meshRate').textContent = '1.2 Mbps';
            $('#statusMesh').textContent = 'ON';
            $('#meshBtn').classList.add('active');
            add("BT MESH CONNECTED", "success");
            testMode = false;
            $('#visualizationContainer').style.display = 'none';
            $('#liveScene').style.display = 'block';
            $('#testModeBtn').classList.remove('active');
            $('#liveModeBtn').classList.add('active');
            $('#statusMode').textContent = 'LIVE';
            $$('.popup').forEach(p => p.style.display = 'none');
        }, 2000);
    }

    function disconnectMesh() {
        btMeshActive = false;
        meshNodes.forEach(node => node.connected = false);
        $('#meshConnected').textContent = '0';
        $('#meshSignal').textContent = '--';
        $('#meshRate').textContent = '--';
        $('#statusMesh').textContent = 'OFF';
        $('#meshBtn').classList.remove('active');
        add("BT MESH DISCONNECTED", "warning");
        switchToTestMode();
    }

    function connectSDK() {
        // Clear any existing timeout
        if (connectSDKTimeout) {
            clearTimeout(connectSDKTimeout);
        }
        
        add("CONNECTING TO ESP32...", "prompt");
        connectSDKTimeout = setTimeout(() => {
            esp32Detected = true;
            sdkConnected = true;
            $('#sdkStatus').textContent = 'CONNECTED';
            $('#sdkESPStatus').textContent = 'DETECTED';
            add("ESP32 SDK CONNECTED", "success");
        }, 1500);
    }

    function runCode() {
        if (!sdkConnected) {
            add("ESP32 NOT CONNECTED", "error");
            return;
        }
        const code = $('#codeInput').value.trim();
        if (!code) {
            add("NO CODE ENTERED", "error");
            return;
        }
        
        // Basic code validation to prevent obvious security issues
        const dangerousPatterns = [
            /eval\s*\(/,
            /Function\s*\(/,
            /setTimeout\s*\([^)]*\)/,
            /setInterval\s*\([^)]*\)/,
            /document\./,
            /window\./,
            /localStorage/,
            /sessionStorage/,
            /XMLHttpRequest/,
            /fetch\s*\(/,
            /import\s/,
            /require\s*\(/
        ];
        
        for (const pattern of dangerousPatterns) {
            if (pattern.test(code)) {
                add("CODE REJECTED: Contains potentially dangerous operations", "error");
                return;
            }
        }
        
        add("EXECUTING JAVASCRIPT CODE...", "prompt");
        setTimeout(() => {
            try {
                // Use a more secure execution environment
                const safeCode = `
                    (function(drone, user, add) {
                        "use strict";
                        ${code}
                    })
                `;
                const func = eval(safeCode);
                func(drone, user, add);
                droneObj.position.copy(drone);
                add("JAVASCRIPT EXECUTED", "success");
            } catch (e) {
                add(`CODE ERROR: ${e.message}`, "error");
            }
        }, 1000);
    }

    function toggleFullscreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => {
                add(`Fullscreen failed: ${err.message}`, "error");
            });
            isFullscreen = true;
            $('#fullscreenBtn').classList.add('active');
            add("FULLSCREEN ON", "success");
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
                isFullscreen = false;
                $('#fullscreenBtn').classList.remove('active');
                add("FULLSCREEN OFF", "success");
            }
        }
    }

    function toggleView() {
        isFPV = !isFPV;
        isGimbal = false;
        $('#viewToggleBtn').textContent = isFPV ? '3PV' : 'FPV';
        $('#viewToggleBtn').classList.toggle('active');
        $('#gimbalBtn').classList.remove('active');
        $('#statusView').textContent = isFPV ? 'FPV' : '3PV';
        add(`VIEW: ${isFPV ? 'FPV' : '3PV'}`, "success");
    }

    async function exportTrain() {
        try {
            const data = { 
                friendly: friendly.map(obj => ({ 
                    x: obj.position.x, 
                    y: obj.position.y, 
                    z: obj.position.z 
                })),
                hostile: hostile.map(obj => ({ 
                    x: obj.position.x, 
                    y: obj.position.y, 
                    z: obj.position.z 
                }))
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `scene_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            add("EXPORT OK", "success");
        } catch (error) {
            console.error('Export error:', error);
            add("EXPORT FAILED", "error");
        }
    }

    async function handleWebcam() {
        if (stream) {
            stopWebcam();
            return;
        }
        
        openPopup('webcamPopup');
        const status = $('#calibStatus');
        status.textContent = 'REQUESTING PERMISSION...';
        
        try {
            // Request camera access with proper error handling
            stream = await navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: 'user',
                    width: { ideal: 640 },
                    height: { ideal: 480 }
                } 
            });
            
            $('#webcamFeed').srcObject = stream;
            status.textContent = 'LIVE - WEBCAM ACTIVE';
            $('#webcamBtn').classList.add('active');
            webcamActive = true;
            add("WEBCAM ON", "success");
            
            // Initialize face detection if available
            if (faceDetection) {
                faceDetection.send({ image: $('#webcamFeed') });
            }
        } catch (error) {
            console.error('Webcam error:', error);
            
            // Handle specific error types
            let errorMessage = 'PERMISSION DENIED OR DEVICE NOT FOUND';
            if (error.name === 'NotAllowedError') {
                errorMessage = 'CAMERA ACCESS DENIED BY USER';
            } else if (error.name === 'NotFoundError') {
                errorMessage = 'NO CAMERA DEVICE FOUND';
            } else if (error.name === 'NotSupportedError') {
                errorMessage = 'CAMERA NOT SUPPORTED IN THIS BROWSER';
            } else if (error.name === 'NotReadableError') {
                errorMessage = 'CAMERA IS ALREADY IN USE';
            }
            
            status.textContent = errorMessage;
            add(`WEBCAM FAIL: ${errorMessage}`, "error");
            
            // Reset webcam state on failure
            stream = null;
            webcamActive = false;
            $('#webcamBtn').classList.remove('active');
        }
    }

    function stopWebcam() {
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            stream = null;
            $('#webcamFeed').srcObject = null;
            $('#webcamBtn').classList.remove('active');
            $('#calibStatus').textContent = 'WEBCAM STOPPED';
            webcamActive = false;
            add("WEBCAM OFF", "success");
        }
    }

    function setupClickToMove() {
        const canvas = $('#visualizationCanvas');
        const events = ['click', 'touchstart'];
        
        events.forEach(eventType => {
            canvas.addEventListener(eventType, (e) => {
                if (!testMode) return;
                e.preventDefault();
                
                const rect = canvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                const x = (clientX - rect.left) / rect.width * 2 - 1;
                const y = -(clientY - rect.top) / rect.height * 2 + 1;
                
                const mouse = new THREE.Vector3(x, y, 0.5);
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, cam);
                
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const position = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, position);

                const intersects = raycaster.intersectObjects([...friendly, ...hostile, droneObj, userObj]);
                if (intersects.length > 0) {
                    selectedObj = intersects[0].object;
                    selectedObj.position.copy(position);
                    add(`MOVED ${selectedObj.userData.type || 'drone'}`, "success");
                }
            });
        });
    }

    function toggleArm() {
        armed = !armed;
        $('#armBtn').classList.toggle('active');
        $('#statusArm').textContent = armed ? 'YES' : 'NO';
        add(armed ? "ARMED" : "DISARMED", armed ? "success" : "warning");
        
        // Update emergency button state
        updateEmergencyButtonState();
    }

    function updateEmergencyButtonState() {
        const emergencyBtn = $('#emergencyBtn');
        if (armed) {
            emergencyBtn.disabled = false;
            emergencyBtn.setAttribute('aria-label', 'Emergency Stop - Active');
        } else {
            emergencyBtn.disabled = true;
            emergencyBtn.setAttribute('aria-label', 'Emergency Stop - Disabled (Drone Not Armed)');
        }
    }

    function emergencySwitch() {
        if (!armed) {
            add("NOT ARMED", "error");
            return;
        }
        
        // Clear any existing RTL interval
        if (rtlInterval) {
            clearInterval(rtlInterval);
        }
        
        cur = State.EMERGENCY;
        emergencyActive = true;
        $('#emergencyBtn').classList.add('active');
        add("EMERGENCY â HOMING TO USER + LAND", "error");
        returnToHome(true);
    }

    function returnToHome(isEmergency = false) {
        // Check if drone is already at home
        if (drone.distanceTo(user) < 1.0) {
            add("DRONE ALREADY AT HOME POSITION", "warning");
            landDrone(isEmergency);
            return;
        }
        
        cur = State.RTL;
        add(isEmergency ? "EMERGENCY LAND" : "RTL", "prompt");

        const safePath = calculateSafePath();
        let step = 0;

        rtlInterval = setInterval(() => {
            if (step >= safePath.length || cur !== State.RTL) {
                landDrone(isEmergency);
                clearInterval(rtlInterval);
                return;
            }
            drone.copy(safePath[step]);
            droneObj.position.copy(drone);
            step++;
        }, 40);
    }

    function calculateSafePath() {
        const path = [];
        const currentPos = drone.clone();
        const homePos = user.clone();
        homePos.y = drone.y;

        const steps = 50;
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            const point = new THREE.Vector3();
            point.lerpVectors(currentPos, homePos, t);

            // Simple obstacle avoidance
            const nearObjects = [...friendly, ...hostile].filter(obj => 
                point.distanceTo(obj.position) < 3
            );
            if (nearObjects.length > 0) {
                point.y += 2;
            }

            path.push(point);
        }

        return path;
    }

    function landDrone(beepOnLand) {
        const landInterval = setInterval(() => {
            if (drone.y <= 0.5) {
                drone.y = 0.5;
                clearInterval(landInterval);
                cur = State.LIVE;
                add("LANDED SAFELY", "success");
                if (beepOnLand) beep();
                $('#statusMode').textContent = testMode ? 'TEST' : 'LIVE';
                // Remove emergency active state
                emergencyActive = false;
                $('#emergencyBtn').classList.remove('active');
            } else {
                drone.y -= 0.08;
            }
            droneObj.position.y = drone.y;
        }, 40);
    }

    function beep() {
        try {
            // Valid base64 encoded 1kHz beep for 1 second
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 1000;
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 1);
        } catch (error) {
            console.error('Audio error:', error);
            // Fallback: try using HTML5 Audio (though less reliable)
            try {
                const audio = new Audio();
                const source = audioContext.createOscillator();
                // This is a simplified fallback - actual implementation would need more work
                console.log('Beep sound requested');
            } catch (fallbackError) {
                console.error('Fallback audio also failed:', fallbackError);
            }
        }
    }

    function setupJoy(id, callback) {
        const joystick = $('#' + id);
        const stick = joystick.querySelector('.joystick-stick');
        const base = joystick.querySelector('.joystick-base');
        let isDragging = false;
        let activeTouchId = null;

        const updateStick = (clientX, clientY) => {
            const rect = base.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            const deltaX = clientX - centerX;
            const deltaY = clientY - centerY;
            const distance = Math.hypot(deltaX, deltaY);
            const angle = Math.atan2(deltaY, deltaX);
            
            const maxDistance = rect.width / 2 - 16;
            const constrainedDistance = Math.min(distance, maxDistance);
            
            const normalizedX = (constrainedDistance / maxDistance) * Math.cos(angle);
            const normalizedY = (constrainedDistance / maxDistance) * Math.sin(angle);
            
            stick.style.transform = `translate(calc(-50% + ${normalizedX * maxDistance}px), calc(-50% + ${normalizedY * maxDistance}px))`;
            callback(normalizedX, normalizedY);
        };

        const resetStick = () => {
            stick.style.transform = 'translate(-50%, -50%)';
            callback(0, 0);
            isDragging = false;
            activeTouchId = null;
        };

        // Mouse events
        base.addEventListener('mousedown', (e) => {
            e.preventDefault();
            isDragging = true;
            updateStick(e.clientX, e.clientY);
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                e.preventDefault();
                updateStick(e.clientX, e.clientY);
            }
        });

        document.addEventListener('mouseup', () => {
            if (isDragging) resetStick();
        });

        // Touch events with multi-touch support
        base.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (activeTouchId === null) {
                const touch = e.changedTouches[0];
                activeTouchId = touch.identifier;
                isDragging = true;
                updateStick(touch.clientX, touch.clientY);
            }
        });

        document.addEventListener('touchmove', (e) => {
            if (isDragging && activeTouchId !== null) {
                e.preventDefault();
                const touch = Array.from(e.changedTouches).find(t => t.identifier === activeTouchId);
                if (touch) {
                    updateStick(touch.clientX, touch.clientY);
                }
            }
        });

        document.addEventListener('touchend', (e) => {
            if (isDragging && activeTouchId !== null) {
                const touch = Array.from(e.changedTouches).find(t => t.identifier === activeTouchId);
                if (touch) {
                    resetStick();
                }
            }
        });

        document.addEventListener('touchcancel', () => {
            if (isDragging) resetStick();
        });
    }

    function addTrail(color = 0x00ff00) {
        // Throttle trail updates for performance
        if (trail.length > 0 && trail.length % 3 !== 0) return;
        
        if (trail.length > 120) {
            const oldSegment = trail.shift();
            scene.remove(oldSegment);
            if (oldSegment.geometry) oldSegment.geometry.dispose();
            if (oldSegment.material) oldSegment.material.dispose();
        }
        
        const segment = new THREE.Mesh(
            new THREE.SphereGeometry(0.05, 4, 3), 
            new THREE.MeshBasicMaterial({ color })
        );
        segment.position.copy(drone);
        scene.add(segment);
        trail.push(segment);
    }

    function termIn(e) {
        if (e.key === 'Enter') {
            const input = $('#terminalInput');
            const command = input.value.trim();
            if (command) {
                add(`$ ${command}`, 'prompt');
                processCommand(command);
                input.value = '';
            }
        } else if (e.key === 'Escape') {
            // Close terminal on Escape key
            $('#terminalPopup').style.display = 'none';
        }
    }

    function processCommand(cmd) {
        const parts = cmd.toLowerCase().split(' ');
        const command = parts[0];
        const args = parts.slice(1);
        
        const commands = {
            test: () => switchToTestMode(),
            live: () => switchToLiveMode(),
            arm: () => toggleArm(),
            disarm: () => {
                armed = false;
                $('#armBtn').classList.remove('active');
                $('#statusArm').textContent = 'NO';
                add("DISARMED", "warning");
                updateEmergencyButtonState();
            },
            emergency: () => emergencySwitch(),
            webcam: () => handleWebcam(),
            stopwebcam: () => stopWebcam(),
            fullscreen: () => toggleFullscreen(),
            view: () => toggleView(),
            gimbal: () => toggleGimbal(),
            sdk: () => openPopup('sdkPopup'),
            connectsdk: () => connectSDK(),
            runcode: () => runCode(),
            mesh: () => toggleMesh(),
            scan: () => scanMeshDevices(),
            connect: () => connectMesh(),
            disconnect: () => disconnectMesh(),
            takeoff: () => {
                if (!armed) {
                    add("DRONE NOT ARMED", "error");
                } else {
                    drone.y += 5;
                    droneObj.position.copy(drone);
                    add("TAKEOFF COMMAND EXECUTED", "success");
                }
            },
            land: () => {
                if (armed) {
                    returnToHome(false);
                } else {
                    add("DRONE NOT ARMED", "error");
                }
            },
            flyto: () => {
                if (args.length >= 3 && armed) {
                    const x = parseFloat(args[0]);
                    const y = parseFloat(args[1]);
                    const z = parseFloat(args[2]);
                    if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                        drone.set(x, y, z);
                        droneObj.position.copy(drone);
                        add(`FLYING TO: ${x}, ${y}, ${z}`, "success");
                    } else {
                        add("INVALID COORDINATES", "error");
                    }
                } else {
                    add("USAGE: flyto x y z", "error");
                }
            },
            adddrone: () => {
                const newDrone = { 
                    id: `DRONE_${String(drones.length + 1).padStart(3, '0')}`, 
                    position: new THREE.Vector3(
                        (Math.random() - 0.5) * 20,
                        3 + Math.random() * 5,
                        (Math.random() - 0.5) * 20
                    ), 
                    active: true 
                };
                drones.push(newDrone);
                $('#statusDrones').textContent = drones.length;
                add(`DRONE ADDED: ${newDrone.id}`, "success");
            },
            switchdrone: () => {
                if (args.length > 0) {
                    const index = parseInt(args[0]) - 1;
                    if (index >= 0 && index < drones.length) {
                        currentDroneIndex = index;
                        drone.copy(drones[index].position);
                        droneObj.position.copy(drone);
                        add(`SWITCHED TO DRONE: ${drones[index].id}`, "success");
                    } else {
                        add("INVALID DRONE INDEX", "error");
                    }
                } else {
                    add("USAGE: switchdrone [index]", "error");
                }
            },
            listdrones: () => {
                add("AVAILABLE DRONES:", "info");
                drones.forEach((drone, index) => {
                    add(`${index + 1}. ${drone.id} - POS: ${drone.position.x.toFixed(1)}, ${drone.position.y.toFixed(1)}, ${drone.position.z.toFixed(1)}`, "info");
                });
            },
            status: () => {
                add(`MODE: ${testMode ? 'TEST' : 'LIVE'}`, "info");
                add(`ARMED: ${armed ? 'YES' : 'NO'}`, "info");
                add(`ALTITUDE: ${drone.y.toFixed(1)}m`, "info");
                add(`POSITION: ${drone.x.toFixed(1)}, ${drone.y.toFixed(1)}, ${drone.z.toFixed(1)}`, "info");
                add(`BT MESH: ${btMeshActive ? 'ACTIVE' : 'INACTIVE'}`, "info");
                add(`ACTIVE DRONES: ${drones.length}`, "info");
            },
            clear: () => {
                $('#terminalLines').innerHTML = '';
            },
            help: () => {
                add("AVAILABLE COMMANDS:", "prompt");
                add("test, live - Switch modes", "info");
                add("arm, disarm - Arm/disarm drone", "info");
                add("takeoff, land - Flight commands", "info");
                add("emergency - Emergency landing", "info");
                add("flyto x y z - Fly to coordinates", "info");
                add("adddrone - Add new drone", "info");
                add("switchdrone [n] - Switch active drone", "info");
                add("listdrones - List all drones", "info");
                add("mesh, scan, connect, disconnect - BT Mesh control", "info");
                add("webcam, stopwebcam - Webcam control", "info");
                add("fullscreen, view, gimbal - UI controls", "info");
                add("sdk, connectsdk, runcode - SDK control", "info");
                add("status - System status", "info");
                add("clear - Clear terminal", "info");
                add("help - This message", "info");
            }
        };

        if (commands[command]) {
            commands[command]();
        } else {
            add(`UNKNOWN COMMAND: ${command} - Type 'help' for available commands`, "error");
        }
    }

    function openPopup(id) {
        $$('.popup').forEach(popup => popup.style.display = 'none');
        const targetPopup = $('#' + id);
        if (targetPopup) {
            targetPopup.style.display = 'block';
        }
    }

    function zoomIn() {
        cameraZoom = Math.min(3, cameraZoom + 0.1);
        cam.fov = 75 / cameraZoom;
        cam.updateProjectionMatrix();
        add("ZOOM IN", "success");
    }

    function zoomOut() {
        cameraZoom = Math.max(0.5, cameraZoom - 0.1);
        cam.fov = 75 / cameraZoom;
        cam.updateProjectionMatrix();
        add("ZOOM OUT", "success");
    }

    function resetView() {
        cameraZoom = 1.0;
        cam.fov = 75;
        cam.updateProjectionMatrix();
        isFPV = false;
        isGimbal = false;
        $('#viewToggleBtn').textContent = 'FPV';
        $('#viewToggleBtn').classList.remove('active');
        $('#gimbalBtn').classList.remove('active');
        $('#statusView').textContent = '3PV';
        cam.position.set(0, 5, 10);
        cam.lookAt(drone);
        add("VIEW RESET", "success");
    }

    function setupFaceDetection() {
        try {
            if (typeof FaceDetection !== 'undefined') {
                faceDetection = new FaceDetection({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/${file}`;
                    }
                });
                
                faceDetection.setOptions({
                    model: 'short',
                    minDetectionConfidence: 0.5
                });
                
                faceDetection.onResults((results) => {
                    userDetected = results.detections && results.detections.length > 0;
                    $('#hudWarning').style.display = userDetected ? 'none' : 'block';
                    if (!userDetected) add("USER MISSING", "error");
                });
                
                add("FACE DETECTION INITIALIZED", "success");
            } else {
                add("FACE DETECTION UNAVAILABLE", "warning");
            }
        } catch (error) {
            console.error('Face detection setup error:', error);
            add("FACE DETECTION FAILED TO INITIALIZE", "error");
        }
    }

    function setupAccelerometer() {
        if (window.DeviceMotionEvent) {
            // Request permission for iOS 13+
            if (typeof DeviceMotionEvent.requestPermission === 'function') {
                DeviceMotionEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            window.addEventListener('devicemotion', handleMotionEvent);
                            add("ACCELEROMETER ACCESS GRANTED", "success");
                        } else {
                            add("ACCELEROMETER ACCESS DENIED", "warning");
                        }
                    })
                    .catch(error => {
                        console.error('Accelerometer permission error:', error);
                        add("ACCELEROMETER PERMISSION ERROR", "error");
                    });
            } else {
                // Non-iOS devices
                window.addEventListener('devicemotion', handleMotionEvent);
            }
        } else {
            add("ACCELEROMETER NOT SUPPORTED", "warning");
        }

        function handleMotionEvent(event) {
            accelData = { 
                x: event.acceleration.x || 0, 
                y: event.acceleration.y || 0, 
                z: event.acceleration.z || 0 
            };
            
            if (btMeshActive) {
                user.x += accelData.x * 0.01;
                user.z += accelData.z * 0.01;
                userObj.position.copy(user);
                
                if (navigator.serviceWorker && navigator.serviceWorker.controller) {
                    navigator.serviceWorker.controller.postMessage({ 
                        type: 'accel', 
                        data: accelData 
                    });
                }
            }
        }
    }

    function setupServiceWorker() {
        if ('serviceWorker' in navigator) {
            try {
                const swBlob = new Blob([swScript], { type: 'application/javascript' });
                serviceWorkerUrl = URL.createObjectURL(swBlob);
                
                navigator.serviceWorker.register(serviceWorkerUrl)
                    .then((registration) => {
                        add("SERVICE WORKER REGISTERED", "success");
                        
                        // Wait for the service worker to be active
                        if (registration.active) {
                            sendInitialDataToSW(registration.active);
                        } else if (registration.installing) {
                            registration.installing.addEventListener('statechange', () => {
                                if (registration.active) {
                                    sendInitialDataToSW(registration.active);
                                }
                            });
                        }
                    })
                    .catch((error) => {
                        console.error('Service Worker registration failed:', error);
                        add(`SW REGISTRATION FAILED: ${error.message}`, "error");
                    });
                
                // Listen for messages from service worker
                navigator.serviceWorker.addEventListener('message', (event) => {
                    if (!event.data || !event.data.type) return;
                    
                    switch (event.data.type) {
                        case 'position':
                            if (event.data.drone) {
                                drone.set(event.data.drone.x, event.data.drone.y, event.data.drone.z);
                                droneObj.position.copy(drone);
                                add("POSITION UPDATED VIA BT MESH", "success");
                            }
                            break;
                        case 'accel_update':
                            // Handle accelerometer updates from service worker if needed
                            break;
                    }
                });
                
            } catch (error) {
                console.error('Service Worker setup error:', error);
                add(`SW SETUP ERROR: ${error.message}`, "error");
            }
        } else {
            add("SERVICE WORKER NOT SUPPORTED", "warning");
        }
    }

    function sendInitialDataToSW(sw) {
        if (sw) {
            sw.postMessage({ 
                type: 'init', 
                map: { 
                    friendly: friendly.map(obj => ({ 
                        x: obj.position.x, 
                        z: obj.position.z 
                    })), 
                    hostile: hostile.map(obj => ({ 
                        x: obj.position.x, 
                        z: obj.position.z 
                    })) 
                } 
            });
        }
    }

    function animate() {
        animationId = requestAnimationFrame(animate);
        const deltaTime = clock.getDelta();

        // Update hostile objects
        hostile.forEach(obj => {
            if (obj.userData && typeof obj.userData.speed === 'number') {
                obj.position.x += Math.sin(Date.now() * 0.001 + obj.userData.id) * obj.userData.speed * deltaTime;
                obj.position.z += Math.cos(Date.now() * 0.001 + obj.userData.id) * obj.userData.speed * deltaTime;
            }
        });

        // Drone movement logic
        if ((cur === State.LIVE || testMode) && armed) {
            const throttle = Math.max(0, left.y);
            const yaw = left.x;
            const pitch = right.y;
            const roll = right.x;
            
            // Vertical movement
            drone.y += throttle * deltaTime * 6;
            drone.y = Math.max(0.5, Math.min(25, drone.y));
            
            // Horizontal movement
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(droneObj.quaternion);
            const rightVec = new THREE.Vector3(1, 0, 0).applyQuaternion(droneObj.quaternion);
            
            drone.add(forward.multiplyScalar(pitch * deltaTime * 7));
            drone.add(rightVec.multiplyScalar(roll * deltaTime * 7));
            
            // Rotation
            droneObj.rotation.y -= yaw * deltaTime * 2.2;
            droneObj.rotation.x = pitch * 0.5;
            droneObj.rotation.z = -roll * 0.5;
            
            droneObj.position.copy(drone);
            addTrail(0x00ff00);

            // Send updates to service worker if BT mesh is active
            if (btMeshActive && navigator.serviceWorker && navigator.serviceWorker.controller) {
                navigator.serviceWorker.controller.postMessage({
                    type: 'update',
                    drone: { x: drone.x, y: drone.y, z: drone.z },
                    user: { x: user.x, z: user.z },
                    objects: [...friendly, ...hostile].map(obj => ({ 
                        x: obj.position.x, 
                        z: obj.position.z, 
                        type: obj.userData ? obj.userData.type : 'unknown' 
                    }))
                });
            }
        } else if (left.y === 0 && right.y === 0 && cur === State.LIVE) {
            // Return to home if no input
            const direction = new THREE.Vector3().subVectors(home, drone).normalize();
            const distance = drone.distanceTo(home);
            if (distance > 0.6) {
                drone.add(direction.multiplyScalar(Math.min(distance, 0.35)));
                droneObj.position.copy(drone);
            }
        }

        // Update tether line
        const positionArray = tetherLine.geometry.attributes.position.array;
        positionArray[0] = drone.x;
        positionArray[1] = drone.y;
        positionArray[2] = drone.z;
        positionArray[3] = user.x;
        positionArray[4] = user.y;
        positionArray[5] = user.z;
        tetherLine.geometry.attributes.position.needsUpdate = true;
        tetherLine.computeLineDistances();

        // Camera positioning
        if (isGimbal && armed) {
            cam.position.copy(drone);
            cam.lookAt(user);
        } else if (isFPV) {
            cam.position.copy(drone);
            cam.position.y += 0.2;
            cam.lookAt(user);
        } else {
            const offset = new THREE.Vector3(0, 5, 12).applyQuaternion(droneObj.quaternion);
            cam.position.lerp(drone.clone().add(offset), 0.12);
            cam.lookAt(drone);
        }

        // Update status display
        $('#statusAlt').textContent = drone.y.toFixed(1) + 'm';
        $('#statusBat').textContent = (98 - Math.floor(clock.getElapsedTime() / 60)) + '%';
        $('#statusDrones').textContent = drones.length;

        // Render scene
        ren.render(scene, cam);

        // Process face detection if webcam is active
        if (stream && faceDetection) {
            faceDetection.send({ image: $('#webcamFeed') });
        }
    }

    function add(message, type = "info") {
        const terminalLines = $('#terminalLines');
        const line = document.createElement('div');
        line.className = `terminal-line terminal-${type}`;
        line.textContent = `> ${message}`;
        terminalLines.appendChild(line);
        terminalLines.scrollTop = terminalLines.scrollHeight;
    }

    function setup() {
        setupJoy('leftJoystick', (x, y) => {
            left.x = x;
            left.y = y;
        });
        
        setupJoy('rightJoystick', (x, y) => {
            right.x = x;
            right.y = y;
        });
        
        // Use passive event listener for resize for better performance
        window.addEventListener('resize', () => {
            cam.aspect = window.innerWidth / window.innerHeight;
            cam.updateProjectionMatrix();
            ren.setSize(window.innerWidth, window.innerHeight);
        }, { passive: true });
    }

    window.addEventListener('load', init);
</script>
</body>
</html>