<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WEBXOS Crawler v2.0</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.2;
            height: 100vh;
            overflow: hidden;
        }

        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s;
        }

        .logo {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #0f0;
            white-space: pre;
            line-height: 1;
            margin-bottom: 20px;
        }

        .loading-bar {
            width: 300px;
            height: 2px;
            background: #111;
            margin-top: 10px;
        }

        .progress {
            width: 0%;
            height: 100%;
            background: #0f0;
            animation: load 2.5s ease-in-out forwards;
        }

        @keyframes load {
            0% { width: 0%; }
            100% { width: 100%; }
        }

        #terminal-container {
            display: none;
            height: 100vh;
            flex-direction: column;
        }

        #output {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            padding-bottom: 10px;
        }

        .line {
            margin-bottom: 2px;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            word-break: break-word;
        }

        .cmd { color: #0ff; }
        .response { color: #0a0; }
        .error { color: #f00; }
        .success { color: #0f0; }
        .info { color: #0af; }
        .stats { color: #080; font-size: 12px; }
        .crawling { color: #ff0; }
        .warning { color: #ff0; }

        #input-container {
            height: 40px;
            background: #000;
            border-top: 1px solid #0a0;
            display: flex;
            align-items: center;
            padding: 0 20px;
            flex-shrink: 0;
        }

        .input-line {
            display: flex;
            align-items: center;
            width: 100%;
            height: 20px;
            gap: 10px;
        }

        .prompt-indicator {
            color: #0f0;
            margin-right: 8px;
            flex-shrink: 0;
        }

        #input-display {
            flex: 1;
            position: relative;
            height: 20px;
            line-height: 20px;
        }

        .input-text {
            position: absolute;
            top: 0;
            left: 0;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            white-space: pre;
        }

        .cursor {
            position: absolute;
            top: 0;
            left: 0;
            width: 8px;
            height: 14px;
            background: #0f0;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        #hidden-input {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
            pointer-events: none;
        }

        .send-btn {
            background: transparent;
            border: 1px solid #0f0;
            color: #0f0;
            width: 32px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            border-radius: 2px;
            flex-shrink: 0;
        }

        .send-btn:hover {
            background: #0a0;
            color: #000;
        }

        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #111;
        }

        ::-webkit-scrollbar-thumb {
            background: #0a0;
        }

        /* Crawler specific styles */
        .url-link {
            color: #0ff;
            text-decoration: underline;
            cursor: pointer;
            word-break: break-all;
        }

        .url-link:hover {
            color: #0f0;
        }

        .link-item {
            margin: 3px 0;
            padding-left: 15px;
            position: relative;
        }

        .link-item::before {
            content: '├─ ';
            color: #0a0;
            position: absolute;
            left: 0;
        }

        .link-item:last-child::before {
            content: '└─ ';
        }

        .crawl-stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #0a0;
            background: #111;
        }

        .stat-item {
            text-align: center;
        }

        .stat-label {
            color: #0a0;
            font-size: 12px;
        }

        .stat-value {
            color: #0f0;
            font-size: 14px;
            font-weight: bold;
        }

        .progress-container {
            width: 100%;
            height: 4px;
            background: #111;
            margin: 10px 0;
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: #0f0;
            width: 0%;
            transition: width 0.3s;
        }

        .results-panel {
            border: 1px solid #0a0;
            margin: 10px 0;
            padding: 10px;
            background: #111;
        }

        .panel-title {
            color: #0ff;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000;
            border: 2px solid #0f0;
            z-index: 2000;
            box-shadow: 0 0 20px #0f0;
            padding: 20px;
            min-width: 500px;
            max-width: 700px;
            max-height: 80vh;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #0a0;
        }

        .modal-title {
            color: #0f0;
            font-size: 16px;
            font-weight: bold;
        }

        .modal-close {
            background: transparent;
            border: 1px solid #0f0;
            color: #0f0;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            background: #0a0;
            color: #000;
        }

        .modal-content {
            max-height: calc(80vh - 100px);
            overflow-y: auto;
        }

        .export-preview {
            width: 100%;
            height: 300px;
            background: #000;
            color: #0a0;
            border: 1px solid #0a0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            padding: 10px;
            white-space: pre-wrap;
            margin-bottom: 15px;
            overflow-y: auto;
        }

        .btn {
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 8px 15px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            flex: 1;
        }

        .btn:hover {
            background: #0a0;
            color: #000;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin: 15px 0;
        }

        .overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
        }

        .memory-warning {
            color: #ff0;
            background: rgba(255, 255, 0, 0.1);
            border: 1px solid #ff0;
            padding: 5px 10px;
            margin: 5px 0;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="logo">
  _____ ______  ___  _    _ _     
 /  __ \| ___ \/ _ \| |  | | |    
 | /  \/| |_/ / /_\ \ |  | | |    
 | |    |    /|  _  | |/\| | |    
 | \__/\| |\ \| | | \  /\  / |____
  \____/\_| \_\_| |_/\/  \/\_____/
        </div>
        <div style="color:#0a0; margin-top:10px; font-size:12px;">Initializing WEBXOS Crawler v2.0...</div>
        <div class="loading-bar"><div class="progress"></div></div>
    </div>

    <div id="terminal-container">
        <div id="output"></div>
        <div id="input-container">
            <div class="input-line">
                <span class="prompt-indicator">$</span>
                <div id="input-display">
                    <div id="input-text" class="input-text"></div>
                    <div id="cursor" class="cursor"></div>
                </div>
                <button id="send-btn" class="send-btn" title="Send (Enter)">↵</button>
            </div>
            <input type="text" id="hidden-input" autocomplete="off" spellcheck="false">
        </div>
    </div>

    <div class="overlay" id="overlay"></div>

    <div class="modal" id="export-modal">
        <div class="modal-header">
            <div class="modal-title">EXPORT CRAWL RESULTS</div>
            <button class="modal-close" onclick="closeExport()">✕</button>
        </div>
        <div class="modal-content">
            <div class="export-preview" id="export-preview"></div>
            <div class="controls">
                <button class="btn" onclick="copyExport()">COPY</button>
                <button class="btn" onclick="downloadExport()">DOWNLOAD</button>
            </div>
        </div>
    </div>

    <script>
        const WEBXOS_ASCII = `  _____ ______  ___  _    _ _     
 /  __ \\| ___ \\/ _ \\| |  | | |    
 | /  \\/| |_/ / /_\\ \\ |  | | |    
 | |    |    /|  _  | |/\\| | |    
 | \\__/\\| |\\ \\| | | \\  /\\  / |____
  \\____/\\_| \\_\\_| |_/\\/  \\/\\_____/`;

        // Constants
        const MAX_LINKS_STORED = 1000; // Memory limit
        const MAX_CONCURRENT_REQUESTS = 3;
        const DEFAULT_DELAY = 1000;

        // State
        const state = {
            history: [],
            histIndex: -1,
            inputText: '',
            cursorPosition: 0,
            isCrawling: false,
            currentCrawl: null,
            crawls: [],
            visitedUrls: new Set(),
            crawlingQueue: [],
            activeRequests: 0,
            maxDepth: 2,
            maxUrls: 100,
            backendUrl: '/api/crawl',
            delay: DEFAULT_DELAY,
            statsInterval: null,
            memoryWarningShown: false
        };

        // DOM elements
        const loading = document.getElementById('loading');
        const terminalContainer = document.getElementById('terminal-container');
        const output = document.getElementById('output');
        const inputText = document.getElementById('input-text');
        const cursor = document.getElementById('cursor');
        const hiddenInput = document.getElementById('hidden-input');
        const sendBtn = document.getElementById('send-btn');

        // Initialize
        setTimeout(() => {
            loading.style.opacity = '0';
            setTimeout(() => {
                loading.style.display = 'none';
                terminalContainer.style.display = 'flex';
                initTerminal();
            }, 500);
        }, 2500);

        async function initTerminal() {
            addLine(WEBXOS_ASCII, 'welcome');
            addLine('', 'response');
            addLine('WEBXOS CRAWLER v2.0', 'response');
            addLine('Server-side web crawler with rate limiting', 'response');
            addLine('Type /help for commands', 'response');
            addLine('', 'response');
            
            // Detect environment
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                addLine('✓ Local development mode', 'info');
                state.backendUrl = '/api/crawl';
            } else {
                addLine('✓ Production mode (Netlify)', 'info');
                state.backendUrl = '/api/crawl';
            }
            
            addLine(`Backend: ${state.backendUrl}`, 'info');
            addLine('Rate limit: 100 requests per 15 minutes', 'stats');
            addLine('Memory limit: ' + MAX_LINKS_STORED + ' links', 'stats');
            addLine('', 'response');

            // Test backend
            addLine('Testing backend connection...', 'info');
            const backendOk = await pingBackend();
            if (backendOk) {
                addLine('✓ Backend connected', 'success');
            } else {
                addLine('✗ Backend connection failed', 'error');
                addLine('Make sure backend server is running', 'warning');
            }
            addLine('', 'response');

            setupInput();
        }

        function setupInput() {
            hiddenInput.focus();
            hiddenInput.addEventListener('input', handleInput);
            hiddenInput.addEventListener('keydown', handleKey);
            sendBtn.addEventListener('click', submitCommand);
            document.addEventListener('click', () => hiddenInput.focus());
            updateDisplay();
        }

        async function submitCommand() {
            const cmd = state.inputText.trim();
            if (cmd) {
                state.history.unshift(cmd);
                state.histIndex = -1;
                addLine(`$ ${cmd}`, 'cmd');
                await process(cmd);
                state.inputText = '';
                state.cursorPosition = 0;
                hiddenInput.value = '';
                updateDisplay();
                scrollToBottom();
            }
        }

        function handleInput(e) {
            state.inputText = hiddenInput.value;
            state.cursorPosition = hiddenInput.selectionStart;
            updateDisplay();
        }

        function handleKey(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                submitCommand();
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (state.histIndex < state.history.length - 1) {
                    state.histIndex++;
                    state.inputText = state.history[state.histIndex];
                    state.cursorPosition = state.inputText.length;
                    hiddenInput.value = state.inputText;
                    updateDisplay();
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (state.histIndex > 0) {
                    state.histIndex--;
                    state.inputText = state.history[state.histIndex];
                    state.cursorPosition = state.inputText.length;
                    hiddenInput.value = state.inputText;
                    updateDisplay();
                } else {
                    state.histIndex = -1;
                    state.inputText = '';
                    state.cursorPosition = 0;
                    hiddenInput.value = '';
                    updateDisplay();
                }
            } else {
                setTimeout(() => {
                    state.cursorPosition = hiddenInput.selectionStart;
                    updateDisplay();
                }, 0);
            }
        }

        function updateDisplay() {
            inputText.textContent = state.inputText;
            const textBeforeCursor = state.inputText.substring(0, state.cursorPosition);
            
            const tempSpan = document.createElement('span');
            tempSpan.style.fontFamily = "'Courier New', monospace";
            tempSpan.style.fontSize = '14px';
            tempSpan.style.whiteSpace = 'pre';
            tempSpan.style.position = 'absolute';
            tempSpan.style.visibility = 'hidden';
            tempSpan.textContent = textBeforeCursor;
            
            document.body.appendChild(tempSpan);
            const cursorLeft = tempSpan.offsetWidth;
            document.body.removeChild(tempSpan);
            
            cursor.style.left = cursorLeft + 'px';
        }

        async function process(cmd) {
            if (cmd.startsWith('/')) {
                const parts = cmd.split(' ');
                const cmdName = parts[0].toLowerCase();
                const args = parts.slice(1).join(' ');

                switch(cmdName) {
                    case '/help': showHelp(); break;
                    case '/crawl': 
                        if (args) await startCrawl(args); 
                        else addResponse('Usage: /crawl <url> [depth] [maxUrls]', 'error');
                        break;
                    case '/stop': stopCrawl(); break;
                    case '/status': showStatus(); break;
                    case '/setbackend': 
                        if (args) await setBackend(args); 
                        else addResponse(`Current backend: ${state.backendUrl}`, 'info');
                        break;
                    case '/testbackend': await testBackend(); break;
                    case '/setdepth': 
                        const depth = parseInt(args);
                        if (!isNaN(depth) && depth >= 1 && depth <= 5) {
                            state.maxDepth = depth;
                            addResponse(`Max depth set to ${depth}`, 'success');
                        } else {
                            addResponse('Usage: /setdepth <1-5>', 'error');
                        }
                        break;
                    case '/setmax': 
                        const max = Math.min(parseInt(args) || state.maxUrls, MAX_LINKS_STORED);
                        if (!isNaN(max) && max >= 10 && max <= MAX_LINKS_STORED) {
                            state.maxUrls = max;
                            addResponse(`Max URLs set to ${max}`, 'success');
                        } else {
                            addResponse(`Usage: /setmax <10-${MAX_LINKS_STORED}>`, 'error');
                        }
                        break;
                    case '/list': listCrawls(); break;
                    case '/export': exportResults(); break;
                    case '/clear': clearTerminal(); break;
                    case '/clearhistory': clearHistory(); break;
                    default: addResponse('Unknown command', 'error');
                }
            } else if (isValidUrl(cmd)) {
                await startCrawl(cmd);
            } else {
                addResponse('Not a valid URL or command', 'error');
            }
        }

        function showHelp() {
            const help = `/help                Show commands
/crawl <url>         Start crawling from URL
/crawl <url> <depth> <max> Start with custom params
/stop                Stop current crawl
/status              Show crawl status
/setbackend <url>    Change backend API URL
/testbackend         Test backend connectivity
/setdepth <1-5>      Set max crawl depth (default: 2)
/setmax <10-${MAX_LINKS_STORED}> Set max URLs to crawl (default: 100)
/list                List all crawls
/export              Export results
/clear               Clear terminal
/clearhistory        Clear crawl history`;
            addResponse(help, 'response');
        }

        function addLine(text, type = 'response') {
            const line = document.createElement('div');
            line.className = 'line';
            line.textContent = text;
            line.style.color = getColor(type);
            output.appendChild(line);
            scrollToBottom();
        }

        function addResponse(text, type = 'response') {
            addLine(text, type);
        }

        function scrollToBottom() {
            setTimeout(() => {
                output.scrollTop = output.scrollHeight;
            }, 10);
        }

        function getColor(type) {
            const colors = {
                'welcome': '#0f0', 'cmd': '#0ff', 'response': '#0a0',
                'error': '#f00', 'success': '#0f0', 'info': '#0af',
                'stats': '#080', 'crawling': '#ff0', 'warning': '#ff0'
            };
            return colors[type] || '#0a0';
        }

        function isValidUrl(string) {
            return string.startsWith('http://') || string.startsWith('https://');
        }

        async function pingBackend() {
            try {
                const pingUrl = state.backendUrl.replace('/crawl', '/ping');
                const response = await fetch(pingUrl, { timeout: 5000 });
                return response.ok;
            } catch {
                return false;
            }
        }

        async function testBackend() {
            addResponse('Testing backend...', 'info');
            const backendOk = await pingBackend();
            if (backendOk) {
                addResponse('✓ Backend is reachable', 'success');
            } else {
                addResponse('✗ Backend is not reachable', 'error');
            }
        }

        async function setBackend(url) {
            const newUrl = url.trim();
            if (!newUrl) {
                addResponse('No URL provided', 'error');
                return;
            }
            
            const oldUrl = state.backendUrl;
            state.backendUrl = newUrl;
            
            addResponse(`Testing new backend: ${newUrl}`, 'info');
            const backendOk = await pingBackend();
            
            if (backendOk) {
                addResponse(`✓ Backend set to: ${newUrl}`, 'success');
            } else {
                state.backendUrl = oldUrl;
                addResponse(`✗ Backend at ${newUrl} is not reachable`, 'error');
                addResponse(`Reverted to: ${oldUrl}`, 'warning');
            }
        }

        async function startCrawl(args) {
            if (state.isCrawling) {
                addResponse('Crawl already in progress. Use /stop first.', 'error');
                return;
            }

            const parts = args.split(' ');
            const url = parts[0];
            const depth = Math.min(parseInt(parts[1]) || state.maxDepth, 5);
            const maxUrls = Math.min(parseInt(parts[2]) || state.maxUrls, MAX_LINKS_STORED);

            if (!isValidUrl(url)) {
                addResponse('Invalid URL. Must start with http:// or https://', 'error');
                return;
            }

            // Test backend first
            addResponse('Testing backend connection...', 'info');
            const backendOk = await pingBackend();
            if (!backendOk) {
                addResponse('Backend is not reachable. Check /setbackend.', 'error');
                return;
            }

            // Reset state
            state.isCrawling = true;
            state.visitedUrls.clear();
            state.crawlingQueue = [];
            state.activeRequests = 0;
            state.memoryWarningShown = false;
            
            state.currentCrawl = {
                id: Date.now().toString(36),
                startUrl: url,
                depth: depth,
                maxUrls: maxUrls,
                startTime: new Date(),
                visited: new Set(),
                links: new Set(),
                results: [],
                status: 'starting'
            };

            addResponse(`Starting crawl [${state.currentCrawl.id}]`, 'success');
            addResponse(`Target: ${url}`, 'info');
            addResponse(`Depth: ${depth}, Max URLs: ${maxUrls}`, 'info');
            addResponse(`Memory limit: ${MAX_LINKS_STORED} links`, 'stats');
            
            if (maxUrls >= MAX_LINKS_STORED * 0.8) {
                addResponse('Warning: Close to memory limit. Consider reducing max URLs.', 'warning');
            }

            createCrawlPanel();
            processCrawlQueue();
        }

        function createCrawlPanel() {
            const panel = document.createElement('div');
            panel.className = 'results-panel';
            panel.id = 'crawl-panel-' + state.currentCrawl.id;
            
            panel.innerHTML = `
                <div class="panel-title">CRAWL [${state.currentCrawl.id}]</div>
                <div class="crawl-stats" id="crawl-stats-${state.currentCrawl.id}">
                    <div class="stat-item">
                        <div class="stat-label">STATUS</div>
                        <div class="stat-value" id="status-${state.currentCrawl.id}">STARTING</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">VISITED</div>
                        <div class="stat-value" id="visited-${state.currentCrawl.id}">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">QUEUE</div>
                        <div class="stat-value" id="queue-${state.currentCrawl.id}">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">ELAPSED</div>
                        <div class="stat-value" id="elapsed-${state.currentCrawl.id}">0s</div>
                    </div>
                </div>
                <div class="progress-container">
                    <div class="progress-bar" id="progress-${state.currentCrawl.id}"></div>
                </div>
                <div id="links-${state.currentCrawl.id}" style="max-height:200px;overflow-y:auto;margin-top:10px;"></div>
            `;
            
            output.appendChild(panel);
            scrollToBottom();
        }

        async function processCrawlQueue() {
            if (!state.isCrawling || !state.currentCrawl) return;
            
            state.currentCrawl.status = 'crawling';
            
            // Start stats updater
            if (state.statsInterval) clearInterval(state.statsInterval);
            state.statsInterval = setInterval(updateStats, 1000);

            // Initial queue item
            state.crawlingQueue.push({ url: state.currentCrawl.startUrl, depth: 0 });
            
            try {
                while (state.isCrawling && state.crawlingQueue.length > 0) {
                    // Check memory limits
                    if (state.currentCrawl.links.size >= state.currentCrawl.maxUrls) {
                        addResponse(`Reached maximum link limit (${state.currentCrawl.maxUrls})`, 'warning');
                        break;
                    }
                    
                    // Process next URL
                    const { url, depth } = state.crawlingQueue.shift();
                    
                    if (shouldSkipUrl(url, depth)) {
                        continue;
                    }
                    
                    await processUrl(url, depth);
                    
                    // Rate limiting delay
                    if (state.delay > 0) {
                        await new Promise(resolve => setTimeout(resolve, state.delay));
                    }
                }
                
                // Queue exhausted or stopped
                completeCrawl();
                
            } catch (error) {
                console.error('Crawl error:', error);
                state.currentCrawl.status = 'error';
                addResponse(`Crawl error: ${error.message}`, 'error');
                stopCrawl();
            }
        }

        function shouldSkipUrl(url, depth) {
            return state.visitedUrls.has(url) || 
                   depth > state.currentCrawl.depth || 
                   state.currentCrawl.visited.size >= state.currentCrawl.maxUrls;
        }

        async function processUrl(url, depth) {
            // Mark as visited
            state.visitedUrls.add(url);
            state.currentCrawl.visited.add(url);
            
            addResponse(`Crawling: ${url} (depth: ${depth})`, 'crawling');
            
            try {
                const response = await fetch(state.backendUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ startUrl: url })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }
                
                // Store result
                state.currentCrawl.results.push({
                    url: url,
                    depth: depth,
                    links: data.linksFound,
                    timestamp: new Date()
                });
                
                // Add new links to queue (with memory check)
                for (const link of data.linksFound) {
                    if (state.currentCrawl.links.size >= state.currentCrawl.maxUrls) {
                        if (!state.memoryWarningShown) {
                            addResponse(`Memory limit reached (${state.currentCrawl.maxUrls} links)`, 'warning');
                            state.memoryWarningShown = true;
                        }
                        break;
                    }
                    
                    if (!state.visitedUrls.has(link)) {
                        state.currentCrawl.links.add(link);
                        
                        if (depth < state.currentCrawl.depth) {
                            state.crawlingQueue.push({ url: link, depth: depth + 1 });
                        }
                    }
                }
                
                // Display the crawled URL
                displayCrawledUrl(url, depth, data.linksFound.length);
                
            } catch (error) {
                addResponse(`Error crawling ${url}: ${error.message}`, 'error');
            }
        }

        function displayCrawledUrl(url, depth, linkCount) {
            const linksContainer = document.getElementById('links-' + state.currentCrawl.id);
            if (!linksContainer) return;
            
            const linkItem = document.createElement('div');
            linkItem.className = 'link-item';
            
            const urlSpan = document.createElement('span');
            urlSpan.className = 'url-link';
            urlSpan.textContent = url;
            urlSpan.title = `Depth: ${depth}, Links: ${linkCount}`;
            urlSpan.onclick = () => window.open(url, '_blank');
            
            const countSpan = document.createElement('span');
            countSpan.style.color = '#0a0';
            countSpan.style.marginLeft = '10px';
            countSpan.textContent = `(${linkCount} links)`;
            
            linkItem.appendChild(urlSpan);
            linkItem.appendChild(countSpan);
            linksContainer.appendChild(linkItem);
            
            // Auto-scroll links container
            linksContainer.scrollTop = linksContainer.scrollHeight;
        }

        function updateStats() {
            if (!state.currentCrawl) return;

            const elapsed = Math.round((new Date() - state.currentCrawl.startTime) / 1000);
            const progress = Math.min(100, (state.currentCrawl.visited.size / state.currentCrawl.maxUrls) * 100);
            
            // Update DOM elements
            const elements = {
                status: document.getElementById('status-' + state.currentCrawl.id),
                visited: document.getElementById('visited-' + state.currentCrawl.id),
                queue: document.getElementById('queue-' + state.currentCrawl.id),
                elapsed: document.getElementById('elapsed-' + state.currentCrawl.id),
                progress: document.getElementById('progress-' + state.currentCrawl.id)
            };
            
            if (elements.status) elements.status.textContent = state.currentCrawl.status.toUpperCase();
            if (elements.visited) elements.visited.textContent = state.currentCrawl.visited.size;
            if (elements.queue) elements.queue.textContent = state.crawlingQueue.length;
            if (elements.elapsed) elements.elapsed.textContent = `${elapsed}s`;
            if (elements.progress) elements.progress.style.width = `${progress}%`;
        }

        function completeCrawl() {
            if (!state.currentCrawl) return;
            
            state.currentCrawl.status = 'completed';
            state.currentCrawl.endTime = new Date();
            state.crawls.push({...state.currentCrawl});
            
            const elapsed = Math.round((state.currentCrawl.endTime - state.currentCrawl.startTime) / 1000);
            
            addResponse(`Crawl [${state.currentCrawl.id}] completed`, 'success');
            addResponse(`Visited: ${state.currentCrawl.visited.size} URLs`, 'stats');
            addResponse(`Found: ${state.currentCrawl.links.size} links`, 'stats');
            addResponse(`Time: ${elapsed}s`, 'stats');
            
            // Cleanup
            if (state.statsInterval) {
                clearInterval(state.statsInterval);
                state.statsInterval = null;
            }
            
            state.isCrawling = false;
            state.currentCrawl = null;
            state.visitedUrls.clear();
            state.crawlingQueue = [];
        }

        function stopCrawl() {
            if (!state.isCrawling) {
                addResponse('No crawl in progress', 'error');
                return;
            }
            
            state.isCrawling = false;
            if (state.currentCrawl) {
                state.currentCrawl.status = 'stopped';
                state.currentCrawl.endTime = new Date();
                state.crawls.push({...state.currentCrawl});
                
                addResponse(`Crawl [${state.currentCrawl.id}] stopped`, 'success');
                addResponse(`Visited ${state.currentCrawl.visited.size} URLs`, 'stats');
                
                updateStats();
                state.currentCrawl = null;
            }
            
            state.visitedUrls.clear();
            state.crawlingQueue = [];
            
            if (state.statsInterval) {
                clearInterval(state.statsInterval);
                state.statsInterval = null;
            }
        }

        function showStatus() {
            if (state.isCrawling && state.currentCrawl) {
                addResponse('Crawl in progress:', 'success');
                addResponse(`ID: ${state.currentCrawl.id}`, 'info');
                addResponse(`URL: ${state.currentCrawl.startUrl}`, 'info');
                addResponse(`Status: ${state.currentCrawl.status}`, 'info');
                addResponse(`Visited: ${state.currentCrawl.visited.size}/${state.currentCrawl.maxUrls}`, 'stats');
                addResponse(`Queue: ${state.crawlingQueue.length}`, 'stats');
                addResponse(`Links: ${state.currentCrawl.links.size}`, 'stats');
                
                const elapsed = Math.round((new Date() - state.currentCrawl.startTime) / 1000);
                addResponse(`Elapsed: ${elapsed}s`, 'stats');
            } else {
                addResponse('No active crawl', 'info');
                addResponse(`Total crawls: ${state.crawls.length}`, 'stats');
                addResponse(`Backend: ${state.backendUrl}`, 'info');
            }
        }

        function listCrawls() {
            if (state.crawls.length === 0) {
                addResponse('No crawl history', 'info');
                return;
            }

            addResponse('Crawl history:', 'success');
            state.crawls.forEach((crawl, index) => {
                const elapsed = crawl.endTime ? 
                    Math.round((crawl.endTime - crawl.startTime) / 1000) : 0;
                
                addResponse(`${index + 1}. [${crawl.id}]`, 'info');
                addResponse(`   URL: ${crawl.startUrl}`, 'response');
                addResponse(`   Status: ${crawl.status}`, 'response');
                addResponse(`   Visited: ${crawl.visited.size} URLs`, 'stats');
                addResponse(`   Links: ${crawl.links.size} found`, 'stats');
                addResponse(`   Time: ${elapsed}s`, 'stats');
                addResponse('', 'response');
            });
        }

        function exportResults() {
            if (state.crawls.length === 0 && !state.currentCrawl) {
                addResponse('No results to export', 'error');
                return;
            }

            let markdown = `# WEBXOS Crawler Export\n`;
            markdown += `## Generated: ${new Date().toLocaleString()}\n\n`;

            const crawlsToExport = state.currentCrawl ? [state.currentCrawl] : state.crawls;
            
            crawlsToExport.forEach((crawl, index) => {
                markdown += `---\n\n`;
                markdown += `### Crawl ${index + 1}: ${crawl.id}\n`;
                markdown += `**URL:** ${crawl.startUrl}\n`;
                markdown += `**Status:** ${crawl.status}\n`;
                markdown += `**Visited:** ${crawl.visited.size} URLs\n`;
                markdown += `**Links:** ${crawl.links.size} found\n\n`;
                
                if (crawl.links.size > 0) {
                    markdown += `#### Links Found:\n\`\`\`\n`;
                    Array.from(crawl.links).forEach(link => {
                        markdown += `${link}\n`;
                    });
                    markdown += `\`\`\`\n\n`;
                }
            });

            document.getElementById('export-preview').textContent = markdown;
            showModal('export-modal');
        }

        function clearTerminal() {
            output.innerHTML = '';
            addLine(WEBXOS_ASCII, 'welcome');
            addLine('', 'response');
            addLine('WEBXOS CRAWLER v2.0', 'response');
            addLine('Terminal cleared', 'success');
        }

        function clearHistory() {
            state.crawls = [];
            addResponse('Crawl history cleared', 'success');
        }

        function closeExport() {
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('export-modal').style.display = 'none';
        }

        function copyExport() {
            const text = document.getElementById('export-preview').textContent;
            navigator.clipboard.writeText(text).then(() => {
                addResponse('Export copied to clipboard', 'success');
                closeExport();
            });
        }

        function downloadExport() {
            const text = document.getElementById('export-preview').textContent;
            const blob = new Blob([text], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `webxos-crawl-${Date.now()}.md`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            addResponse('Export downloaded', 'success');
            closeExport();
        }

        function showModal(modalId) {
            document.getElementById('overlay').style.display = 'block';
            document.getElementById(modalId).style.display = 'block';
        }

        // Event listeners for modals
        document.getElementById('overlay').addEventListener('click', closeExport);
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeExport();
                hiddenInput.focus();
            }
        });
    </script>
</body>
</html>
