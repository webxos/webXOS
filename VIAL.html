<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WebXOS Vial Wallet</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Press Start 2P', monospace; }
        html, body { 
            height: 100vh; 
            overflow: hidden; 
            background: #000; 
            color: #0f0; 
            display: flex; 
            flex-direction: column; 
            touch-action: manipulation; 
            position: relative;
        }
        
        /* Scanlines effect */
        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 100;
        }
        
        /* Grid background */
        body::after {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 0, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 0, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
            pointer-events: none;
            z-index: -1;
        }
        
        header {
            padding: 10px;
            text-align: center;
            border-bottom: 2px solid #0f0;
            background: rgba(0, 20, 0, 0.8);
            z-index: 10;
        }
        
        h1 {
            font-size: 1.6rem;
            text-shadow: 0 0 5px #0f0;
            margin-bottom: 5px;
        }
        
        .header-info {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            margin-top: 5px;
        }
        
        #terminal {
            flex: 1;
            margin: 10px;
            background: rgba(0, 20, 0, 0.7);
            border: 2px solid #0f0;
            border-radius: 5px;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        
        #terminal-log {
            flex: 1;
            overflow-y: auto;
            padding-right: 5px;
        }
        
        #terminal-log p {
            margin: 5px 0;
            font-size: 0.8rem;
            line-height: 1.3;
        }
        
        #terminal-input {
            display: flex;
            margin-top: 10px;
            border-top: 1px solid #0f0;
            padding-top: 10px;
        }
        
        #prompt-input {
            flex: 1;
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 8px;
            font-size: 0.8rem;
        }
        
        #send-button {
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 8px 15px;
            margin-left: 5px;
            cursor: pointer;
        }
        
        #vial-status {
            height: 120px;
            margin: 0 10px 10px;
            display: flex;
            gap: 10px;
        }
        
        .vial-container {
            flex: 1;
            background: rgba(0, 20, 0, 0.7);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 8px;
            display: flex;
            flex-direction: column;
        }
        
        .vial-header {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            margin-bottom: 5px;
        }
        
        .vial-name {
            font-weight: bold;
        }
        
        .vial-status {
            color: #0f0;
        }
        
        .vial-status.training {
            color: #ff0;
        }
        
        .vial-status.error {
            color: #f00;
        }
        
        .metric-bar {
            height: 8px;
            background: #333;
            border: 1px solid #0f0;
            border-radius: 2px;
            margin: 3px 0;
            overflow: hidden;
        }
        
        .metric-fill {
            height: 100%;
            transition: width 0.3s;
        }
        
        .fps-fill {
            background: #0f0;
        }
        
        .latency-fill {
            background: #f00;
        }
        
        .vial-metrics {
            font-size: 0.6rem;
            margin-top: 5px;
        }
        
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 0 10px 10px;
            justify-content: center;
        }
        
        button {
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 8px 12px;
            font-size: 0.7rem;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #0f0;
            color: #000;
        }
        
        button:disabled {
            background: #333;
            color: #666;
            border-color: #666;
            cursor: not-allowed;
        }
        
        button.active {
            background: #0f0;
            color: #000;
        }
        
        #error-notification {
            display: none;
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(255, 0, 0, 0.8);
            color: #fff;
            padding: 10px;
            border-radius: 3px;
            font-size: 0.8rem;
            max-width: 300px;
            z-index: 1000;
            box-shadow: 0 0 10px #ff0000;
            border: 1px solid #ff0000;
        }
        
        #error-notification.visible {
            display: block;
        }
        
        #donate-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000;
            border: 2px solid #0f0;
            padding: 20px;
            border-radius: 5px;
            z-index: 2000;
            box-shadow: 0 0 20px #0f0;
            text-align: center;
            max-width: 300px;
        }
        
        #donate-popup.visible {
            display: block;
        }
        
        #donate-popup h2 {
            margin-bottom: 15px;
            font-size: 1rem;
        }
        
        #donate-popup p {
            margin: 10px 0;
            font-size: 0.8rem;
        }
        
        #donate-close {
            margin-top: 15px;
            padding: 8px 15px;
        }
        
        .command {
            color: #0ff;
        }
        
        .error {
            color: #f00;
        }
        
        .success {
            color: #0f0;
        }
        
        .warning {
            color: #ff0;
        }
        
        .balance {
            color: #0af;
        }
        
        /* Scrollbar styling */
        #terminal-log::-webkit-scrollbar {
            width: 8px;
        }
        
        #terminal-log::-webkit-scrollbar-track {
            background: rgba(0, 30, 0, 0.5);
        }
        
        #terminal-log::-webkit-scrollbar-thumb {
            background: #0f0;
            border-radius: 4px;
        }
        
        /* Neurot particles */
        .neurot {
            position: fixed;
            width: 3px;
            height: 3px;
            background-color: #0f0;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1;
            box-shadow: 0 0 5px #0f0;
        }
    </style>
</head>
<body>
    <header>
        <h1>WebXOS Vial Wallet</h1>
        <div class="header-info">
            <span>NETWORK: <span id="network-status">OFFLINE</span></span>
            <span>BLOCKS: <span id="block-count">0</span></span>
            <span>REPUTATION: <span id="reputation">0</span></span>
        </div>
    </header>
    
    <div id="terminal">
        <div id="terminal-log">
            <p>> WebXOS Vial Wallet initialized. Type /help for commands.</p>
            <p class="balance">$WEBXOS Balance: 0.0000</p>
        </div>
        <div id="terminal-input">
            <input type="text" id="prompt-input" placeholder="Enter command...">
            <button id="send-button">SEND</button>
        </div>
    </div>
    
    <div id="vial-status">
        <!-- Vial status bars will be generated here -->
    </div>
    
    <div class="button-group">
        <button id="authButton">AUTHENTICATE</button>
        <button id="voidButton">VOID</button>
        <button id="quantumLinkButton" disabled>QUANTUM LINK</button>
        <button id="exportButton" disabled>EXPORT</button>
        <button id="importButton" disabled>IMPORT</button>
        <button id="apiAccessButton" disabled>API ACCESS</button>
        <button id="donateButton">DONATE</button>
    </div>
    
    <div id="error-notification"></div>
    
    <div id="donate-popup">
        <h2>SUPPORT WEBXOS</h2>
        <p>PAYPAL DONATION LINK COMING SOON</p>
        <p>THANK YOU FOR YOUR SUPPORT!</p>
        <p>- webXOS 2025</p>
        <button id="donate-close">CLOSE</button>
    </div>
    
    <input type="file" id="file-input" accept=".md" style="display: none;">

    <script>
        // Global state
        let isAuthenticated = false;
        let isOffline = true;
        let wallet = {
            address: null,
            balance: 0,
            hash: null,
            key: null
        };
        let agenticNetworkId = null;
        let reputation = 0;
        let blockchain = [];
        let apiCredentials = { key: null, secret: null };
        let vials = [];
        let logEntries = [];
        let fps = 60;
        let latency = 0;
        let lastUpdateTime = 0;
        let frameCount = 0;
        let fpsUpdateTime = 0;
        
        // Initialize vials with empty state
        function initializeVials() {
            vials = [
                {
                    id: 'vial1',
                    status: 'stopped',
                    code: '',
                    codeLength: 0,
                    webxosHash: '',
                    wallet: {
                        balance: 0,
                        address: '',
                        hash: ''
                    },
                    tasks: [],
                    quantumState: { qubits: [], entanglement: 'initialized' },
                    trainingData: [],
                    config: {},
                    isTraining: false,
                    fps: 60,
                    latency: 0
                },
                {
                    id: 'vial2',
                    status: 'stopped',
                    code: '',
                    codeLength: 0,
                    webxosHash: '',
                    wallet: {
                        balance: 0,
                        address: '',
                        hash: ''
                    },
                    tasks: [],
                    quantumState: { qubits: [], entanglement: 'initialized' },
                    trainingData: [],
                    config: {},
                    isTraining: false,
                    fps: 60,
                    latency: 0
                },
                {
                    id: 'vial3',
                    status: 'stopped',
                    code: '',
                    codeLength: 0,
                    webxosHash: '',
                    wallet: {
                        balance: 0,
                        address: '',
                        hash: ''
                    },
                    tasks: [],
                    quantumState: { qubits: [], entanglement: 'initialized' },
                    trainingData: [],
                    config: {},
                    isTraining: false,
                    fps: 60,
                    latency: 0
                },
                {
                    id: 'vial4',
                    status: 'stopped',
                    code: '',
                    codeLength: 0,
                    webxosHash: '',
                    wallet: {
                        balance: 0,
                        address: '',
                        hash: ''
                    },
                    tasks: [],
                    quantumState: { qubits: [], entanglement: 'initialized' },
                    trainingData: [],
                    config: {},
                    isTraining: false,
                    fps: 60,
                    latency: 0
                }
            ];
            
            wallet.balance = 0;
            updateBalanceDisplay();
        }
        
        // Parse markdown wallet format
        function parseMarkdownWallet(markdownText) {
            const lines = markdownText.split('\n');
            const result = {
                agenticNetwork: {},
                wallet: {},
                apiCredentials: {},
                blockchain: {},
                vials: []
            };
            
            let currentVial = null;
            let inCodeBlock = false;
            let codeBlock = [];
            let currentCodeLanguage = '';
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Agentic Network section
                if (line.startsWith('- Network ID:')) {
                    result.agenticNetwork.networkId = line.split(':')[1].trim();
                } else if (line.startsWith('- Reputation:')) {
                    result.agenticNetwork.reputation = parseInt(line.split(':')[1].trim()) || 0;
                }
                
                // Wallet section
                else if (line.startsWith('- Wallet Key:')) {
                    result.wallet.key = line.split(':')[1].trim();
                } else if (line.startsWith('- Session Balance:')) {
                    const balanceMatch = line.match(/- Session Balance: ([\d.]+) \$WEBXOS/);
                    if (balanceMatch) {
                        result.wallet.balance = parseFloat(balanceMatch[1]) || 0;
                    }
                } else if (line.startsWith('- Address:')) {
                    result.wallet.address = line.split(':')[1].trim();
                } else if (line.startsWith('- Hash:')) {
                    result.wallet.hash = line.split(':')[1].trim();
                }
                
                // API Credentials section
                else if (line.startsWith('- Key:')) {
                    result.apiCredentials.key = line.split(':')[1].trim();
                } else if (line.startsWith('- Secret:')) {
                    result.apiCredentials.secret = line.split(':')[1].trim();
                }
                
                // Blockchain section
                else if (line.startsWith('- Blocks:')) {
                    result.blockchain.blocks = parseInt(line.split(':')[1].trim()) || 0;
                } else if (line.startsWith('- Last Hash:')) {
                    result.blockchain.lastHash = line.split(':')[1].trim();
                }
                
                // Vial sections
                else if (line.startsWith('# Vial Agent:')) {
                    if (currentVial) {
                        // Save the previous vial
                        currentVial.code = codeBlock.join('\n');
                        currentVial.codeLength = currentVial.code.length;
                        result.vials.push(currentVial);
                        codeBlock = [];
                    }
                    
                    const vialId = line.split(':')[1].trim();
                    currentVial = {
                        id: vialId,
                        status: 'stopped',
                        code: '',
                        codeLength: 0,
                        webxosHash: '',
                        wallet: {
                            balance: 0,
                            address: '',
                            hash: ''
                        },
                        tasks: [],
                        quantumState: { qubits: [], entanglement: 'initialized' },
                        trainingData: [],
                        config: {},
                        isTraining: false,
                        fps: 60,
                        latency: 0
                    };
                }
                
                // Vial properties
                else if (currentVial && line.startsWith('- Status:')) {
                    currentVial.status = line.split(':')[1].trim();
                } else if (currentVial && line.startsWith('- Language:')) {
                    // Language info - we don't need to store this separately
                } else if (currentVial && line.startsWith('- Code Length:')) {
                    const lengthMatch = line.match(/- Code Length: (\d+) bytes/);
                    if (lengthMatch) {
                        currentVial.codeLength = parseInt(lengthMatch[1]) || 0;
                    }
                } else if (currentVial && line.startsWith('- $WEBXOS Hash:')) {
                    currentVial.webxosHash = line.split(':')[1].trim();
                } else if (currentVial && line.startsWith('- Wallet Balance:')) {
                    const balanceMatch = line.match(/- Wallet Balance: ([\d.]+) \$WEBXOS/);
                    if (balanceMatch) {
                        currentVial.wallet.balance = parseFloat(balanceMatch[1]) || 0;
                    }
                } else if (currentVial && line.startsWith('- Wallet Address:')) {
                    currentVial.wallet.address = line.split(':')[1].trim();
                } else if (currentVial && line.startsWith('- Wallet Hash:')) {
                    currentVial.wallet.hash = line.split(':')[1].trim();
                } else if (currentVial && line.startsWith('- Tasks:')) {
                    const tasksStr = line.split(':')[1].trim();
                    currentVial.tasks = tasksStr === 'none' ? [] : tasksStr.split(',').map(t => t.trim());
                } else if (currentVial && line.startsWith('- Quantum State:')) {
                    try {
                        const jsonStr = line.split(':')[1].trim();
                        currentVial.quantumState = JSON.parse(jsonStr);
                    } catch (e) {
                        console.warn('Failed to parse Quantum State JSON');
                    }
                } else if (currentVial && line.startsWith('- Training Data:')) {
                    try {
                        const jsonStr = line.split(':')[1].trim();
                        currentVial.trainingData = JSON.parse(jsonStr);
                    } catch (e) {
                        console.warn('Failed to parse Training Data JSON');
                    }
                } else if (currentVial && line.startsWith('- Config:')) {
                    try {
                        const jsonStr = line.split(':')[1].trim();
                        currentVial.config = JSON.parse(jsonStr);
                    } catch (e) {
                        console.warn('Failed to parse Config JSON');
                    }
                }
                
                // Code blocks
                else if (line.startsWith('```')) {
                    if (inCodeBlock) {
                        inCodeBlock = false;
                        if (currentVial) {
                            currentVial.code = codeBlock.join('\n');
                            currentVial.codeLength = currentVial.code.length;
                        }
                        codeBlock = [];
                    } else {
                        inCodeBlock = true;
                        currentCodeLanguage = line.replace('```', '').trim();
                    }
                } else if (inCodeBlock && currentVial) {
                    codeBlock.push(lines[i]); // Keep original formatting
                }
            }
            
            // Don't forget the last vial
            if (currentVial) {
                result.vials.push(currentVial);
            }
            
            return result;
        }
        
        // Log event to terminal
        function logEvent(message, type = 'normal') {
            const timestamp = new Date().toLocaleTimeString();
            const typeClass = type === 'command' ? 'command' : 
                             type === 'error' ? 'error' : 
                             type === 'success' ? 'success' : 
                             type === 'warning' ? 'warning' : 
                             type === 'balance' ? 'balance' : 'normal';
            
            const logEntry = `<p class="${typeClass}">[${timestamp}] ${message}</p>`;
            logEntries.push(logEntry);
            
            // Keep only last 100 entries
            if (logEntries.length > 100) {
                logEntries.shift();
            }
            
            updateTerminal();
        }
        
        // Update terminal display
        function updateTerminal() {
            const terminalLog = document.getElementById('terminal-log');
            terminalLog.innerHTML = logEntries.join('');
            terminalLog.scrollTop = terminalLog.scrollHeight;
        }
        
        // Update balance display
        function updateBalanceDisplay() {
            const balanceElement = document.querySelector('.balance');
            if (balanceElement) {
                balanceElement.textContent = `$WEBXOS Balance: ${wallet.balance.toFixed(4)}`;
            }
            
            document.getElementById('reputation').textContent = reputation;
            document.getElementById('block-count').textContent = blockchain.length;
        }
        
        // Update vial status bars
        function updateVialStatusBars() {
            const vialStatus = document.getElementById('vial-status');
            if (!vialStatus) return;
            
            vialStatus.innerHTML = vials.map(vial => {
                const statusClass = vial.isTraining ? 'training' : 
                                  vial.status === 'running' ? 'running' : 'stopped';
                
                // Calculate FPS and latency metrics (simulated)
                vial.fps = Math.max(30, Math.min(120, vial.fps + (Math.random() - 0.5) * 10));
                vial.latency = Math.max(5, Math.min(200, vial.latency + (Math.random() - 0.5) * 10));
                
                const fpsPercent = (vial.fps / 120) * 100;
                const latencyPercent = (vial.latency / 200) * 100;
                
                return `
                    <div class="vial-container">
                        <div class="vial-header">
                            <span class="vial-name">${vial.id}</span>
                            <span class="vial-status ${statusClass}">${vial.status.toUpperCase()}</span>
                        </div>
                        <div class="metric-bar">
                            <div class="metric-fill fps-fill" style="width: ${fpsPercent}%"></div>
                        </div>
                        <div class="metric-bar">
                            <div class="metric-fill latency-fill" style="width: ${latencyPercent}%"></div>
                        </div>
                        <div class="vial-metrics">
                            <div>FPS: ${Math.round(vial.fps)}</div>
                            <div>LATENCY: ${Math.round(vial.latency)}ms</div>
                            <div>SIZE: ${vial.codeLength} bytes</div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Show error notification
        function showErrorNotification(message) {
            const errorNotification = document.getElementById('error-notification');
            if (errorNotification) {
                errorNotification.textContent = message;
                errorNotification.classList.add('visible');
                setTimeout(() => {
                    errorNotification.classList.remove('visible');
                }, 5000);
            }
        }
        
        // Authenticate function
        function authenticate() {
            const isOnline = confirm('Authenticate in online mode? Cancel for offline mode.');
            isOffline = !isOnline;
            
            if (isOnline) {
                // Use the provided wallet data for online mode
                const providedWalletMarkdown = `# WebXOS Vial and Wallet Export

## Agentic Network
- Network ID: 54965687-3871-4f3d-a803-ac9840af87c4
- Session Start: 2025-10-28T00:30:42.782Z
- Session Duration: 0.00 seconds
- Reputation: 9838494354407

## Wallet
- Wallet Key: a1d57580-d88b-4c90-a0f8-6f2c8511b1e4
- Session Balance: 146094.0000 $WEBXOS
- Address: e8aa2491-f9a4-4541-ab68-fe7a32fb8f1d
- Hash: bdb28098e471909be10e8980cfed20268a27ed7dfeadcc7175a7d63cc7c05617

## API Credentials
- Key: c678d6bb-8176-4745-899d-e5213019f096
- Secret: 0d85e55a4f5f06f10b95773ae80b9b50f2ace216100aa938707d4e5ec0bf2709

## Blockchain
- Blocks: 7
- Last Hash: a271e44cb3b0dfb84dbb4703b356bc5ba5466e9e17e82c2f223532bf0c28749e

## Vials
# Vial Agent: vial1
- Status: running
- Language: Python
- Code Length: 1484134 bytes
- $WEBXOS Hash: 1ea34723-38db-45a3-b5bb-cb07b383c2fd
- Wallet Balance: 36523.5000 $WEBXOS
- Wallet Address: 59cc28fa-ff12-4ad0-bb4e-af64fe2d441d
- Wallet Hash: a271e44cb3b0dfb84dbb4703b356bc5ba5466e9e17e82c2f223532bf0c28749e
- Tasks: none
- Quantum State: {
      "qubits": [],
      "entanglement": "synced"
    }
- Training Data: [
      {
        "tasks": [],
        "parameters": {},
        "hash": "a271e44cb3b0dfb84dbb4703b356bc5ba5466e9e17e82c2f223532bf0c28749e"
      }
    ]
- Config: {}

\`\`\`python
import torch
import torch.nn as nn

class VialAgent1(nn.Module):
    def __init__(self):
        super().__init__()
        self.fc = nn.Linear(10, 1)
    def forward(self, x):
        return torch.sigmoid(self.fc(x))

model = VialAgent1()
\`\`\`
---

# Vial Agent: vial2
- Status: running
- Language: Python
- Code Length: 1484131 bytes
- $WEBXOS Hash: 2983fb73-2ce0-402f-8b76-f20175302fc4
- Wallet Balance: 36523.5000 $WEBXOS
- Wallet Address: e7fa09d2-9d98-4cfd-bc44-4f8035e1cf20
- Wallet Hash: a271e44cb3b0dfb84dbb4703b356bc5ba5466e9e17e82c2f223532bf0c28749e
- Tasks: none
- Quantum State: {
      "qubits": [],
      "entanglement": "synced"
    }
- Training Data: [
      {
        "tasks": [],
        "parameters": {},
        "hash": "a271e44cb3b0dfb84dbb4703b356bc5ba5466e9e17e82c2f223532bf0c28749e"
      }
    ]
- Config: {}

\`\`\`python
import torch
import torch.nn as nn

class VialAgent2(nn.Module):
    def __init__(self):
        super().__init__()
        self.fc = nn.Linear(20, 2)
    def forward(self, x):
        return torch.relu(self.fc(x))

model = VialAgent2()
\`\`\`
---

# Vial Agent: vial3
- Status: running
- Language: Python
- Code Length: 1484131 bytes
- $WEBXOS Hash: 2c217c70-6c5f-402f-a491-a0a85c36ddf3
- Wallet Balance: 36523.5000 $WEBXOS
- Wallet Address: af1baa76-5a1f-4b9b-9463-55ced39fe6dd
- Wallet Hash: a271e44cb3b0dfb84dbb4703b356bc5ba5466e9e17e82c2f223532bf0c28749e
- Tasks: none
- Quantum State: {
      "qubits": [],
      "entanglement": "synced"
    }
- Training Data: [
      {
        "tasks": [],
        "parameters": {},
        "hash": "a271e44cb3b0dfb84dbb4703b356bc5ba5466e9e17e82c2f223532bf0c28749e"
      }
    ]
- Config: {}

\`\`\`python
import torch
import torch.nn as nn

class VialAgent3(nn.Module):
    def __init__(self):
        super().__init__()
        self.fc = nn.Linear(15, 3)
    def forward(self, x):
        return torch.tanh(self.fc(x))

model = VialAgent3()
\`\`\`
---

# Vial Agent: vial4
- Status: running
- Language: Python
- Code Length: 1484141 bytes
- $WEBXOS Hash: 405e6101-2b0f-4aad-851e-7e5710994fb2
- Wallet Balance: 36523.5000 $WEBXOS
- Wallet Address: 143ec9b7-0e80-4842-9f03-e936da7a5844
- Wallet Hash: a271e44cb3b0dfb84dbb4703b356bc5ba5466e9e17e82c2f223532bf0c28749e
- Tasks: none
- Quantum State: {
      "qubits": [],
      "entanglement": "synced"
    }
- Training Data: [
      {
        "tasks": [],
        "parameters": {},
        "hash": "a271e44cb3b0dfb84dbb4703b356bc5ba5466e9e17e82c2f223532bf0c28749e"
      }
    ]
- Config: {}

\`\`\`python
import torch
import torch.nn as nn

class VialAgent4(nn.Module):
    def __init__(self):
        super().__init__()
        self.fc = nn.Linear(25, 4)
    def forward(self, x):
        return torch.softmax(self.fc(x), dim=1)

model = VialAgent4()
\`\`\`

## Instructions
- **Reuse**: Import this .md file via the "Import" button to resume training.
- **Extend**: Modify agent code externally, then reimport.
- **Share**: Send this .md file to others to continue training with the same wallet.
- **API**: Use API credentials with LangChain to train vials (online mode only).
- **Cash Out**: $WEBXOS balance and reputation are tied to the wallet address and hash for secure verification (online mode only).

Generated by Vial MCP Controller`;
                
                const walletData = parseMarkdownWallet(providedWalletMarkdown);
                
                agenticNetworkId = walletData.agenticNetwork.networkId;
                wallet.key = walletData.wallet.key;
                wallet.balance = walletData.wallet.balance;
                wallet.address = walletData.wallet.address;
                wallet.hash = walletData.wallet.hash;
                apiCredentials = walletData.apiCredentials;
                reputation = walletData.agenticNetwork.reputation;
                
                // Initialize blockchain with provided data
                blockchain = Array(walletData.blockchain.blocks).fill().map((_, i) => ({
                    index: i,
                    hash: i === walletData.blockchain.blocks - 1 ? walletData.blockchain.lastHash : `prev_hash_${i}`,
                    timestamp: new Date().toISOString()
                }));
                
                // Update vials with provided data
                if (walletData.vials && walletData.vials.length > 0) {
                    vials = walletData.vials;
                }
                
                logEvent('Authenticated in ONLINE mode with provided wallet data', 'success');
                logEvent(`Network ID: ${agenticNetworkId}`, 'command');
                logEvent(`Wallet Balance: ${wallet.balance.toFixed(4)} $WEBXOS`, 'balance');
                logEvent(`Reputation: ${reputation}`, 'balance');
            } else {
                // Offline mode with new wallet
                agenticNetworkId = generateUUID();
                wallet.key = generateUUID();
                wallet.address = generateUUID();
                wallet.hash = generateUUID();
                apiCredentials.key = generateUUID();
                apiCredentials.secret = generateUUID();
                reputation = 0;
                blockchain = [];
                
                logEvent('Authenticated in OFFLINE mode with new wallet', 'success');
            }
            
            isAuthenticated = true;
            document.getElementById('authButton').classList.add('active');
            document.getElementById('network-status').textContent = isOffline ? 'OFFLINE' : 'ONLINE';
            document.getElementById('network-status').style.color = isOffline ? '#f00' : '#0f0';
            
            // Enable buttons
            document.getElementById('quantumLinkButton').disabled = false;
            document.getElementById('exportButton').disabled = false;
            document.getElementById('importButton').disabled = false;
            document.getElementById('apiAccessButton').disabled = isOffline;
            
            updateBalanceDisplay();
            updateVialStatusBars();
        }
        
        // Void function
        function voidVials() {
            isAuthenticated = false;
            isOffline = true;
            wallet = { address: null, balance: 0, hash: null, key: null };
            agenticNetworkId = null;
            reputation = 0;
            blockchain = [];
            apiCredentials = { key: null, secret: null };
            
            initializeVials();
            
            document.getElementById('authButton').classList.remove('active');
            document.getElementById('network-status').textContent = 'OFFLINE';
            document.getElementById('network-status').style.color = '#f00';
            
            // Disable buttons
            document.getElementById('quantumLinkButton').disabled = true;
            document.getElementById('exportButton').disabled = true;
            document.getElementById('importButton').disabled = true;
            document.getElementById('apiAccessButton').disabled = true;
            
            logEvent('All data voided. System reset.', 'warning');
            updateBalanceDisplay();
            updateVialStatusBars();
        }
        
        // Quantum Link function
        function quantumLink() {
            if (!isAuthenticated) {
                showErrorNotification('Not authenticated. Please authenticate first.');
                return;
            }
            
            logEvent('Activating Quantum Link for agent synchronization...', 'command');
            
            vials.forEach(vial => {
                vial.isTraining = true;
                vial.status = 'running';
                
                // Simulate training process
                setTimeout(() => {
                    vial.isTraining = false;
                    vial.status = 'running';
                    vial.wallet.balance += 100; // Simulated earnings
                    wallet.balance = vials.reduce((sum, v) => sum + v.wallet.balance, 0);
                    updateBalanceDisplay();
                    updateVialStatusBars();
                }, 2000);
            });
            
            updateVialStatusBars();
        }
        
        // Export function
        function exportVials() {
            if (!isAuthenticated) {
                showErrorNotification('Not authenticated. Please authenticate first.');
                return;
            }
            
            const exportData = {
                agenticNetwork: {
                    networkId: agenticNetworkId,
                    sessionStart: new Date().toISOString(),
                    reputation: reputation
                },
                wallet: {
                    key: wallet.key,
                    balance: wallet.balance,
                    address: wallet.address,
                    hash: wallet.hash
                },
                apiCredentials: apiCredentials,
                blockchain: {
                    blocks: blockchain.length,
                    lastHash: blockchain.length > 0 ? blockchain[blockchain.length-1].hash : 'none'
                },
                vials: vials
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `vial_wallet_export_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            logEvent('Wallet and vial data exported successfully', 'success');
        }
        
        // Import function
        function importFile() {
            if (!isAuthenticated) {
                showErrorNotification('Not authenticated. Please authenticate first.');
                return;
            }
            
            document.getElementById('file-input').click();
        }
        
        // Handle file import
        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const fileContent = e.target.result;
                    let importData;
                    
                    // Check if it's a markdown file
                    if (file.name.endsWith('.md')) {
                        importData = parseMarkdownWallet(fileContent);
                    } else {
                        // Assume it's JSON
                        importData = JSON.parse(fileContent);
                    }
                    
                    // Update wallet data
                    if (importData.wallet) {
                        wallet.key = importData.wallet.key || wallet.key;
                        wallet.balance = importData.wallet.balance || wallet.balance;
                        wallet.address = importData.wallet.address || wallet.address;
                        wallet.hash = importData.wallet.hash || wallet.hash;
                    }
                    
                    // Update vials
                    if (importData.vials && Array.isArray(importData.vials)) {
                        vials = importData.vials;
                    }
                    
                    // Update other data
                    if (importData.agenticNetwork) {
                        agenticNetworkId = importData.agenticNetwork.networkId || agenticNetworkId;
                        reputation = importData.agenticNetwork.reputation || reputation;
                    }
                    
                    if (importData.apiCredentials) {
                        apiCredentials = importData.apiCredentials;
                    }
                    
                    if (importData.blockchain) {
                        // We don't replace the entire blockchain, just update the count
                        blockchain = Array(importData.blockchain.blocks || 0).fill().map((_, i) => ({
                            index: i,
                            hash: `imported_hash_${i}`,
                            timestamp: new Date().toISOString()
                        }));
                    }
                    
                    logEvent('Wallet data imported successfully', 'success');
                    updateBalanceDisplay();
                    updateVialStatusBars();
                } catch (error) {
                    showErrorNotification('Failed to import file: Invalid format');
                    logEvent(`Import error: ${error.message}`, 'error');
                }
            };
            reader.readAsText(file);
            
            // Reset file input
            event.target.value = '';
        }
        
        // API Access function
        function apiAccess() {
            if (!isAuthenticated) {
                showErrorNotification('Not authenticated. Please authenticate first.');
                return;
            }
            
            if (isOffline) {
                showErrorNotification('API access is disabled in offline mode.');
                return;
            }
            
            logEvent(`API Key: ${apiCredentials.key}`, 'command');
            logEvent(`API Secret: ${apiCredentials.secret}`, 'command');
            logEvent('Use these credentials with LangChain to train vials', 'command');
        }
        
        // Donate function
        function donate() {
            document.getElementById('donate-popup').classList.add('visible');
        }
        
        // Close donate popup
        function closeDonatePopup() {
            document.getElementById('donate-popup').classList.remove('visible');
        }
        
        // Handle command input
        function handleCommand() {
            const input = document.getElementById('prompt-input');
            const command = input.value.trim();
            input.value = '';
            
            if (!command) return;
            
            logEvent(`> ${command}`, 'command');
            
            if (command === '/help') {
                logEvent('Available commands:');
                logEvent('/status - Show vial status');
                logEvent('/balance - Show wallet balance');
                logEvent('/train <vial> - Train a specific vial');
                logEvent('/stop <vial> - Stop training a vial');
                logEvent('/blockchain - Show blockchain info');
                return;
            }
            
            if (command === '/status') {
                vials.forEach(vial => {
                    logEvent(`${vial.id}: ${vial.status} | FPS: ${Math.round(vial.fps)} | Latency: ${Math.round(vial.latency)}ms`);
                });
                return;
            }
            
            if (command === '/balance') {
                logEvent(`Wallet Balance: ${wallet.balance.toFixed(4)} $WEBXOS`, 'balance');
                logEvent(`Reputation: ${reputation}`, 'balance');
                return;
            }
            
            if (command.startsWith('/train ')) {
                const vialId = command.split(' ')[1];
                const vial = vials.find(v => v.id === vialId);
                if (vial) {
                    vial.isTraining = true;
                    vial.status = 'running';
                    logEvent(`Training started for ${vialId}`, 'success');
                    
                    // Simulate training
                    setTimeout(() => {
                        vial.isTraining = false;
                        vial.wallet.balance += 50;
                        wallet.balance = vials.reduce((sum, v) => sum + v.wallet.balance, 0);
                        updateBalanceDisplay();
                        logEvent(`Training completed for ${vialId}. Earned 50 $WEBXOS`, 'success');
                        updateVialStatusBars();
                    }, 3000);
                    
                    updateVialStatusBars();
                } else {
                    logEvent(`Vial ${vialId} not found`, 'error');
                }
                return;
            }
            
            if (command.startsWith('/stop ')) {
                const vialId = command.split(' ')[1];
                const vial = vials.find(v => v.id === vialId);
                if (vial) {
                    vial.isTraining = false;
                    logEvent(`Training stopped for ${vialId}`, 'warning');
                    updateVialStatusBars();
                } else {
                    logEvent(`Vial ${vialId} not found`, 'error');
                }
                return;
            }
            
            if (command === '/blockchain') {
                logEvent(`Blockchain height: ${blockchain.length}`, 'command');
                if (blockchain.length > 0) {
                    logEvent(`Last block hash: ${blockchain[blockchain.length-1].hash.substring(0, 16)}...`, 'command');
                }
                return;
            }
            
            logEvent(`Unknown command: ${command}. Type /help for available commands.`, 'error');
        }
        
        // FPS and performance monitoring
        function updatePerformanceMetrics() {
            const now = performance.now();
            frameCount++;
            
            if (now >= fpsUpdateTime + 1000) {
                fps = frameCount;
                frameCount = 0;
                fpsUpdateTime = now;
                
                // Update global latency (simulated)
                latency = Math.max(5, Math.min(200, latency + (Math.random() - 0.5) * 5));
                
                // Update vial metrics
                vials.forEach(vial => {
                    vial.fps = Math.max(30, Math.min(120, vial.fps + (Math.random() - 0.5) * 2));
                    vial.latency = Math.max(5, Math.min(200, vial.latency + (Math.random() - 0.5) * 5));
                });
                
                updateVialStatusBars();
            }
            
            lastUpdateTime = now;
            requestAnimationFrame(updatePerformanceMetrics);
        }
        
        // Neurot particle system
        function createNeurotParticles() {
            const neurotCount = 30;
            const neurotContainer = document.createElement('div');
            neurotContainer.id = 'neurot-container';
            document.body.appendChild(neurotContainer);
            
            for (let i = 0; i < neurotCount; i++) {
                createNeurot();
            }
            
            function createNeurot() {
                const neurot = document.createElement('div');
                neurot.className = 'neurot';
                
                const x = Math.random() * window.innerWidth;
                const y = Math.random() * window.innerHeight;
                const size = Math.random() * 3 + 1;
                const opacity = Math.random() * 0.5 + 0.3;
                
                neurot.style.left = `${x}px`;
                neurot.style.top = `${y}px`;
                neurot.style.width = `${size}px`;
                neurot.style.height = `${size}px`;
                neurot.style.opacity = opacity;
                
                neurotContainer.appendChild(neurot);
                animateNeurot(neurot);
            }
            
            function animateNeurot(neurot) {
                let x = parseFloat(neurot.style.left);
                let y = parseFloat(neurot.style.top);
                
                const xSpeed = (Math.random() - 0.5) * 0.3;
                const ySpeed = (Math.random() - 0.5) * 0.3;
                
                function move() {
                    x += xSpeed;
                    y += ySpeed;
                    
                    if (x > window.innerWidth) x = 0;
                    if (x < 0) x = window.innerWidth;
                    if (y > window.innerHeight) y = 0;
                    if (y < 0) y = window.innerHeight;
                    
                    neurot.style.left = `${x}px`;
                    neurot.style.top = `${y}px`;
                    
                    requestAnimationFrame(move);
                }
                
                move();
            }
        }
        
        // UUID generator
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
                const r = Math.random() * 16 | 0;
                return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
            });
        }
        
        // Initialize the application
        function initialize() {
            createNeurotParticles();
            initializeVials();
            updateVialStatusBars();
            updatePerformanceMetrics();
            
            // Set up event listeners
            document.getElementById('authButton').addEventListener('click', authenticate);
            document.getElementById('voidButton').addEventListener('click', voidVials);
            document.getElementById('quantumLinkButton').addEventListener('click', quantumLink);
            document.getElementById('exportButton').addEventListener('click', exportVials);
            document.getElementById('importButton').addEventListener('click', importFile);
            document.getElementById('apiAccessButton').addEventListener('click', apiAccess);
            document.getElementById('donateButton').addEventListener('click', donate);
            document.getElementById('donate-close').addEventListener('click', closeDonatePopup);
            document.getElementById('file-input').addEventListener('change', handleFileImport);
            document.getElementById('send-button').addEventListener('click', handleCommand);
            document.getElementById('prompt-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleCommand();
                }
            });
            
            logEvent('WebXOS Vial Wallet initialized successfully', 'success');
            logEvent('Type /help for available commands', 'command');
        }
        
        // Start the application when the page loads
        window.addEventListener('load', initialize);
    </script>
</body>
</html>