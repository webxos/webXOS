<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>XFORC3D: STRIKE | WEBXOS 2025</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      background:#000; color:#0f0; font-family:'Courier New', monospace;
      overflow:hidden; height:100vh; user-select:none;
    }
    #gameContainer { position:relative; width:100%; height:100vh; overflow:hidden; }
    #gameCanvas { position:absolute; inset:0; width:100%; height:100%; z-index:1; }
    #hud {
      position:absolute; inset:0; z-index:2; pointer-events:none;
      background:linear-gradient(rgba(0,20,0,0.1), rgba(0,20,0,0.1));
    }
    .hud-frame { position:absolute; border:1px solid #0f0; background:rgba(0,20,0,0.7); box-shadow:0 0 10px #0f0; }
    #radar { top:20px; left:20px; width:200px; height:200px; border-radius:50%; overflow:hidden; }
    #radar-display { position:absolute; inset:0; border-radius:50%;
      background:radial-gradient(circle, rgba(0,50,0,0.3) 0%, rgba(0,20,0,0.8) 70%); border:2px solid #0f0; }
    #radar-sweep { position:absolute; inset:0; border-radius:50%;
      background:conic-gradient(transparent 330deg, #0f0 360deg); opacity:0.3; animation:radar-sweep 4s linear infinite; }
    @keyframes radar-sweep { 0% { transform:rotate(0deg); } 100% { transform:rotate(360deg); } }

    #system-status { top:20px; right:20px; width:300px; height:150px; padding:10px; }
    .status-item { display:flex; justify-content:space-between; margin-bottom:5px; font-size:12px; }
    .status-value { color:#0f0; }

    #weapon-system { bottom:20px; left:20px; width:300px; height:110px; padding:10px; }
    #weapon-selector { display:flex; gap:10px; margin-bottom:10px; }
    .weapon-option { padding:5px 10px; border:1px solid #0f0; background:rgba(0,20,0,0.5); font-size:12px; cursor:pointer; pointer-events:auto; }
    .weapon-option.active { background:rgba(0,255,0,0.3); box-shadow:0 0 5px #0f0; }

    #targeting-system { bottom:20px; right:20px; width:300px; height:110px; padding:10px; }
    #target-info { font-size:12px; line-height:1.4; }

    /* Enhanced Crosshair */
    #crosshair { 
      position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); 
      width:60px; height:60px; z-index:10; pointer-events:none; 
    }
    .crosshair-dot {
      position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);
      width:4px; height:4px; background:#0f0; border-radius:50%;
      box-shadow:0 0 5px #0f0, 0 0 10px #0f0;
    }
    .crosshair-circle {
      position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);
      width:24px; height:24px; border:1px solid #0f0; border-radius:50%;
      box-shadow:0 0 5px #0f0;
    }
    .crosshair-line {
      position:absolute; background:#0f0; box-shadow:0 0 3px #0f0;
    }
    #crosshair-top { top:0; left:50%; width:1px; height:10px; transform:translateX(-50%); }
    #crosshair-bottom { bottom:0; left:50%; width:1px; height:10px; transform:translateX(-50%); }
    #crosshair-left { left:0; top:50%; width:10px; height:1px; transform:translateY(-50%); }
    #crosshair-right { right:0; top:50%; width:10px; height:1px; transform:translateY(-50%); }

    /* Mission Briefing - will fade out after a few seconds */
    #mission-briefing { 
      position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); 
      width:500px; height:300px; padding:20px; text-align:center; 
      display:none; flex-direction:column; justify-content:center;
      background:rgba(0,20,0,0.9); border:2px solid #0f0; z-index:5;
      box-shadow:0 0 20px #0f0;
      transition: opacity 1.5s ease-in-out;
    }
    #mission-title { font-size:28px; margin-bottom:20px; text-shadow:0 0 10px #0f0; }
    #mission-objectives { font-size:16px; line-height:1.5; margin-bottom:20px; }
    #briefing-continue { 
      margin-top:20px; padding:10px 20px; 
      background:rgba(0,30,0,0.7); border:1px solid #0f0; 
      color:#0f0; cursor:pointer; pointer-events:auto;
      transition: all 0.3s;
    }
    #briefing-continue:hover { background:rgba(0,60,0,0.7); box-shadow:0 0 10px #0f0; }

    #altitude-display { right:20px; top:50%; transform:translateY(-50%); width:40px; height:200px; border:1px solid #0f0; background:rgba(0,20,0,0.7); }
    #altitude-fill { position:absolute; bottom:0; width:100%; background:linear-gradient(to top, #0f0, #0a0); transition:height 0.2s; }
    #altitude-value { position:absolute; top:-20px; width:100%; text-align:center; font-size:12px; }

    #speed-display { left:20px; top:50%; transform:translateY(-50%); width:40px; height:200px; border:1px solid #0f0; background:rgba(0,20,0,0.7); }
    #speed-fill { position:absolute; bottom:0; width:100%; background:linear-gradient(to top, #0ff, #00f); transition:height 0.2s; }
    #speed-value { position:absolute; top:-20px; width:100%; text-align:center; font-size:12px; }

    #threat-warning { position:absolute; top:10%; left:50%; transform:translateX(-50%); font-size:18px; color:#f00; text-shadow:0 0 10px #f00; opacity:0; transition:opacity 0.3s; }

    #comms-log { position:absolute; bottom:130px; left:50%; transform:translateX(-50%); width:500px; height:80px; padding:10px; font-size:12px; overflow:hidden; }
    .comms-message { margin-bottom:5px; opacity:0.8; animation:comms-fade 5s forwards; }
    @keyframes comms-fade { 0%{opacity:0.8;} 80%{opacity:0.8;} 100%{opacity:0;} }

    #menu { position:absolute; inset:0; background:rgba(0,10,0,0.95); display:none; flex-direction:column; justify-content:center; align-items:center; z-index:100; }
    #menu-title { font-size:48px; margin-bottom:30px; text-shadow:0 0 20px #0f0; }
    .menu-button { padding:15px 30px; margin:10px; background:rgba(0,30,0,0.7); border:2px solid #0f0; color:#0f0; font-size:18px; cursor:pointer; text-shadow:0 0 5px #0f0; box-shadow:0 0 10px #0f0; transition:all 0.25s; pointer-events:auto; }
    .menu-button:hover { background:rgba(0,60,0,0.7); box-shadow:0 0 20px #0f0; }

    #game-over { position:absolute; inset:0; background:rgba(0,0,0,0.9); display:none; flex-direction:column; justify-content:center; align-items:center; z-index:100; }
    #game-over-title { font-size:48px; margin-bottom:20px; color:#f00; text-shadow:0 0 20px #f00; }
    #final-stats { font-size:18px; margin-bottom:30px; text-align:center; }

    #loading-screen { position:absolute; inset:0; background:#000; display:flex; flex-direction:column; justify-content:center; align-items:center; z-index:200; }
    #loading-title { font-size:36px; margin-bottom:30px; color:#0f0; text-shadow:0 0 10px #0f0; }
    #loading-bar { width:300px; height:20px; border:1px solid #0f0; background:rgba(0,20,0,0.7); overflow:hidden; }
    #loading-progress { height:100%; background:linear-gradient(90deg, #0f0, #0a0); width:0%; transition:width 0.5s; }
    #loading-text { margin-top:10px; font-size:14px; }

    .data-stream { position:absolute; inset:0; pointer-events:none; z-index:1; opacity:0.08;
      background:linear-gradient(transparent 50%, rgba(0,255,0,0.03) 50%); background-size:100% 4px; animation:data-stream 20s linear infinite; }
    @keyframes data-stream { 0%{background-position:0 0;} 100%{background-position:0 100%;} }
    
    #controls-hint { 
      position:absolute; bottom:20px; left:50%; transform:translateX(-50%); 
      font-size:12px; color:#0f0; text-align:center; 
      background:rgba(0,20,0,0.7); padding:5px 10px; border:1px solid #0f0; 
      transition: opacity 1s ease-in-out;
    }
    
    #credits { 
      position:absolute; inset:0; background:rgba(0,10,0,0.95); 
      display:none; flex-direction:column; justify-content:center; align-items:center; z-index:100; 
    }
    #credits-title { font-size:36px; margin-bottom:20px; text-shadow:0 0 10px #0f0; }
    .credits-text { font-size:16px; margin-bottom:10px; text-align:center; line-height:1.5; }
  </style>
</head>
<body>
  <div id="gameContainer">
    <div class="data-stream"></div>

    <div id="loading-screen">
      <div id="loading-title">XFORC3D: STRIKE</div>
      <div id="loading-bar"><div id="loading-progress"></div></div>
      <div id="loading-text">INITIALIZING COMBAT SYSTEMS...</div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="hud">
      <div id="radar" class="hud-frame">
        <div id="radar-display"></div><div id="radar-sweep"></div>
      </div>

      <div id="system-status" class="hud-frame">
        <div class="status-item"><span>SYSTEM STATUS:</span><span class="status-value" id="system-status-value">STANDBY</span></div>
        <div class="status-item"><span>POWER:</span><span class="status-value" id="power-value">100%</span></div>
        <div class="status-item"><span>FUEL:</span><span class="status-value" id="fuel-value">100%</span></div>
        <div class="status-item"><span>ARMOR:</span><span class="status-value" id="armor-value">100%</span></div>
        <div class="status-item"><span>WEAPONS:</span><span class="status-value" id="weapons-value">ONLINE</span></div>
        <div class="status-item"><span>TARGETING:</span><span class="status-value" id="targeting-value">ACTIVE</span></div>
      </div>

      <div id="weapon-system" class="hud-frame">
        <div id="weapon-selector">
          <div class="weapon-option active" data-weapon="gatling">GATLING</div>
          <div class="weapon-option" data-weapon="rockets">ROCKETS</div>
          <div class="weapon-option" data-weapon="missiles">MISSILES</div>
        </div>
        <div id="weapon-status">
          <div class="status-item"><span>AMMO:</span><span class="status-value" id="ammo-value">∞</span></div>
          <div class="status-item"><span>MODE:</span><span class="status-value" id="fire-mode">AUTO</span></div>
        </div>
      </div>

      <div id="targeting-system" class="hud-frame">
        <div id="target-info">
          <div>TARGET: <span id="target-name">NONE</span></div>
          <div>DISTANCE: <span id="target-distance">---</span></div>
          <div>THREAT: <span id="target-threat">LOW</span></div>
          <div>LOCK: <span id="target-lock">---</span></div>
        </div>
      </div>

      <!-- Enhanced Crosshair -->
      <div id="crosshair">
        <div class="crosshair-dot"></div>
        <div class="crosshair-circle"></div>
        <div id="crosshair-top" class="crosshair-line"></div>
        <div id="crosshair-bottom" class="crosshair-line"></div>
        <div id="crosshair-left" class="crosshair-line"></div>
        <div id="crosshair-right" class="crosshair-line"></div>
      </div>

      <!-- Mission Briefing - Will fade out after a few seconds -->
      <div id="mission-briefing">
        <div id="mission-title">OPERATION: URBAN STRIKE</div>
        <div id="mission-objectives">
          - NEUTRALIZE ENEMY AIR DEFENSES<br>
          - CLEAR DESIGNATED ZONES<br>
          - PROTECT CIVILIAN INFRASTRUCTURE<br>
          - ELIMINATE HOSTILE FORCES
        </div>
        <div id="briefing-continue">CLICK TO CONTINUE</div>
      </div>

      <div id="altitude-display" class="hud-frame">
        <div id="altitude-value">ALT</div><div id="altitude-fill" style="height:50%;"></div>
      </div>

      <div id="speed-display" class="hud-frame">
        <div id="speed-value">SPD</div><div id="speed-fill" style="height:30%;"></div>
      </div>

      <div id="threat-warning">THREAT ALERT!</div>
      <div id="comms-log" class="hud-frame"></div>
      <div id="controls-hint">CLICK/F: FIRE │ WASD: MOVE │ MOUSE: AIM │ SPACE: ASCEND │ SHIFT: DESCEND │ 1-3: WEAPONS │ ESC: PAUSE</div>
    </div>

    <div id="menu">
      <div id="menu-title">XFORC3D: STRIKE</div>
      <div class="menu-button" id="start-button">START MISSION</div>
      <div class="menu-button" id="credits-button">CREDITS</div>
    </div>
    
    <div id="credits">
      <div id="credits-title">CREDITS</div>
      <div class="credits-text">XFORC3D: STRIKE</div>
      <div class="credits-text">Developed by WEBXOS</div>
      <div class="credits-text">© 2025 WebXOS. All rights reserved.</div>
      <div class="credits-text">x.com/webxos</div>
      <div class="credits-text">webxos.netlify.app</div>
      <div class="menu-button" id="back-button">BACK</div>
    </div>

    <div id="pause-menu" style="display:none;">
      <div id="menu-title">GAME PAUSED</div>
      <div class="menu-button" id="resume-button">RESUME MISSION</div>
      <div class="menu-button" id="restart-button">RESTART MISSION</div>
      <div class="menu-button" id="main-menu-button">MAIN MENU</div>
    </div>

    <div id="game-over">
      <div id="game-over-title">MISSION FAILED</div>
      <div id="final-stats">
        <div>ENEMIES ELIMINATED: <span id="final-kills">0</span></div>
        <div>MISSION TIME: <span id="final-time">00:00</span></div>
        <div>DAMAGE TAKEN: <span id="final-damage">0%</span></div>
        <div>ACCURACY: <span id="final-accuracy">0%</span></div>
      </div>
      <div class="menu-button" id="restart-end-button">RESTART MISSION</div>
      <div class="menu-button" id="menu-end-button">MAIN MENU</div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Core
    let scene, camera, renderer, helicopter, clock = new THREE.Clock();
    let cityGeometry = [], enemies = [];
    let playerProjectiles = [], enemyProjectiles = [];
    let gameActive = false, gameOver = false;

    // Stats
    let missionTime = 0, enemiesKilled = 0, shotsFired = 0, shotsHit = 0;
    let damageTaken = 0, missionTimerId = null;

    const player = {
      health: 100, fuel: 100,
      ammo: { gatling: Infinity, rockets: 20, missiles: 10 },
      currentWeapon: 'gatling',
      altitude: 50, speed: 0,
      lastFire: 0
    };

    const controls = { 
      forward:false, backward:false, left:false, right:false, 
      up:false, down:false, fire:false, zoom:false,
      mouseX: 0, mouseY: 0
    };

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x001122);
      scene.fog = new THREE.Fog(0x001122, 50, 300);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

      renderer = new THREE.WebGLRenderer({ 
        canvas: document.getElementById('gameCanvas'), 
        antialias: false 
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));

      createCity();
      createHelicopter();
      createLighting();
      simulateLoading();
      setupEvents();
      animate();
    }

    function simulateLoading() {
      let progress = 0;
      const loadingInterval = setInterval(() => {
        progress += 2;
        document.getElementById('loading-progress').style.width = `${progress}%`;
        if (progress >= 100) {
          clearInterval(loadingInterval);
          setTimeout(() => {
            document.getElementById('loading-screen').style.display = 'none';
            document.getElementById('menu').style.display = 'flex';
          }, 300);
        }
      }, 40);
    }

    function showMissionBriefing() {
      document.getElementById('mission-briefing').style.display = 'flex';
      
      document.getElementById('briefing-continue').addEventListener('click', startGameplay, { once: true });
      
      const keyHandler = (e) => {
        if (e.code === 'Space' || e.code === 'Enter') {
          startGameplay();
          document.removeEventListener('keydown', keyHandler);
        }
      };
      document.addEventListener('keydown', keyHandler, { once: true });
    }

    function createCity() {
      createDistrict(-100, 0, -100, 8, 8);
      createDistrict(100, 0, -100, 8, 8);
      createDistrict(-100, 0, 100, 8, 8);
      createDistrict(100, 0, 100, 8, 8);
      createDistrict(0, 0, 0, 12, 12);

      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(1000, 1000, 1, 1),
        new THREE.MeshBasicMaterial({ color:0x003300, wireframe:true })
      );
      ground.rotation.x = -Math.PI / 2;
      scene.add(ground);

      const gridHelper = new THREE.GridHelper(1000, 50, 0x00ff00, 0x003300);
      gridHelper.position.y = 0.1;
      scene.add(gridHelper);
    }

    function createDistrict(x, y, z, rows, cols) {
      const mat = new THREE.MeshBasicMaterial({ color:0x001100, wireframe:true });
      for (let i=0;i<rows;i++) for (let j=0;j<cols;j++) {
        if (Math.random() < 0.2) continue;
        const h = 10 + Math.random()*40, w = 5 + Math.random()*10, d = 5 + Math.random()*10;
        const b = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), mat);
        b.position.set(x + i*20 - (rows*20)/2, h/2, z + j*20 - (cols*20)/2);
        cityGeometry.push(b); scene.add(b);
      }
    }

    function createHelicopter() {
      helicopter = new THREE.Group();
      const bodyMat = new THREE.MeshBasicMaterial({ color:0x00ff00, wireframe:true });
      
      helicopter.userData = {};
      
      helicopter.add(new THREE.Mesh(new THREE.BoxGeometry(3,1.5,6), bodyMat));
      
      const cockpit = new THREE.Mesh(new THREE.SphereGeometry(1,8,8), bodyMat);
      cockpit.position.set(0, 0.8, -1); 
      helicopter.add(cockpit);
      
      const tail = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,4), bodyMat);
      tail.position.set(0, 0.2, 4); 
      helicopter.add(tail);
      
      const mainRotor = new THREE.Mesh(new THREE.BoxGeometry(10,0.2,1), bodyMat);
      mainRotor.position.set(0,1.5,0); 
      helicopter.add(mainRotor);
      helicopter.userData.mainRotor = mainRotor;
      
      const tailRotor = new THREE.Mesh(new THREE.BoxGeometry(1,0.2,0.2), bodyMat);
      tailRotor.position.set(0,0.5,5.5); 
      helicopter.add(tailRotor);
      helicopter.userData.tailRotor = tailRotor;

      helicopter.position.set(0,50,0);
      scene.add(helicopter);

      camera.position.set(0, 1, -3);
      helicopter.add(camera);
    }

    function createLighting() {
      scene.add(new THREE.AmbientLight(0x202020));
      const dir = new THREE.DirectionalLight(0x00ff00, 0.5);
      dir.position.set(10,20,10); 
      scene.add(dir);
      
      for (let i=0;i<5;i++) {
        const l = new THREE.PointLight(0x00ff00, 0.5, 50);
        l.position.set((Math.random()-0.5)*200, 30+Math.random()*50, (Math.random()-0.5)*200);
        scene.add(l);
      }
    }

    function setupEvents() {
      // Keyboard events
      document.addEventListener('keydown', (e) => {
        if (!gameActive || gameOver) return;
        
        switch(e.code) {
          case 'KeyW': controls.forward = true; break;
          case 'KeyS': controls.backward = true; break;
          case 'KeyA': controls.left = true; break;
          case 'KeyD': controls.right = true; break;
          case 'Space': controls.up = true; break;
          case 'ShiftLeft': controls.down = true; break;
          case 'KeyF': controls.fire = true; break;
          case 'KeyZ': controls.zoom = true; break;
          case 'Digit1': selectWeapon('gatling'); break;
          case 'Digit2': selectWeapon('rockets'); break;
          case 'Digit3': selectWeapon('missiles'); break;
          case 'Escape': togglePause(); break;
        }
      });

      document.addEventListener('keyup', (e) => {
        switch(e.code) {
          case 'KeyW': controls.forward = false; break;
          case 'KeyS': controls.backward = false; break;
          case 'KeyA': controls.left = false; break;
          case 'KeyD': controls.right = false; break;
          case 'Space': controls.up = false; break;
          case 'ShiftLeft': controls.down = false; break;
          case 'KeyF': controls.fire = false; break;
          case 'KeyZ': controls.zoom = false; break;
        }
      });

      // Mouse events
      document.addEventListener('mousedown', (e) => {
        if (!gameActive || gameOver) return;
        
        if (e.button === 0) controls.fire = true;
        if (e.button === 2) controls.zoom = true;
      });
      
      document.addEventListener('mouseup', (e) => {
        if (e.button === 0) controls.fire = false;
        if (e.button === 2) controls.zoom = false;
      });
      
      document.addEventListener('contextmenu', (e) => e.preventDefault());

      // Pointer lock implementation for mouse movement
      document.addEventListener('click', () => {
        if (gameActive && !gameOver && !document.pointerLockElement) {
          renderer.domElement.requestPointerLock();
        }
      });

      document.addEventListener('pointerlockchange', () => {
        if (document.pointerLockElement === renderer.domElement) {
          document.addEventListener('mousemove', updateMouseLook, false);
        } else {
          document.removeEventListener('mousemove', updateMouseLook, false);
        }
      });

      // Window resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // UI events
      document.getElementById('start-button').addEventListener('click', startGame);
      document.getElementById('credits-button').addEventListener('click', showCredits);
      document.getElementById('back-button').addEventListener('click', showMainMenu);
      document.getElementById('resume-button').addEventListener('click', resumeGame);
      document.getElementById('restart-button').addEventListener('click', restartGame);
      document.getElementById('main-menu-button').addEventListener('click', showMainMenu);
      document.getElementById('restart-end-button').addEventListener('click', restartGame);
      document.getElementById('menu-end-button').addEventListener('click', showMainMenu);

      document.querySelectorAll('.weapon-option').forEach(opt => {
        opt.addEventListener('click', () => selectWeapon(opt.dataset.weapon));
      });
    }

    function updateMouseLook(e) {
      if (!gameActive || gameOver) return;
      
      controls.mouseX = e.movementX * 0.002;
      controls.mouseY = e.movementY * 0.002;
      
      helicopter.rotation.y -= controls.mouseX;
      camera.rotation.x = Math.max(-Math.PI/3, Math.min(Math.PI/3, camera.rotation.x - controls.mouseY));
    }

    function selectWeapon(weapon) {
      player.currentWeapon = weapon;
      document.querySelectorAll('.weapon-option').forEach(o => o.classList.remove('active'));
      const el = document.querySelector(`[data-weapon="${weapon}"]`);
      if (el) el.classList.add('active');
      document.getElementById('ammo-value').textContent = player.ammo[weapon] === Infinity ? '∞' : player.ammo[weapon];
    }

    function startGame() {
      document.getElementById('menu').style.display = 'none';
      showMissionBriefing();
    }

    function startGameplay() {
      document.getElementById('mission-briefing').style.opacity = '0';
      setTimeout(() => {
        document.getElementById('mission-briefing').style.display = 'none';
      }, 1500);
      
      document.getElementById('game-over').style.display = 'none';
      gameActive = true; 
      gameOver = false;

      // Reset stats/state
      missionTime = 0; 
      enemiesKilled = 0; 
      shotsFired = 0; 
      shotsHit = 0; 
      damageTaken = 0;
      player.health = 100; 
      player.fuel = 100;
      player.ammo.rockets = 20; 
      player.ammo.missiles = 10;
      player.altitude = 50; 
      player.speed = 0; 
      player.lastFire = 0;
      selectWeapon(player.currentWeapon);

      // Reset position/orientation
      helicopter.position.set(0,50,0);
      helicopter.rotation.set(0,0,0);
      camera.rotation.set(0,0,0);

      // Clear world arrays and scene actors
      for (const e of enemies) scene.remove(e); 
      enemies = [];
      for (const p of playerProjectiles) scene.remove(p); 
      playerProjectiles = [];
      for (const p of enemyProjectiles) scene.remove(p); 
      enemyProjectiles = [];

      // Timer cleanup and restart
      if (missionTimerId) { 
        clearInterval(missionTimerId); 
        missionTimerId = null; 
      }
      
      missionTimerId = setInterval(() => {
        if (gameActive && !gameOver) { 
          missionTime++; 
          updateTimer(); 
        }
      }, 1000);

      spawnEnemies(5);
      addCommsMessage("Command: Mission initiated. Clear the urban zone of hostile forces.");
      document.getElementById('system-status-value').textContent = 'OPERATIONAL';
      
      // Request pointer lock for mouse control
      renderer.domElement.requestPointerLock();
      
      // Hide controls hint after game starts
      setTimeout(() => {
        document.getElementById('controls-hint').style.opacity = '0.5';
      }, 5000);
    }

    function restartGame() {
      endGameCleanup();
      startGameplay();
    }

    function resumeGame() {
      document.getElementById('pause-menu').style.display = 'none';
      gameActive = true;
      gameOver = false;
      renderer.domElement.requestPointerLock();
    }

    function showMainMenu() {
      endGameCleanup();
      document.getElementById('menu').style.display = 'flex';
      document.getElementById('pause-menu').style.display = 'none';
      document.getElementById('game-over').style.display = 'none';
      document.getElementById('credits').style.display = 'none';
      gameActive = false;
    }

    function showCredits() {
      document.getElementById('menu').style.display = 'none';
      document.getElementById('credits').style.display = 'flex';
    }

    function togglePause() {
      if (gameOver) return;
      
      if (gameActive) {
        gameActive = false;
        document.getElementById('pause-menu').style.display = 'flex';
        if (document.pointerLockElement) document.exitPointerLock();
        addCommsMessage("System: Paused.");
      } else {
        resumeGame();
      }
    }

    function updateTimer() {
      const m = Math.floor(missionTime / 60);
      const s = missionTime % 60;
      document.getElementById('timer-value').textContent = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
    }

    function addCommsMessage(msg) {
      const log = document.getElementById('comms-log');
      const el = document.createElement('div');
      el.className = 'comms-message'; 
      el.textContent = msg;
      log.appendChild(el);
      while (log.children.length > 4) log.removeChild(log.firstChild);
    }

    function spawnEnemies(count) {
      for (let i=0;i<count;i++) {
        const enemy = new THREE.Mesh(
          new THREE.BoxGeometry(2,2,2),
          new THREE.MeshBasicMaterial({ color:0xff0000, wireframe:true })
        );
        
        // Spawn enemies at a safe distance from player
        let spawnX, spawnZ;
        do {
          spawnX = (Math.random()-0.5)*400;
          spawnZ = (Math.random()-0.5)*400;
        } while (Math.sqrt(spawnX*spawnX + spawnZ*spawnZ) < 100);
        
        enemy.position.set(spawnX, 5 + Math.random()*20, spawnZ);
        enemy.userData = { 
          health:30, 
          type:'ground', 
          lastShot:0,
          speed: 2 + Math.random() * 3
        };
        enemies.push(enemy); 
        scene.add(enemy);
      }
      addCommsMessage(`Intel: ${count} hostile targets detected in the area.`);
    }

    function updateHelicopter(dt) {
      if (!gameActive || gameOver) return;

      // Movement with proper rotation handling
      const moveSpeed = 30 * dt;
      const rotSpeed = 2 * dt;
      
      // Calculate movement direction based on helicopter rotation
      const direction = new THREE.Vector3();
      
      if (controls.forward) direction.z -= moveSpeed;
      if (controls.backward) direction.z += moveSpeed;
      if (controls.left) direction.x -= moveSpeed;
      if (controls.right) direction.x += moveSpeed;
      
      // Apply rotation to movement direction
      direction.applyEuler(new THREE.Euler(0, helicopter.rotation.y, 0));
      
      // Vertical movement
      if (controls.up) direction.y += moveSpeed;
      if (controls.down) direction.y -= moveSpeed;

      // Apply movement
      helicopter.position.add(direction);

      // Update player stats
      player.altitude = helicopter.position.y;
      player.speed = direction.length() / dt;

      // Fuel consumption - only when moving
      const isMoving = controls.forward || controls.backward || controls.left || controls.right || 
                       controls.up || controls.down;
      player.fuel = Math.max(0, player.fuel - dt * (isMoving ? 0.5 : 0.1));

      // Rotor animation
      if (helicopter.userData.mainRotor) {
        helicopter.userData.mainRotor.rotation.y += dt * 12;
      }
      if (helicopter.userData.tailRotor) {
        helicopter.userData.tailRotor.rotation.x += dt * 24;
      }

      // Weapon firing
      if (controls.fire) fireWeapon();
      
      // Camera zoom
      camera.fov = controls.zoom ? 30 : 75; 
      camera.updateProjectionMatrix();

      // Boundary checks
      helicopter.position.x = Math.max(-200, Math.min(200, helicopter.position.x));
      helicopter.position.z = Math.max(-200, Math.min(200, helicopter.position.z));
      helicopter.position.y = Math.max(10, Math.min(150, helicopter.position.y));

      updateHUD();
    }

    function fireWeapon() {
      const now = performance.now();
      const w = player.currentWeapon;
      const ammo = player.ammo[w];

      if (w !== 'gatling' && ammo <= 0) return;

      let rate = 100; 
      if (w==='gatling') rate=50; 
      if (w==='rockets') rate=500; 
      if (w==='missiles') rate=1000;
      
      if (now - player.lastFire < rate) return;
      player.lastFire = now;

      if (w !== 'gatling') player.ammo[w]--;
      shotsFired++;

      const geom = new THREE.SphereGeometry(0.12, 6, 6);
      let mat = new THREE.MeshBasicMaterial({ color:0xffff00 });
      if (w==='rockets') mat = new THREE.MeshBasicMaterial({ color:0xff8800 });
      if (w==='missiles') mat = new THREE.MeshBasicMaterial({ color:0xff0000 });

      const projectile = new THREE.Mesh(geom, mat);
      
      // Position projectile in front of helicopter
      const projectileOffset = new THREE.Vector3(0, 0, -2);
      projectileOffset.applyQuaternion(helicopter.quaternion);
      projectile.position.copy(helicopter.position).add(projectileOffset);

      // Calculate direction based on camera orientation
      const dir = new THREE.Vector3(); 
      camera.getWorldDirection(dir);
      
      let speed = 50; 
      if (w==='rockets') speed = 30; 
      if (w==='missiles') speed = 40;

      projectile.userData = { 
        velocity: dir.multiplyScalar(speed), 
        damage: (w==='gatling'?5:(w==='rockets'?15:25)), 
        ttl: 4 
      };
      
      playerProjectiles.push(projectile); 
      scene.add(projectile);

      document.getElementById('ammo-value').textContent = player.ammo[w] === Infinity ? '∞' : player.ammo[w];
    }

    function updatePlayerProjectiles(dt) {
      for (let i=playerProjectiles.length-1;i>=0;i--) {
        const p = playerProjectiles[i];
        p.position.add(p.userData.velocity.clone().multiplyScalar(dt));
        p.userData.ttl -= dt;

        // Collision detection with enemies
        for (let j=enemies.length-1;j>=0;j--) {
          const e = enemies[j];
          if (p.position.distanceTo(e.position) < 3) {
            e.userData.health -= p.userData.damage;
            shotsHit++;
            createExplosion(p.position);
            scene.remove(p); 
            playerProjectiles.splice(i,1);

            if (e.userData.health <= 0) {
              scene.remove(e); 
              enemies.splice(j,1); 
              enemiesKilled++;
              addCommsMessage("Target eliminated.");
              
              // Spawn new enemies if we're getting low, but cap at 20 total kills for victory
              if (enemies.length < 3 && enemiesKilled < 20) {
                spawnEnemies(2);
              }
            }
            break;
          }
        }

        if (p.userData.ttl <= 0 || p.position.distanceTo(helicopter.position) > 250) {
          scene.remove(p); 
          playerProjectiles.splice(i,1);
        }
      }
    }

    function enemyFire(enemy) {
      const geom = new THREE.SphereGeometry(0.2, 6, 6);
      const mat = new THREE.MeshBasicMaterial({ color:0xff0000 });
      const proj = new THREE.Mesh(geom, mat);
      proj.position.copy(enemy.position); 
      proj.position.y += 1;
      
      const dir = new THREE.Vector3(); 
      dir.subVectors(helicopter.position, enemy.position).normalize();
      
      proj.userData = { 
        velocity: dir.multiplyScalar(20), 
        damage: 5, 
        ttl: 6 
      };
      
      enemyProjectiles.push(proj); 
      scene.add(proj);
    }

    function updateEnemyProjectiles(dt) {
      for (let i=enemyProjectiles.length-1;i>=0;i--) {
        const p = enemyProjectiles[i];
        p.position.add(p.userData.velocity.clone().multiplyScalar(dt));
        p.userData.ttl -= dt;

        if (p.position.distanceTo(helicopter.position) < 3) {
          player.health = Math.max(0, player.health - p.userData.damage);
          damageTaken += p.userData.damage;
          flashThreat();
          createExplosion(p.position);
          scene.remove(p); 
          enemyProjectiles.splice(i,1);
          
          if (player.health <= 0) { 
            endGame(false); 
          }
          continue;
        }

        if (p.userData.ttl <= 0) { 
          scene.remove(p); 
          enemyProjectiles.splice(i,1); 
        }
      }
    }

    function updateEnemies(dt) {
      for (const e of enemies) {
        // Move toward player but maintain altitude
        const dir = new THREE.Vector3(); 
        dir.subVectors(helicopter.position, e.position).normalize();
        dir.y = 0; // Keep enemies at ground level
        
        e.position.add(dir.multiplyScalar(e.userData.speed * dt));
        
        // Keep enemies within bounds
        e.position.x = Math.max(-190, Math.min(190, e.position.x));
        e.position.z = Math.max(-190, Math.min(190, e.position.z));
        
        // Face the player
        e.lookAt(helicopter.position);
        
        // Enemy firing
        const now = performance.now();
        if (now - (e.userData.lastShot || 0) > 2000) { 
          enemyFire(e); 
          e.userData.lastShot = now; 
        }
      }
    }

    function flashThreat() {
      const tw = document.getElementById('threat-warning');
      tw.style.opacity = 1; 
      setTimeout(() => tw.style.opacity = 0, 500);
    }

    function updateHUD() {
      document.getElementById('power-value').textContent = `${Math.round(player.health)}%`;
      document.getElementById('fuel-value').textContent = `${Math.round(player.fuel)}%`;
      document.getElementById('armor-value').textContent = `${Math.round(player.health)}%`;

      const altPct = Math.max(0, Math.min(100, (player.altitude / 150) * 100));
      const spdPct = Math.max(0, Math.min(100, (player.speed / 100) * 100));
      
      document.getElementById('altitude-fill').style.height = `${altPct}%`;
      document.getElementById('speed-fill').style.height = `${spdPct}%`;

      if (enemies.length > 0) {
        const closest = enemies.reduce((a,b) =>
          (a.position.distanceTo(helicopter.position) < b.position.distanceTo(helicopter.position)) ? a : b);
        const d = Math.round(closest.position.distanceTo(helicopter.position));
        document.getElementById('target-name').textContent = 'HOSTILE';
        document.getElementById('target-distance').textContent = `${d}m`;
        document.getElementById('target-threat').textContent = d < 50 ? 'HIGH' : 'MEDIUM';
        document.getElementById('target-lock').textContent = d < 100 ? 'ACQUIRED' : 'SCANNING';
      } else {
        document.getElementById('target-name').textContent = 'NONE';
        document.getElementById('target-distance').textContent = '---';
        document.getElementById('target-threat').textContent = 'LOW';
        document.getElementById('target-lock').textContent = '---';
      }
      
      // Check for victory condition
      if (enemiesKilled >= 20 && enemies.length === 0) {
        endGame(true);
      }
      
      // Check for failure conditions
      if (player.fuel <= 0 || player.health <= 0) {
        endGame(false);
      }
    }

    function createExplosion(position) {
      const exp = new THREE.Mesh(
        new THREE.SphereGeometry(2, 6, 6),
        new THREE.MeshBasicMaterial({ color:0xff6600, wireframe:true })
      );
      exp.position.copy(position); 
      scene.add(exp);
      setTimeout(() => scene.remove(exp), 200);
    }

    function endGame(victory) {
      if (gameOver) return;
      gameActive = false; 
      gameOver = true;

      if (document.pointerLockElement) document.exitPointerLock();
      
      document.getElementById('game-over').style.display = 'flex';
      const t = document.getElementById('game-over-title');
      
      if (victory) { 
        t.textContent = 'MISSION ACCOMPLISHED'; 
        t.style.color = '#0f0'; 
        t.style.textShadow = '0 0 20px #0f0'; 
      } else { 
        t.textContent = 'MISSION FAILED'; 
        t.style.color = '#f00'; 
        t.style.textShadow = '0 0 20px #f00'; 
      }

      document.getElementById('final-kills').textContent = enemiesKilled;
      const m = Math.floor(missionTime / 60), s = missionTime % 60;
      document.getElementById('final-time').textContent = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
      document.getElementById('final-damage').textContent = `${Math.min(100, 100 - player.health)}%`;
      const acc = shotsFired > 0 ? Math.round((shotsHit / shotsFired) * 100) : 0;
      document.getElementById('final-accuracy').textContent = `${acc}%`;
      
      addCommsMessage(victory ? "Command: Area secured. Well done." : "Command: Abort. Hull integrity lost.");
    }

    function endGameCleanup() {
      if (missionTimerId) { 
        clearInterval(missionTimerId); 
        missionTimerId = null; 
      }
      for (const p of playerProjectiles) scene.remove(p); 
      playerProjectiles = [];
      for (const p of enemyProjectiles) scene.remove(p); 
      enemyProjectiles = [];
      document.getElementById('game-over').style.display = 'none';
      if (document.pointerLockElement) document.exitPointerLock();
    }

    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.05);

      if (gameActive && !gameOver) {
        updateHelicopter(dt);
        updatePlayerProjectiles(dt);
        updateEnemies(dt);
        updateEnemyProjectiles(dt);
      }
      renderer.render(scene, camera);
    }

    // Initialize the game
    window.addEventListener('load', init);
  </script>
</body>
</html>