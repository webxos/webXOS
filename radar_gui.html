<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>webXOS IoT RADAR HUD TEMPLATE</title>
    <meta name="theme-color" content="#000000">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
        }
        
        body {
            background: #000;
            color: #0f0;
            overflow: hidden;
            height: 100vh;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        #appContainer {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }
        
        .matrix-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                linear-gradient(rgba(0, 255, 0, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 0, 0.05) 1px, transparent 1px);
            background-size: 20px 20px;
            opacity: 0.3;
            z-index: 1;
        }
        
        .crt-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, transparent 50%, rgba(0, 20, 0, 0.1) 50%);
            background-size: 100% 4px;
            z-index: 5;
            pointer-events: none;
            animation: scanline 8s linear infinite;
        }
        
        @keyframes scanline {
            0% { background-position: 0 0; }
            100% { background-position: 0 100%; }
        }
        
        #visualizationContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }
        
        #ideInterface {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }
        
        /* Header with Glitch Effect */
        .header {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 40px;
            background: rgba(0, 0, 0, 0.8);
            border-bottom: 1px solid #0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 12;
            overflow: hidden;
            animation: glitch 5s infinite;
            pointer-events: none;
        }
        
        @keyframes glitch {
            0%, 100% { transform: translateX(0); }
            5% { transform: translateX(-1px); }
            10% { transform: translateX(1px); }
            15% { transform: translateX(-1px); }
            20% { transform: translateX(1px); }
            25% { transform: translateX(0); }
            50% { transform: translateX(0); }
            55% { transform: translateX(-1px) skewX(-1deg); }
            60% { transform: translateX(1px) skewX(1deg); }
            65% { transform: translateX(-1px) skewX(-1deg); }
            70% { transform: translateX(1px) skewX(1deg); }
            75% { transform: translateX(0); }
        }
        
        .header-text {
            font-size: 14px;
            color: #0f0;
            letter-spacing: 1px;
            text-shadow: 0 0 5px #0f0;
        }
        
        /* Control Buttons */
        .ctrl-btn {
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #0f0;
            color: #0f0;
            font-size: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 2px 2px 0 #000;
            transform: skew(-2deg);
            transition: all 0.2s;
            pointer-events: auto;
            position: relative;
            z-index: 11;
        }
        
        .ctrl-btn:hover, .ctrl-btn:active {
            background: #0f0;
            color: #000;
        }
        
        .ctrl-btn.active {
            background: #0f0;
            color: #000;
        }
        
        /* Control Containers */
        .main-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 11;
            pointer-events: none;
        }
        
        .main-controls > * {
            pointer-events: auto;
        }
        
        /* Status Panel */
        .status-panel {
            position: absolute;
            top: 50px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #0f0;
            padding: 10px;
            font-size: 10px;
            z-index: 11;
            pointer-events: none;
            max-width: 200px;
        }
        
        .status-item {
            margin-bottom: 5px;
        }
        
        .status-value {
            color: #0ff;
        }
        
        /* Terminal Panel */
        .terminal-panel {
            position: absolute;
            bottom: 100px;
            left: 10px;
            width: 300px;
            height: 200px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #0f0;
            z-index: 11;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .terminal-header {
            background: rgba(0, 20, 0, 0.9);
            padding: 5px;
            font-size: 10px;
            border-bottom: 1px solid #0f0;
        }
        
        .terminal-content {
            flex: 1;
            overflow-y: auto;
            padding: 5px;
            font-size: 9px;
            pointer-events: auto;
        }
        
        .terminal-item {
            margin-bottom: 3px;
            cursor: pointer;
            padding: 2px;
            pointer-events: auto;
            border-bottom: 1px solid rgba(0, 255, 0, 0.1);
        }
        
        .terminal-item:hover {
            background: rgba(0, 255, 0, 0.1);
        }
        
        .terminal-item.active {
            background: rgba(0, 255, 0, 0.2);
        }
        
        /* Radar Panel */
        .radar-panel {
            position: absolute;
            top: 50px;
            left: 10px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #0f0;
            z-index: 11;
            overflow: hidden;
        }
        
        .radar-canvas {
            width: 100%;
            height: 100%;
        }
        
        /* Object Tag Editor */
        .tag-editor {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 10, 0, 0.95);
            border: 2px solid #0f0;
            padding: 15px;
            z-index: 20;
            display: none;
            width: 250px;
            pointer-events: auto;
        }
        
        .tag-editor input {
            width: 100%;
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 5px;
            margin-bottom: 10px;
            font-size: 12px;
        }
        
        .tag-editor button {
            width: 100%;
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 5px;
            cursor: pointer;
            margin-top: 5px;
        }
        
        .tag-editor button:hover {
            background: #0f0;
            color: #000;
        }
        
        /* Mobile Optimization */
        @media (max-width: 767px) {
            .ctrl-btn {
                width: 50px;
                height: 50px;
                font-size: 7px;
            }
            
            .main-controls {
                bottom: 15px;
                gap: 8px;
            }
            
            .status-panel {
                font-size: 8px;
                max-width: 150px;
            }
            
            .terminal-panel {
                width: 250px;
                height: 150px;
            }
            
            .radar-panel {
                width: 120px;
                height: 120px;
            }
        }
    </style>
</head>
<body>
    <div id="appContainer">
        <div class="matrix-grid"></div>
        <div class="crt-overlay"></div>
        
        <!-- Header -->
        <div class="header">
            <div class="header-text">webXOS IoT RADAR HUD TEMPLATE</div>
        </div>
        
        <!-- 3D SCENE -->
        <div id="visualizationContainer">
            <canvas id="visualizationCanvas"></canvas>
        </div>
        
        <div id="ideInterface">
            <!-- STATUS PANEL -->
            <div class="status-panel">
                <div class="status-item">FRAMES: <span id="fpsCounter" class="status-value">60</span></div>
                <div class="status-item">OBJECTS: <span id="objectCount" class="status-value">0</span></div>
                <div class="status-item">FACING: <span id="faceDirection" class="status-value">0°</span></div>
                <div class="status-item">MODE: <span id="modeStatus" class="status-value">MIRROR</span></div>
                <div class="status-item">SELECTED: <span id="selectedObject" class="status-value">NONE</span></div>
            </div>
            
            <!-- TERMINAL PANEL -->
            <div class="terminal-panel">
                <div class="terminal-header">OBJECT TERMINAL</div>
                <div class="terminal-content" id="terminalContent">
                    <!-- Object list will be populated here -->
                </div>
            </div>
            
            <!-- RADAR PANEL -->
            <div class="radar-panel">
                <canvas class="radar-canvas" id="radarCanvas"></canvas>
            </div>
            
            <!-- MAIN CONTROLS -->
            <div class="main-controls">
                <button id="modeBtn" class="ctrl-btn" aria-label="Toggle Mode">RADAR 1</button>
                <button id="resetBtn" class="ctrl-btn" aria-label="Reset Scene">RADAR 2</button>
                <button id="scanBtn" class="ctrl-btn" aria-label="Scan Objects">ADD OBJECTS</button>
            </div>
            
            <!-- OBJECT TAG EDITOR -->
            <div class="tag-editor" id="tagEditor">
                <div style="margin-bottom: 10px; text-align: center;">EDIT OBJECT TAG</div>
                <input type="text" id="tagInput" placeholder="Enter object label...">
                <button id="saveTag">SAVE TAG</button>
                <button id="cancelTag">CANCEL</button>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script>
        // Main Application Variables
        let scene, camera, renderer, clock;
        let faceMesh, objects = [], entities = [];
        let faceDirection = 0;
        let isMirrorMode = true;
        let animationId = null;
        let frameCount = 0;
        let lastTime = 0;
        let fps = 60;
        let selectedObject = null;
        let radarPulseAngle = 0;
        let objectIdCounter = 0;
        let entityIdCounter = 0;
        
        // Face geometry data
        const faceGeometry = {
            vertices: [
                0, 0, 0,           // Center
                0, 0.8, 0,         // Top
                0, -0.8, 0,        // Bottom
                -0.8, 0, 0,        // Left
                0.8, 0, 0,         // Right
                -0.5, 0.5, 0.2,    // Left eye area
                0.5, 0.5, 0.2,     // Right eye area
                -0.3, -0.3, 0.2,   // Left mouth area
                0.3, -0.3, 0.2,    // Right mouth area
                -0.6, 0.2, 0,      // Left cheek
                0.6, 0.2, 0,       // Right cheek
                0, -0.6, 0.1       // Chin
            ],
            indices: [
                0,1, 0,2, 0,3, 0,4, // Center connections
                1,3, 1,4, 2,3, 2,4, // Outer connections
                3,5, 4,6, 5,9, 6,10, // Eye/cheek connections
                7,8, 7,9, 8,10, 7,11, 8,11 // Mouth/chin connections
            ]
        };

        // Initialize the application
        function init() {
            try {
                init3D();
                createFaceMesh();
                setupEventListeners();
                generateObjects();
                animate();
                
                console.log("Personal Mirror IDE initialized successfully");
            } catch (error) {
                console.error('Initialization error:', error);
            }
        }

        function init3D() {
            try {
                // Initialize Three.js scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000000);
                
                // Create camera with optimized settings
                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
                camera.position.set(0, 0, 5);
                
                // Create renderer with performance optimizations
                const canvas = document.getElementById('visualizationCanvas');
                renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas, 
                    antialias: false,
                    powerPreference: "low-power"
                });
                
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(1); // Limit pixel ratio for performance
                
                // Add subtle ambient light
                scene.add(new THREE.AmbientLight(0x003300));
                
                // Create a grid floor with neon green color
                const gridHelper = new THREE.GridHelper(20, 20, 0x00ff00, 0x004400);
                scene.add(gridHelper);
                
                // Add axes helper for reference
                const axesHelper = new THREE.AxesHelper(2);
                scene.add(axesHelper);
                
                clock = new THREE.Clock();
                
            } catch (error) {
                console.error('3D initialization error:', error);
            }
        }

        function createFaceMesh() {
            // Create a simplified face geometry
            const geometry = new THREE.BufferGeometry();
            
            // Set vertices
            const vertices = new Float32Array(faceGeometry.vertices);
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            
            // Set indices for lines
            geometry.setIndex(faceGeometry.indices);
            
            // Create material with neon green color
            const material = new THREE.LineBasicMaterial({ 
                color: 0x00ff00,
                linewidth: 1
            });
            
            // Create mesh
            faceMesh = new THREE.LineSegments(geometry, material);
            scene.add(faceMesh);
            
            console.log("Face mesh created with neon green geometry");
        }

        function updateFaceDirection() {
            // Simulate face movement based on time and user interaction
            const time = clock.getElapsedTime();
            
            // Gentle swaying motion for the face
            faceDirection = Math.sin(time * 0.5) * 30; // -30 to 30 degrees
            
            // Update face mesh rotation
            if (faceMesh) {
                faceMesh.rotation.y = faceDirection * Math.PI / 180;
            }
            
            // Update status display
            document.getElementById('faceDirection').textContent = `${faceDirection.toFixed(0)}°`;
        }

        function generateObjects() {
            // Clear existing objects
            objects.forEach(obj => {
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
                scene.remove(obj);
            });
            objects = [];
            
            // Reset object counter
            objectIdCounter = 0;
            
            // Create objects for performance
            const numObjects = 7 + Math.floor(Math.random() * 5); // 7-11 objects
            
            for (let i = 0; i < numObjects; i++) {
                const isFriendly = Math.random() > 0.3; // 70% friendly
                
                // Position objects around the face
                const angle = (i / numObjects) * Math.PI * 2;
                const distance = 2 + Math.random() * 5; // 2-7 units away
                
                const x = Math.sin(angle) * distance;
                const y = (Math.random() - 0.5) * 2; // Vary height
                const z = Math.cos(angle) * distance;
                
                // Use simple geometries for performance
                let geometry;
                const shapeType = Math.floor(Math.random() * 4);
                
                switch(shapeType) {
                    case 0:
                        geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                        break;
                    case 1:
                        geometry = new THREE.SphereGeometry(0.15, 6, 4);
                        break;
                    case 2:
                        geometry = new THREE.ConeGeometry(0.1, 0.3, 5);
                        break;
                    case 3:
                        geometry = new THREE.CylinderGeometry(0.1, 0.1, 0.3, 6);
                        break;
                }
                
                // Create material with neon green for friendly, red for hostile
                const material = new THREE.MeshBasicMaterial({ 
                    color: isFriendly ? 0x00ff00 : 0xff0000,
                    wireframe: true
                });
                
                const obj = new THREE.Mesh(geometry, material);
                obj.position.set(x, y, z);
                
                // Add user data for tracking
                obj.userData = {
                    type: isFriendly ? 'friendly' : 'hostile',
                    id: objectIdCounter++,
                    label: `OBJ_${objectIdCounter}`,
                    initialAngle: angle,
                    distance: distance
                };
                
                scene.add(obj);
                objects.push(obj);
            }
            
            // Update object count display
            document.getElementById('objectCount').textContent = objects.length;
            
            // Update terminal
            updateTerminal();
            
            // Generate entities (red mesh cubes)
            generateEntities();
        }

        function generateEntities() {
            // Clear existing entities
            entities.forEach(entity => {
                if (entity.geometry) entity.geometry.dispose();
                if (entity.material) entity.material.dispose();
                scene.remove(entity);
            });
            entities = [];
            
            // Reset entity counter
            entityIdCounter = 0;
            
            // Create entities (red mesh cubes) further from the face
            const numEntities = 5 + Math.floor(Math.random() * 3); // 5-7 entities
            
            for (let i = 0; i < numEntities; i++) {
                // Position entities further out
                const angle = (i / numEntities) * Math.PI * 2;
                const distance = 8 + Math.random() * 4; // 8-12 units away
                
                const x = Math.sin(angle) * distance;
                const y = (Math.random() - 0.5) * 3; // Vary height more
                const z = Math.cos(angle) * distance;
                
                // Create red mesh cube
                const geometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xff0000,
                    wireframe: false,
                    transparent: true,
                    opacity: 0.7
                });
                
                const entity = new THREE.Mesh(geometry, material);
                entity.position.set(x, y, z);
                
                // Add user data for tracking
                entity.userData = {
                    type: 'entity',
                    id: entityIdCounter++,
                    label: `ENTITY_${entityIdCounter}`,
                    initialAngle: angle,
                    distance: distance
                };
                
                scene.add(entity);
                entities.push(entity);
            }
            
            // Update terminal with entities
            updateTerminal();
        }

        function updateObjects() {
            const time = clock.getElapsedTime();
            
            // Animate objects
            objects.forEach((obj, index) => {
                const initialAngle = obj.userData.initialAngle;
                const radius = obj.userData.distance;
                
                // Orbit around the face
                obj.position.x = Math.sin(initialAngle + time * 0.3) * radius;
                obj.position.z = Math.cos(initialAngle + time * 0.3) * radius;
                
                // Add slight floating motion
                obj.position.y = (Math.sin(time * 0.7 + index) * 0.5);
                
                // Rotate objects
                obj.rotation.x += 0.01;
                obj.rotation.y += 0.02;
                
                // Pulse effect for hostile objects
                if (obj.userData.type === 'hostile') {
                    const scale = 1 + Math.sin(time * 3) * 0.2;
                    obj.scale.set(scale, scale, scale);
                }
            });
            
            // Animate entities
            entities.forEach((entity, index) => {
                const initialAngle = entity.userData.initialAngle;
                const radius = entity.userData.distance;
                
                // Orbit around the face
                entity.position.x = Math.sin(initialAngle + time * 0.2) * radius;
                entity.position.z = Math.cos(initialAngle + time * 0.2) * radius;
                
                // Add floating motion
                entity.position.y = (Math.sin(time * 0.5 + index) * 1);
                
                // Rotate entities
                entity.rotation.x += 0.02;
                entity.rotation.y += 0.03;
                entity.rotation.z += 0.01;
            });
        }

        function updateTerminal() {
            const terminalContent = document.getElementById('terminalContent');
            terminalContent.innerHTML = '';
            
            // Add objects to terminal
            objects.forEach(obj => {
                const item = document.createElement('div');
                item.className = 'terminal-item';
                item.textContent = `${obj.userData.label} [${obj.userData.type}]`;
                item.dataset.objectId = obj.userData.id;
                item.dataset.type = 'object';
                
                item.addEventListener('click', () => {
                    // Remove active class from all items
                    document.querySelectorAll('.terminal-item').forEach(i => {
                        i.classList.remove('active');
                    });
                    
                    // Add active class to clicked item
                    item.classList.add('active');
                    
                    // Select the object
                    selectObject(obj);
                });
                
                terminalContent.appendChild(item);
            });
            
            // Add entities to terminal
            entities.forEach(entity => {
                const item = document.createElement('div');
                item.className = 'terminal-item';
                item.textContent = `${entity.userData.label} [${entity.userData.type}]`;
                item.dataset.objectId = entity.userData.id;
                item.dataset.type = 'entity';
                
                item.addEventListener('click', () => {
                    // Remove active class from all items
                    document.querySelectorAll('.terminal-item').forEach(i => {
                        i.classList.remove('active');
                    });
                    
                    // Add active class to clicked item
                    item.classList.add('active');
                    
                    // Select the entity
                    selectObject(entity);
                });
                
                terminalContent.appendChild(item);
            });
        }

        function selectObject(obj) {
            // Deselect previous object
            if (selectedObject) {
                if (selectedObject.userData.type === 'entity') {
                    selectedObject.material.color.setHex(0xff0000);
                } else {
                    selectedObject.material.color.setHex(
                        selectedObject.userData.type === 'friendly' ? 0x00ff00 : 0xff0000
                    );
                }
            }
            
            // Select new object
            selectedObject = obj;
            
            // Highlight based on type
            if (obj.userData.type === 'entity') {
                obj.material.color.setHex(0xff6666); // Lighter red for selection
            } else {
                obj.material.color.setHex(0x00aaff); // Blue for selection
            }
            
            // Update status
            document.getElementById('selectedObject').textContent = obj.userData.label;
            
            // Open tag editor
            document.getElementById('tagInput').value = obj.userData.label;
            document.getElementById('tagEditor').style.display = 'block';
        }

        function updateRadar() {
            const canvas = document.getElementById('radarCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.offsetWidth;
            const height = canvas.height = canvas.offsetHeight;
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(centerX, centerY) - 10;
            
            // Clear radar
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            
            // Draw radar circles
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 1;
            
            // Outer circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Middle circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * 0.66, 0, Math.PI * 2);
            ctx.stroke();
            
            // Inner circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * 0.33, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw crosshairs
            ctx.beginPath();
            ctx.moveTo(centerX, 5);
            ctx.lineTo(centerX, height - 5);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(5, centerY);
            ctx.lineTo(width - 5, centerY);
            ctx.stroke();
            
            // Draw radar pulse (rotating red line)
            radarPulseAngle += 0.05;
            ctx.strokeStyle = '#f00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(
                centerX + Math.sin(radarPulseAngle) * radius,
                centerY - Math.cos(radarPulseAngle) * radius
            );
            ctx.stroke();
            
            // Draw objects on radar
            objects.forEach(obj => {
                const dx = obj.position.x;
                const dz = obj.position.z;
                const angle = Math.atan2(dx, dz) - (faceDirection * Math.PI / 180);
                const distance = Math.sqrt(dx*dx + dz*dz);
                
                if (distance < 10) { // Only show objects within radar range
                    const radarX = centerX + Math.sin(angle) * (distance / 10) * radius;
                    const radarY = centerY - Math.cos(angle) * (distance / 10) * radius;
                    
                    ctx.fillStyle = obj.userData.type === 'friendly' ? '#0f0' : '#f00';
                    ctx.beginPath();
                    ctx.arc(radarX, radarY, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // Draw entities on radar
            entities.forEach(entity => {
                const dx = entity.position.x;
                const dz = entity.position.z;
                const angle = Math.atan2(dx, dz) - (faceDirection * Math.PI / 180);
                const distance = Math.sqrt(dx*dx + dz*dz);
                
                if (distance < 15) { // Show entities further out
                    const radarX = centerX + Math.sin(angle) * (distance / 15) * radius;
                    const radarY = centerY - Math.cos(angle) * (distance / 15) * radius;
                    
                    ctx.fillStyle = '#f00';
                    ctx.beginPath();
                    ctx.arc(radarX, radarY, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add glow effect for entities
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.arc(radarX, radarY, 7, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // Draw user position (center)
            ctx.fillStyle = '#0ff';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw direction indicator
            ctx.strokeStyle = '#ff0';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(
                centerX + Math.sin(faceDirection * Math.PI / 180) * 15,
                centerY - Math.cos(faceDirection * Math.PI / 180) * 15
            );
            ctx.stroke();
        }

        function toggleMode() {
            isMirrorMode = !isMirrorMode;
            document.getElementById('modeStatus').textContent = isMirrorMode ? 'MIRROR' : 'SCANNER';
            document.getElementById('modeBtn').classList.toggle('active');
            
            // Regenerate objects when mode changes
            generateObjects();
            
            console.log(`Mode switched to: ${isMirrorMode ? 'Mirror' : 'Scanner'}`);
        }

        function resetScene() {
            // Reset face direction
            faceDirection = 0;
            
            // Regenerate objects and entities
            generateObjects();
            
            // Close tag editor if open
            document.getElementById('tagEditor').style.display = 'none';
            selectedObject = null;
            document.getElementById('selectedObject').textContent = 'NONE';
            
            console.log("Scene reset");
        }

        function scanObjects() {
            // Simulate scanning for new objects
            const newObjects = 2 + Math.floor(Math.random() * 3); // 2-4 new objects
            
            for (let i = 0; i < newObjects; i++) {
                const isFriendly = Math.random() > 0.3;
                const angle = Math.random() * Math.PI * 2;
                const distance = 3 + Math.random() * 4; // 3-7 units away
                
                const x = Math.sin(angle) * distance;
                const y = (Math.random() - 0.5) * 2;
                const z = Math.cos(angle) * distance;
                
                const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const material = new THREE.MeshBasicMaterial({ 
                    color: isFriendly ? 0x00ff00 : 0xff0000,
                    wireframe: true
                });
                
                const obj = new THREE.Mesh(geometry, material);
                obj.position.set(x, y, z);
                
                obj.userData = {
                    type: isFriendly ? 'friendly' : 'hostile',
                    id: objectIdCounter++,
                    label: `SCANNED_${objectIdCounter}`,
                    initialAngle: angle,
                    distance: distance
                };
                
                scene.add(obj);
                objects.push(obj);
            }
            
            // Update object count and terminal
            document.getElementById('objectCount').textContent = objects.length;
            updateTerminal();
            
            console.log(`Scan complete: ${newObjects} new objects detected`);
        }

        function setupEventListeners() {
            // Button event listeners
            document.getElementById('modeBtn').addEventListener('click', toggleMode);
            document.getElementById('resetBtn').addEventListener('click', resetScene);
            document.getElementById('scanBtn').addEventListener('click', scanObjects);
            
            // Tag editor event listeners
            document.getElementById('saveTag').addEventListener('click', () => {
                if (selectedObject && document.getElementById('tagInput').value.trim() !== '') {
                    selectedObject.userData.label = document.getElementById('tagInput').value;
                    document.getElementById('selectedObject').textContent = selectedObject.userData.label;
                    updateTerminal();
                    document.getElementById('tagEditor').style.display = 'none';
                }
            });
            
            document.getElementById('cancelTag').addEventListener('click', () => {
                document.getElementById('tagEditor').style.display = 'none';
            });
            
            // Window resize handler
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }, { passive: true });
            
            // Mouse movement for interactive face control
            window.addEventListener('mousemove', (e) => {
                // Map mouse position to face rotation (-30 to 30 degrees)
                const normalizedX = (e.clientX / window.innerWidth) * 2 - 1;
                faceDirection = normalizedX * 30;
            }, { passive: true });
            
            // Cleanup on page unload
            window.addEventListener('beforeunload', cleanup);
            
            console.log("Event listeners setup complete");
        }

        function cleanup() {
            // Stop animation loop
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            // Clean up Three.js resources
            if (scene) {
                scene.traverse(object => {
                    if (object.geometry) object.geometry.dispose();
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(material => material.dispose());
                        } else {
                            object.material.dispose();
                        }
                    }
                });
            }
            
            console.log("Cleanup completed");
        }

        function calculateFPS() {
            frameCount++;
            const currentTime = performance.now();
            
            if (currentTime - lastTime >= 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                document.getElementById('fpsCounter').textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }
        }

        function animate() {
            animationId = requestAnimationFrame(animate);
            
            // Calculate FPS
            calculateFPS();
            
            // Update face direction
            updateFaceDirection();
            
            // Update objects and entities
            updateObjects();
            
            // Update radar
            updateRadar();
            
            // Render scene
            renderer.render(scene, camera);
        }

        // Initialize the application when the window loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
