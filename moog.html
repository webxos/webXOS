<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>webXOS MOOG</title>
  <style>
    * {
      box-sizing: border-box;
      user-select: none;
      font-family: 'Courier New', Courier, monospace;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: #0a0704;
      background-image: radial-gradient(circle at 30% 50%, #2f1f12 0%, #020100 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .synth-container {
      max-width: 1600px;
      width: 100%;
      background: #1a120b;
      background: linear-gradient(165deg, #2b1f15, #0f0a06);
      border-radius: 60px 60px 50px 50px;
      box-shadow: 0 30px 40px rgba(0,0,0,1), inset 2px 2px 8px #6b4f34, inset -8px -8px 20px #030201;
      padding: 30px 25px 35px;
      border: 6px solid #2b1c10;
    }

    .panel {
      background: #1e140e;
      background: repeating-linear-gradient(0deg, 
        #2f231a 0px, #2f231a 3px, 
        #1a120b 3px, #1a120b 8px),
        radial-gradient(circle at 30% 40%, #3f2d1d, #0c0804);
      border-radius: 45px 45px 35px 35px;
      padding: 25px 20px 30px;
      margin-bottom: 30px;
      box-shadow: inset 0 0 0 3px #2f1f12, inset 0 0 40px #000000, 0 12px 0 #0a0603;
      border-bottom: 4px solid #5a3f27;
    }

    h1 {
      text-align: center;
      margin: 0 0 10px 0;
      font-size: 2.8rem;
      font-weight: 800;
      letter-spacing: 8px;
      color: #ebcbaa;
      text-shadow: 3px 3px 0 #3e2b1a, 6px 6px 0 #0f0905, 0 0 20px #c9934b;
      text-transform: uppercase;
    }

    .subhead {
      text-align: center;
      color: #cbae85;
      font-size: 1.3rem;
      letter-spacing: 6px;
      margin-top: -10px;
      margin-bottom: 25px;
      text-transform: uppercase;
      background: #1f140e;
      display: inline-block;
      padding: 5px 30px;
      border-radius: 40px;
      box-shadow: inset 0 2px 6px #0f0804;
    }

    .synth-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 25px 18px;
      justify-content: center;
      margin: 20px 0 10px;
    }

    .section {
      background: #1b130c;
      border-radius: 40px;
      padding: 18px 15px 22px;
      box-shadow: inset 0 2px 8px #5f4330, 0 8px 0 #0b0704;
      border: 1px solid #4d3824;
      min-width: 260px;
      flex: 1 1 280px;
    }

    .section-title {
      font-size: 1.5rem;
      font-weight: bold;
      color: #edd7b3;
      text-align: center;
      margin-bottom: 18px;
      text-transform: uppercase;
      letter-spacing: 2px;
      background: #2f1f12;
      padding: 5px 0;
      border-radius: 40px;
      box-shadow: inset 0 2px 5px #3e2e1d;
    }

    .knob-row {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 15px 10px;
    }

    .knob-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 95px;
    }

    .knob-label {
      font-size: 0.85rem;
      font-weight: bold;
      margin-top: 8px;
      color: #f2dbb4;
      text-shadow: 2px 2px 0 #1e150e;
      background: #1f1610;
      padding: 4px 8px;
      border-radius: 40px;
      box-shadow: inset 0 1px 4px #5f4330, 0 2px 0 #0b0704;
      letter-spacing: 1px;
      white-space: nowrap;
    }

    canvas.knob-canvas {
      width: 80px;
      height: 80px;
      display: block;
      background: #1a130d;
      border-radius: 50%;
      box-shadow: 0 6px 0 #0c0805, 0 12px 20px black, inset 0 -3px 5px #3d2e1f, inset 0 3px 8px #9a7b58;
      cursor: grab;
      touch-action: none;
    }

    .switch-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 95px;
    }
    .switch-label {
      font-size: 0.8rem;
      color: #f2dbb0;
      margin-bottom: 5px;
      background: #1f1610;
      padding: 3px 10px;
      border-radius: 20px;
    }
    .switch-select {
      background: #120d08;
      border: 2px solid #6b4f34;
      color: #f2dbb0;
      font-size: 1rem;
      padding: 5px 8px;
      border-radius: 40px;
      font-weight: bold;
      box-shadow: inset 0 2px 6px #0f0904, 0 4px 0 #130e08;
      text-transform: uppercase;
      font-family: inherit;
      width: 100%;
      text-align: center;
    }

    .keyboard {
      background: #120d08;
      padding: 25px 8px 12px;
      border-radius: 45px 45px 40px 40px;
      box-shadow: inset 0 -6px 0 #0a0603, inset 0 8px 18px #5f4330, 0 15px 0 #0b0704;
      margin-top: 30px;
      border-bottom: 4px solid #6b4f34;
    }

    .keys-container {
      display: flex;
      height: 220px;
      position: relative;
      background: #0f0a06;
      border-radius: 20px;
    }

    .white-key {
      background: #e8ddcc;
      background: linear-gradient(145deg, #f0e5d2 0%, #dacfb8 100%);
      flex: 1 1 0;
      height: 100%;
      border: 1px solid #3f2e1d;
      border-radius: 0 0 16px 16px;
      box-shadow: inset 0 -10px 0 #9a8461, inset 0 -3px 12px #b3976b, 2px 2px 5px black;
      cursor: pointer;
      position: relative;
      z-index: 1;
      transition: 0.02s linear;
    }
    .white-key:active {
      background: #cfc3a6;
      box-shadow: inset 0 -4px 0 #7c623e;
      transform: translateY(6px);
    }

    .black-key {
      position: absolute;
      width: 4.5%;
      height: 62%;
      background: #1e1914;
      background: linear-gradient(145deg, #3b3126, #0f0b07);
      border: 1px solid #6f532f;
      border-radius: 0 0 10px 10px;
      box-shadow: inset 0 -5px 0 #413420, 0 8px 10px black;
      z-index: 20;
      cursor: pointer;
      transition: 0.02s linear;
      top: 0;
    }
    .black-key:active {
      background: #0f0c08;
      transform: translateY(5px);
    }

    .footer {
      color: #b38d5f;
      text-align: center;
      margin-top: 20px;
      font-size: 1rem;
      letter-spacing: 3px;
      text-transform: uppercase;
    }
  </style>
</head>
<body>
<div class="synth-container">
  <div class="panel">
    <h1>WEBXOS | MOOG</h1>
    <div class="subhead">Browser Based Synth</div>

    <div class="synth-grid" id="controlsGrid"></div>

    <div class="keyboard">
      <div class="keys-container" id="pianoKeys"></div>
      <div style="text-align:right; color:#b18d5f; padding:10px 15px 0;">DARK WOOD 路 32 KEYS 路 ARP 路 DELAY</div>
    </div>
    <div class="footer">moog 路 webXOS edition</div>
  </div>
</div>

<script>
  (function() {
    let audioCtx = null;
    let masterGain = null;
    let filterNode = null;
    let vcaGain = null;
    let noiseGain = null;
    let noiseSource = null;

    let oscGain1, oscGain2, oscGain3;
    let osc1, osc2, osc3;

    let lfoNode = null;
    let lfoDepth = 0;
    let lfoTarget = 'pitch';

    let attack = 0.01, decay = 0.1, sustain = 0.7, release = 0.3;
    let currentBaseFreq = 220;
    let targetFreq = 220;
    let glideTime = 0.05;
    let glideOn = false;
    let isNoteOn = false;

    const oscParams = [
      { coarse: 0, fine: 0, level: 0.8, waveform: 'sawtooth', octave: 1 },
      { coarse: 0, fine: 0, level: 0.6, waveform: 'triangle', octave: 1 },
      { coarse: 0, fine: 0, level: 0.5, waveform: 'square', octave: 1 }
    ];
    let noiseLevel = 0;
    let cutoff = 800, resonance = 2;
    let lfoRate = 5;

    let delayNode, feedbackGain, wetGain, dryGain;
    let delayTime = 0.3, delayFeedback = 0.4, delayMix = 0.3;

    let arpActive = false;
    let arpRate = 8;
    let arpMode = 'up';
    let arpInterval = null;
    let pressedNotes = [];        // array of { freq, midi } in order pressed

    function initAudio() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.7;

      dryGain = audioCtx.createGain();
      dryGain.gain.value = 1 - delayMix;
      delayNode = audioCtx.createDelay(2.0);
      delayNode.delayTime.value = delayTime;
      feedbackGain = audioCtx.createGain();
      feedbackGain.gain.value = delayFeedback;
      wetGain = audioCtx.createGain();
      wetGain.gain.value = delayMix;

      masterGain.connect(dryGain);
      masterGain.connect(delayNode);
      delayNode.connect(feedbackGain);
      feedbackGain.connect(delayNode);
      delayNode.connect(wetGain);
      dryGain.connect(audioCtx.destination);
      wetGain.connect(audioCtx.destination);

      filterNode = audioCtx.createBiquadFilter();
      filterNode.type = 'lowpass';
      filterNode.frequency.value = cutoff;
      filterNode.Q.value = resonance;

      vcaGain = audioCtx.createGain();
      vcaGain.gain.value = 0;

      oscGain1 = audioCtx.createGain(); oscGain1.gain.value = 0;
      oscGain2 = audioCtx.createGain(); oscGain2.gain.value = 0;
      oscGain3 = audioCtx.createGain(); oscGain3.gain.value = 0;

      noiseGain = audioCtx.createGain(); noiseGain.gain.value = 0;
      const bufferSize = 2 * audioCtx.sampleRate;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
      noiseSource = audioCtx.createBufferSource();
      noiseSource.buffer = buffer;
      noiseSource.loop = true;
      noiseSource.start(0);
      noiseSource.connect(noiseGain);

      oscGain1.connect(filterNode);
      oscGain2.connect(filterNode);
      oscGain3.connect(filterNode);
      noiseGain.connect(filterNode);
      filterNode.connect(vcaGain);
      vcaGain.connect(masterGain);

      lfoNode = audioCtx.createOscillator();
      lfoNode.frequency.value = lfoRate;
      lfoNode.type = 'sine';
      lfoNode.start(0);
    }

    function startEnvelope() {
      const now = audioCtx.currentTime;
      vcaGain.gain.cancelScheduledValues(now);
      vcaGain.gain.setValueAtTime(0, now);
      vcaGain.gain.linearRampToValueAtTime(1, now + attack);
      vcaGain.gain.linearRampToValueAtTime(sustain, now + attack + decay);
    }

    function releaseEnvelope() {
      const now = audioCtx.currentTime;
      vcaGain.gain.cancelScheduledValues(now);
      vcaGain.gain.setValueAtTime(vcaGain.gain.value || 0, now);
      vcaGain.gain.linearRampToValueAtTime(0, now + release);
    }

    function computeOscFreq(baseFreq, oscIdx) {
      const p = oscParams[oscIdx];
      const octMul = p.octave;
      const semitone = p.coarse;
      const cents = p.fine;
      const totalSemis = semitone + cents/100;
      return baseFreq * octMul * Math.pow(2, totalSemis/12);
    }

    async function triggerNote(freq) {
      await ensureAudio();
      if (!audioCtx) return;

      targetFreq = freq;
      if (!glideOn || !isNoteOn) currentBaseFreq = targetFreq;
      isNoteOn = true;

      if (osc1) { osc1.stop(); osc1.disconnect(); }
      if (osc2) { osc2.stop(); osc2.disconnect(); }
      if (osc3) { osc3.stop(); osc3.disconnect(); }

      osc1 = audioCtx.createOscillator();
      osc2 = audioCtx.createOscillator();
      osc3 = audioCtx.createOscillator();
      osc1.type = oscParams[0].waveform;
      osc2.type = oscParams[1].waveform;
      osc3.type = oscParams[2].waveform;
      osc1.frequency.value = computeOscFreq(currentBaseFreq, 0);
      osc2.frequency.value = computeOscFreq(currentBaseFreq, 1);
      osc3.frequency.value = computeOscFreq(currentBaseFreq, 2);

      osc1.connect(oscGain1);
      osc2.connect(oscGain2);
      osc3.connect(oscGain3);

      oscGain1.gain.setValueAtTime(oscParams[0].level, audioCtx.currentTime);
      oscGain2.gain.setValueAtTime(oscParams[1].level, audioCtx.currentTime);
      oscGain3.gain.setValueAtTime(oscParams[2].level, audioCtx.currentTime);
      noiseGain.gain.setValueAtTime(noiseLevel, audioCtx.currentTime);

      osc1.start();
      osc2.start();
      osc3.start();

      if (glideOn && Math.abs(currentBaseFreq - targetFreq) > 0.01) {
        const now = audioCtx.currentTime;
        osc1.frequency.linearRampToValueAtTime(computeOscFreq(targetFreq,0), now + glideTime);
        osc2.frequency.linearRampToValueAtTime(computeOscFreq(targetFreq,1), now + glideTime);
        osc3.frequency.linearRampToValueAtTime(computeOscFreq(targetFreq,2), now + glideTime);
        currentBaseFreq = targetFreq;
      } else {
        currentBaseFreq = targetFreq;
      }

      startEnvelope();
    }

    function stopNote() {
      if (!isNoteOn) return;
      releaseEnvelope();
      isNoteOn = false;
    }

    function handleKeyDown(freq) {
      if (pressedNotes.find(n => Math.abs(n.freq - freq) < 0.1)) return;

      const midi = Math.round(12 * Math.log2(freq/440) + 69);
      pressedNotes.push({ freq, midi });

      if (arpActive) {
        if (!arpInterval && pressedNotes.length > 0) startArpeggiator();
      } else {
        triggerNote(freq);
      }
    }

    function handleKeyUp(freq) {
      const index = pressedNotes.findIndex(n => Math.abs(n.freq - freq) < 0.1);
      if (index === -1) return;
      pressedNotes.splice(index, 1);

      if (arpActive) {
        if (pressedNotes.length === 0) stopArpeggiator();
      } else {
        if (pressedNotes.length > 0) {
          triggerNote(pressedNotes[pressedNotes.length-1].freq);
        } else {
          stopNote();
        }
      }
    }

    function startArpeggiator() {
      if (arpInterval) clearInterval(arpInterval);
      if (!arpActive || pressedNotes.length === 0) return;
      arpIndex = 0;
      arpDirection = 1;
      stepArpeggiator();
      arpInterval = setInterval(stepArpeggiator, 1000 / arpRate);
    }

    function stopArpeggiator() {
      if (arpInterval) {
        clearInterval(arpInterval);
        arpInterval = null;
      }
      stopNote();
    }

    function stepArpeggiator() {
      if (!arpActive || pressedNotes.length === 0) {
        stopArpeggiator();
        return;
      }
      let freq;
      const notes = pressedNotes.map(n => n.freq);
      if (arpMode === 'up') {
        freq = notes[arpIndex % notes.length];
        arpIndex = (arpIndex + 1) % notes.length;
      } else if (arpMode === 'down') {
        freq = notes[notes.length - 1 - (arpIndex % notes.length)];
        arpIndex = (arpIndex + 1) % notes.length;
      } else if (arpMode === 'updown') {
        let idx = arpIndex % (notes.length * 2 - 2 || 1);
        if (idx < notes.length) {
          freq = notes[idx];
        } else {
          freq = notes[2 * notes.length - 2 - idx];
        }
        arpIndex++;
      } else {
        freq = notes[Math.floor(Math.random() * notes.length)];
      }
      triggerNote(freq);
      setTimeout(() => {
        if (arpActive) releaseEnvelope();
      }, 400 / arpRate);
    }

    function updateDelay() {
      if (delayNode) {
        delayNode.delayTime.value = delayTime;
        feedbackGain.gain.value = delayFeedback;
        dryGain.gain.value = 1 - delayMix;
        wetGain.gain.value = delayMix;
      }
    }

    async function ensureAudio() {
      if (!audioCtx) initAudio();
      if (audioCtx.state === 'suspended') await audioCtx.resume();
    }

    function updateFilter() {
      if (filterNode) {
        filterNode.frequency.value = cutoff;
        filterNode.Q.value = resonance;
      }
    }

    // ---------- UI GENERATION ----------
    const container = document.getElementById('controlsGrid');
    const sections = [
      { title: 'OSC 1', items: [
        { type: 'knob', label: 'COARSE', min:-12, max:12, step:1, default:0, cb: v => oscParams[0].coarse = v },
        { type: 'knob', label: 'FINE', min:-100, max:100, default:0, cb: v => oscParams[0].fine = v },
        { type: 'knob', label: 'LEVEL', min:0, max:1, default:0.8, cb: v => oscParams[0].level = v },
        { type: 'switch', label: 'WAVE', options: ['saw','triangle','square'], default:'saw', cb: v => oscParams[0].waveform = v },
        { type: 'switch', label: 'OCTAVE', options: ['32\'','16\'','8\'','4\'','2\''], default:'8\'', cb: v => { const map={'32\'':0.25,'16\'':0.5,'8\'':1,'4\'':2,'2\'':4}; oscParams[0].octave = map[v]; } }
      ]},
      { title: 'OSC 2', items: [
        { type: 'knob', label: 'COARSE', min:-12, max:12, default:0, cb: v => oscParams[1].coarse = v },
        { type: 'knob', label: 'FINE', min:-100, max:100, default:0, cb: v => oscParams[1].fine = v },
        { type: 'knob', label: 'LEVEL', min:0, max:1, default:0.6, cb: v => oscParams[1].level = v },
        { type: 'switch', label: 'WAVE', options: ['saw','triangle','square'], default:'triangle', cb: v => oscParams[1].waveform = v },
        { type: 'switch', label: 'OCTAVE', options: ['32\'','16\'','8\'','4\'','2\''], default:'8\'', cb: v => { const map={'32\'':0.25,'16\'':0.5,'8\'':1,'4\'':2,'2\'':4}; oscParams[1].octave = map[v]; } }
      ]},
      { title: 'OSC 3', items: [
        { type: 'knob', label: 'COARSE', min:-12, max:12, default:0, cb: v => oscParams[2].coarse = v },
        { type: 'knob', label: 'FINE', min:-100, max:100, default:0, cb: v => oscParams[2].fine = v },
        { type: 'knob', label: 'LEVEL', min:0, max:1, default:0.5, cb: v => oscParams[2].level = v },
        { type: 'switch', label: 'WAVE', options: ['saw','triangle','square'], default:'square', cb: v => oscParams[2].waveform = v },
        { type: 'switch', label: 'OCTAVE', options: ['32\'','16\'','8\'','4\'','2\''], default:'8\'', cb: v => { const map={'32\'':0.25,'16\'':0.5,'8\'':1,'4\'':2,'2\'':4}; oscParams[2].octave = map[v]; } }
      ]},
      { title: 'NOISE / FILTER', items: [
        { type: 'knob', label: 'NOISE LVL', min:0, max:1, default:0, cb: v => noiseLevel = v },
        { type: 'knob', label: 'CUTOFF', min:20, max:5000, default:800, log:true, cb: v => { cutoff=v; updateFilter(); } },
        { type: 'knob', label: 'RESON', min:0, max:15, default:2, cb: v => { resonance=v; updateFilter(); } }
      ]},
      { title: 'ADSR', items: [
        { type: 'knob', label: 'ATTACK', min:0.002, max:2, default:0.01, log:true, cb: v => attack=v },
        { type: 'knob', label: 'DECAY', min:0.01, max:3, default:0.1, cb: v => decay=v },
        { type: 'knob', label: 'SUSTAIN', min:0, max:1, default:0.7, cb: v => sustain=v },
        { type: 'knob', label: 'RELEASE', min:0.01, max:4, default:0.3, cb: v => release=v }
      ]},
      { title: 'LFO', items: [
        { type: 'knob', label: 'RATE', min:0.1, max:20, default:5, cb: v => { lfoRate=v; if(lfoNode) lfoNode.frequency.value=v; } },
        { type: 'knob', label: 'DEPTH', min:0, max:1, default:0, cb: v => lfoDepth=v },
        { type: 'switch', label: 'TARGET', options: ['PITCH','FILTER'], default:'PITCH', cb: v => lfoTarget = v.toLowerCase() }
      ]},
      { title: 'GLIDE / MASTER', items: [
        { type: 'knob', label: 'GLIDE', min:0.01, max:1, default:0.05, cb: v => glideTime=v },
        { type: 'switch', label: 'GLIDE SW', options: ['OFF','ON'], default:'OFF', cb: v => glideOn = (v==='ON') },
        { type: 'knob', label: 'VOLUME', min:0, max:1, default:0.7, cb: v => { if(masterGain) masterGain.gain.value=v; } }
      ]},
      { title: 'ARPEGGIATOR', items: [
        { type: 'knob', label: 'RATE', min:0.5, max:20, default:8, log:true, cb: v => { arpRate=v; if(arpActive) { stopArpeggiator(); startArpeggiator(); } } },
        { type: 'switch', label: 'MODE', options: ['UP','DOWN','UPDOWN','RANDOM'], default:'UP', cb: v => arpMode = v.toLowerCase() },
        { type: 'switch', label: 'ON/OFF', options: ['OFF','ON'], default:'OFF', cb: v => { 
          arpActive = (v==='ON'); 
          if(arpActive) { 
            if(pressedNotes.length) startArpeggiator(); 
          } else { 
            stopArpeggiator(); 
            if(pressedNotes.length) triggerNote(pressedNotes[pressedNotes.length-1].freq); 
          } 
        } }
      ]},
      { title: 'DELAY', items: [
        { type: 'knob', label: 'TIME', min:0.01, max:1.5, default:0.3, cb: v => { delayTime=v; updateDelay(); } },
        { type: 'knob', label: 'FEEDBACK', min:0, max:0.9, default:0.4, cb: v => { delayFeedback=v; updateDelay(); } },
        { type: 'knob', label: 'MIX', min:0, max:1, default:0.3, cb: v => { delayMix=v; updateDelay(); } }
      ]}
    ];

    const knobList = [];

    sections.forEach(section => {
      const secDiv = document.createElement('div');
      secDiv.className = 'section';
      secDiv.innerHTML = `<div class="section-title">${section.title}</div><div class="knob-row" id="row-${section.title.replace(/\s/g,'')}"></div>`;
      const row = secDiv.querySelector('.knob-row');
      section.items.forEach(item => {
        if (item.type === 'knob') {
          const id = 'knob_' + Math.random().toString(36).substring(2,8);
          const itemDiv = document.createElement('div');
          itemDiv.className = 'knob-item';
          itemDiv.innerHTML = `<canvas id="${id}" class="knob-canvas" width="80" height="80"></canvas>
                               <span class="knob-label">${item.label}</span>`;
          row.appendChild(itemDiv);
          knobList.push({ id, ...item });
        } else if (item.type === 'switch') {
          const itemDiv = document.createElement('div');
          itemDiv.className = 'switch-item';
          let opts = item.options.map(o => `<option value="${o}" ${o===item.default?'selected':''}>${o}</option>`).join('');
          itemDiv.innerHTML = `<span class="switch-label">${item.label}</span>
                               <select class="switch-select" data-cb="${item.label}">${opts}</select>`;
          row.appendChild(itemDiv);
          const select = itemDiv.querySelector('select');
          select.addEventListener('change', e => item.cb(e.target.value));
        }
      });
      container.appendChild(secDiv);
    });

    function drawKnob(canvas, val, min, max, log) {
      const ctx = canvas.getContext('2d');
      const w=80, h=80;
      ctx.clearRect(0,0,w,h);
      
      ctx.beginPath();
      ctx.arc(w/2, h/2, 32, 0, 2*Math.PI);
      ctx.fillStyle = '#1f1711';
      ctx.shadowColor = '#000';
      ctx.shadowBlur = 10;
      ctx.fill();
      ctx.shadowBlur = 0;
      
      ctx.beginPath();
      ctx.arc(w/2, h/2, 26, 0, 2*Math.PI);
      ctx.fillStyle = '#2f261d';
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(w/2, h/2, 24, 0, 2*Math.PI);
      const grad = ctx.createRadialGradient(30,30,5, 40,40,30);
      grad.addColorStop(0, '#4a3e32');
      grad.addColorStop(0.7, '#1e1610');
      ctx.fillStyle = grad;
      ctx.fill();

      let normVal = (val - min) / (max - min);
      if (log) normVal = Math.log(val/min) / Math.log(max/min);
      const angleMin = -2.356;
      const angleMax = 2.356;
      const angle = angleMin + normVal * (angleMax - angleMin);
      const cx=40, cy=40;
      const x2 = cx + Math.sin(angle)*23;
      const y2 = cy - Math.cos(angle)*23;
      ctx.beginPath();
      ctx.moveTo(cx,cy);
      ctx.lineTo(x2,y2);
      ctx.lineWidth = 6;
      ctx.strokeStyle = '#ffaa33';
      ctx.shadowBlur = 12;
      ctx.shadowColor = '#ff8800';
      ctx.stroke();
      ctx.shadowBlur = 0;
      
      ctx.beginPath();
      ctx.arc(cx,cy,6,0,2*Math.PI);
      ctx.fillStyle = '#1a130d';
      ctx.fill();
      ctx.strokeStyle = '#ad874f';
      ctx.lineWidth = 1.5;
      ctx.stroke();
    }

    knobList.forEach(k => {
      const canvas = document.getElementById(k.id);
      let value = k.default;
      let dragging = false;
      drawKnob(canvas, value, k.min, k.max, k.log);

      function getAngle(e) {
        const rect = canvas.getBoundingClientRect();
        const cx = rect.left + rect.width/2;
        const cy = rect.top + rect.height/2;
        let x = e.clientX ?? e.touches[0].clientX;
        let y = e.clientY ?? e.touches[0].clientY;
        return Math.atan2(y-cy, -(x-cx));
      }

      function setFromEvent(e) {
        e.preventDefault();
        let angle = getAngle(e);
        const angleMin = -2.356, angleMax = 2.356;
        let norm = (angle - angleMin) / (angleMax - angleMin);
        norm = Math.min(1, Math.max(0, norm));
        let newVal;
        if (k.log) {
          newVal = k.min * Math.pow(k.max/k.min, norm);
        } else {
          newVal = k.min + norm * (k.max - k.min);
        }
        value = newVal;
        drawKnob(canvas, value, k.min, k.max, k.log);
        k.cb(value);
      }

      canvas.addEventListener('mousedown', e => { e.preventDefault(); dragging = true; setFromEvent(e); window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', onUp); });
      function onMove(e) { if (!dragging) return; e.preventDefault(); setFromEvent(e); }
      function onUp() { dragging = false; window.removeEventListener('mousemove', onMove); window.removeEventListener('mouseup', onUp); }
      canvas.addEventListener('touchstart', e => { e.preventDefault(); dragging = true; setFromEvent(e); window.addEventListener('touchmove', onTouchMove, {passive:false}); window.addEventListener('touchend', onTouchEnd); });
      function onTouchMove(e) { if (!dragging) return; e.preventDefault(); setFromEvent(e); }
      function onTouchEnd() { dragging = false; window.removeEventListener('touchmove', onTouchMove); window.removeEventListener('touchend', onTouchEnd); }
    });

    // ---------- 32-key keyboard (C3 to G5 = MIDI 48-79) ----------
    const notes = [];
    for (let midi = 48; midi <= 79; midi++) {
      const pc = midi % 12;
      const white = [0,2,4,5,7,9,11].includes(pc);
      const oct = Math.floor(midi/12)-1;
      const names = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
      const name = names[pc] + oct;
      const freq = 440 * Math.pow(2, (midi-69)/12);
      notes.push({ midi, white, name, freq });
    }

    const keyContainer = document.getElementById('pianoKeys');
    keyContainer.innerHTML = '';
    notes.filter(n => n.white).forEach(n => {
      const div = document.createElement('div');
      div.className = 'white-key';
      div.dataset.freq = n.freq;
      div.dataset.note = n.name;
      keyContainer.appendChild(div);
    });

    const whiteCount = notes.filter(n => n.white).length;
    const whiteW = 100 / whiteCount;  // % per white key
    const blackW = 4.5; // % as defined in CSS

    notes.filter(n => !n.white).forEach(n => {
      const div = document.createElement('div');
      div.className = 'black-key';
      div.dataset.freq = n.freq;
      div.dataset.note = n.name;
      const leftWhite = notes.filter(m => m.white && m.midi < n.midi).length;
      // position black key centered on the boundary between white keys
      // boundary at leftWhite * whiteW, center there, so left edge = leftWhite * whiteW - blackW/2
      div.style.left = `calc(${leftWhite * whiteW}% - ${blackW/2}%)`;
      keyContainer.appendChild(div);
    });

    // keyboard events
    document.querySelectorAll('[data-freq]').forEach(k => {
      k.addEventListener('mousedown', e => {
        e.preventDefault();
        const freq = parseFloat(e.target.dataset.freq);
        handleKeyDown(freq);
      });
      k.addEventListener('mouseup', e => {
        e.preventDefault();
        const freq = parseFloat(e.target.dataset.freq);
        handleKeyUp(freq);
      });
      k.addEventListener('touchstart', e => {
        e.preventDefault();
        const freq = parseFloat(e.target.dataset.freq);
        handleKeyDown(freq);
      });
      k.addEventListener('touchend', e => {
        e.preventDefault();
        const freq = parseFloat(e.target.dataset.freq);
        handleKeyUp(freq);
      });
    });

    document.body.addEventListener('mousedown', ()=> { if(audioCtx && audioCtx.state==='suspended') audioCtx.resume(); });
    document.body.addEventListener('touchstart', ()=> { if(audioCtx && audioCtx.state==='suspended') audioCtx.resume(); });
  })();
</script>
</body>
</html>
