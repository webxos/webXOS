<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EXOSKELETON 2 | Neural Audio-Visual Encryption</title>
    
    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <style>
        /* ===== RESET & BASE STYLES ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.2;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        /* ===== LOADING SCREEN ===== */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }
        
        .ascii-skeleton {
            white-space: pre;
            font-size: 6px;
            line-height: 0.9;
            color: #0f0;
            text-align: center;
            animation: pulse 2s infinite;
            text-shadow: 0 0 5px #0f0;
            margin-bottom: 20px;
        }
        
        .loading-text {
            color: #0a0;
            font-size: 16px;
            text-align: center;
            animation: blink 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        /* ===== MAIN LAYOUT ===== */
        .main-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            display: none;
        }
        
        /* ===== HEADER ===== */
        #header {
            padding: 12px;
            border-bottom: 1px solid #0f0;
            background: rgba(0,0,0,0.95);
            z-index: 1;
            flex-shrink: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.1);
        }
        
        .header-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .logo {
            color: #0f0;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 0 0 10px #0f0;
        }
        
        .logo-subtitle {
            color: #0a0;
            font-size: 12px;
            opacity: 0.8;
        }
        
        .header-right {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #0f0;
            box-shadow: 0 0 10px #0f0;
            animation: pulse 2s infinite;
        }
        
        /* ===== TERMINAL CONTAINER ===== */
        .terminal-container {
            display: flex;
            height: calc(100vh - 70px);
            overflow: hidden;
        }
        
        /* ===== NEURAL VISUALIZATION PANEL ===== */
        .neural-panel {
            width: 360px;
            border-right: 1px solid #0f0;
            background: rgba(0,10,0,0.2);
            position: relative;
            flex-shrink: 0;
            overflow: hidden;
            padding: 15px;
            display: flex;
            flex-direction: column;
        }
        
        .panel-header {
            color: #0f0;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #0f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .visualization-container {
            flex: 1;
            position: relative;
            perspective: 1000px;
            border: 1px solid rgba(0, 255, 0, 0.3);
            border-radius: 5px;
            overflow: hidden;
            background: rgba(0,0,0,0.7);
            box-shadow: inset 0 0 30px rgba(0, 255, 0, 0.1);
        }
        
        .hologram-grid {
            position: absolute;
            width: 280px;
            height: 280px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transform-style: preserve-3d;
            animation: rotateHologram 40s infinite linear;
        }
        
        .grid-square {
            position: absolute;
            background: rgba(0,255,0,0.6);
            border: 1px solid #0f0;
            box-shadow: 0 0 8px #0f0;
            animation: pulseSquare 3s infinite;
            min-width: 8px;
            min-height: 8px;
            z-index: 3;
        }
        
        .neural-overlay {
            position: absolute;
            width: 280px;
            height: 280px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 5;
        }
        
        .neural-node {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #0f0;
            border-radius: 50%;
            box-shadow: 0 0 10px #0f0;
            animation: pulseNode 2s infinite;
        }
        
        .neural-connection {
            position: absolute;
            background: rgba(0, 255, 0, 0.3);
            height: 1px;
            transform-origin: 0 0;
            z-index: 2;
        }
        
        .encryption-status {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 10px;
            color: #0f0;
            background: rgba(0,0,0,0.8);
            padding: 5px 10px;
            border: 1px solid #0f0;
            border-radius: 3px;
            z-index: 100;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
        }
        
        /* ===== TERMINAL OUTPUT ===== */
        .terminal-output {
            flex: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: rgba(0,5,0,0.1);
        }
        
        #terminal {
            flex: 1;
            min-height: 0;
            overflow-y: auto;
            padding: 15px;
            padding-bottom: 0;
            display: flex;
            flex-direction: column;
            scroll-behavior: smooth;
        }
        
        #output {
            min-height: 0;
            display: flex;
            flex-direction: column;
            flex: 1;
        }
        
        .line {
            margin-bottom: 3px;
            word-wrap: break-word;
            word-break: break-all;
            flex-shrink: 0;
            padding: 3px 0;
        }
        
        .input-line {
            color: #0f0;
            font-weight: bold;
            border-left: 2px solid #0f0;
            padding-left: 10px;
            background: rgba(0,255,0,0.05);
        }
        
        .output-line {
            color: #0a0;
        }
        
        .error {
            color: #f00;
            text-shadow: 0 0 3px #f00;
            border-left: 2px solid #f00;
            padding-left: 10px;
            background: rgba(255,0,0,0.05);
        }
        
        .success {
            color: #0f0;
            text-shadow: 0 0 3px #0f0;
            border-left: 2px solid #0f0;
            padding-left: 10px;
            background: rgba(0,255,0,0.05);
        }
        
        /* ===== ENTRY STYLING ===== */
        .exo-entry {
            margin: 10px 0;
            padding: 12px;
            background: rgba(0,255,0,0.03);
            border: 1px solid rgba(0,255,0,0.2);
            border-radius: 3px;
            word-break: break-word;
            flex-shrink: 0;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.1);
            transition: all 0.3s;
        }
        
        .exo-entry:hover {
            border-color: #0f0;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
            transform: translateY(-1px);
        }
        
        .entry-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 12px;
            color: #080;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(0, 255, 0, 0.2);
        }
        
        .entry-content {
            margin: 8px 0;
            padding: 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 3px;
            border: 1px solid rgba(0, 255, 0, 0.1);
        }
        
        .entry-footer {
            font-size: 10px;
            color: #080;
            margin-top: 8px;
            padding-top: 5px;
            border-top: 1px solid rgba(0,255,0,0.1);
        }
        
        .entry-controls {
            display: flex;
            gap: 5px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .entry-controls button {
            background: rgba(0,255,0,0.1);
            border: 1px solid #0f0;
            color: #0f0;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 11px;
            border-radius: 3px;
            transition: all 0.2s;
            min-width: 70px;
        }
        
        .entry-controls button:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 10px #0f0;
        }
        
        /* ===== BOTTOM BAR ===== */
        #bottom-bar {
            padding: 12px;
            background: rgba(0,0,0,0.95);
            border-top: 1px solid #0f0;
            display: flex;
            gap: 10px;
            flex-shrink: 0;
            align-items: center;
            box-shadow: 0 -5px 20px rgba(0, 255, 0, 0.1);
        }
        
        #command-input {
            flex: 1;
            background: rgba(0,0,0,0.8);
            border: 1px solid #0f0;
            color: #0f0;
            padding: 10px 15px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            border-radius: 3px;
            transition: all 0.3s;
        }
        
        #command-input:focus {
            outline: none;
            border-color: #0a0;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
            background: rgba(0,0,0,0.9);
        }
        
        #bottom-bar button {
            background: rgba(0,255,0,0.1);
            border: 1px solid #0f0;
            color: #0f0;
            padding: 10px 15px;
            cursor: pointer;
            min-width: 100px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-radius: 3px;
            transition: all 0.2s;
        }
        
        #bottom-bar button:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 15px #0f0;
            transform: translateY(-1px);
        }
        
        /* ===== MODAL POPUPS ===== */
        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            z-index: 1000;
        }
        
        .popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            border: 2px solid #0f0;
            padding: 25px;
            display: none;
            z-index: 1001;
            box-shadow: 0 0 50px rgba(0,255,0,0.4);
            max-width: 700px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            border-radius: 5px;
        }
        
        .popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #0f0;
        }
        
        .popup-title {
            color: #0f0;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 0 0 10px #0f0;
        }
        
        .close-btn {
            background: rgba(0,0,0,0.8);
            border: 1px solid #f00;
            color: #f00;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            border-radius: 3px;
            transition: all 0.2s;
        }
        
        .close-btn:hover {
            background: #f00;
            color: #000;
            box-shadow: 0 0 15px #f00;
        }
        
        /* ===== PLAYER POPUP ===== */
        .player-controls {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            justify-content: center;
        }
        
        .player-controls button {
            background: rgba(0,255,0,0.1);
            border: 1px solid #0f0;
            color: #0f0;
            padding: 12px 25px;
            cursor: pointer;
            min-width: 100px;
            font-size: 14px;
            border-radius: 3px;
            transition: all 0.2s;
        }
        
        .player-controls button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .player-controls button:hover:not(:disabled) {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 20px #0f0;
        }
        
        /* ===== PROGRESS BAR ===== */
        .progress-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: #000;
            display: none;
            z-index: 1002;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #0f0, #0a0, #0f0);
            background-size: 200% 100%;
            width: 0%;
            transition: width 0.3s;
            animation: progressGlow 2s infinite linear;
        }
        
        /* ===== ANIMATIONS ===== */
        @keyframes rotateHologram {
            0% { transform: translate(-50%, -50%) rotateY(0deg) rotateX(15deg) rotateZ(0deg); }
            100% { transform: translate(-50%, -50%) rotateY(360deg) rotateX(15deg) rotateZ(5deg); }
        }
        
        @keyframes pulseSquare {
            0%, 100% { 
                opacity: 0.6; 
                transform: scale(1); 
                box-shadow: 0 0 5px #0f0;
            }
            50% { 
                opacity: 0.9; 
                transform: scale(1.1); 
                box-shadow: 0 0 15px #0f0;
            }
        }
        
        @keyframes pulseNode {
            0%, 100% { 
                opacity: 0.5; 
                transform: scale(1); 
                box-shadow: 0 0 5px #0f0;
            }
            50% { 
                opacity: 1; 
                transform: scale(1.3); 
                box-shadow: 0 0 20px #0f0;
            }
        }
        
        @keyframes progressGlow {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        
        /* ===== SCROLLBAR ===== */
        #terminal::-webkit-scrollbar {
            width: 10px;
        }
        
        #terminal::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.5);
            border: 1px solid #0f0;
            border-radius: 3px;
        }
        
        #terminal::-webkit-scrollbar-thumb {
            background: #0f0;
            border: 1px solid #000;
            border-radius: 3px;
            box-shadow: 0 0 10px #0f0;
        }
        
        #terminal::-webkit-scrollbar-thumb:hover {
            background: #0a0;
            box-shadow: 0 0 15px #0a0;
        }
        
        /* ===== RESPONSIVE ===== */
        @media (max-width: 1024px) {
            .terminal-container {
                flex-direction: column;
            }
            
            .neural-panel {
                width: 100%;
                height: 300px;
                border-right: none;
                border-bottom: 1px solid #0f0;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading">
        <div class="ascii-skeleton">
          _     _      _              _            _            _              _            _             _          _            _            _          
        /\ \ /_/\    /\ \           /\ \         / /\         /\_\           /\ \         _\ \          /\ \       /\ \         /\ \         /\ \     _  
       /  \ \\ \ \   \ \_\         /  \ \       / /  \       / / /  _       /  \ \       /\__ \        /  \ \      \_\ \       /  \ \       /  \ \   /\_\
      / /\ \ \\ \ \__/ / /        / /\ \ \     / / /\ \__   / / /  /\_\    / /\ \ \     / /_ \_\      / /\ \ \     /\__ \     / /\ \ \     / /\ \ \_/ / /
     / / /\ \_\\ \__ \/_/        / / /\ \ \   / / /\ \___\ / / /__/ / /   / / /\ \_\   / / /\/_/     / / /\ \_\   / /_ \ \   / / /\ \ \   / / /\ \___/ / 
    / /_/_ \/_/ \/_/\__/\       / / /  \ \_\  \ \ \ \/___// /\_____/ /   / /_/_ \/_/  / / /         / /_/_ \/_/  / / /\ \ \ / / /  \ \_\ / / /  \/____/  
   / /____/\     _/\/__\ \     / / /   / / /   \ \ \     / /\_______/   / /____/\    / / /         / /____/\    / / /  \/_// / /   / / // / /    / / /   
  / /\____\/    / _/_/\ \ \   / / /   / / /_    \ \ \   / / /\ \ \     / /\____\/   / / / ____    / /\____\/   / / /      / / /   / / // / /    / / /    
 / / /______   / / /   \ \ \ / / /___/ / //_/\__/ / /  / / /  \ \ \   / / /______  / /_/_/ ___/\ / / /______  / / /      / / /___/ / // / /    / / /     
/ / /_______\ / / /    /_/ // / /____\/ / \ \/___/ /  / / /    \ \ \ / / /_______\/_______/\__\// / /_______\/_/ /      / / /____\/ // / /    / / /      
\/__________/ \/_/     \_\/ \/_________/   \_____\/   \/_/      \_\_\\/__________/\_______\/    \/__________/\_\/       \/_________/ \/_/     \/_/       
        </div>
        <div class="loading-text">Initializing Neural Encryption System...</div>
    </div>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Header -->
        <div id="header">
            <div class="header-left">
                <div class="logo">EXOSKELETON 2</div>
                <div class="logo-subtitle">Neural Audio-Visual Encryption</div>
            </div>
            <div class="header-right">
                <div class="status-indicator"></div>
                <div style="font-size: 12px; color: #0a0;" id="global-status">ENCRYPTION: ACTIVE</div>
            </div>
        </div>

        <!-- Terminal Container -->
        <div class="terminal-container">
            <!-- Neural Visualization Panel -->
            <div class="neural-panel">
                <div class="panel-header">
                    <span>NEURAL GRID VISUALIZATION</span>
                    <span style="font-size: 11px; color: #0a0;">LIVE</span>
                </div>
                <div class="visualization-container">
                    <div class="hologram-grid" id="hologram-grid"></div>
                    <div class="neural-overlay" id="neural-overlay"></div>
                    <div class="encryption-status" id="encryption-status">SYSTEM: IDLE</div>
                </div>
            </div>

            <!-- Terminal Output -->
            <div class="terminal-output">
                <div id="terminal">
                    <div id="output">
                        <!-- Content will be added here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Bottom Bar -->
        <div id="bottom-bar">
            <input type="text" id="command-input" placeholder="Enter text to encrypt or type /help for commands..." autocomplete="off">
            <button id="encode-btn">ENCRYPT</button>
            <button id="import-btn">IMPORT</button>
            <button id="export-btn">EXPORT</button>
            <button id="help-btn">HELP</button>
        </div>
    </div>

    <!-- Popup Overlay -->
    <div id="popup-overlay" class="popup-overlay"></div>

    <!-- Player Popup -->
    <div id="player-popup" class="popup">
        <div class="popup-header">
            <div class="popup-title">üîä 56K AUDIO PLAYER</div>
            <button class="close-btn" id="close-player-btn">‚úï</button>
        </div>
        <div id="player-info" style="margin: 15px 0; padding: 15px; background: rgba(0,255,0,0.05); border: 1px solid rgba(0,255,0,0.3); border-radius: 3px;">
            No audio loaded
        </div>
        <div class="player-controls">
            <button id="play-btn">‚ñ∂ PLAY</button>
            <button id="pause-btn" disabled>‚è∏ PAUSE</button>
            <button id="stop-btn" disabled>‚èπ STOP</button>
            <button id="export-audio-btn">üíæ EXPORT</button>
        </div>
        <div style="margin: 20px 0;">
            <div style="display: flex; align-items: center; gap: 15px;">
                <span style="color: #0f0; font-size: 14px;">VOLUME:</span>
                <input type="range" id="volume-slider" min="0" max="100" value="70" style="flex: 1;">
                <span id="volume-value" style="color: #0a0; min-width: 40px; font-size: 14px;">70%</span>
            </div>
        </div>
        <div id="player-time" style="text-align: center; font-size: 14px; color: #0f0; margin: 10px 0; font-family: monospace;">--:-- / --:--</div>
        <div id="audio-info" style="margin-top: 15px; font-size: 12px; color: #080; text-align: center;">
            Sample Rate: -- Hz | Duration: -- | Size: -- KB
        </div>
    </div>

    <!-- Help Popup -->
    <div id="help-popup" class="popup">
        <div class="popup-header">
            <div class="popup-title">EXOSKELETON 2 COMMANDS</div>
            <button class="close-btn" id="close-help-btn">‚úï</button>
        </div>
        <div style="margin: 20px 0;">
            <div style="color: #0f0; margin-bottom: 15px; font-size: 16px; padding-bottom: 10px; border-bottom: 1px solid #0f0;">
                BASIC COMMANDS:
            </div>
            <div style="display: grid; grid-template-columns: 1fr 2fr; gap: 10px; margin-bottom: 20px;">
                <div style="color: #0a0; font-weight: bold;">[any text]</div>
                <div>Encrypt text into neural grid + 56K audio</div>
                
                <div style="color: #0a0; font-weight: bold;">/help</div>
                <div>Show this help menu</div>
                
                <div style="color: #0a0; font-weight: bold;">/clear</div>
                <div>Clear terminal screen</div>
                
                <div style="color: #0a0; font-weight: bold;">/list</div>
                <div>Show all encrypted entries</div>
                
                <div style="color: #0a0; font-weight: bold;">/export [id]</div>
                <div>Export entry as EXOSKELETON.ZIP</div>
                
                <div style="color: #0a0; font-weight: bold;">/import</div>
                <div>Import EXOSKELETON.ZIP file</div>
                
                <div style="color: #0a0; font-weight: bold;">/play [id]</div>
                <div>Play encrypted 56K audio</div>
                
                <div style="color: #0a0; font-weight: bold;">/visualize [id]</div>
                <div>Regenerate neural visualization</div>
                
                <div style="color: #0a0; font-weight: bold;">/status</div>
                <div>Show system status</div>
            </div>
        </div>
    </div>

    <!-- Hidden File Input -->
    <input type="file" id="file-input" accept=".zip,.exoskeleton" style="display:none;">

    <!-- Progress Container -->
    <div id="progress-container" class="progress-container">
        <div id="progress-bar" class="progress-bar"></div>
    </div>

    <script>
        // ==================== GLOBAL STATE ====================
        const EXOSKELETON2 = {
            // Core state
            entries: [],
            currentEntry: null,
            neuralGrid: [],
            neuralNodes: [[], [], []],
            neuralConnections: [],
            
            // Audio state
            audioContext: null,
            currentAudio: null,
            currentSource: null,
            isPlaying: false,
            volume: 0.7,
            
            // Processing state
            isProcessing: false,
            
            // Database
            db: null,
            dbName: 'Exoskeleton2DB',
            dbVersion: 7,
            
            // Encryption
            appKey: 'EXOSKELETON2_APP_KEY_2025_FIXED', // Fixed for import/export compatibility
            
            // Visualization
            lastVisualizationUpdate: 0,
            currentVisualizedEntryId: null,
            
            // Auto-scroll
            autoScroll: true
        };

        // ==================== INITIALIZATION ====================
        async function init() {
            // Show loading screen
            setTimeout(async () => {
                document.getElementById('loading').style.display = 'none';
                document.querySelector('.main-container').style.display = 'flex';
                
                await typewriterLog('EXOSKELETON 2 - Neural Audio-Visual Encryption System');
                await sleep(300);
                await typewriterLog('Initializing encryption engine...');
                await sleep(300);
                await typewriterLog('Loading 56K modem audio processor...');
                
                // Initialize components
                await initDB();
                await initializeAudio();
                await loadEntries();
                
                await typewriterLog('Encryption system ready ‚úì');
                await typewriterLog('56K audio encoder ready ‚úì');
                await typewriterLog('Neural grid visualization active ‚úì');
                await typewriterLog('System ready. Type /help for commands.');
                await typewriterLog('Enter text to create neural-audio encryption.');
                
                setupEventListeners();
                document.getElementById('command-input').focus();
                
                updateEncryptionStatus('READY');
                updateGlobalStatus('ACTIVE');
                
            }, 2500);
        }

        function updateGlobalStatus(status) {
            document.getElementById('global-status').textContent = `ENCRYPTION: ${status}`;
        }

        // ==================== DATABASE ====================
        async function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(EXOSKELETON2.dbName, EXOSKELETON2.dbVersion);
                
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('entries')) {
                        const store = db.createObjectStore('entries', { keyPath: 'id' });
                        store.createIndex('timestamp', 'timestamp');
                        store.createIndex('hash', 'hash');
                    }
                };
                
                request.onsuccess = (e) => {
                    EXOSKELETON2.db = e.target.result;
                    resolve();
                };
                
                request.onerror = (e) => {
                    console.error('Database error:', e);
                    typewriterLog('Database initialization failed', 'error');
                    resolve();
                };
            });
        }

        async function saveEntry(entry) {
            if (!EXOSKELETON2.db) return Promise.resolve();
            
            return new Promise((resolve, reject) => {
                const tx = EXOSKELETON2.db.transaction(['entries'], 'readwrite');
                const store = tx.objectStore('entries');
                
                const request = store.put(entry);
                
                request.onsuccess = () => resolve();
                request.onerror = (e) => reject(e);
            });
        }

        async function loadEntries() {
            if (!EXOSKELETON2.db) return;
            
            return new Promise((resolve, reject) => {
                const tx = EXOSKELETON2.db.transaction(['entries'], 'readonly');
                const store = tx.objectStore('entries');
                const request = store.getAll();
                
                request.onsuccess = (e) => {
                    const entries = e.target.result || [];
                    EXOSKELETON2.entries = entries;
                    
                    if (entries.length > 0) {
                        typewriterLog(`Loaded ${entries.length} encrypted entries from database`);
                        entries.forEach(entry => displayEntry(entry, false));
                        const latest = entries[entries.length - 1];
                        updateVisualization(latest.neuralData, latest.id);
                    }
                    resolve();
                };
                
                request.onerror = (e) => reject(e);
            });
        }

        async function deleteEntry(id) {
            const index = EXOSKELETON2.entries.findIndex(e => e.id === id);
            if (index !== -1) {
                EXOSKELETON2.entries.splice(index, 1);
            }
            
            if (!EXOSKELETON2.db) return Promise.resolve();
            
            return new Promise((resolve, reject) => {
                const tx = EXOSKELETON2.db.transaction(['entries'], 'readwrite');
                const store = tx.objectStore('entries');
                
                const request = store.delete(id);
                request.onsuccess = () => resolve();
                request.onerror = () => reject();
            });
        }

        // ==================== AUDIO FUNCTIONS ====================
        async function initializeAudio() {
            try {
                EXOSKELETON2.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                return true;
            } catch (error) {
                console.error('Audio context failed:', error);
                typewriterLog('Audio context initialization failed - some features disabled', 'error');
                return false;
            }
        }

        function generateModemAudio(text, sampleRate = 44100) {
            // Enhanced 56K modem frequencies
            const FREQUENCIES = {
                MARK: [1200, 1300],      // Binary 1 frequencies
                SPACE: [2400, 2500],     // Binary 0 frequencies
                ANSWER: [2100],          // Answer tone
                CARRIER: [1800]          // Carrier
            };
            
            const BAUD_RATE = 2400;
            const BIT_DURATION = sampleRate / BAUD_RATE;
            
            // Generate encryption key from text
            const encryptionKey = CryptoJS.SHA256(text + EXOSKELETON2.appKey).toString();
            const keyBytes = [];
            for (let i = 0; i < encryptionKey.length; i += 2) {
                keyBytes.push(parseInt(encryptionKey.substr(i, 2), 16));
            }
            
            const encoder = new TextEncoder();
            const bytes = encoder.encode(text);
            
            // XOR encryption with key
            const encryptedBytes = new Uint8Array(bytes.length);
            for (let i = 0; i < bytes.length; i++) {
                encryptedBytes[i] = bytes[i] ^ keyBytes[i % keyBytes.length];
            }
            
            // Calculate buffer size
            const handshakeSamples = sampleRate * 1.0; // 1.0s handshake
            const dataSamples = encryptedBytes.length * 10 * BIT_DURATION;
            const endSamples = sampleRate * 0.3;
            const totalSamples = Math.ceil(handshakeSamples + dataSamples + endSamples);
            
            const audioBuffer = EXOSKELETON2.audioContext.createBuffer(1, totalSamples, sampleRate);
            const data = audioBuffer.getChannelData(0);
            
            let sampleIndex = 0;
            
            // Handshake sequence
            for (let i = 0; i < sampleRate; i++) {
                const t = i / sampleRate;
                data[sampleIndex++] = 0.7 * Math.sin(2 * Math.PI * FREQUENCIES.ANSWER[0] * t);
            }
            
            for (let i = 0; i < 0.3 * sampleRate; i++) {
                const t = (i + sampleRate) / sampleRate;
                data[sampleIndex++] = 0.6 * Math.sin(2 * Math.PI * FREQUENCIES.CARRIER[0] * t);
            }
            
            // Data transmission with frequency hopping
            let freqIndex = 0;
            for (let byte of encryptedBytes) {
                // Start bit (0)
                const startFreq = FREQUENCIES.SPACE[freqIndex % FREQUENCIES.SPACE.length];
                for (let i = 0; i < BIT_DURATION; i++) {
                    const t = sampleIndex / sampleRate;
                    data[sampleIndex++] = 0.7 * Math.sin(2 * Math.PI * startFreq * t);
                }
                
                // 8 data bits
                for (let bit = 0; bit < 8; bit++) {
                    const value = (byte >> bit) & 1;
                    const freqSet = value ? FREQUENCIES.MARK : FREQUENCIES.SPACE;
                    const freq = freqSet[freqIndex % freqSet.length];
                    
                    for (let i = 0; i < BIT_DURATION; i++) {
                        const t = sampleIndex / sampleRate;
                        const noise = (Math.random() - 0.5) * 0.05;
                        data[sampleIndex++] = (0.65 + noise) * Math.sin(2 * Math.PI * freq * t);
                    }
                    
                    freqIndex++;
                }
                
                // Stop bit (1)
                const stopFreq = FREQUENCIES.MARK[freqIndex % FREQUENCIES.MARK.length];
                for (let i = 0; i < BIT_DURATION; i++) {
                    const t = sampleIndex / sampleRate;
                    data[sampleIndex++] = 0.7 * Math.sin(2 * Math.PI * stopFreq * t);
                }
                
                // Small pause between bytes
                for (let i = 0; i < BIT_DURATION * 0.3 && sampleIndex < totalSamples; i++) {
                    data[sampleIndex++] = 0;
                }
            }
            
            // End sequence
            for (let i = 0; i < endSamples && sampleIndex < totalSamples; i++) {
                const t = i / sampleRate;
                const freq = 400 + (200 * Math.sin(Math.PI * t));
                data[sampleIndex++] = 0.4 * Math.sin(2 * Math.PI * freq * t);
            }
            
            // Fill remaining with silence
            while (sampleIndex < totalSamples) {
                data[sampleIndex++] = 0;
            }
            
            return {
                buffer: audioBuffer,
                encryptionKey: encryptionKey,
                baudRate: BAUD_RATE,
                sampleRate: sampleRate,
                duration: audioBuffer.duration,
                encryptedBytes: Array.from(encryptedBytes)
            };
        }

        // ==================== NEURAL ENCRYPTION ====================
        function generateNeuralEncryption(text) {
            // Generate hash from text and app key (FIXED for import/export compatibility)
            const hash = CryptoJS.SHA512(text + EXOSKELETON2.appKey + text.length).toString();
            const seed = parseInt(hash.substring(0, 8), 16) || 12345678;
            
            // Generate 3D grid squares
            const gridSquares = [];
            const squareCount = Math.min(Math.max(text.length * 2, 20), 80);
            
            for (let i = 0; i < squareCount; i++) {
                const charCode = text.charCodeAt(i % text.length) || 65;
                const hashPart = parseInt(hash.substring(i * 2, i * 2 + 2), 16) || 0;
                
                const size = 8 + (hashPart % 15);
                const angle = (i * 137.5) * (Math.PI / 180);
                const radius = 60 + (i % 40);
                const left = 140 + Math.cos(angle) * radius;
                const top = 140 + Math.sin(angle) * radius;
                const depth = (hashPart % 100) - 50;
                
                const rotateX = (charCode % 180) - 90;
                const rotateY = (hashPart % 180) - 90;
                const rotateZ = (i * 15) % 360;
                
                const opacity = 0.4 + (hashPart % 60) / 100;
                const hue = (hashPart + i * 30) % 120;
                
                gridSquares.push({
                    size,
                    left,
                    top,
                    depth,
                    rotateX,
                    rotateY,
                    rotateZ,
                    opacity,
                    hue,
                    charCode
                });
            }
            
            // Generate neural nodes
            const neuralNodes = [[], [], []];
            const layers = [9, 6, 3];
            
            for (let layer = 0; layer < 3; layer++) {
                for (let i = 0; i < layers[layer]; i++) {
                    const angle = (i * (360 / layers[layer]) + layer * 45) * (Math.PI / 180);
                    const radius = 70 + layer * 30;
                    const x = 140 + Math.cos(angle) * radius;
                    const y = 140 + Math.sin(angle) * radius;
                    const z = (layer - 1) * 60;
                    
                    const nodeHash = parseInt(hash.substring((layer * 10 + i) * 2, (layer * 10 + i) * 2 + 2), 16) || 0;
                    const intensity = 0.5 + (nodeHash % 50) / 100;
                    
                    neuralNodes[layer].push({ 
                        x, y, z, 
                        intensity,
                        layer,
                        index: i
                    });
                }
            }
            
            // Create connections
            const connections = [];
            for (let layer = 0; layer < 2; layer++) {
                const currentLayer = neuralNodes[layer];
                const nextLayer = neuralNodes[layer + 1];
                
                for (let i = 0; i < currentLayer.length; i++) {
                    for (let j = 0; j < nextLayer.length; j++) {
                        if ((i + j + layer) % 3 === 0 || Math.random() < 0.3) {
                            connections.push({
                                from: { ...currentLayer[i], layer, index: i },
                                to: { ...nextLayer[j], layer: layer + 1, index: j },
                                strength: 0.5 + Math.random() * 0.5
                            });
                        }
                    }
                }
            }
            
            return {
                hash,
                seed,
                gridSquares,
                neuralNodes,
                connections,
                timestamp: Date.now(),
                textLength: text.length,
                encryptionLevel: '56K_NEURAL_V2'
            };
        }

        // ==================== VISUALIZATION ====================
        function updateVisualization(encryptionData, entryId = null) {
            const gridContainer = document.getElementById('hologram-grid');
            const neuralContainer = document.getElementById('neural-overlay');
            
            // Clear previous visualization
            gridContainer.innerHTML = '';
            neuralContainer.innerHTML = '';
            
            updateEncryptionStatus('RENDERING...');
            
            // If no encryption data provided, show idle state
            if (!encryptionData) {
                updateEncryptionStatus('IDLE');
                EXOSKELETON2.currentVisualizedEntryId = null;
                return;
            }
            
            // Add grid squares
            encryptionData.gridSquares.forEach((square, i) => {
                const div = document.createElement('div');
                div.className = 'grid-square';
                div.style.width = `${square.size}px`;
                div.style.height = `${square.size}px`;
                div.style.left = `${square.left}px`;
                div.style.top = `${square.top}px`;
                div.style.transform = `
                    translateZ(${square.depth}px) 
                    rotateX(${square.rotateX}deg) 
                    rotateY(${square.rotateY}deg)
                    rotateZ(${square.rotateZ}deg)
                `;
                div.style.opacity = square.opacity;
                div.style.background = `hsla(${square.hue}, 100%, 50%, ${square.opacity})`;
                div.style.borderColor = `hsl(${square.hue}, 100%, 70%)`;
                div.style.boxShadow = `0 0 10px hsla(${square.hue}, 100%, 50%, 0.5)`;
                div.style.animationDelay = `${(i % 20) * 0.05}s`;
                div.style.animationDuration = `${3 + (i % 7)}s`;
                gridContainer.appendChild(div);
            });
            
            // Add neural nodes
            encryptionData.neuralNodes.forEach((layer, layerIndex) => {
                layer.forEach((node, nodeIndex) => {
                    const div = document.createElement('div');
                    div.className = 'neural-node';
                    div.style.left = `${node.x}px`;
                    div.style.top = `${node.y}px`;
                    div.style.transform = `translateZ(${node.z}px)`;
                    div.style.animationDelay = `${(layerIndex * 0.5 + nodeIndex * 0.1)}s`;
                    div.style.animationDuration = `${1.5 + (nodeIndex % 3)}s`;
                    div.style.boxShadow = `0 0 ${5 + node.intensity * 15}px #0f0`;
                    neuralContainer.appendChild(div);
                });
            });
            
            // Add neural connections
            if (encryptionData.connections) {
                encryptionData.connections.forEach((connection, i) => {
                    const from = connection.from;
                    const to = connection.to;
                    
                    const line = document.createElement('div');
                    line.className = 'neural-connection';
                    
                    const dx = to.x - from.x;
                    const dy = to.y - from.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx) * (180 / Math.PI);
                    
                    line.style.width = `${distance}px`;
                    line.style.left = `${from.x}px`;
                    line.style.top = `${from.y}px`;
                    line.style.transform = `
                        rotate(${angle}deg)
                        translateZ(${(from.z + to.z) / 2}px)
                    `;
                    line.style.opacity = 0.1 + (connection.strength * 0.3);
                    line.style.height = `${1 + connection.strength * 2}px`;
                    
                    neuralContainer.appendChild(line);
                });
            }
            
            setTimeout(() => {
                updateEncryptionStatus(`ENCRYPTED: ${encryptionData.hash.substring(0, 12)}...`);
            }, 1000);
            
            // Track which entry is currently visualized
            EXOSKELETON2.currentVisualizedEntryId = entryId;
        }

        function updateEncryptionStatus(status) {
            const statusElement = document.getElementById('encryption-status');
            if (statusElement) {
                statusElement.textContent = `STATUS: ${status}`;
                
                if (status.includes('RENDERING') || status.includes('ENCRYPTING')) {
                    statusElement.style.color = '#ff0';
                    statusElement.style.textShadow = '0 0 5px #ff0';
                } else if (status.includes('READY') || status.includes('ENCRYPTED')) {
                    statusElement.style.color = '#0f0';
                    statusElement.style.textShadow = '0 0 5px #0f0';
                } else if (status.includes('ERROR')) {
                    statusElement.style.color = '#f00';
                    statusElement.style.textShadow = '0 0 5px #f00';
                } else {
                    statusElement.style.color = '#0a0';
                    statusElement.style.textShadow = '0 0 5px #0a0';
                }
            }
        }

        // ==================== ENTRY CREATION ====================
        async function createEncryptedEntry(text) {
            if (EXOSKELETON2.isProcessing) {
                log('System busy processing another request', 'error');
                return null;
            }
            
            EXOSKELETON2.isProcessing = true;
            showProgress('Initializing encryption...', 0);
            
            try {
                updateProgress(20);
                updateEncryptionStatus('GENERATING NEURAL GRID...');
                
                const neuralData = generateNeuralEncryption(text);
                updateProgress(40);
                
                updateEncryptionStatus('GENERATING 56K AUDIO...');
                const audioResult = generateModemAudio(text);
                updateProgress(70);
                
                const audioData = {
                    sampleRate: audioResult.sampleRate,
                    duration: audioResult.duration,
                    data: Array.from(audioResult.buffer.getChannelData(0)),
                    encryptionKey: audioResult.encryptionKey,
                    baudRate: audioResult.baudRate,
                    encryptedBytes: audioResult.encryptedBytes
                };
                updateProgress(85);
                
                const entry = {
                    id: Date.now() + Math.floor(Math.random() * 1000),
                    text: text,
                    hash: neuralData.hash,
                    neuralData: neuralData,
                    audioData: audioData,
                    timestamp: Date.now(),
                    encrypted: true,
                    encryptionLevel: '56K_NEURAL_V2',
                    audioDuration: audioResult.duration,
                    audioSize: Math.round(audioResult.buffer.length * 4 / 1024)
                };
                
                await saveEntry(entry);
                EXOSKELETON2.entries.push(entry);
                updateProgress(100);
                
                displayEntry(entry);
                updateVisualization(neuralData, entry.id);
                
                await typewriterLog(`‚úì Created encrypted entry #${EXOSKELETON2.entries.length}`, 'success');
                await typewriterLog(`Hash: ${neuralData.hash.substring(0, 24)}...`);
                await typewriterLog(`Audio: ${audioResult.baudRate} baud, ${audioResult.duration.toFixed(2)}s`);
                
                hideProgress();
                EXOSKELETON2.isProcessing = false;
                updateEncryptionStatus('READY');
                return entry;
                
            } catch (error) {
                console.error('Encryption failed:', error);
                log(`Encryption failed: ${error.message}`, 'error');
                updateEncryptionStatus('ERROR');
                hideProgress();
                EXOSKELETON2.isProcessing = false;
                return null;
            }
        }

        // ==================== FIXED ZIP CREATION ====================
        async function createExoskeletonZip(entry) {
            showProgress('Creating EXOSKELETON.ZIP...', 0);
            
            try {
                const zip = new JSZip();
                
                // 1. Create manifest
                const manifest = {
                    version: 'EXOSKELETON2_V2',
                    id: entry.id,
                    timestamp: entry.timestamp,
                    textLength: entry.text.length,
                    encryptionLevel: entry.encryptionLevel,
                    hash: entry.hash,
                    audioInfo: {
                        baudRate: entry.audioData.baudRate,
                        duration: entry.audioData.duration,
                        sampleRate: entry.audioData.sampleRate
                    }
                };
                zip.file("MANIFEST.json", JSON.stringify(manifest, null, 2));
                updateProgress(15);
                
                // 2. Store original text (plain for now - we'll fix encryption)
                zip.file("TEXT.txt", entry.text);
                updateProgress(30);
                
                // 3. Store neural data
                zip.file("NEURAL.json", JSON.stringify(entry.neuralData));
                updateProgress(45);
                
                // 4. Store audio data as base64 encoded array
                const audioArray = new Float32Array(entry.audioData.data);
                const audioBuffer = audioArray.buffer;
                const audioBase64 = arrayBufferToBase64(audioBuffer);
                zip.file("AUDIO.dat", audioBase64);
                updateProgress(60);
                
                // 5. Store audio metadata
                const audioMeta = {
                    sampleRate: entry.audioData.sampleRate,
                    duration: entry.audioData.duration,
                    length: entry.audioData.data.length
                };
                zip.file("AUDIO_META.json", JSON.stringify(audioMeta));
                updateProgress(75);
                
                // 6. Create validation signature using text + hash
                const signature = {
                    textHash: CryptoJS.SHA256(entry.text).toString(),
                    neuralHash: entry.hash,
                    timestamp: new Date().toISOString(),
                    validation: CryptoJS.SHA512(entry.text + entry.hash).toString().substring(0, 32)
                };
                zip.file("SIGNATURE.json", JSON.stringify(signature));
                updateProgress(90);
                
                // 7. Add readme
                const readme = `EXOSKELETON 2.0 ENCRYPTION CONTAINER
===================================
Created: ${new Date(entry.timestamp).toISOString()}
Hash: ${entry.hash}
Text Length: ${entry.text.length} characters
Audio: ${entry.audioData.baudRate} baud, ${entry.audioData.duration.toFixed(2)}s

This container can be imported back into EXOSKELETON 2.0
for neural visualization and audio playback.`;
                zip.file("README.txt", readme);
                updateProgress(100);
                
                const content = await zip.generateAsync({ 
                    type: "blob",
                    compression: "DEFLATE",
                    compressionOptions: { level: 6 }
                });
                
                hideProgress();
                return content;
                
            } catch (error) {
                console.error('ZIP creation failed:', error);
                log(`ZIP creation failed: ${error.message}`, 'error');
                hideProgress();
                return null;
            }
        }

        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function recreateAudioBuffer(audioData) {
            if (!EXOSKELETON2.audioContext) {
                EXOSKELETON2.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            const audioBuffer = EXOSKELETON2.audioContext.createBuffer(
                1, 
                audioData.data.length, 
                audioData.sampleRate
            );
            
            const channelData = audioBuffer.getChannelData(0);
            for (let i = 0; i < audioData.data.length; i++) {
                channelData[i] = audioData.data[i];
            }
            
            return audioBuffer;
        }

        // ==================== FIXED IMPORT SYSTEM ====================
        async function importExoskeletonZip(file) {
            if (!file.name.toLowerCase().endsWith('.zip') && !file.name.toLowerCase().endsWith('.exoskeleton')) {
                log('Only .zip or .exoskeleton files are supported', 'error');
                return;
            }
            
            showProgress('Importing EXOSKELETON.ZIP...', 0);
            updateGlobalStatus('IMPORTING');
            
            try {
                const zip = new JSZip();
                const zipData = await zip.loadAsync(file);
                updateProgress(20);
                
                // Check for manifest
                if (!zipData.files['MANIFEST.json']) {
                    throw new Error('Invalid EXOSKELETON container: Missing MANIFEST.json');
                }
                
                // Load manifest
                const manifest = JSON.parse(await zipData.files['MANIFEST.json'].async('text'));
                updateProgress(30);
                
                // Load text
                if (!zipData.files['TEXT.txt']) {
                    throw new Error('Invalid EXOSKELETON container: Missing TEXT.txt');
                }
                const text = await zipData.files['TEXT.txt'].async('text');
                updateProgress(40);
                
                // Load neural data
                if (!zipData.files['NEURAL.json']) {
                    throw new Error('Invalid EXOSKELETON container: Missing NEURAL.json');
                }
                const neuralData = JSON.parse(await zipData.files['NEURAL.json'].async('text'));
                updateProgress(50);
                
                // Load audio data
                if (!zipData.files['AUDIO.dat'] || !zipData.files['AUDIO_META.json']) {
                    throw new Error('Invalid EXOSKELETON container: Missing audio files');
                }
                updateProgress(60);
                
                // Load audio metadata
                const audioMeta = JSON.parse(await zipData.files['AUDIO_META.json'].async('text'));
                
                // Load audio binary data
                const audioBase64 = await zipData.files['AUDIO.dat'].async('text');
                const audioBuffer = base64ToArrayBuffer(audioBase64);
                const floatArray = new Float32Array(audioBuffer);
                updateProgress(70);
                
                // Validate signature if present
                if (zipData.files['SIGNATURE.json']) {
                    const signature = JSON.parse(await zipData.files['SIGNATURE.json'].async('text'));
                    const computedHash = CryptoJS.SHA512(text + neuralData.hash).toString().substring(0, 32);
                    if (computedHash !== signature.validation) {
                        log('Warning: Signature validation failed - file may have been modified', 'error');
                    }
                }
                updateProgress(80);
                
                // Create entry from imported data
                const entry = {
                    id: manifest.id || Date.now(),
                    text: text,
                    hash: neuralData.hash || CryptoJS.SHA512(text + EXOSKELETON2.appKey + text.length).toString(),
                    neuralData: neuralData,
                    audioData: {
                        sampleRate: audioMeta.sampleRate || 44100,
                        duration: audioMeta.duration || 0,
                        data: Array.from(floatArray),
                        baudRate: manifest.audioInfo?.baudRate || 2400
                    },
                    timestamp: manifest.timestamp || Date.now(),
                    encrypted: true,
                    imported: true,
                    encryptionLevel: manifest.encryptionLevel || '56K_NEURAL_V2',
                    sourceFile: file.name
                };
                updateProgress(90);
                
                // Save to database
                await saveEntry(entry);
                EXOSKELETON2.entries.push(entry);
                updateProgress(100);
                
                // Display entry
                displayEntry(entry);
                updateVisualization(neuralData, entry.id);
                
                hideProgress();
                updateGlobalStatus('ACTIVE');
                
                await typewriterLog(`‚úì Imported: ${file.name}`, 'success');
                await typewriterLog(`Text: ${text.substring(0, 60)}${text.length > 60 ? '...' : ''}`);
                await typewriterLog(`Audio: ${entry.audioData.baudRate} baud, ${entry.audioData.duration.toFixed(2)}s`);
                await typewriterLog(`Neural: ${neuralData.gridSquares.length} grid squares`);
                
            } catch (error) {
                console.error('Import failed:', error);
                log(`Import failed: ${error.message}`, 'error');
                hideProgress();
                updateGlobalStatus('ERROR');
                
                // Try legacy format
                setTimeout(() => {
                    log('Trying legacy format detection...', 'output');
                    tryLegacyImport(file);
                }, 1000);
            }
        }

        async function tryLegacyImport(file) {
            try {
                const zip = new JSZip();
                const zipData = await zip.loadAsync(file);
                
                // Look for common files
                const files = Object.keys(zipData.files);
                
                if (files.includes('CONTENT.enc') && files.includes('NEURAL.json')) {
                    log('Detected legacy EXOSKELETON format, attempting conversion...', 'output');
                    
                    // For legacy format, we'll try to extract what we can
                    let text = 'LEGACY IMPORT - Data encrypted in older format';
                    let neuralData = { gridSquares: [], neuralNodes: [[], [], []] };
                    
                    if (zipData.files['NEURAL.json']) {
                        neuralData = JSON.parse(await zipData.files['NEURAL.json'].async('text'));
                    }
                    
                    const entry = {
                        id: Date.now(),
                        text: text,
                        hash: neuralData.hash || CryptoJS.SHA256(text).toString(),
                        neuralData: neuralData,
                        timestamp: Date.now(),
                        encrypted: true,
                        imported: true,
                        encryptionLevel: 'LEGACY',
                        sourceFile: file.name + ' (legacy)'
                    };
                    
                    await saveEntry(entry);
                    EXOSKELETON2.entries.push(entry);
                    displayEntry(entry);
                    updateVisualization(neuralData, entry.id);
                    
                    log('‚úì Legacy format imported (visualization only)', 'success');
                }
            } catch (legacyError) {
                console.error('Legacy import failed:', legacyError);
                log('Cannot read this file format', 'error');
            }
        }

        // ==================== EXPORT SYSTEM ====================
        async function exportEntryAsZip(entryId) {
            const entry = EXOSKELETON2.entries.find(e => e.id === entryId);
            if (!entry) {
                log('Entry not found', 'error');
                return;
            }
            
            const zipBlob = await createExoskeletonZip(entry);
            if (!zipBlob) {
                log('Failed to create ZIP', 'error');
                return;
            }
            
            const timestamp = new Date(entry.timestamp).toISOString().slice(0, 19).replace(/[:T]/g, '-');
            const hashShort = entry.hash.substring(0, 8);
            const filename = `EXOSKELETON_${hashShort}_${timestamp}.zip`;
            
            const url = URL.createObjectURL(zipBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
            
            await typewriterLog(`‚úì Exported: ${filename}`, 'success');
            await typewriterLog(`Size: ${Math.round(zipBlob.size / 1024)} KB`);
            await typewriterLog('This file can be imported back into EXOSKELETON 2.0');
        }

        // ==================== UI FUNCTIONS ====================
        function displayEntry(entry, scroll = true) {
            const output = document.getElementById('output');
            const entryDiv = document.createElement('div');
            entryDiv.className = 'exo-entry';
            entryDiv.id = `entry-${entry.id}`;
            
            const shortText = entry.text.length > 80 
                ? entry.text.substring(0, 80) + '...' 
                : entry.text;
            
            const timestamp = new Date(entry.timestamp).toLocaleTimeString();
            const date = new Date(entry.timestamp).toLocaleDateString();
            const audioInfo = entry.audioData ? 
                `${entry.audioData.baudRate || '?'} baud, ${entry.audioData.duration.toFixed(2)}s` : 
                'No audio';
            
            entryDiv.innerHTML = `
                <div class="entry-header">
                    <span style="color: #0f0; font-weight: bold;">#${EXOSKELETON2.entries.length} - ${entry.encryptionLevel}</span>
                    <span style="color: #0a0;">${date} ${timestamp}</span>
                </div>
                <div class="entry-content">
                    ${shortText}
                </div>
                <div class="entry-footer">
                    <div>Hash: ${entry.hash.substring(0, 24)}...</div>
                    <div>Audio: ${audioInfo} | ${entry.imported ? '(Imported)' : '(Created)'}</div>
                </div>
                <div class="entry-controls">
                    <button onclick="playEntry(${entry.id})">‚ñ∂ PLAY</button>
                    <button onclick="visualizeEntry(${entry.id})">üîÆ VISUALIZE</button>
                    <button onclick="exportEntry(${entry.id})">üì¶ EXPORT</button>
                    <button onclick="showEntryDetails(${entry.id})">üîç DETAILS</button>
                    <button onclick="deleteEntryUI(${entry.id})" style="color: #f00;">üóë DELETE</button>
                </div>
            `;
            
            output.appendChild(entryDiv);
            
            if (scroll) {
                scrollToBottom();
            }
        }

        async function playEntry(entryId) {
            const entry = EXOSKELETON2.entries.find(e => e.id === entryId);
            if (!entry || !entry.audioData) {
                log('Audio not available for this entry', 'error');
                return;
            }
            
            await playAudio(entry);
        }

        function visualizeEntry(entryId) {
            const entry = EXOSKELETON2.entries.find(e => e.id === entryId);
            if (!entry) {
                log('Entry not found', 'error');
                return;
            }
            
            updateVisualization(entry.neuralData, entry.id);
            typewriterLog(`Visualizing entry #${EXOSKELETON2.entries.findIndex(e => e.id === entryId) + 1}`, 'success');
        }

        function showEntryDetails(entryId) {
            const entry = EXOSKELETON2.entries.find(e => e.id === entryId);
            if (!entry) {
                log('Entry not found', 'error');
                return;
            }
            
            const details = `
Entry Details:
-------------
ID: ${entry.id}
Created: ${new Date(entry.timestamp).toLocaleString()}
Text Length: ${entry.text.length} characters
Encryption: ${entry.encryptionLevel}
Hash: ${entry.hash}
Audio: ${entry.audioData ? `${entry.audioData.baudRate} baud, ${entry.audioData.duration.toFixed(2)}s` : 'None'}
Neural Grid: ${entry.neuralData.gridSquares.length} squares
Neural Nodes: ${entry.neuralData.neuralNodes.flat().length} nodes
${entry.imported ? 'Imported from file' : 'Created locally'}
`;
            
            log(details, 'output');
        }

        async function deleteEntryUI(entryId) {
            if (confirm('Permanently delete this encrypted entry?')) {
                try {
                    await deleteEntry(entryId);
                    const element = document.getElementById(`entry-${entryId}`);
                    if (element) element.remove();
                    
                    // Clear visualization if this was the visualized entry
                    if (EXOSKELETON2.currentVisualizedEntryId === entryId) {
                        if (EXOSKELETON2.entries.length > 0) {
                            // Show the latest entry
                            const latestEntry = EXOSKELETON2.entries[EXOSKELETON2.entries.length - 1];
                            updateVisualization(latestEntry.neuralData, latestEntry.id);
                        } else {
                            // Clear visualization completely
                            updateVisualization(null);
                        }
                    }
                    
                    typewriterLog('Entry deleted', 'success');
                } catch (error) {
                    log('Delete failed', 'error');
                }
            }
        }

        // ==================== AUDIO PLAYBACK ====================
        async function playAudio(entry) {
            if (!entry.audioData) {
                log('No audio data available', 'error');
                return;
            }
            
            if (!EXOSKELETON2.audioContext) {
                EXOSKELETON2.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            if (EXOSKELETON2.audioContext.state === 'suspended') {
                await EXOSKELETON2.audioContext.resume();
            }
            
            if (EXOSKELETON2.currentSource) {
                try {
                    EXOSKELETON2.currentSource.stop();
                } catch (e) {}
                EXOSKELETON2.currentSource = null;
            }
            
            const audioBuffer = recreateAudioBuffer(entry.audioData);
            
            EXOSKELETON2.currentSource = EXOSKELETON2.audioContext.createBufferSource();
            EXOSKELETON2.currentSource.buffer = audioBuffer;
            
            const gainNode = EXOSKELETON2.audioContext.createGain();
            gainNode.gain.value = EXOSKELETON2.volume;
            
            EXOSKELETON2.currentSource.connect(gainNode);
            gainNode.connect(EXOSKELETON2.audioContext.destination);
            
            EXOSKELETON2.currentSource.start();
            EXOSKELETON2.isPlaying = true;
            EXOSKELETON2.currentAudio = entry;
            
            showPlayer();
            document.getElementById('player-info').innerHTML = `
                <div style="color: #0f0; font-weight: bold;">Playing: ${entry.text.substring(0, 40)}${entry.text.length > 40 ? '...' : ''}</div>
                <div style="font-size: 11px; color: #0a0; margin-top: 5px;">
                    ${entry.audioData.baudRate || '?'} baud | ${audioBuffer.duration.toFixed(2)}s
                </div>
            `;
            
            document.getElementById('audio-info').innerHTML = `
                Sample Rate: ${entry.audioData.sampleRate} Hz | 
                Duration: ${audioBuffer.duration.toFixed(2)}s | 
                Size: ${Math.round(entry.audioData.data.length * 4 / 1024)} KB
            `;
            
            const startTime = EXOSKELETON2.audioContext.currentTime;
            const updateTime = () => {
                if (EXOSKELETON2.isPlaying) {
                    const currentTime = EXOSKELETON2.audioContext.currentTime - startTime;
                    const timeElement = document.getElementById('player-time');
                    timeElement.textContent = 
                        formatTime(currentTime) + ' / ' + formatTime(audioBuffer.duration);
                    
                    requestAnimationFrame(updateTime);
                }
            };
            updateTime();
            
            typewriterLog(`Playing 56K encrypted audio (${audioBuffer.duration.toFixed(2)}s)`, 'success');
            
            EXOSKELETON2.currentSource.onended = () => {
                EXOSKELETON2.isPlaying = false;
                EXOSKELETON2.currentSource = null;
                document.getElementById('player-time').textContent = 
                    formatTime(audioBuffer.duration) + ' / ' + formatTime(audioBuffer.duration);
            };
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function showPlayer() {
            document.getElementById('player-popup').style.display = 'block';
            document.getElementById('popup-overlay').style.display = 'block';
        }

        function closePlayer() {
            document.getElementById('player-popup').style.display = 'none';
            document.getElementById('popup-overlay').style.display = 'none';
            
            if (EXOSKELETON2.currentSource && EXOSKELETON2.isPlaying) {
                try {
                    EXOSKELETON2.currentSource.stop();
                } catch (e) {}
                EXOSKELETON2.isPlaying = false;
            }
        }

        function exportAudioAsWav() {
            if (!EXOSKELETON2.currentAudio || !EXOSKELETON2.currentAudio.audioData) {
                log('No audio to export', 'error');
                return;
            }
            
            const entry = EXOSKELETON2.currentAudio;
            const audioBuffer = recreateAudioBuffer(entry.audioData);
            
            // Convert to WAV
            const numChannels = 1;
            const sampleRate = audioBuffer.sampleRate;
            const format = 1;
            const bitDepth = 16;
            
            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;
            const dataSize = audioBuffer.length * numChannels * bytesPerSample;
            
            const arrayBuffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(arrayBuffer);
            
            // WAV header
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, format, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * blockAlign, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);
            
            let offset = 44;
            for (let i = 0; i < audioBuffer.length; i++) {
                const sample = Math.max(-1, Math.min(1, audioBuffer.getChannelData(0)[i]));
                view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                offset += 2;
            }
            
            const blob = new Blob([arrayBuffer], { type: 'audio/wav' });
            const url = URL.createObjectURL(blob);
            
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[:T]/g, '-');
            const hashShort = entry.hash.substring(0, 8);
            const filename = `EXOSKELETON_AUDIO_${hashShort}_${timestamp}.wav`;
            
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
            
            typewriterLog(`Exported audio: ${filename}`, 'success');
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // ==================== HELPER FUNCTIONS ====================
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function showProgress(message, percent) {
            const container = document.getElementById('progress-container');
            const bar = document.getElementById('progress-bar');
            
            if (message) {
                typewriterLog(message);
            }
            
            container.style.display = 'block';
            bar.style.width = percent + '%';
        }

        function updateProgress(percent) {
            const bar = document.getElementById('progress-bar');
            bar.style.width = percent + '%';
        }

        function hideProgress() {
            const container = document.getElementById('progress-container');
            const bar = document.getElementById('progress-bar');
            
            setTimeout(() => {
                container.style.display = 'none';
                bar.style.width = '0%';
            }, 300);
        }

        async function typewriterLog(message, type = 'output') {
            const output = document.getElementById('output');
            const div = document.createElement('div');
            div.className = `line ${type}-line`;
            output.appendChild(div);
            
            let i = 0;
            
            function typeChar() {
                if (i < message.length) {
                    div.textContent = message.substring(0, i + 1);
                    i++;
                    setTimeout(typeChar, 10);
                }
            }
            
            typeChar();
            await sleep(message.length * 10 + 100);
            scrollToBottom();
        }

        function log(message, type = 'output') {
            const output = document.getElementById('output');
            const div = document.createElement('div');
            div.className = `line ${type}-line`;
            div.textContent = message;
            output.appendChild(div);
            scrollToBottom();
        }

        function scrollToBottom() {
            if (!EXOSKELETON2.autoScroll) return;
            
            const terminal = document.getElementById('terminal');
            setTimeout(() => {
                terminal.scrollTop = terminal.scrollHeight;
            }, 10);
        }

        // ==================== COMMAND PROCESSING ====================
        function setupEventListeners() {
            const input = document.getElementById('command-input');
            const encodeBtn = document.getElementById('encode-btn');
            const importBtn = document.getElementById('import-btn');
            const exportBtn = document.getElementById('export-btn');
            const helpBtn = document.getElementById('help-btn');
            const fileInput = document.getElementById('file-input');
            
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') processCommand();
            });
            
            encodeBtn.addEventListener('click', () => {
                if (input.value.trim()) {
                    processCommand();
                }
            });
            
            importBtn.addEventListener('click', () => {
                fileInput.click();
            });
            
            exportBtn.addEventListener('click', async () => {
                if (EXOSKELETON2.entries.length === 0) {
                    log('No entries to export', 'error');
                    return;
                }
                
                const latestEntry = EXOSKELETON2.entries[EXOSKELETON2.entries.length - 1];
                await exportEntryAsZip(latestEntry.id);
            });
            
            helpBtn.addEventListener('click', () => {
                document.getElementById('help-popup').style.display = 'block';
                document.getElementById('popup-overlay').style.display = 'block';
            });
            
            fileInput.addEventListener('change', (e) => {
                if (e.target.files[0]) {
                    importExoskeletonZip(e.target.files[0]);
                }
                fileInput.value = '';
            });
            
            document.getElementById('play-btn').addEventListener('click', () => {
                if (EXOSKELETON2.currentAudio && !EXOSKELETON2.isPlaying) {
                    playAudio(EXOSKELETON2.currentAudio);
                }
            });
            
            document.getElementById('pause-btn').addEventListener('click', () => {
                if (EXOSKELETON2.audioContext && EXOSKELETON2.isPlaying) {
                    EXOSKELETON2.audioContext.suspend().then(() => {
                        EXOSKELETON2.isPlaying = false;
                    });
                }
            });
            
            document.getElementById('stop-btn').addEventListener('click', () => {
                if (EXOSKELETON2.currentSource) {
                    try {
                        EXOSKELETON2.currentSource.stop();
                    } catch (e) {}
                    EXOSKELETON2.isPlaying = false;
                    EXOSKELETON2.currentSource = null;
                }
            });
            
            document.getElementById('export-audio-btn').addEventListener('click', exportAudioAsWav);
            
            const volumeSlider = document.getElementById('volume-slider');
            const volumeValue = document.getElementById('volume-value');
            volumeSlider.addEventListener('input', (e) => {
                EXOSKELETON2.volume = e.target.value / 100;
                volumeValue.textContent = `${e.target.value}%`;
            });
            
            document.getElementById('close-player-btn').addEventListener('click', closePlayer);
            document.getElementById('close-help-btn').addEventListener('click', () => {
                document.getElementById('help-popup').style.display = 'none';
                document.getElementById('popup-overlay').style.display = 'none';
            });
            
            document.getElementById('popup-overlay').addEventListener('click', () => {
                closePlayer();
                document.getElementById('help-popup').style.display = 'none';
                document.getElementById('popup-overlay').style.display = 'none';
            });
            
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closePlayer();
                    document.getElementById('help-popup').style.display = 'none';
                    document.getElementById('popup-overlay').style.display = 'none';
                }
            });
            
            const terminal = document.getElementById('terminal');
            terminal.addEventListener('scroll', () => {
                const scrollBottom = terminal.scrollHeight - terminal.scrollTop - terminal.clientHeight;
                EXOSKELETON2.autoScroll = scrollBottom < 50;
            });
        }

        async function processCommand() {
            const input = document.getElementById('command-input');
            const cmd = input.value.trim();
            
            if (!cmd) return;
            
            log(`> ${cmd}`, 'input');
            
            if (cmd.startsWith('/')) {
                const parts = cmd.split(' ');
                const command = parts[0].toLowerCase();
                const args = parts.slice(1).join(' ');
                
                switch (command) {
                    case '/help':
                        document.getElementById('help-popup').style.display = 'block';
                        document.getElementById('popup-overlay').style.display = 'block';
                        break;
                        
                    case '/clear':
                        if (confirm('Clear terminal screen?')) {
                            document.getElementById('output').innerHTML = '';
                            typewriterLog('Terminal cleared. System ready.');
                        }
                        break;
                        
                    case '/list':
                        if (EXOSKELETON2.entries.length === 0) {
                            log('No encrypted entries', 'output');
                        } else {
                            log(`Total entries: ${EXOSKELETON2.entries.length}`, 'output');
                            EXOSKELETON2.entries.forEach((entry, i) => {
                                const shortText = entry.text.length > 40 
                                    ? entry.text.substring(0, 40) + '...' 
                                    : entry.text;
                                log(`${i + 1}. ${shortText} [${entry.encryptionLevel}]`, 'output');
                            });
                        }
                        break;
                        
                    case '/export':
                        if (args) {
                            const id = parseFloat(args);
                            const entry = EXOSKELETON2.entries.find(e => e.id === id);
                            if (entry) {
                                await exportEntryAsZip(id);
                            } else {
                                log('Entry not found', 'error');
                            }
                        } else {
                            log('Usage: /export [id] or click EXPORT for latest', 'error');
                        }
                        break;
                        
                    case '/import':
                        document.getElementById('file-input').click();
                        break;
                        
                    case '/play':
                        if (args) {
                            const id = parseFloat(args);
                            playEntry(id);
                        } else {
                            log('Usage: /play [id]', 'error');
                        }
                        break;
                        
                    case '/visualize':
                        if (args) {
                            const id = parseFloat(args);
                            visualizeEntry(id);
                        } else {
                            if (EXOSKELETON2.entries.length > 0) {
                                const latest = EXOSKELETON2.entries[EXOSKELETON2.entries.length - 1];
                                visualizeEntry(latest.id);
                            }
                        }
                        break;
                        
                    case '/status':
                        log(`System Status:`, 'output');
                        log(`- Entries: ${EXOSKELETON2.entries.length}`, 'output');
                        log(`- Audio: ${EXOSKELETON2.audioContext ? 'READY' : 'DISABLED'}`, 'output');
                        log(`- Database: ${EXOSKELETON2.db ? 'ACTIVE' : 'DISABLED'}`, 'output');
                        log(`- App Key: ${EXOSKELETON2.appKey.substring(0, 20)}...`, 'output');
                        break;
                        
                    default:
                        log(`Unknown command: ${command}`, 'error');
                        log(`Type /help for available commands`, 'output');
                        break;
                }
            } else {
                await createEncryptedEntry(cmd);
            }
            
            input.value = '';
            input.focus();
        }

        // ==================== GLOBAL FUNCTIONS ====================
        window.playEntry = playEntry;
        window.visualizeEntry = visualizeEntry;
        window.exportEntry = exportEntryAsZip;
        window.deleteEntryUI = deleteEntryUI;
        window.showEntryDetails = showEntryDetails;
        window.closePlayer = closePlayer;

        // ==================== INITIALIZE ====================
        window.addEventListener('load', init);
    </script>
</body>
</html>