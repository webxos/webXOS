<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRIOS: SIEGE (BETA TEST)</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
        }
    }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: #00ff00;
            font-family: 'Press Start 2P', monospace;
            overflow: hidden;
            user-select: none;
            font-size: 10px;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            pointer-events: none;
            text-shadow: 0 0 5px #00ff00;
        }
        
        #logo {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 8px;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00;
            animation: pulse 2s infinite;
        }
        
        .stat-bar {
            width: 180px;
            height: 16px;
            background: rgba(0, 255, 0, 0.2);
            border: 1px solid #00ff00;
            margin-bottom: 4px;
            position: relative;
            overflow: hidden;
        }
        
        .stat-fill {
            height: 100%;
            background: #00ff00;
            box-shadow: 0 0 10px #00ff00;
            transition: width 0.3s;
        }
        
        #ammoFill {
            background: #ffff00;
            box-shadow: 0 0 10px #ffff00;
        }
        
        #bossHealthFill {
            background: #ff0000;
            box-shadow: 0 0 10px #ff0000;
        }
        
        #bossHealthBar {
            display: none;
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            z-index: 100;
            text-align: center;
        }
        
        .bossLabel {
            margin-bottom: 4px;
            font-size: 12px;
            color: #ff0000;
            text-shadow: 0 0 10px #ff0000;
        }
        
        .bossBar {
            width: 100%;
            height: 20px;
            border: 2px solid #ff0000;
            background: rgba(255, 0, 0, 0.1);
        }
        
        .stat-text {
            margin: 3px 0;
            font-size: 10px;
        }
        
        #waveCountdown {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 80px;
            color: #ff0000;
            text-shadow: 0 0 20px #ff0000;
            z-index: 150;
            pointer-events: none;
            display: none;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff00;
            font-size: 20px;
            z-index: 100;
            pointer-events: none;
            text-shadow: 0 0 5px #00ff00;
        }
        
        #weaponInfo {
            position: absolute;
            bottom: 8px;
            left: 8px;
            font-size: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: 3px;
        }
        
        #menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 200;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
            transform: scale(1);
            transform-origin: center center;
        }
        
        #title {
            font-size: 28px;
            margin-bottom: 20px;
            color: #00ff00;
            text-shadow: 0 0 20px #00ff00, 0 0 40px #00ff00;
            animation: pulse 2s infinite;
        }
        
        #startButton, #settingsButton {
            margin: 15px 0;
            padding: 8px 16px;
            background: transparent;
            border: 2px solid #00ff00;
            color: #00ff00;
            font-family: 'Press Start 2P', monospace;
            font-size: 14px;
            cursor: pointer;
            text-shadow: 0 0 10px #00ff00;
            box-shadow: 0 0 20px #00ff00;
            transition: all 0.3s;
        }
        
        #startButton:hover, #settingsButton:hover {
            background: rgba(0, 255, 0, 0.2);
            box-shadow: 0 0 40px #00ff00;
        }
        
        #settings {
            display: none;
            flex-direction: column;
            align-items: center;
        }
        
        #gameGuide {
            max-width: 500px;
            margin: 15px;
            text-align: left;
            font-size: 10px;
            line-height: 1.4;
        }
        
        #gameOver {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 200;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
            transform: scale(1);
            transform-origin: center center;
        }
        
        #gameOverTitle {
            font-size: 28px;
            margin-bottom: 15px;
        }
        
        #restartButton {
            margin: 15px 0;
            padding: 8px 16px;
            background: transparent;
            border: 2px solid #00ff00;
            color: #00ff00;
            font-family: 'Press Start 2P', monospace;
            font-size: 14px;
            cursor: pointer;
            text-shadow: 0 0 10px #00ff00;
            box-shadow: 0 0 20px #00ff00;
            transition: all 0.3s;
        }
        
        #restartButton:hover {
            background: rgba(0, 255, 0, 0.2);
            box-shadow: 0 0 40px #00ff00;
        }
        
        #credits {
            font-size: 8px;
            margin-top: 15px;
            text-align: center;
            width: 80%;
        }
        
        #loadSplash, #loadBar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #00ff00;
            z-index: 300;
            transform: scale(1);
            transform-origin: center center;
        }
        
        #loadTitle {
            font-size: 20px;
            margin-bottom: 15px;
        }
        
        #progressBar {
            width: 250px;
            height: 16px;
            background: rgba(0, 255, 0, 0.2);
            border: 2px solid #00ff00;
        }
        
        #loadFill {
            height: 100%;
            background: #00ff00;
            width: 0%;
        }
        
        #webxosLogo {
            font-size: 28px;
            color: #00ff00;
            text-shadow: 0 0 20px #00ff00;
            animation: pulse 2s infinite;
        }
        
        #slogan {
            font-size: 14px;
            color: #00ff00;
            text-shadow: 0 0 20px #00ff00;
            animation: matrix-fall 2s linear infinite;
        }
        
        #cyborgEngineLogo {
            font-size: 28px;
            color: #00ff00;
            text-shadow: 0 0 20px #00ff00;
            animation: glitch 3s infinite;
            margin-top: 15px;
        }
        
        #continueButton {
            margin: 20px 0;
            padding: 8px 16px;
            background: transparent;
            border: 2px solid #00ff00;
            color: #00ff00;
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            cursor: pointer;
            text-shadow: 0 0 10px #00ff00;
            box-shadow: 0 0 20px #00ff00;
            transition: all 0.3s;
            display: none;
        }
        
        #continueButton:hover {
            background: rgba(0, 255, 0, 0.2);
            box-shadow: 0 0 40px #00ff00;
        }
        
        @keyframes pulse {
            0% { opacity: 0.8; }
            50% { opacity: 1; }
            100% { opacity: 0.8; }
        }
        
        @keyframes matrix-fall {
            0% { transform: translateY(-15px); opacity: 1; }
            100% { transform: translateY(15px); opacity: 0; }
        }
        
        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }
        
        .glitch {
            position: relative;
        }
        
        .glitch::before, .glitch::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .glitch::before {
            left: 3px;
            text-shadow: -3px 0 #ff00ff;
            clip: rect(88px, 900px, 112px, 0);
            animation: glitch-anim 5s infinite linear alternate-reverse;
        }
        
        .glitch::after {
            left: -3px;
            text-shadow: -3px 0 #00ffff;
            clip: rect(88px, 900px, 112px, 0);
            animation: glitch-anim2 5s infinite linear alternate-reverse;
        }
        
        @keyframes glitch-anim {
            0% { clip: rect(84px, 9999px, 88px, 0); }
            5% { clip: rect(24px, 9999px, 118px, 0); }
            10% { clip: rect(96px, 9999px, 58px, 0); }
            15% { clip: rect(84px, 9999px, 146px, 0); }
            20% { clip: rect(126px, 9999px, 54px, 0); }
            25% { clip: rect(68px, 9999px, 110px, 0); }
            30% { clip: rect(172px, 9999px, 146px, 0); }
            35% { clip: rect(40px, 9999px, 40px, 0); }
            40% { clip: rect(52px, 9999px, 120px, 0); }
            45% { clip: rect(50px, 9999px, 132px, 0); }
            50% { clip: rect(114px, 9999px, 196px, 0); }
            55% { clip: rect(10px, 9999px, 92px, 0); }
            60% { clip: rect(164px, 9999px, 62px, 0); }
            65% { clip: rect(108px, 9999px, 54px, 0); }
            70% { clip: rect(56px, 9999px, 198px, 0); }
            75% { clip: rect(90px, 9999px, 138px, 0); }
            80% { clip: rect(46px, 9999px, 170px, 0); }
            85% { clip: rect(108px, 9999px, 168px, 0); }
            90% { clip: rect(90px, 9999px, 94px, 0); }
            95% { clip: rect(74px, 9999px, 40px, 0); }
            100% { clip: rect(8px, 9999px, 182px, 0); }
        }
        
        @keyframes glitch-anim2 {
            0% { clip: rect(130px, 9999px, 200px, 0); }
            5% { clip: rect(104px, 9999px, 148px, 0); }
            10% { clip: rect(158px, 9999px, 170px, 0); }
            15% { clip: rect(150px, 9999px, 10px, 0); }
            20% { clip: rect(134px, 9999px, 122px, 0); }
            25% { clip: rect(28px, 9999px, 158px, 0); }
            30% { clip: rect(2px, 9999px, 132px, 0); }
            35% { clip: rect(172px, 9999px, 60px, 0); }
            40% { clip: rect(46px, 9999px, 196px, 0); }
            45% { clip: rect(170px, 9999px, 144px, 0); }
            50% { clip: rect(142px, 9999px, 150px, 0); }
            55% { clip: rect(4px, 9999px, 96px, 0); }
            60% { clip: rect(60px, 9999px, 32px, 0); }
            65% { clip: rect(118px, 9999px, 100px, 0); }
            70% { clip: rect(82px, 9999px, 124px, 0); }
            75% { clip: rect(4px, 9999px, 164px, 0); }
            80% { clip: rect(94px, 9999px, 146px, 0); }
            85% { clip: rect(6px, 9999px, 54px, 0); }
            90% { clip: rect(52px, 9999px, 110px, 0); }
            95% { clip: rect(84px, 9999px, 194px, 0); }
            100% { clip: rect(76px, 9999px, 98px, 0); }
        }
        
        #laserBeam {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 0;
            background: linear-gradient(to right, #ff0000, #ff5500, #ff0000);
            box-shadow: 0 0 20px #ff0000, 0 0 40px #ff5500;
            transform-origin: 0 0;
            display: none;
            z-index: 90;
            border-radius: 4px;
        }
        
        #xrayDot {
            position: absolute;
            width: 15px;
            height: 15px;
            background: radial-gradient(circle, #ff0000, #ff5500, #ff0000);
            border-radius: 50%;
            box-shadow: 0 0 20px #ff0000, 0 0 40px #ff5500;
            display: none;
            z-index: 91;
        }
        
        .roman {
            font-size: 28px;
            color: #ff0000;
            text-shadow: 0 0 10px #ff0000;
        }
        
        /* Simplified HUD elements */
        .compact-hud {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .hud-row {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .hud-label {
            font-size: 8px;
            min-width: 50px;
        }
        
        .hud-value {
            font-size: 8px;
            min-width: 30px;
        }
        
        /* Laser charging effect */
        #laserCharge {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 10px;
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid #ff0000;
            display: none;
            z-index: 100;
        }
        
        #laserChargeFill {
            height: 100%;
            background: linear-gradient(to right, #ff0000, #ff5500);
            width: 0%;
            transition: width 0.1s;
        }
        
        .performance-rating {
            font-size: 24px;
            margin: 10px 0;
            color: #ffff00;
            text-shadow: 0 0 10px #ffff00;
        }
        
        /* Simplified gun model */
        .simple-gun {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 80px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ff00;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 5px;
            z-index: 80;
        }
        
        .gun-name {
            font-size: 10px;
            margin-bottom: 5px;
        }
        
        .gun-ammo {
            font-size: 12px;
            color: #ffff00;
        }
        
        /* Enhanced Laser Beam */
        .laser-stream {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 89;
        }
        
        .laser-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #ff0000;
            border-radius: 50%;
            box-shadow: 0 0 8px #ff0000, 0 0 16px #ff5500;
        }
        
        #bloomOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(255, 50, 50, 0.3) 0%, rgba(0, 0, 0, 0) 70%);
            pointer-events: none;
            z-index: 88;
            display: none;
        }
    </style>
</head>
<body>
    <div id="loadSplash">
        <div id="webxosLogo">WEBXOS</div>
        <div id="slogan">BROWSER BASED GAMES PRESENTS</div>
        <div id="cyborgEngineLogo">TRIOS: SIEGE</div>
    </div>
    <div id="loadBar" style="display:none;">
        <div id="loadTitle" class="glitch" data-text="TRIOS: SIEGE">TRIOS: SIEGE</div>
        <div id="progressBar"><div id="loadFill"></div></div>
        <button id="continueButton">CLICK TO PLAY</button>
    </div>
    <div id="gameContainer">
        <div id="ui">
            <div id="logo" class="glitch" data-text="TRIOS: SIEGE">TRIOS: SIEGE</div>
            
            <div class="compact-hud">
                <div class="hud-row">
                    <div class="hud-label">UNLIMITED HP:</div>
                    <div class="hud-value" id="healthValue">100</div>
                    <div class="stat-bar"><div id="healthFill" class="stat-fill" style="width: 100%;"></div></div>
                </div>
                
                <div class="hud-row">
                    <div class="hud-label">AMMO:</div>
                    <div class="hud-value" id="ammoValue">100</div>
                    <div class="stat-bar"><div id="ammoFill" class="stat-fill" style="width: 100%;"></div></div>
                </div>
                
                <div class="stat-text">WAVES COMPLETED: <span id="waveNumber">1</span>/4</div>
                <div class="stat-text">DRAGONS PURGED: <span id="enemiesLeft">0</span></div>
                <div class="stat-text">FINAL SCORE: <span id="scoreValue">0</span></div>
                <div class="stat-text">DMG TAKEN: <span id="towerDamageValue">0</span></div>
            </div>
            
            <!-- Moved boss health bar outside compact-hud for better positioning -->
            <div id="bossHealthBar">
                <div class="bossLabel">TRIOS: <span id="bossHealthValue">20000</span></div>
                <div class="bossBar"><div id="bossHealthFill" class="stat-fill" style="width: 100%;"></div></div>
            </div>
            
            <div id="waveCountdown" class="roman"></div>
        </div>
        
        <div id="crosshair">+</div>
        <div id="laserBeam"></div>
        <div id="xrayDot"></div>
        <div id="laserCharge"><div id="laserChargeFill"></div></div>
        <div id="bloomOverlay"></div>
        <div class="laser-stream" id="laserStream"></div>
        
        <!-- Simplified gun display -->
        <div class="simple-gun">
            <div class="gun-name" id="weaponName">GATLING GUN</div>
            <div class="gun-ammo" id="ammoDisplay">100</div>
        </div>
        
        <div id="menu" style="display:none;">
            <h1 id="title" class="glitch" data-text="TRIOS: SIEGE">TRIOS: SIEGE</h1>
            <button id="startButton">PLAY</button>
            <button id="settingsButton">SETTINGS</button>
            <div id="settings" style="display:none;">
                <label>Y Invert <input type="checkbox" id="invertY"></label>
                <label>Sensitivity <input type="range" id="sensitivity" min="0.1" max="2" step="0.1" value="1"></label>
                <button id="closeSettings">CLOSE</button>
            </div>
            <div id="gameGuide">
                <h2>TRIOS: SIEGE</h2>
                <p>Login complete: Weclome... PURGE: simulated cyborg mech online... defend the database from data storm dragons.</p>
                <p><strong>CONTROLS:</strong></p>
                <ul>
                    <li>WASD: Move | Mouse: Aim | LMB: Gatling Gun | RMB: Plasma Beam</li>
                    <li>SPACE: Speed Boost | SHIFT: Jet Pack | F: Activate Shield</li>
                    <li>ESC: Pause | F11: Fullscreen</li>
                </ul>
                <p><strong>DRAGONS:</strong></p>
                <ul>
                   
                    <li>GRID Dragons: RED WIREFRAME DRAGONS</li>
                    <li>TRIOS: FINAL BOSS WAVE 4</li>
                </ul>
                <p><strong>WAVES:</strong></p>
                <ul>
                    <li>4 waves of increasing difficulty</li>
                    <li>10-second countdown between waves</li>
                    <li>Final wave features the TRIOS boss</li>
                </ul>
                <p><strong>BETA TEST SCORING:</strong></p>
                <ul>
                    <li>Base score: 10,000</li>
                    <li>Penalties: -10 per second, -1 per damage point</li>
                    <li>Higher score = Better Performance</li>
                </ul>
            </div>
        </div>
        
        <div id="gameOver" style="display:none;">
            <h1 id="gameOverTitle">MISSION COMPLETE</h1>
            <div id="performanceRating" class="performance-rating">PERFECT PERFORMANCE</div>
            <div id="finalScore">FINAL SCORE: <span id="finalScoreValue">0</span></div>
            <div id="timeTaken">TIME TAKEN: <span id="timeTakenValue">0</span>s</div>
            <div id="towerDamage">TOWER DAMAGE TAKEN: <span id="towerDamageFinalValue">0</span></div>
            <div id="credits">webXOS 2025 | XFORC3D engine | MIT license</div>
            <button id="restartButton">RESTART</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        const PI_2 = Math.PI / 2;
        PointerLockControls.prototype.onMouseMove = function ( event ) {
            if ( this.enabled === false ) return;
            var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
            var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
            const sens = window.game ? window.game.sensitivity : 1;
            const inv = window.game && window.game.invertY ? -1 : 1;
            this.yawObject.rotation.y -= movementX * 0.002 * sens;
            this.pitchObject.rotation.x -= movementY * 0.002 * sens * inv;
            this.pitchObject.rotation.x = Math.max( - PI_2, Math.min( PI_2, this.pitchObject.rotation.x ) );
        };

        class Game {
            constructor() {
                window.game = this;
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                
                // Performance optimization: simpler renderer
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: false,
                    powerPreference: "low-power"
                });
                
                this.setupRenderer();
                this.setupScene();
                this.createCentralTower();
                this.createTown();
                this.setupLighting();
                this.setupParticles();
                this.setupControls();
                
                this.enemies = [];
                this.projectiles = [];
                this.enemyProjectiles = [];
                this.companions = []; // Empty array - companions removed
                
                this.health = 100;
                this.ammo = 100;
                this.towerDamage = 0;
                this.score = 10000;
                this.wave = 1;
                this.enemiesInWave = 0;
                this.enemiesKilled = 0;
                this.damageTaken = 0;
                this.damageDone = 0;
                this.waveStartTime = 0;
                this.waveTimes = [];
                
                this.gameActive = false;
                this.gameOver = false;
                this.shieldActive = false;
                this.sensitivity = 1;
                this.invertY = false;
                this.zoomActive = false;
                this.xrayActive = false;
                this.waveCountdownActive = false;
                this.countdownValue = 10;
                this.jetPackActive = false;
                this.speedBoostActive = false;
                
                // Quake-style movement physics
                this.velocity = new THREE.Vector3();
                this.direction = new THREE.Vector3();
                this.moveSpeed = 0.25; // Same speed
                this.speedBoostMultiplier = 2.0;
                this.jetPackPower = 0.15;
                this.onGround = true;
                this.gravity = -0.02;
                
                // Weapon bobbing - SLOWER ANIMATION
                this.bobTime = 0;
                this.bobIntensity = 0.02; // Reduced from 0.05
                
                // Gatling gun spread
                this.gatlingSpread = 0.15;
                this.gatlingProjectilesPerShot = 7;
                
                // Performance optimization: smaller pools
                this.projectilePool = [];
                this.enemyProjectilePool = [];
                this.poolSize = 50; // Reduced from 80
                this.activeProjectiles = [];
                this.activeEnemyProjectiles = [];
                
                this.enemyPool = [];
                this.activeEnemies = [];
                
                this.spatialGrid = new Map();
                this.gridSize = 20; // Reduced for smaller zone
                this.cellsX = Math.ceil(320 / this.gridSize); // 20% smaller zone
                this.cellsZ = Math.ceil(320 / this.gridSize);
                
                this.flowField = new Float32Array(this.cellsX * this.cellsZ * 3);
                
                // Initialize clock
                this.clock = new THREE.Clock();
                
                // Initialize buildings array
                this.buildings = [];
                
                // Boss special attack tracking
                this.bossSpecialAttackCooldown = 0;
                
                // Performance tracking
                this.frameCount = 0;
                this.lastFpsUpdate = 0;
                this.fps = 0;
                
                // Laser charging
                this.laserChargeTime = 0;
                this.laserMaxCharge = 1.0;
                this.laserDamage = 0;
                this.playerCurrentTarget = null;
                this.laserParticles = [];
                this.laserParticlePool = [];
                
                // Boss movement patterns
                this.bossMovementPatterns = ['chase', 'circle', 'evade', 'hover'];
                this.currentBossPattern = 'chase';
                this.bossPatternTime = 0;
                this.bossPatternDuration = 5; // seconds per pattern
                
                // Initialize pools after scene is set up
                this.initPools();
                this.initEnemyPools();
                this.initLaserParticlePool();
                
                // Build flow field after buildings exist
                this.buildFlowField();
                
                // Prevent context menu
                document.body.addEventListener('contextmenu', e => e.preventDefault());
                
                document.getElementById('loadSplash').style.display = 'flex';
                document.getElementById('loadBar').style.display = 'none';
                document.getElementById('menu').style.display = 'none';
                document.getElementById('gameOver').style.display = 'none';
                
                // Extended loading sequence with manual continue
                setTimeout(() => {
                    document.getElementById('loadSplash').style.display = 'none';
                    document.getElementById('loadBar').style.display = 'flex';
                    document.getElementById('loadFill').style.transition = 'width 2s linear';
                    setTimeout(() => {
                        document.getElementById('loadFill').style.width = '100%';
                        // Show continue button after loading completes
                        setTimeout(() => {
                            document.getElementById('continueButton').style.display = 'block';
                        }, 500);
                    }, 100);
                }, 2000); // Longer initial delay
                
                // Continue button event listener
                document.getElementById('continueButton').addEventListener('click', () => {
                    document.getElementById('loadBar').style.display = 'none';
                    document.getElementById('menu').style.display = 'flex';
                });
                
                this.animate();
                this.setupEventListeners();
            }

            initPools() {
                for (let i = 0; i < this.poolSize; i++) {
                    const proj = this.createPooledProjectile(false);
                    this.projectilePool.push(proj);
                    this.scene.add(proj);
                    
                    const enemyProj = this.createPooledProjectile(true);
                    this.enemyProjectilePool.push(enemyProj);
                    this.scene.add(enemyProj);
                }
            }

            createPooledProjectile(isEnemy) {
                // Ultra-simplified projectiles
                const geo = new THREE.SphereGeometry(isEnemy ? 0.1 : 0.08, 3, 2);
                const mat = new THREE.MeshBasicMaterial({ 
                    color: isEnemy ? 0xff0000 : 0xffff00,
                    wireframe: true
                });
                const proj = new THREE.Mesh(geo, mat);
                proj.visible = false;
                proj.userData.active = false;
                return proj;
            }

            initEnemyPools() {
                for (let i = 0; i < this.poolSize; i++) {
                    const enemy = this.createPooledDragon();
                    this.enemyPool.push(enemy);
                    this.scene.add(enemy);
                }
            }

            createPooledDragon() {
                // ULTRA-SIMPLIFIED: Single triangle dragon
                const group = new THREE.Group();
                
                // Body: Single triangle
                const bodyGeo = new THREE.ConeGeometry(0.5, 1.5, 3);
                const bodyMat = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.rotation.x = Math.PI / 2;
                group.add(body);
                
                // Head: Smaller triangle
                const headGeo = new THREE.ConeGeometry(0.3, 0.5, 3);
                const headMat = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.z = -0.8;
                head.rotation.x = Math.PI / 2;
                group.add(head);
                
                // Wings: Simple triangles
                const wingGeo = new THREE.ConeGeometry(0.4, 0.8, 3);
                const wingMat = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
                
                const leftWing = new THREE.Mesh(wingGeo, wingMat);
                leftWing.position.set(-0.5, 0, -0.2);
                leftWing.rotation.x = Math.PI / 2;
                leftWing.rotation.z = Math.PI / 4;
                group.add(leftWing);
                
                const rightWing = new THREE.Mesh(wingGeo, wingMat);
                rightWing.position.set(0.5, 0, -0.2);
                rightWing.rotation.x = Math.PI / 2;
                rightWing.rotation.z = -Math.PI / 4;
                group.add(rightWing);
                
                // Store wing references for animation
                group.userData.wings = [leftWing, rightWing];
                
                // Tail: Small triangle
                const tailGeo = new THREE.ConeGeometry(0.15, 0.6, 3);
                const tailMat = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
                const tail = new THREE.Mesh(tailGeo, tailMat);
                tail.position.z = 0.6;
                tail.rotation.x = Math.PI / 2;
                group.add(tail);
                
                group.visible = false;
                group.userData = { 
                    active: false, 
                    health: 0, 
                    type: 'dragon',
                    wings: [leftWing, rightWing],
                    lastMelee: 0,
                    lastRanged: 0
                };
                return group;
            }

            createBossDragon() {
                // MASSIVE 10x LARGER BOSS DRAGON
                const group = new THREE.Group();
                
                // Scale the entire boss 10x larger
                group.scale.set(10, 10, 10);
                
                const bodyGeo = new THREE.ConeGeometry(0.8, 2.5, 4);
                const bodyMat = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.rotation.x = Math.PI / 2;
                group.add(body);
                
                const headGeo = new THREE.ConeGeometry(0.5, 1.0, 4);
                const headMat = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.z = -1.5;
                head.rotation.x = Math.PI / 2;
                group.add(head);
                
                // Three horns
                const hornGeo = new THREE.ConeGeometry(0.1, 0.6, 3);
                const hornMat = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
                
                for (let i = 0; i < 3; i++) {
                    const horn = new THREE.Mesh(hornGeo, hornMat);
                    const angle = (i / 3) * Math.PI * 2;
                    horn.position.set(
                        Math.cos(angle) * 0.3,
                        0.2,
                        -1.6
                    );
                    horn.rotation.x = Math.PI / 2;
                    group.add(horn);
                }
                
                // Wings
                const wingGeo = new THREE.ConeGeometry(0.6, 1.5, 3);
                const wingMat = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
                
                const leftWing = new THREE.Mesh(wingGeo, wingMat);
                leftWing.position.set(-0.9, 0, -0.6);
                leftWing.rotation.x = Math.PI / 2;
                leftWing.rotation.z = Math.PI / 4;
                group.add(leftWing);
                
                const rightWing = new THREE.Mesh(wingGeo, wingMat);
                rightWing.position.set(0.9, 0, -0.6);
                rightWing.rotation.x = Math.PI / 2;
                rightWing.rotation.z = -Math.PI / 4;
                group.add(rightWing);
                
                group.userData.wings = [leftWing, rightWing];
                
                const tailGeo = new THREE.ConeGeometry(0.2, 1.5, 3);
                const tailMat = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
                const tail = new THREE.Mesh(tailGeo, tailMat);
                tail.position.z = 1.2;
                tail.rotation.x = Math.PI / 2;
                group.add(tail);
                
                group.userData = { 
                    active: true, 
                    health: 20000, // INCREASED BOSS HEALTH
                    maxHealth: 20000,
                    type: 'boss',
                    name: 'TRIOS',
                    speed: 0.25, // Slightly faster
                    damage: 50, // More damage
                    lastMelee: 0,
                    lastRanged: 0,
                    attackCooldown: 1.5, // Faster attacks
                    wings: [leftWing, rightWing],
                    lastSpecial: 0,
                    specialCooldown: 3, // More frequent special attacks
                    movementPattern: 'chase',
                    patternTime: 0,
                    evasionCooldown: 0,
                    lastPosition: new THREE.Vector3()
                };
                return group;
            }

            initLaserParticlePool() {
                const laserStream = document.getElementById('laserStream');
                for (let i = 0; i < 30; i++) { // Reduced particle count
                    const particle = document.createElement('div');
                    particle.className = 'laser-particle';
                    particle.style.display = 'none';
                    laserStream.appendChild(particle);
                    this.laserParticlePool.push(particle);
                }
            }

            getLaserParticle() {
                if (this.laserParticlePool.length > 0) {
                    const particle = this.laserParticlePool.pop();
                    particle.style.display = 'block';
                    return particle;
                }
                return null; // Don't create new particles if pool is empty
            }

            releaseLaserParticle(particle) {
                particle.style.display = 'none';
                this.laserParticlePool.push(particle);
            }

            updateLaserBeam() {
                if (!this.xrayActive) return;
                
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
                
                // Use recursive intersection to detect hits on dragon groups
                const intersects = raycaster.intersectObjects(this.activeEnemies, true);
                
                let hitPoint = null;
                let hitDistance = 800; // Default max distance (reduced for smaller zone)
                
                if (intersects.length > 0) {
                    // Find the parent enemy group from the intersected mesh
                    let enemy = intersects[0].object;
                    while (enemy.parent && !this.activeEnemies.includes(enemy)) {
                        enemy = enemy.parent;
                    }
                    
                    // If we found a valid enemy, apply damage
                    if (this.activeEnemies.includes(enemy)) {
                        // Continuous damage while laser is active
                        const dmg = enemy.userData.type === 'boss' ? 10 : 3; // More damage to boss
                        enemy.userData.health -= dmg;
                        this.damageDone += dmg;
                        
                        if (enemy.userData.health <= 0) {
                            this.killEnemy(enemy);
                        }
                        
                        // Set player's current target for companions
                        this.playerCurrentTarget = enemy;
                        
                        hitPoint = intersects[0].point;
                        hitDistance = intersects[0].distance;
                    }
                }
                
                // Create laser particles (fewer for performance)
                if (this.laserChargeTime >= this.laserMaxCharge && Math.random() < 0.5) {
                    const particle = this.getLaserParticle();
                    if (particle) {
                        // Position particle along the laser beam
                        const t = Math.random();
                        const particleDistance = hitDistance * t;
                        
                        const cameraDirection = new THREE.Vector3();
                        this.camera.getWorldDirection(cameraDirection);
                        const particlePos = this.camera.position.clone().add(
                            cameraDirection.multiplyScalar(particleDistance)
                        );
                        
                        const screenPos = this.worldToScreen(particlePos);
                        particle.style.left = `${screenPos.x}px`;
                        particle.style.top = `${screenPos.y}px`;
                        
                        // Add slight random offset for stream effect
                        particle.style.transform = `translate(${(Math.random()-0.5)*3}px, ${(Math.random()-0.5)*3}px)`;
                        
                        // Remove particle after a short time
                        setTimeout(() => {
                            this.releaseLaserParticle(particle);
                        }, 100);
                    }
                }
                
                // Show laser beam
                const beam = document.getElementById('laserBeam');
                const dot = document.getElementById('xrayDot');
                
                // Calculate beam length based on distance to hit point
                const beamLength = hitDistance * 50;
                beam.style.height = `${beamLength}px`;
                beam.style.display = 'block';
                
                // Calculate beam angle based on camera direction
                const cameraDirection = new THREE.Vector3();
                this.camera.getWorldDirection(cameraDirection);
                const beamAngle = Math.atan2(cameraDirection.x, cameraDirection.z);
                beam.style.transform = `translate(-50%, -50%) rotate(${beamAngle}rad)`;
                
                // Position the hit dot at the intersection point
                if (hitPoint) {
                    const screenPos = this.worldToScreen(hitPoint);
                    dot.style.left = `${screenPos.x}px`;
                    dot.style.top = `${screenPos.y}px`;
                    dot.style.display = 'block';
                } else {
                    dot.style.display = 'none';
                }
                
                // Show bloom effect
                document.getElementById('bloomOverlay').style.display = 'block';
            }

            buildFlowField() {
                const gridW = this.cellsX, gridH = this.cellsZ;
                const costField = new Uint8Array(gridW * gridH).fill(255); // INF
                const dirs = [[0,-1],[1,-1],[1,0],[1,1],[0,1],[-1,1],[-1,0],[-1,-1]];
                
                // Mark obstacles (buildings)
                this.buildings.forEach(b => {
                    const box = b.userData.collisionBox;
                    const minX = Math.max(0, Math.floor((box.minX + 160) / this.gridSize));
                    const maxX = Math.min(gridW - 1, Math.floor((box.maxX + 160) / this.gridSize));
                    const minZ = Math.max(0, Math.floor((box.minZ + 160) / this.gridSize));
                    const maxZ = Math.min(gridH - 1, Math.floor((box.maxZ + 160) / this.gridSize));
                    for (let gx = minX; gx <= maxX; gx++) for (let gz = minZ; gz <= maxZ; gz++) {
                        costField[gx + gz * gridW] = 0; // Blocked
                    }
                });
                
                // BFS from tower
                const towerX = Math.floor(160 / this.gridSize), towerZ = Math.floor(160 / this.gridSize);
                const queue = [{x: towerX, z: towerZ, cost: 0}];
                costField[towerX + towerZ * gridW] = 0;
                
                while (queue.length) {
                    const curr = queue.shift();
                    for (const [dx, dz] of dirs) {
                        const nx = curr.x + dx, nz = curr.z + dz;
                        if (nx < 0 || nx >= gridW || nz < 0 || nz >= gridH) continue;
                        const nidx = nx + nz * gridW;
                        if (costField[nidx] === 0) continue; // Blocked
                        if (costField[nidx] > curr.cost + 1) {
                            costField[nidx] = curr.cost + 1;
                            queue.push({x: nx, z: nz, cost: curr.cost + 1});
                        }
                    }
                }
                
                // Flow vectors
                for (let gz = 0; gz < gridH; gz++) for (let gx = 0; gx < gridW; gx++) {
                    const idx = (gx + gz * gridW) * 3;
                    if (costField[gx + gz * gridW] === 255 || costField[gx + gz * gridW] === 0) {
                        this.flowField[idx] = 0; this.flowField[idx+2] = 0;
                        continue;
                    }
                    let bestDx = 0, bestDz = 0, bestCost = 255;
                    for (const [dx, dz] of dirs) {
                        const nx = gx + dx, nz = gz + dz;
                        if (nx < 0 || nx >= gridW || nz < 0 || nz >= gridH) continue;
                        const ncost = costField[nx + nz * gridW];
                        if (ncost < bestCost && ncost !== 0) {
                            bestCost = ncost;
                            bestDx = dx; bestDz = dz;
                        }
                    }
                    const flow = new THREE.Vector3(bestDx, 0, bestDz).normalize();
                    this.flowField[idx] = flow.x;
                    this.flowField[idx+2] = flow.z;
                }
            }

            setupRenderer() {
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(1);
                this.renderer.setClearColor(0x000000);
                document.getElementById('gameContainer').appendChild(this.renderer.domElement);
            }

            setupScene() {
                // 20% smaller zone: 320x320 instead of 400x400
                const groundGeometry = new THREE.PlaneGeometry(320, 320, 8, 8); // Reduced segments
                const groundMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x003300, 
                    wireframe: true,
                    transparent: true,
                    opacity: 0.3
                });
                this.ground = new THREE.Mesh(groundGeometry, groundMaterial);
                this.ground.rotation.x = -Math.PI / 2;
                this.scene.add(this.ground);

                const gridHelper = new THREE.GridHelper(320, 8, 0x003300, 0x001100); // Reduced grid lines
                gridHelper.material.transparent = true;
                gridHelper.material.opacity = 0.5;
                this.scene.add(gridHelper);
            }

            createCentralTower() {
                this.tower = new THREE.Group();
                
                const baseGeometry = new THREE.CylinderGeometry(4, 6, 16, 6); // Smaller for smaller zone
                const baseMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x222222, 
                    wireframe: true
                });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = 8;
                this.tower.add(base);
                
                const midGeometry = new THREE.CylinderGeometry(3, 4, 12, 6);
                const mid = new THREE.Mesh(midGeometry, baseMaterial);
                mid.position.y = 22;
                this.tower.add(mid);
                
                const topGeometry = new THREE.SphereGeometry(5, 6, 4);
                const topMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff00, 
                    wireframe: true
                });
                const top = new THREE.Mesh(topGeometry, topMaterial);
                top.position.y = 32;
                this.tower.add(top);
                
                const spikeGeometry = new THREE.ConeGeometry(0.4, 2.5, 4);
                const spikeMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff00, 
                    wireframe: true
                });
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
                    spike.position.set(
                        Math.cos(angle) * 4,
                        32,
                        Math.sin(angle) * 4
                    );
                    spike.rotation.x = Math.PI / 2;
                    this.tower.add(spike);
                }
                
                this.tower.position.set(0, 0, 0);
                this.scene.add(this.tower);
                
                const energyFieldGeometry = new THREE.SphereGeometry(12, 6, 6); // Reduced segments
                const energyFieldMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff00, 
                    wireframe: true,
                    transparent: true,
                    opacity: 0.2
                });
                this.energyField = new THREE.Mesh(energyFieldGeometry, energyFieldMaterial);
                this.energyField.position.set(0, 16, 0);
                this.scene.add(this.energyField);
            }

            createTown() {
                this.buildings = [];
                
                // Create four roads leading to the tower (adjusted for smaller zone)
                this.createRoad(0, 0, -160, 0, 0, 160, 8);
                this.createRoad(-160, 0, 0, 160, 0, 0, 8);
                
                // Create buildings along the roads (adjusted positions for smaller zone)
                this.createDistrict(-40, 0, -40, 2, 2);
                this.createDistrict(40, 0, -25, 2, 2);
                this.createDistrict(-25, 0, 25, 2, 2);
                this.createDistrict(25, 0, 40, 2, 2);
            }

            createRoad(startX, startY, startZ, endX, endY, endZ, width) {
                const roadLength = Math.sqrt((endX - startX)**2 + (endZ - startZ)**2);
                const roadGeometry = new THREE.PlaneGeometry(roadLength, width);
                const roadMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x333333, 
                    wireframe: true
                });
                const road = new THREE.Mesh(roadGeometry, roadMaterial);
                
                // Position the road
                road.position.set((startX + endX) / 2, 0.1, (startZ + endZ) / 2);
                
                // Rotate to align with the road direction
                const angle = Math.atan2(endZ - startZ, endX - startX);
                road.rotation.x = -Math.PI / 2;
                road.rotation.z = -angle;
                
                this.scene.add(road);
            }

            createDistrict(x, y, z, rows, cols) {
                const buildingMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x003300, 
                    wireframe: true
                });

                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        const building = this.createBuilding();
                        building.position.set(x + i * 16, 0, z + j * 13); // Adjusted spacing
                        this.scene.add(building);
                        this.buildings.push(building);
                    }
                }
            }

            createBuilding() {
                const building = new THREE.Group();
                // Slightly smaller buildings for smaller zone
                const height = 12 + Math.random() * 16;
                const width = 4 + Math.random() * 2;
                const depth = 4 + Math.random() * 2;
                
                const walls = new THREE.Mesh(
                    new THREE.BoxGeometry(width, height, depth),
                    new THREE.MeshBasicMaterial({ 
                        color: 0x003300, 
                        wireframe: true
                    })
                );
                walls.position.y = height / 2;
                
                building.add(walls);
                
                // Add collision box for jet pack landing and solid obstacles
                building.userData.collisionBox = {
                    minX: building.position.x - width/2,
                    maxX: building.position.x + width/2,
                    minZ: building.position.z - depth/2,
                    maxZ: building.position.z + depth/2,
                    height: height
                };
                
                return building;
            }

            createPlayer() {
                this.player = new THREE.Group();
                this.player.position.set(0, 1, 0);
                this.createCyborg();
                this.scene.add(this.player);

                // Quake-style weapon positioning
                this.weaponOffset = new THREE.Vector3(0.3, -0.2, -0.5);
                this.createGatlingGun();
                
                // COMPANION DRAGONS REMOVED
            }

            createCyborg() {
                while(this.player.children.length > 0) { 
                    this.player.remove(this.player.children[0]); 
                }
                
                // Cyborg body
                const bodyGeometry = new THREE.BoxGeometry(1, 2, 1);
                const bodyMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff00, 
                    wireframe: true
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                this.player.add(body);

                // Head
                const headGeometry = new THREE.SphereGeometry(0.5, 6, 6);
                const head = new THREE.Mesh(headGeometry, bodyMaterial);
                head.position.y = 1.5;
                this.player.add(head);

                // Shield
                const shieldGeometry = new THREE.SphereGeometry(1.5, 6, 6);
                const shieldMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.3
                });
                this.shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
                this.shield.visible = false;
                this.player.add(this.shield);

                // JET PACK REMOVED - No visual model

                document.getElementById('weaponName').textContent = 'GATLING GUN';
            }

            createGatlingGun() {
                // Remove existing gun if present
                if (this.gunGroup) {
                    this.camera.remove(this.gunGroup);
                }
                
                this.gunGroup = new THREE.Group();
                const gunMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff00, 
                    wireframe: true
                });
                
                // SIMPLIFIED: Main gun body
                const gunBody = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2, 0.2, 1.2, 6),
                    gunMaterial
                );
                gunBody.rotation.x = Math.PI / 2;
                gunBody.position.set(0.4, 0.15, 0.15);
                this.gunGroup.add(gunBody);
                
                // SIMPLIFIED: Gun barrels (2 barrels for performance)
                this.barrelGroup = new THREE.Group();
                const barrelGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.9, 4);
                
                for (let i = 0; i < 2; i++) {
                    const barrel = new THREE.Mesh(barrelGeometry, gunMaterial);
                    const angle = (i / 2) * Math.PI * 2;
                    const radius = 0.1;
                    barrel.position.set(
                        Math.cos(angle) * radius,
                        Math.sin(angle) * radius,
                        0.45
                    );
                    barrel.rotation.x = Math.PI / 2;
                    this.barrelGroup.add(barrel);
                }
                
                this.barrelGroup.position.set(0.4, 0.15, 0);
                this.gunGroup.add(this.barrelGroup);
                
                // SIMPLIFIED: Ammo drum
                const ammoDrum = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 0.5, 6),
                    gunMaterial
                );
                ammoDrum.rotation.x = Math.PI / 2;
                ammoDrum.position.set(-0.15, 0.15, 0);
                this.gunGroup.add(ammoDrum);
                
                // SIMPLIFIED: Gun handle
                const handle = new THREE.Mesh(
                    new THREE.BoxGeometry(0.15, 0.4, 0.15),
                    gunMaterial
                );
                handle.position.set(0.25, -0.15, 0);
                this.gunGroup.add(handle);
                
                // SIMPLIFIED: Trigger
                const trigger = new THREE.Mesh(
                    new THREE.BoxGeometry(0.08, 0.1, 0.04),
                    gunMaterial
                );
                trigger.position.set(0.35, -0.08, 0.1);
                this.gunGroup.add(trigger);
                
                // Position gun in Quake-style first-person view
                this.gunGroup.position.copy(this.weaponOffset);
                this.camera.add(this.gunGroup);
            }

            getPooledEnemy() {
                for (let enemy of this.enemyPool) {
                    if (!enemy.userData.active) {
                        return enemy;
                    }
                }
                // If pool is exhausted, create a new one and add to scene
                const newEnemy = this.createPooledDragon();
                this.enemyPool.push(newEnemy);
                this.scene.add(newEnemy);
                return newEnemy;
            }

            releaseEnemy(enemy) {
                enemy.userData.active = false;
                enemy.visible = false;
                enemy.position.set(0, -100, 0);
            }

            setupControls() {
                this.controls = new PointerLockControls(this.camera, document.body);
                this.scene.add(this.controls.getObject());
                
                this.moveState = {
                    forward: false,
                    backward: false,
                    left: false,
                    right: false,
                    shift: false,    // Jet pack
                    space: false     // Speed boost
                };

                this.mouseState = {
                    left: false,
                    right: false
                };

                this.attackCooldown = 0;
                this.xrayCooldown = 0;
            }

            setupLighting() {
                const ambientLight = new THREE.AmbientLight(0x404040);
                this.scene.add(ambientLight);
                
                const redLight = new THREE.PointLight(0xff0000, 0.5, 80); // Reduced range for smaller zone
                redLight.position.set(0, 10, 0);
                this.scene.add(redLight);
                
                const towerLight = new THREE.PointLight(0x00ff00, 1, 40); // Reduced range for smaller zone
                towerLight.position.set(0, 32, 0);
                this.scene.add(towerLight);
            }

            setupParticles() {
                // Performance optimization: fewer particles
                this.particleGeometry = new THREE.BufferGeometry();
                const particleCount = 20; // Reduced from 30
                const positions = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount * 3; i++) {
                    positions[i] = (Math.random() - 0.5) * 8;
                }
                
                this.particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                this.particleMaterial = new THREE.PointsMaterial({
                    color: 0xffff00,
                    size: 0.1,
                    transparent: true
                });
                
                this.particleSystem = new THREE.Points(this.particleGeometry, this.particleMaterial);
                this.particleSystem.visible = false;
                this.scene.add(this.particleSystem);
            }

            setupEventListeners() {
                document.addEventListener('click', () => {
                    if (!this.gameActive) {
                        if (document.getElementById('menu').style.display !== 'none') {
                            return;
                        } else if (document.getElementById('gameOver').style.display !== 'none') {
                            this.restartGame();
                        }
                        return;
                    }
                    
                    if (!this.controls.isLocked) {
                        this.controls.lock();
                    }
                });

                document.addEventListener('keydown', (event) => {
                    if (!this.gameActive) return;
                    
                    switch (event.code) {
                        case 'KeyW': this.moveState.forward = true; break;
                        case 'KeyA': this.moveState.left = true; break;
                        case 'KeyS': this.moveState.backward = true; break;
                        case 'KeyD': this.moveState.right = true; break;
                        case 'ShiftLeft': 
                            this.moveState.shift = true; 
                            this.jetPackActive = true;
                            break;
                        case 'Space': 
                            this.moveState.space = true;
                            this.speedBoostActive = true;
                            break;
                        case 'KeyF': this.activateShield(); break;
                        case 'Escape': this.togglePause(); break;
                        case 'F11': 
                            event.preventDefault();
                            if (!document.fullscreenElement) {
                                document.documentElement.requestFullscreen();
                            } else {
                                document.exitFullscreen();
                            }
                            break;
                    }
                });

                document.addEventListener('keyup', (event) => {
                    if (!this.gameActive) return;
                    
                    switch (event.code) {
                        case 'KeyW': this.moveState.forward = false; break;
                        case 'KeyA': this.moveState.left = false; break;
                        case 'KeyS': this.moveState.backward = false; break;
                        case 'KeyD': this.moveState.right = false; break;
                        case 'ShiftLeft': 
                            this.moveState.shift = false;
                            this.jetPackActive = false;
                            break;
                        case 'Space': 
                            this.moveState.space = false;
                            this.speedBoostActive = false;
                            break;
                        case 'KeyF': this.deactivateShield(); break;
                    }
                });

                document.addEventListener('mousedown', (event) => {
                    if (!this.gameActive || !this.controls.isLocked) return;
                    
                    if (event.button === 0) {
                        this.mouseState.left = true;
                    } else if (event.button === 2) {
                        this.mouseState.right = true;
                        this.activateXray();
                    }
                });

                document.addEventListener('mouseup', (event) => {
                    if (!this.gameActive || !this.controls.isLocked) return;
                    
                    if (event.button === 0) {
                        this.mouseState.left = false;
                    } else if (event.button === 2) {
                        this.mouseState.right = false;
                        this.deactivateXray();
                    }
                });

                document.getElementById('startButton').addEventListener('click', () => {
                    this.startGame();
                });

                document.getElementById('settingsButton').addEventListener('click', () => {
                    document.getElementById('settings').style.display = 'flex';
                });

                document.getElementById('closeSettings').addEventListener('click', () => {
                    document.getElementById('settings').style.display = 'none';
                });

                document.getElementById('invertY').addEventListener('change', (e) => {
                    this.invertY = e.target.checked;
                });

                document.getElementById('sensitivity').addEventListener('input', (e) => {
                    this.sensitivity = parseFloat(e.target.value);
                });

                document.getElementById('restartButton').addEventListener('click', () => {
                    this.restartGame();
                });

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            activateShield() {
                this.shieldActive = true;
                this.shield.visible = true;
            }

            deactivateShield() {
                this.shieldActive = false;
                this.shield.visible = false;
            }

            activateXray() {
                this.xrayActive = true;
                document.getElementById('weaponName').textContent = 'PLASMA BEAM';
                document.getElementById('crosshair').textContent = '';
                document.getElementById('crosshair').style.color = '#ff0000';
                document.getElementById('crosshair').style.textShadow = '0 0 10px #ff0000';
                document.getElementById('laserCharge').style.display = 'block';
                
                // 2x zoom
                this.camera.fov = 75 / 2;
                this.camera.updateProjectionMatrix();
            }

            deactivateXray() {
                this.xrayActive = false;
                document.getElementById('weaponName').textContent = 'GATLING GUN';
                document.getElementById('crosshair').textContent = '+';
                document.getElementById('crosshair').style.color = '#00ff00';
                document.getElementById('crosshair').style.textShadow = '0 0 5px #00ff00';
                document.getElementById('laserBeam').style.display = 'none';
                document.getElementById('xrayDot').style.display = 'none';
                document.getElementById('laserCharge').style.display = 'none';
                document.getElementById('bloomOverlay').style.display = 'none';
                document.getElementById('laserChargeFill').style.width = '0%';
                this.laserChargeTime = 0;
                this.laserDamage = 0;
                
                // Reset zoom
                this.camera.fov = 75;
                this.camera.updateProjectionMatrix();
                
                // Clear all laser particles
                const laserStream = document.getElementById('laserStream');
                while (laserStream.firstChild) {
                    laserStream.removeChild(laserStream.firstChild);
                }
                this.laserParticlePool = [];
                this.initLaserParticlePool();
            }

            startGame() {
                document.getElementById('menu').style.display = 'none';
                this.gameActive = true;
                this.controls.lock();
                this.startTime = Date.now();
                this.damageTaken = 0;
                this.damageDone = 0;
                this.towerDamage = 0;
                this.score = 10000;
                this.createPlayer();
                if (this.player) {
                    this.controls.getObject().position.copy(this.player.position);
                }
                this.startWaveCountdown();
            }

            startWaveCountdown() {
                this.waveCountdownActive = true;
                this.countdownValue = 10;
                document.getElementById('waveCountdown').style.display = 'block';
                document.getElementById('waveCountdown').textContent = this.toRoman(this.countdownValue);
                
                const countdownInterval = setInterval(() => {
                    this.countdownValue--;
                    document.getElementById('waveCountdown').textContent = this.toRoman(this.countdownValue);
                    
                    if (this.countdownValue <= 0) {
                        clearInterval(countdownInterval);
                        document.getElementById('waveCountdown').style.display = 'none';
                        this.waveCountdownActive = false;
                        this.startWave(this.wave);
                    }
                }, 1000);
            }

            toRoman(num) {
                const romanNumerals = [
                    '', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X'
                ];
                return romanNumerals[num];
            }

            restartGame() {
                document.getElementById('gameOver').style.display = 'none';
                this.gameActive = true;
                
                // Remove old player before creating new one
                if (this.player) {
                    this.scene.remove(this.player);
                }
                
                this.health = 100;
                this.ammo = 100;
                this.towerDamage = 0;
                this.score = 10000;
                this.wave = 1;
                this.enemiesKilled = 0;
                this.damageTaken = 0;
                this.damageDone = 0;
                this.waveTimes = [];
                this.jetPackActive = false;
                this.speedBoostActive = false;
                
                this.activeEnemies.forEach(enemy => this.releaseEnemy(enemy));
                this.activeEnemies = [];
                
                this.activeProjectiles.forEach(proj => this.releaseProjectile(proj, false));
                this.activeProjectiles = [];
                
                this.activeEnemyProjectiles.forEach(proj => this.releaseProjectile(proj, true));
                this.activeEnemyProjectiles = [];
                
                document.getElementById('bossHealthBar').style.display = 'none';
                
                this.createPlayer();
                if (this.player) {
                    this.controls.getObject().position.copy(this.player.position);
                }
                
                this.startWaveCountdown();
                
                this.controls.lock();
            }

            togglePause() {
                if (this.gameActive) {
                    this.controls.unlock();
                    document.getElementById('menu').style.display = 'flex';
                    this.gameActive = false;
                } else {
                    document.getElementById('menu').style.display = 'none';
                    this.gameActive = true;
                    this.controls.lock();
                }
            }

            fireWeapon() {
                if (this.shieldActive) return;
                if (this.ammo <= 0) return;
                
                // Fire multiple projectiles with spread
                for (let i = 0; i < this.gatlingProjectilesPerShot; i++) {
                    const proj = this.projectilePool.pop() || this.createPooledProjectile(false);
                    const dir = new THREE.Vector3();
                    this.camera.getWorldDirection(dir);
                    
                    // Add random spread
                    dir.x += (Math.random() - 0.5) * this.gatlingSpread;
                    dir.y += (Math.random() - 0.5) * this.gatlingSpread;
                    dir.z += (Math.random() - 0.5) * this.gatlingSpread;
                    dir.normalize();
                    
                    proj.position.copy(this.camera.position);
                    proj.userData = { 
                        dir: dir.clone(), 
                        speed: 120,
                        damage: 15, 
                        type: 'gatling', 
                        active: true 
                    };
                    proj.visible = true;
                    this.activeProjectiles.push(proj);
                    
                    // Set player's current target
                    const raycaster = new THREE.Raycaster();
                    raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
                    const intersects = raycaster.intersectObjects(this.activeEnemies, true);
                    if (intersects.length > 0) {
                        let enemy = intersects[0].object;
                        while (enemy.parent && !this.activeEnemies.includes(enemy)) {
                            enemy = enemy.parent;
                        }
                        if (this.activeEnemies.includes(enemy)) {
                            this.playerCurrentTarget = enemy;
                        }
                    }
                }
                
                // Rotate gatling gun barrels when firing
                if (this.barrelGroup) {
                    this.barrelGroup.rotation.z += 0.5;
                }
                
                this.ammo -= 1;
                if (this.ammo < 0) this.ammo = 0;
            }

            fireXray() {
                if (this.shieldActive) return;
                if (this.ammo <= 0) return;
                
                // Laser charging
                if (this.laserChargeTime < this.laserMaxCharge) {
                    this.laserChargeTime += 0.05;
                    if (this.laserChargeTime > this.laserMaxCharge) this.laserChargeTime = this.laserMaxCharge;
                    document.getElementById('laserChargeFill').style.width = `${(this.laserChargeTime / this.laserMaxCharge) * 100}%`;
                }
                
                // Update laser beam
                this.updateLaserBeam();
                
                // Consume ammo only when fully charged
                if (this.laserChargeTime >= this.laserMaxCharge) {
                    this.ammo -= 0.5; // Continuous ammo drain
                    if (this.ammo < 0) this.ammo = 0;
                }
            }

            worldToScreen(position) {
                const vector = position.clone();
                vector.project(this.camera);
                
                return {
                    x: (vector.x * 0.5 + 0.5) * window.innerWidth,
                    y: (-(vector.y * 0.5) + 0.5) * window.innerHeight
                };
            }

            fireEnemyProjectile(enemy) {
                const proj = this.enemyProjectilePool.pop() || this.createPooledProjectile(true);
                const dir = new THREE.Vector3();
                
                if (enemy.userData.type === 'boss') {
                    // Boss targets player with giant fireballs
                    dir.subVectors(this.controls.getObject().position, enemy.position).normalize();
                    
                    // Make boss projectiles 3x larger
                    proj.scale.set(3, 3, 3);
                    proj.userData.damage = 30; // More damage from boss
                } else {
                    // Regular enemies target tower
                    dir.subVectors(this.tower.position, enemy.position).normalize();
                }
                
                proj.position.copy(enemy.position);
                proj.userData = { 
                    dir: dir.clone(), 
                    speed: enemy.userData.type === 'boss' ? 20 : 24, // Slightly slower but larger boss projectiles
                    damage: enemy.userData.damage, 
                    type: 'enemy', 
                    active: true 
                };
                proj.visible = true;
                this.activeEnemyProjectiles.push(proj);
            }

            // Boss special attack - Giant fireball barrage
            fireBossSpecial(enemy) {
                // Fire multiple giant fireballs in a spread pattern
                for (let i = 0; i < 8; i++) {
                    const proj = this.enemyProjectilePool.pop() || this.createPooledProjectile(true);
                    const dir = new THREE.Vector3();
                    
                    // Calculate spread direction
                    const angle = (i / 8) * Math.PI * 2;
                    const spread = 0.5; // Wider spread
                    dir.subVectors(this.controls.getObject().position, enemy.position).normalize();
                    dir.x += Math.cos(angle) * spread;
                    dir.z += Math.sin(angle) * spread;
                    dir.normalize();
                    
                    proj.position.copy(enemy.position);
                    
                    // Make special attack projectiles even larger
                    proj.scale.set(4, 4, 4);
                    
                    proj.userData = { 
                        dir: dir.clone(), 
                        speed: 25,
                        damage: enemy.userData.damage * 2, // Double damage for special
                        type: 'enemy', 
                        active: true 
                    };
                    proj.visible = true;
                    this.activeEnemyProjectiles.push(proj);
                }
            }

            startWave(waveNumber) {
                this.wave = waveNumber;
                this.enemiesKilled = 0;
                this.waveStartTime = Date.now();
                
                // Clear existing enemies before spawning new ones
                this.activeEnemies.forEach(enemy => this.releaseEnemy(enemy));
                this.activeEnemies = [];
                
                if (waveNumber === 4) {
                    // Final boss wave
                    this.enemiesInWave = 1;
                    const boss = this.createBossDragon();
                    
                    // Spawn boss high in the air at edge of map
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 120; // Further out for bigger boss
                    boss.position.set(
                        Math.cos(angle) * distance, 
                        40, // Higher starting position
                        Math.sin(angle) * distance
                    );
                    
                    boss.visible = true;
                    this.scene.add(boss);
                    this.activeEnemies.push(boss);
                    
                    // Store initial position for movement patterns
                    boss.userData.lastPosition = boss.position.clone();
                    
                    // Show boss health bar
                    document.getElementById('bossHealthBar').style.display = 'block';
                    document.getElementById('bossHealthValue').textContent = Math.round(boss.userData.health);
                    document.getElementById('bossHealthFill').style.width = '100%';
                } else {
                    // Regular waves with MORE DRAGONS and INCREASED HEALTH
                    if (waveNumber === 1) {
                        this.enemiesInWave = 8; // Increased from 6
                    } else if (waveNumber === 2) {
                        this.enemiesInWave = 12; // Increased from 8
                    } else if (waveNumber === 3) {
                        this.enemiesInWave = 16; // Increased from 10
                    }
                    
                    for (let i = 0; i < this.enemiesInWave; i++) {
                        const enemy = this.getPooledEnemy();
                        
                        // Spawn from one of four roads
                        const road = Math.floor(Math.random() * 4);
                        let x, z;
                        switch(road) {
                            case 0: x = -150; z = Math.random() * 80 - 40; break; // West road
                            case 1: x = 150; z = Math.random() * 80 - 40; break; // East road
                            case 2: x = Math.random() * 80 - 40; z = -150; break; // North road
                            case 3: x = Math.random() * 80 - 40; z = 150; break; // South road
                        }
                        
                        enemy.position.set(x, 8 + Math.random() * 16, z);
                        
                        const data = enemy.userData;
                        // INCREASED DRAGON HEALTH
                        data.health = 80 + waveNumber * 20; // Increased from 30 + waveNumber * 10
                        data.maxHealth = data.health;
                        data.speed = 0.28 + waveNumber * 0.02;
                        data.damage = 5 + waveNumber * 2;
                        data.lastMelee = 0;
                        data.lastRanged = 0;
                        data.attackCooldown = 3;
                        data.active = true;
                        enemy.visible = true;
                        this.activeEnemies.push(enemy);
                    }
                }
                
                document.getElementById('waveNumber').textContent = waveNumber;
                document.getElementById('enemiesLeft').textContent = this.enemiesInWave;
            }

            updateSpatialGrid() {
                this.spatialGrid.clear();
                for (const enemy of this.activeEnemies) {
                    const cellX = Math.floor((enemy.position.x + 160) / this.gridSize); // Adjusted for smaller zone
                    const cellZ = Math.floor((enemy.position.z + 160) / this.gridSize);
                    const cellId = cellX + ',' + cellZ;
                    if (!this.spatialGrid.has(cellId)) this.spatialGrid.set(cellId, []);
                    this.spatialGrid.get(cellId).push(enemy);
                }
            }

            updateBossMovement(enemy, deltaTime) {
                const data = enemy.userData;
                const now = Date.now() / 1000;
                
                // Update movement pattern timer
                data.patternTime += deltaTime;
                if (data.patternTime > this.bossPatternDuration) {
                    // Switch to a random pattern
                    const availablePatterns = this.bossMovementPatterns.filter(p => p !== data.movementPattern);
                    data.movementPattern = availablePatterns[Math.floor(Math.random() * availablePatterns.length)];
                    data.patternTime = 0;
                }
                
                // Flap wings using stored references
                if (data.wings && data.wings.length >= 2) {
                    data.wings[0].rotation.z = Math.sin(now * 8) * 0.3;
                    data.wings[1].rotation.z = -Math.sin(now * 8) * 0.3;
                }
                
                const playerPos = this.controls.getObject().position;
                const toPlayer = new THREE.Vector3().subVectors(playerPos, enemy.position);
                const distanceToPlayer = toPlayer.length();
                
                // Different movement patterns for the boss
                switch(data.movementPattern) {
                    case 'chase':
                        // Chase the player but maintain some distance
                        const chaseDir = toPlayer.clone().normalize();
                        if (distanceToPlayer < 50) {
                            // Too close, move away
                            chaseDir.multiplyScalar(-1);
                        }
                        enemy.position.addScaledVector(chaseDir, data.speed);
                        break;
                        
                    case 'circle':
                        // Circle around the player
                        const circleRadius = 60;
                        const circleSpeed = 0.02;
                        const angle = data.patternTime * circleSpeed;
                        const circlePos = new THREE.Vector3(
                            playerPos.x + Math.cos(angle) * circleRadius,
                            enemy.position.y,
                            playerPos.z + Math.sin(angle) * circleRadius
                        );
                        const toCircle = new THREE.Vector3().subVectors(circlePos, enemy.position).normalize();
                        enemy.position.addScaledVector(toCircle, data.speed * 1.5);
                        break;
                        
                    case 'evade':
                        // Evade player attacks by moving perpendicular to player direction
                        const evadeDir = toPlayer.clone().normalize();
                        const perpendicular = new THREE.Vector3(-evadeDir.z, 0, evadeDir.x);
                        const evadePattern = Math.sin(data.patternTime * 3);
                        enemy.position.addScaledVector(perpendicular, data.speed * evadePattern);
                        
                        // Also move slightly away from player
                        if (distanceToPlayer < 80) {
                            enemy.position.addScaledVector(evadeDir, -data.speed * 0.5);
                        }
                        break;
                        
                    case 'hover':
                        // Hover in place with slight movement
                        const hoverX = Math.sin(data.patternTime * 2) * 0.5;
                        const hoverZ = Math.cos(data.patternTime * 2) * 0.5;
                        enemy.position.x += hoverX;
                        enemy.position.z += hoverZ;
                        break;
                }
                
                // Keep boss within bounds and at appropriate height
                enemy.position.x = Math.max(-150, Math.min(150, enemy.position.x));
                enemy.position.z = Math.max(-150, Math.min(150, enemy.position.z));
                enemy.position.y = Math.max(20, Math.min(60, enemy.position.y)); // Keep boss flying high
                
                // Boss attacks
                if (now - data.lastRanged > data.attackCooldown) {
                    this.fireEnemyProjectile(enemy);
                    data.lastRanged = now;
                }
                
                // Boss special attack
                if (now - data.lastSpecial > data.specialCooldown) {
                    this.fireBossSpecial(enemy);
                    data.lastSpecial = now;
                }
                
                // Store current position for next frame
                data.lastPosition.copy(enemy.position);
            }

            updateEnemies(deltaTime) {
                const now = Date.now() / 1000;
                const attackDistance = 16; // Reduced for smaller zone
                
                for (let i = this.activeEnemies.length - 1; i >= 0; i--) {
                    const enemy = this.activeEnemies[i];
                    const data = enemy.userData;
                    
                    if (data.type === 'boss') {
                        // Use special boss movement
                        this.updateBossMovement(enemy, deltaTime);
                    } else {
                        // Regular enemies use flow field to navigate to tower
                        const gx = Math.floor((enemy.position.x + 160) / this.gridSize); // Adjusted for smaller zone
                        const gz = Math.floor((enemy.position.z + 160) / this.gridSize);
                        if (gx < 0 || gx >= this.cellsX || gz < 0 || gz >= this.cellsZ) continue;
                        const fIdx = (gx + gz * this.cellsX) * 3;
                        const dir = new THREE.Vector3(this.flowField[fIdx], 0, this.flowField[fIdx + 2]).normalize();
                        enemy.position.addScaledVector(dir, data.speed);
                        
                        // Flap wings using stored references
                        if (data.wings && data.wings.length >= 2) {
                            data.wings[0].rotation.z = Math.sin(now * 10) * 0.5;
                            data.wings[1].rotation.z = -Math.sin(now * 10) * 0.5;
                        }
                    }
                    
                    // Attack logic
                    let target = data.type === 'boss' ? this.controls.getObject() : this.tower;
                    const inMeleeRange = this.checkCollision(enemy, target, attackDistance);
                    
                    // Separate melee and ranged attacks
                    if (inMeleeRange && now - data.lastMelee > data.attackCooldown) {
                        if (target === this.tower) {
                            this.towerDamage += data.damage;
                        } else {
                            // Boss attacks player
                            let dmg = data.damage;
                            if (this.shieldActive) dmg *= 0.5;
                            this.health -= dmg;
                            this.damageTaken += dmg;
                            
                            if (this.health <= 0) {
                                this.health = 0;
                                this.gameOverScreen(true);
                            }
                        }
                        data.lastMelee = now;
                    }
                }
                
                // COMPANION DRAGONS REMOVED - No update needed
            }

            updateProjectiles(deltaTime) {
                this.updateSpatialGrid();
                
                const maxDistSq = 25600; // 160^2 (reduced for smaller zone)
                
                // Use deltaTime for projectile movement
                for (let i = this.activeProjectiles.length - 1; i >= 0; i--) {
                    const proj = this.activeProjectiles[i];
                    const data = proj.userData;
                    proj.position.addScaledVector(data.dir, data.speed * deltaTime);
                    
                    const cellX = Math.floor((proj.position.x + 160) / this.gridSize); // Adjusted for smaller zone
                    const cellZ = Math.floor((proj.position.z + 160) / this.gridSize);
                    
                    let hit = false;
                    for (let dx = -1; dx <= 1; dx++) for (let dz = -1; dz <= 1; dz++) {
                        const checkX = cellX + dx;
                        const checkZ = cellZ + dz;
                        if (checkX < 0 || checkX >= this.cellsX || checkZ < 0 || checkZ >= this.cellsZ) continue;
                        const cellId = checkX + ',' + checkZ;
                        const cellEnemies = this.spatialGrid.get(cellId);
                        if (!cellEnemies) continue;
                        
                        for (const enemy of cellEnemies) {
                            if (this.checkCollision(proj, enemy, enemy.userData.type === 'boss' ? 10 : 2)) {
                                const dmg = data.damage;
                                enemy.userData.health -= dmg;
                                this.damageDone += dmg;
                                hit = true;
                                if (enemy.userData.health <= 0) this.killEnemy(enemy);
                                break;
                            }
                        }
                        if (hit) break;
                    }
                    
                    // Check collision with buildings (solid obstacles)
                    if (!hit) {
                        for (const building of this.buildings) {
                            const box = building.userData.collisionBox;
                            if (proj.position.x >= box.minX && proj.position.x <= box.maxX &&
                                proj.position.z >= box.minZ && proj.position.z <= box.maxZ &&
                                proj.position.y <= box.height + 1 && proj.position.y > 0) {
                                hit = true;
                                break;
                            }
                        }
                    }
                    
                    // COMPANION DRAGONS REMOVED - No collision check needed
                    
                    if (hit || proj.position.lengthSq() > maxDistSq) {
                        this.releaseProjectile(proj, false);
                        this.activeProjectiles.splice(i, 1);
                    }
                }
                
                // Use deltaTime for enemy projectile movement
                for (let i = this.activeEnemyProjectiles.length - 1; i >= 0; i--) {
                    const proj = this.activeEnemyProjectiles[i];
                    const data = proj.userData;
                    proj.position.addScaledVector(data.dir, data.speed * deltaTime);
                    
                    // Check collision with buildings (solid obstacles)
                    let hit = false;
                    for (const building of this.buildings) {
                        const box = building.userData.collisionBox;
                        if (proj.position.x >= box.minX && proj.position.x <= box.maxX &&
                            proj.position.z >= box.minZ && proj.position.z <= box.maxZ &&
                            proj.position.y <= box.height + 1 && proj.position.y > 0) {
                            hit = true;
                            break;
                        }
                    }
                    
                    if (!hit && this.checkCollision(proj, this.controls.getObject(), data.damage > 20 ? 5 : 2)) {
                        let dmg = data.damage;
                        if (this.shieldActive) dmg *= 0.5;
                        this.health -= dmg;
                        this.damageTaken += dmg;
                        hit = true;
                        
                        if (this.health <= 0) {
                            this.health = 0;
                            this.gameOverScreen(true);
                        }
                    } 
                    
                    if (!hit && this.checkCollision(proj, this.tower, 5)) {
                        this.towerDamage += data.damage;
                        hit = true;
                    } 
                    
                    // COMPANION DRAGONS REMOVED - No collision check needed
                    
                    if (hit || proj.position.lengthSq() > maxDistSq) {
                        this.releaseProjectile(proj, true);
                        this.activeEnemyProjectiles.splice(i, 1);
                    }
                }
            }

            updatePlayer(deltaTime) {
                if (!this.controls.isLocked || !this.gameActive || this.waveCountdownActive) return;

                if (this.ammo < 100) {
                    this.ammo += 3 * deltaTime;
                    if (this.ammo > 100) this.ammo = 100;
                }

                if (this.attackCooldown > 0) {
                    this.attackCooldown -= deltaTime;
                }

                if (this.xrayCooldown > 0) {
                    this.xrayCooldown -= deltaTime;
                }

                if (this.mouseState.left && this.attackCooldown <= 0) {
                    this.fireWeapon();
                    this.attackCooldown = 0.05;
                }

                if (this.mouseState.right && this.xrayCooldown <= 0) {
                    this.fireXray();
                    this.xrayCooldown = 0.05;
                }

                // Quake-style movement physics
                this.direction.set(0, 0, 0);
                
                // Corrected movement directions
                if (this.moveState.forward) this.direction.z = 1;
                if (this.moveState.backward) this.direction.z = -1;
                if (this.moveState.left) this.direction.x = -1;
                if (this.moveState.right) this.direction.x = 1;
                
                this.direction.normalize();
                
                // Apply movement relative to camera direction
                const cameraDirection = new THREE.Vector3();
                this.camera.getWorldDirection(cameraDirection);
                cameraDirection.y = 0;
                cameraDirection.normalize();
                
                const rightVector = new THREE.Vector3();
                rightVector.crossVectors(cameraDirection, new THREE.Vector3(0, 1, 0));
                
                const moveX = rightVector.multiplyScalar(this.direction.x);
                const moveZ = cameraDirection.multiplyScalar(this.direction.z);
                const moveDirection = moveX.add(moveZ);
                
                // Apply movement speed with boost
                let speed = this.moveSpeed;
                if (this.speedBoostActive) {
                    speed *= this.speedBoostMultiplier;
                }
                
                this.velocity.x = moveDirection.x * speed;
                this.velocity.z = moveDirection.z * speed;
                
                // Apply gravity or jet pack
                if (this.jetPackActive) {
                    // Jet pack active - fly upward
                    this.velocity.y = this.jetPackPower;
                    this.onGround = false;
                } else {
                    // Normal gravity
                    this.velocity.y += this.gravity;
                }
                
                // Check building collisions for landing
                const newPosition = this.controls.getObject().position.clone().add(this.velocity);
                let onBuilding = false;
                
                for (const building of this.buildings) {
                    const box = building.userData.collisionBox;
                    if (newPosition.x >= box.minX && newPosition.x <= box.maxX &&
                        newPosition.z >= box.minZ && newPosition.z <= box.maxZ &&
                        newPosition.y <= box.height + 1 && newPosition.y > box.height - 1) {
                        newPosition.y = box.height + 1;
                        this.velocity.y = 0;
                        onBuilding = true;
                        this.onGround = true;
                        break;
                    }
                }
                
                // Check ground collision if not on building
                if (!onBuilding && newPosition.y <= 1) {
                    newPosition.y = 1;
                    this.velocity.y = 0;
                    this.onGround = true;
                } else if (!onBuilding) {
                    this.onGround = false;
                }
                
                // Apply movement
                this.controls.getObject().position.copy(newPosition);
                this.player.position.copy(newPosition);
                
                // Weapon bobbing effect - SLOWER ANIMATION
                if (this.gunGroup && (this.direction.x !== 0 || this.direction.z !== 0)) {
                    this.bobTime += deltaTime * 5; // Reduced from 10
                    const bobX = Math.sin(this.bobTime) * this.bobIntensity;
                    const bobY = Math.abs(Math.sin(this.bobTime * 2)) * this.bobIntensity;
                    this.gunGroup.position.x = this.weaponOffset.x + bobX;
                    this.gunGroup.position.y = this.weaponOffset.y + bobY;
                } else if (this.gunGroup) {
                    // Return to original position
                    this.gunGroup.position.lerp(this.weaponOffset, 0.1);
                }

                // Update score based on time and damage
                const currentTime = (Date.now() - this.startTime) / 1000;
                this.score = Math.max(0, 10000 - currentTime * 10 - this.towerDamage);

                document.getElementById('healthValue').textContent = Math.round(this.health);
                document.getElementById('healthFill').style.width = `${this.health}%`;
                document.getElementById('ammoValue').textContent = Math.round(this.ammo);
                document.getElementById('ammoFill').style.width = `${this.ammo}%`;
                document.getElementById('ammoDisplay').textContent = Math.round(this.ammo);
                document.getElementById('scoreValue').textContent = Math.round(this.score);
                document.getElementById('towerDamageValue').textContent = Math.round(this.towerDamage);
                document.getElementById('enemiesLeft').textContent = this.enemiesInWave - this.enemiesKilled;
                
                // Update boss health if active
                if (this.wave === 4 && this.activeEnemies.length > 0 && this.activeEnemies[0].userData.type === 'boss') {
                    const boss = this.activeEnemies[0];
                    const healthPercent = (boss.userData.health / boss.userData.maxHealth) * 100;
                    document.getElementById('bossHealthValue').textContent = Math.round(boss.userData.health);
                    document.getElementById('bossHealthFill').style.width = `${healthPercent}%`;
                }
            }

            checkCollision(obj1, obj2, threshold) {
                return obj1.position.distanceTo(obj2.position) < threshold;
            }

            releaseProjectile(proj, isEnemy) {
                proj.userData.active = false;
                proj.visible = false;
                proj.position.set(0, -100, 0);
                // Reset scale for pooled projectiles
                proj.scale.set(1, 1, 1);
                if (isEnemy) {
                    this.enemyProjectilePool.push(proj);
                } else {
                    this.projectilePool.push(proj);
                }
            }

            createExplosion(position) {
                const particles = new THREE.Points(
                    this.particleGeometry,
                    this.particleMaterial
                );
                particles.position.copy(position);
                particles.visible = true;
                this.scene.add(particles);
                
                setTimeout(() => {
                    this.scene.remove(particles);
                }, 500);
            }

            killEnemy(enemy) {
                this.createExplosion(enemy.position);
                
                this.releaseEnemy(enemy);
                this.enemiesKilled++;
                
                if (this.enemiesKilled >= this.enemiesInWave) {
                    // Record wave time
                    const waveTime = (Date.now() - this.waveStartTime) / 1000;
                    this.waveTimes.push(waveTime);
                    
                    if (this.wave >= 4) {
                        this.gameWinScreen();
                    } else {
                        setTimeout(() => {
                            this.wave++;
                            this.startWaveCountdown();
                        }, 2000);
                    }
                }
            }

            // Game over screen with player death detection
            gameOverScreen(playerDied = false) {
                this.gameActive = false;
                this.controls.unlock();
                
                document.getElementById('gameOver').style.display = 'flex';
                document.getElementById('gameOverTitle').textContent = playerDied ? 'CYBORG DOWN' : 'MISSION COMPLETE';
                
                const totalTime = (Date.now() - this.startTime) / 1000;
                this.calculateFinalScore(totalTime);
                
                document.getElementById('timeTakenValue').textContent = Math.round(totalTime);
                document.getElementById('towerDamageFinalValue').textContent = Math.round(this.towerDamage);
            }

            gameWinScreen() {
                this.gameActive = false;
                this.controls.unlock();
                
                document.getElementById('gameOver').style.display = 'flex';
                document.getElementById('gameOverTitle').textContent = 'MISSION COMPLETE';
                
                const totalTime = (Date.now() - this.startTime) / 1000;
                this.calculateFinalScore(totalTime);
                
                document.getElementById('timeTakenValue').textContent = Math.round(totalTime);
                document.getElementById('towerDamageFinalValue').textContent = Math.round(this.towerDamage);
            }

            calculateFinalScore(totalTime) {
                // Calculate final score based on time and damage
                const finalScore = Math.max(0, 10000 - totalTime * 10 - this.towerDamage);
                document.getElementById('finalScoreValue').textContent = Math.round(finalScore);
                
                // Performance rating
                let rating = "PERFECT PERFORMANCE";
                if (finalScore < 8000) rating = "GOOD PERFORMANCE";
                if (finalScore < 6000) rating = "AVERAGE PERFORMANCE";
                if (finalScore < 4000) rating = "POOR PERFORMANCE";
                if (finalScore < 2000) rating = "NEEDS IMPROVEMENT";
                
                document.getElementById('performanceRating').textContent = rating;
            }

            animate() {
                const deltaTime = Math.min(0.033, this.clock.getDelta());
                
                // Performance optimization: skip frames if needed
                this.frameCount++;
                const now = performance.now();
                if (now - this.lastFpsUpdate >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastFpsUpdate = now;
                }
                
                if (this.gameActive && !this.gameOver) {
                    this.updatePlayer(deltaTime);
                    this.updateEnemies(deltaTime);
                    this.updateProjectiles(deltaTime);
                }
                
                this.renderer.render(this.scene, this.camera);
                requestAnimationFrame(() => this.animate());
            }
        }

        window.addEventListener('load', () => {
            new Game();
        });
    </script>
</body>
</html>
