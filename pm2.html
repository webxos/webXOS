<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PERSONAL MIRROR</title>
    <meta name="theme-color" content="#000000">
    <link rel="manifest" href="data:application/manifest+json,{
        \"name\": \"PERSONAL MIRROR\",
        \"short_name\": \"Mirror AR\",
        \"description\": \"Webcam-based AR object recognition\",
        \"start_url\": \"./\",
        \"display\": \"fullscreen\",
        \"background_color\": \"#000000\",
        \"theme_color\": \"#000000\",
        \"icons\": [
            {
                \"src\": \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkyIiBoZWlnaHQ9IjE5MiIgdmlld0JveD0iMCAwIDE5MiAxOTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxOTIiIGhlaWdodD0iMTkyIiBmaWxsPSIjMDAwMDAwIi8+CjxwYXRoIGQ9Ik05NiAxMjhMMTI4IDk2SDY0TDEyOCA2NEw5NiAzMkw2NCA2NEgxMjhMNjQgOTZIMTI4LDk2IDEyOFoiIGZpbGw9IiMwMGZmMDAiLz4KPC9zdmc+Cg==\",
                \"sizes\": \"192x192\",
                \"type\": \"image/svg+xml\"
            }
        ]
    }">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <style>
        *{margin:0;padding:0;box-sizing:border-box;font-family:'Press Start 2P',cursive;image-rendering:pixelated}
        body{background:#000;color:#0f0;overflow:hidden;height:100vh;user-select:none;-webkit-tap-highlight-color:transparent}
        #appContainer{position:relative;width:100%;height:100vh;overflow:hidden}
        .matrix-grid{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(rgba(0,255,0,0.1)1px,transparent 1px),linear-gradient(90deg,rgba(0,255,0,0.1)1px,transparent 1px);background-size:16px 16px;opacity:0.3}
        .crt-overlay{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(to bottom,transparent 50%,rgba(0,20,0,0.1)50%);background-size:100% 4px;z-index:5;pointer-events:none;animation:scanline 8s linear infinite}
        @keyframes scanline{0%{background-position:0 0}100%{background-position:0 100%}}
        #visualizationContainer{position:absolute;top:0;left:0;width:100%;height:100%;z-index:2}
        #webcamCanvas{position:absolute;top:0;left:0;width:100%;height:100%;z-index:2}
        .top-banner{position:absolute;top:0;left:0;width:100%;height:40px;background:rgba(255,0,255,0.9);border-bottom:2px solid #f0f;display:flex;align-items:center;justify-content:center;z-index:12;animation:glitch 3s infinite}
        @keyframes glitch{0%,100%{transform:translateX(0)}5%{transform:translateX(-2px)}10%{transform:translateX(2px)}15%{transform:translateX(-1px)}20%{transform:translateX(1px)}25%,75%{transform:translateX(0)}55%{transform:translateX(-1px) skewX(-2deg)}60%{transform:translateX(1px) skewX(2deg)}65%{transform:translateX(-1px) skewX(-1deg)}70%{transform:translateX(1px) skewX(1deg)}}
        .top-banner::before{content:'';position:absolute;top:0;left:-10%;width:120%;height:100%;background:linear-gradient(90deg,transparent,rgba(255,255,255,0.2),transparent);animation:shimmer 2s infinite}
        @keyframes shimmer{0%{transform:translateX(-100%)}100%{transform:translateX(100%)}}
        .top-banner-text{font-size:12px;color:#000;text-shadow:1px 1px 0 #fff;letter-spacing:1px}
        .ctrl-btn{width:48px;height:48px;background:#000;border:2px solid #0f0;color:#0f0;font-size:6px;display:flex;align-items:center;justify-content:center;cursor:pointer;box-shadow:2px 2px 0 #000;transform:skew(-2deg);transition:background 0.1s,color 0.1s;touch-action:none;position:absolute;z-index:11}
        .ctrl-btn:hover,.ctrl-btn:active{background:#0f0;color:#000}
        .ctrl-btn.active{background:#0f0;color:#000}
        #webcamBtn{top:50%;left:16px;transform:translateY(-50%)}
        #modeBtn{top:50%;right:16px;transform:translateY(-50%)}
        .popup{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,10,0,0.98);border:none;padding:0;z-index:100;font-size:8px;color:#0f0}
        .popup-close{position:absolute;top:16px;right:16px;width:32px;height:32px;background:#000;border:2px solid #f00;color:#f00;font-size:8px;cursor:pointer;display:flex;align-items:center;justify-content:center;touch-action:none}
        .popup-close:hover,.popup-close:active{background:#f00;color:#000}
        .popup-btn{width:100%;margin:8px;padding:8px;background:#000;border:2px solid #0f0;color:#0f0;font-size:8px;cursor:pointer;text-align:center;touch-action:none}
        .popup-btn:hover,.popup-btn:active{background:#0f0;color:#000}
        .webcam-mesh-container{width:100%;height:100%;background:#000;border:none;position:relative;overflow:hidden}
        .webcam-grid{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(rgba(0,255,0,0.1)1px,transparent 1px),linear-gradient(90deg,rgba(0,255,0,0.1)1px,transparent 1px);background-size:20px 20px;z-index:1}
        #calibStatus{font-size:6px;color:#ff0;margin:8px 16px;position:absolute;bottom:0;left:0}
        #hudWarning{position:absolute;top:20%;left:50%;transform:translate(-50%,-50%);color:#f00;font-size:12px;text-shadow:1px 1px 0 #000;z-index:11;display:none}
        .terminal{position:absolute;bottom:16px;left:50%;transform:translateX(-50%);width:90%;max-width:600px;height:120px;background:rgba(0,10,0,0.9);border:2px solid #0f0;padding:8px;font-size:8px;color:#0f0;overflow-y:auto;z-index:10}
        .terminal-line{margin-bottom:4px}
        @media (min-width:768px){.ctrl-btn{width:56px;height:56px;font-size:8px}}
        .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
        .ctrl-btn:focus,.popup-btn:focus{outline:2px solid #0ff;outline-offset:2px}
    </style>
</head>
<body>
<div id="appContainer">
    <div class="matrix-grid"></div>
    <div class="crt-overlay"></div>
    <div class="top-banner">
        <div class="top-banner-text">PERSONAL MIRROR</div>
    </div>
    <div id="visualizationContainer"><canvas id="visualizationCanvas"></canvas></div>
    <canvas id="webcamCanvas"></canvas>
    <div id="ideInterface">
        <button id="webcamBtn" class="ctrl-btn" aria-label="Toggle Webcam">MIRROR</button>
        <button id="modeBtn" class="ctrl-btn" aria-label="Toggle Mode">DESKTOP</button>
        <div id="hudWarning">USER MISSING</div>
        <div class="terminal" id="terminal"></div>
    </div>
    <div class="popup" id="webcamPopup">
        <div class="popup-close" aria-label="Close Webcam">X</div>
        <div class="webcam-mesh-container" id="webcamMeshContainer">
            <canvas id="webcamCanvasPopup"></canvas>
            <div class="webcam-grid"></div>
        </div>
        <div id="calibStatus">IDLE</div>
        <button class="popup-btn" id="stopWebcam" aria-label="Stop Webcam">STOP MIRROR</button>
    </div>
</div>

<script>
    let scene, cam, ren, clock;
    let userObj, objects = [];
    let userDetected = false;
    let stream, faceMesh, camera;
    let isDesktopMode = true;
    const user = new THREE.Vector3(0, 1, 0);
    let animationId = null;
    let terminalLines = [];

    const $ = s => document.querySelector(s);
    const $$ = s => document.querySelectorAll(s);

    function init() {
        init3D();
        setupFaceDetection();
        setupEventListeners();
        animate();
    }

    function init3D() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        cam.position.set(0, 2, 5);
        const canvas = $('#visualizationCanvas');
        ren = new THREE.WebGLRenderer({ canvas, antialias: false, powerPreference: "low-power" });
        ren.setSize(window.innerWidth, window.innerHeight);
        ren.setPixelRatio(1);
        clock = new THREE.Clock();
        scene.add(new THREE.AmbientLight(0x003300));
        const dir = new THREE.DirectionalLight(0x00ff00, 0.4);
        dir.position.set(5, 10, 5);
        scene.add(dir);
        const gridSize = 20, gridDiv = 20;
        const gridMat = new THREE.LineBasicMaterial({ color: 0x004400 });
        const gridGeo = new THREE.BufferGeometry();
        const positions = [];
        for (let i = -gridSize / 2; i <= gridSize / 2; i += gridSize / gridDiv) {
            positions.push(i, 0, -gridSize / 2, i, 0, gridSize / 2);
            positions.push(-gridSize / 2, 0, i, gridSize / 2, 0, i);
        }
        gridGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        scene.add(new THREE.LineSegments(gridGeo, gridMat));
        userObj = new THREE.Mesh(
            new THREE.SphereGeometry(0.2, 8, 8),
            new THREE.MeshBasicMaterial({ color: 0x00ffff })
        );
        userObj.position.copy(user);
        scene.add(userObj);
        cam.lookAt(user);
        ren.render(scene, cam);
    }

    function setupFaceDetection() {
        faceMesh = new FaceMesh({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
        });
        faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        faceMesh.onResults(onFaceMeshResults);
    }

    function onFaceMeshResults(results) {
        userDetected = results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0;
        $('#hudWarning').style.display = userDetected ? 'none' : 'block';
        const canvas = $('#webcamPopup').style.display === 'block' ? $('#webcamCanvasPopup') : $('#webcamCanvas');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (results.image) {
            ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
        }
        if (userDetected) {
            const landmarks = results.multiFaceLandmarks[0];
            drawConnectors(ctx, landmarks, FACEMESH_TESSELATION, { color: '#C0C0C070', lineWidth: 1 });
            drawConnectors(ctx, landmarks, FACEMESH_RIGHT_EYE, { color: '#FF3030', lineWidth: 1 });
            drawConnectors(ctx, landmarks, FACEMESH_LEFT_EYE, { color: '#30FF30', lineWidth: 1 });
            drawConnectors(ctx, landmarks, FACEMESH_FACE_OVAL, { color: '#E0E0E0', lineWidth: 1 });
            updateObjects(landmarks);
            $('#calibStatus').textContent = `LIVE - OBJECTS: ${objects.length}`;
        } else {
            $('#calibStatus').textContent = 'NO FACE DETECTED';
            clearObjects();
        }
    }

    function updateObjects(landmarks) {
        clearObjects();
        const numObjects = 3;
        for (let i = 0; i < numObjects; i++) {
            const type = Math.random() > 0.5 ? 'cube' : 'sphere';
            const angle = (Math.random() * 120 - 60) * Math.PI / 180;
            const distance = 2 + Math.random() * 3;
            const pos = new THREE.Vector3(
                user.x + Math.sin(angle) * distance,
                user.y + (Math.random() * 1),
                user.z + Math.cos(angle) * distance
            );
            let geometry = type === 'cube' ? 
                new THREE.BoxGeometry(0.2, 0.2, 0.2) : 
                new THREE.SphereGeometry(0.2, 8, 8);
            const material = new THREE.MeshBasicMaterial({ 
                color: type === 'cube' ? 0x00ff00 : 0xff0000,
                wireframe: true
            });
            const obj = new THREE.Mesh(geometry, material);
            obj.position.copy(pos);
            obj.userData = { type, id: i, distance };
            scene.add(obj);
            objects.push(obj);
            logToTerminal(`Detected ${type} at distance ${distance.toFixed(1)}m`);
        }
    }

    function clearObjects() {
        objects.forEach(obj => {
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) obj.material.dispose();
            scene.remove(obj);
        });
        objects = [];
    }

    function logToTerminal(message) {
        const timestamp = new Date().toLocaleTimeString();
        terminalLines.push(`[${timestamp}] ${message}`);
        if (terminalLines.length > 10) terminalLines.shift();
        const terminal = $('#terminal');
        terminal.innerHTML = terminalLines.map(line => `<div class="terminal-line">${line}</div>`).join('');
        terminal.scrollTop = terminal.scrollHeight;
    }

    function handleWebcam() {
        if (stream) {
            openPopup('webcamPopup');
            return;
        }
        $('#calibStatus').textContent = 'REQUESTING CAMERA ACCESS...';
        navigator.mediaDevices.getUserMedia({ 
            video: { facingMode: 'user', width: { ideal: 480 }, height: { ideal: 360 } } 
        })
        .then(s => {
            stream = s;
            const video = document.createElement('video');
            video.id = 'webcamVideo';
            video.srcObject = stream;
            video.autoplay = true;
            video.playsInline = true;
            video.style.display = 'none';
            document.body.appendChild(video);
            camera = new Camera(video, {
                onFrame: async () => await faceMesh.send({ image: video }),
                width: 480,
                height: 360
            });
            camera.start();
            const canvas = $('#webcamCanvas');
            const canvasPopup = $('#webcamCanvasPopup');
            canvas.width = 480;
            canvas.height = 360;
            canvasPopup.width = window.innerWidth;
            canvasPopup.height = window.innerHeight;
            $('#calibStatus').textContent = 'LIVE - OBJECT DETECTION ACTIVE';
            $('#webcamBtn').classList.add('active');
            openPopup('webcamPopup');
            logToTerminal('Webcam initialized');
        })
        .catch(error => {
            $('#calibStatus').textContent = error.name === 'NotAllowedError' ? 'CAMERA ACCESS DENIED' : 'NO CAMERA FOUND';
            $('#webcamBtn').classList.remove('active');
            logToTerminal('Webcam access failed');
        });
    }

    function stopWebcam() {
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            stream = null;
            if (camera) camera.stop();
            const video = $('#webcamVideo');
            if (video) video.remove();
            $('#webcamBtn').classList.remove('active');
            $('#calibStatus').textContent = 'WEBCAM STOPPED';
            $('#webcamPopup').style.display = 'none';
            logToTerminal('Webcam stopped');
        }
    }

    function toggleMode() {
        isDesktopMode = !isDesktopMode;
        $('#modeBtn').textContent = isDesktopMode ? 'DESKTOP' : 'MOBILE';
        $('#modeBtn').classList.toggle('active');
        ren.setSize(window.innerWidth, window.innerHeight);
        cam.aspect = window.innerWidth / window.innerHeight;
        cam.updateProjectionMatrix();
        logToTerminal(`Mode switched to ${isDesktopMode ? 'Desktop' : 'Mobile'}`);
    }

    function setupEventListeners() {
        $('#webcamBtn').addEventListener('click', handleWebcam);
        $('#stopWebcam').addEventListener('click', stopWebcam);
        $('#modeBtn').addEventListener('click', toggleMode);
        $$('.popup-close').forEach(button => {
            button.addEventListener('click', () => {
                const popup = button.closest('.popup');
                popup.style.display = 'none';
                if (popup.id === 'webcamPopup' && stream) stopWebcam();
            });
        });
        window.addEventListener('resize', () => {
            cam.aspect = window.innerWidth / window.innerHeight;
            cam.updateProjectionMatrix();
            ren.setSize(window.innerWidth, window.innerHeight);
            const canvasPopup = $('#webcamCanvasPopup');
            canvasPopup.width = window.innerWidth;
            canvasPopup.height = window.innerHeight;
        }, { passive: true });
        window.addEventListener('beforeunload', cleanup);
    }

    function cleanup() {
        if (animationId) cancelAnimationFrame(animationId);
        if (stream) stopWebcam();
        if (scene) {
            scene.traverse(object => {
                if (object.geometry) object.geometry.dispose();
                if (object.material) object.material.dispose();
            });
        }
    }

    function animate() {
        animationId = requestAnimationFrame(animate);
        const deltaTime = clock.getDelta();
        objects.forEach((obj, index) => {
            if (obj.userData.type === 'cube') {
                obj.rotation.y += deltaTime * 0.3;
            } else {
                obj.scale.setScalar(1 + Math.sin(Date.now() * 0.005 + index) * 0.1);
            }
        });
        cam.position.set(user.x, user.y + 2, user.z + 5);
        cam.lookAt(user);
        ren.render(scene, cam);
    }

    function openPopup(id) {
        $$('.popup').forEach(popup => popup.style.display = 'none');
        $('#' + id).style.display = 'block';
    }

    window.addEventListener('load', init);
</script>
</body>
</html>
