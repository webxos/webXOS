<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>edTV: CHANNEL 4</title>
    <meta name="theme-color" content="#000000">
    <link rel="manifest" href="data:application/manifest+json,{
        \"name\": \"3D Data Capture\",
        \"short_name\": \"3D Capture\",
        \"description\": \"3D geometry data capture and export\",
        \"start_url\": \"./\",
        \"display\": \"fullscreen\",
        \"background_color\": \"#000000\",
        \"theme_color\": \"#000000\",
        \"icons\": [
            {
                \"src\": \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkyIiBoZWlnaHQ9IjE5MiIgdmlld0JveD0iMCAwIDE5MiAxOTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxOTIiIGhlaWdodD0iMTkyIiBmaWxsPSIjMDAwMDAwIi8+CjxwYXRoIGQ9Ik05NiAxMjhMMTI4IDk2SDY0TDEyOCA2NEw5NiAzMkw2NCA2NEgxMjhMNjQgOTZIMTI4TDk2IDEyOFoiIGZpbGw9IiMwMGZmMDAiLz4KPC9zdmc+Cg==\",
                \"sizes\": \"192x192\",
                \"type\": \"image/svg+xml\"
            }
        ]
    }">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js"></script>
    <script src="https://docs.opencv.org/4.5.0/opencv.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        *{margin:0;padding:0;box-sizing:border-box;font-family:'Press Start 2P',cursive;image-rendering:pixelated}
        body{background:#000;color:#0f0;overflow:hidden;height:100vh;user-select:none;-webkit-tap-highlight-color:transparent}
        #appContainer{position:relative;width:100%;height:100vh;overflow:hidden}
        .matrix-grid{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(rgba(0,255,0,0.1)1px,transparent 1px),linear-gradient(90deg,rgba(0,255,0,0.1)1px,transparent 1px);background-size:16px 16px;opacity:0.3}
        .crt-overlay{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(to bottom,transparent 50%,rgba(0,20,0,0.1)50%);background-size:100% 4px;z-index:5;pointer-events:none;animation:scanline 8s linear infinite}
        @keyframes scanline{0%{background-position:0 0}100%{background-position:0 100%}}
        #visualizationContainer{position:absolute;top:0;left:0;width:100%;height:100%;z-index:2}
        #ideInterface{position:absolute;top:0;left:0;width:100%;height:100%;z-index:10}
        .top-banner{position:absolute;top:0;left:0;width:100%;height:40px;background:rgba(255,0,255,0.9);border-bottom:2px solid #f0f;display:flex;align-items:center;justify-content:center;z-index:12;overflow:hidden;animation:glitch 3s infinite}
        @keyframes glitch{0%,100%{transform:translateX(0)}5%{transform:translateX(-2px)}10%{transform:translateX(2px)}15%{transform:translateX(-1px)}20%{transform:translateX(1px)}25%{transform:translateX(0)}50%{transform:translateX(0)}55%{transform:translateX(-1px) skewX(-2deg)}60%{transform:translateX(1px) skewX(2deg)}65%{transform:translateX(-1px) skewX(-1deg)}70%{transform:translateX(1px) skewX(1deg)}75%{transform:translateX(0)}}
        .top-banner-text{font-size:12px;color:#000;text-shadow:1px 1px 0 #fff;letter-spacing:1px}
        .ctrl-btn{width:120px;height:52px;background:#000;border:3px solid #0ff;color:#0ff;font-size:10px;display:flex;align-items:center;justify-content:center;cursor:pointer;box-shadow:3px 3px 0 #000;transform:skew(-2deg);transition:background 0.1s,color 0.1s;touch-action:none;margin:10px}
        .ctrl-btn:hover,.ctrl-btn:active{background:#0ff;color:#000}
        .ctrl-btn.active{background:#0ff;color:#000}
        .export-btn{border-color:#f0f;color:#f0f}
        .export-btn:hover,.export-btn:active{background:#f0f;color:#000}
        .export-btn.active{background:#f0f;color:#000}
        .controls-container{position:absolute;bottom:20px;left:50%;transform:translateX(-50%);display:flex;gap:10px;z-index:11;flex-wrap:wrap;justify-content:center}
        #pip{position:fixed;top:20px;right:20px;width:240px;border:4px solid #fff;border-radius:12px;cursor:pointer;z-index:10;transition:all 0.4s}
        #pip.fullscreen{top:0;left:0;width:100%;height:100%;border:none;border-radius:0}
        .mirror-popup{display:block;position:fixed;top:0;right:0;width:240px;height:180px;background:rgba(0,10,0,0.95);border:3px solid #0ff;padding:8px;z-index:100;box-shadow:6px 6px 0 #000,inset 2px 2px 0 #0ff;resize:both;overflow:hidden;font-size:8px;color:#0ff;border-radius:4px}
        .mirror-header{display:flex;justify-content:space-between;align-items:center;padding:4px 8px;background:rgba(0,255,255,0.2);border-bottom:2px solid #0ff;margin-bottom:8px;cursor:move;user-select:none}
        .mirror-title{font-size:10px;color:#0ff;text-shadow:1px 1px 0 #000}
        .mirror-close{width:24px;height:24px;background:#000;border:2px solid #f00;color:#f00;font-size:10px;cursor:pointer;display:flex;align-items:center;justify-content:center;touch-action:none}
        .mirror-close:hover,.mirror-close:active{background:#f00;color:#000}
        .mirror-content{width:100%;height:calc(100% - 40px);position:relative}
        .webcam-mesh-container{width:100%;height:100%;background:#000;border:2px solid #0f0;position:relative;overflow:hidden}
        .webcam-grid{position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(rgba(0,255,0,0.1)1px,transparent 1px),linear-gradient(90deg,rgba(0,255,0,0.1)1px,transparent 1px);background-size:20px 20px;z-index:1}
        .face-direction-arrow{position:absolute;top:50%;left:50%;width:40px;height:40px;transform-origin:center;z-index:3;transition:transform 0.1s ease}
        .face-direction-arrow::before{content:'';position:absolute;top:0;left:50%;transform:translateX(-50%);width:0;height:0;border-left:8px solid transparent;border-right:8px solid transparent;border-bottom:20px solid #f00}
        .face-direction-arrow::after{content:'';position:absolute;top:20px;left:50%;transform:translateX(-50%);width:4px;height:20px;background:#f00}
        .user-position-marker{position:absolute;width:12px;height:12px;background:#0ff;border-radius:50%;z-index:2;box-shadow:0 0 10px #0ff}
        #calibStatus{font-size:6px;color:#ff0;margin:4px 0;text-align:center}
        #radarCanvas{width:100%;height:100px;border:2px solid #0f0;background:#000;display:block;margin-top:8px}
        .radar-container{position:relative;width:100%;height:100px;display:none}
        #hudWarning{position:absolute;top:20%;left:50%;transform:translate(-50%,-50%);color:#f00;font-size:12px;text-shadow:1px 1px 0 #000;z-index:11;display:none}
        @media (max-width:767px){.mirror-popup{width:200px;height:150px}.controls-container{flex-direction:column;align-items:center;}.ctrl-btn{width:140px;height:56px;font-size:12px}}
        #webcamCanvas{position:absolute;top:0;left:0;width:100%;height:100%;z-index:2}
        #sceneClickArea{position:absolute;top:0;left:0;width:100%;height:calc(100% - 80px);z-index:3;cursor:pointer}
        .status-panel{position:absolute;top:50px;right:10px;background:rgba(0,0,0,0.8);border:2px solid #0ff;padding:8px;font-size:8px;color:#0ff;max-width:200px;z-index:11}
        #errorLog{position:absolute;top:40px;left:10px;background:rgba(0,0,0,0.8);border:2px solid #f00;padding:8px;font-size:8px;color:#f00;max-height:200px;overflow:auto;z-index:11;width:200px}
    </style>
</head>
<body>
<div id="appContainer">
    <div class="matrix-grid"></div>
    <div class="crt-overlay"></div>
    <div class="top-banner">
        <div class="top-banner-text">edTV: CHANNEL 4</div>
    </div>
    <div id="visualizationContainer">
        <canvas id="visualizationCanvas"></canvas>
        <div id="sceneClickArea" title="Click to center view"></div>
    </div>
    <div class="status-panel">
        <div>OBJECTS: <span id="objectCount">0</span></div>
        <div>FACES: <span id="faceCount">0</span></div>
        <div>DATA POINTS: <span id="dataPointCount">0</span></div>
    </div>
    <div id="ideInterface">
        <div class="controls-container">
            <button id="mirrorBtn" class="ctrl-btn" aria-label="Calibrate 3D Capture">CALIBRATE</button>
            <button id="exportBtn" class="ctrl-btn export-btn" aria-label="Export 3D Data">EXPORT</button>
            <button id="resetBtn" class="ctrl-btn" style="border-color:#ff0;color:#ff0" aria-label="Reset Scene">RESET</button>
        </div>
        <div id="hudWarning">NO DATA CAPTURED</div>
    </div>
    <div class="mirror-popup" id="mirrorPopup">
        <div class="mirror-header">
            <div class="mirror-title">3D DATA CAPTURE</div>
            <div class="mirror-close" aria-label="Close Mirror">X</div>
        </div>
        <div class="mirror-content">
            <div class="webcam-mesh-container" id="webcamMeshContainer">
                <canvas id="webcamCanvas"></canvas>
                <div class="webcam-grid"></div>
                <div class="face-direction-arrow" id="faceDirectionArrow"></div>
                <div class="user-position-marker" id="userPositionMarker" style="top:50%;left:50%;"></div>
            </div>
            <div id="calibStatus">CALIBRATING...</div>
            <div class="radar-container">
                <canvas id="radarCanvas"></canvas>
            </div>
        </div>
    </div>
    <div id="errorLog"></div>
</div>
<video id="pip" autoplay playsinline muted style="display:none"></video>
<script>
    let scene, cam, ren, clock;
    let userObj, objects = [], lightPoints = [];
    let faceDirection = 0, userDetected = false;
    let stream, faceMesh, camera, objectDetector;
    let isFrontCam = true;
    const user = new THREE.Vector3(0, 0, 0);
    let animationId = null; let pipVideo; let face3DLines;
    let serviceWorkerUrl = null;
    let mirrorDragging = false;
    let mirrorOffset = { x: 0, y: 0 };
    let cameraDistance = 5;
    let mask, lightSource;
    const geometryDataSchema = {
        version: "1.0",
        timestamp: "",
        metadata: {
            app: "edTV_CHANNEL_4",
            captureType: "face_objects_3d_thermal",
            coordinateSystem: "right_handed"
        },
        faceGeometry: {
            vertices: [],
            normals: [],
            faces: [],
            landmarks: []
        },
        environmentObjects: [],
        camera: {
            position: { x: 0, y: 0, z: 0 },
            rotation: { x: 0, y: 0, z: 0 },
            fov: 75
        }
    };
    const $ = s => document.querySelector(s);
    function logError(msg) {
        const log = $('#errorLog');
        log.innerHTML += `${new Date().toISOString()}: ${msg}<br>`;
        log.scrollTop = log.scrollHeight;
    }
    function init() {
        try {
            init3D();
            setupFaceDetection();
            setupObjectDetection();
            setupServiceWorker();
            setupEventListeners();
            autoStartMirror();
            animate();
        } catch (error) {
            logError(error.message);
        }
    }
    function init3D() {
        try {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            cam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            cam.position.set(0, 0, cameraDistance);
            const canvas = $('#visualizationCanvas');
            ren = new THREE.WebGLRenderer({canvas: canvas, antialias: false});
            ren.setSize(window.innerWidth, window.innerHeight);
            ren.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            clock = new THREE.Clock();
            scene.add(new THREE.AmbientLight(0x003300));
            lightSource = new THREE.PointLight(0xffffff, 1, 100);
            lightSource.position.set(0,0,0);
            scene.add(lightSource);
            const gridSize = 20, gridDiv = 20;
            const gridMat = new THREE.LineBasicMaterial({ color: 0x004400 });
            const gridGeo = new THREE.BufferGeometry();
            const positions = [];
            for (let i = -gridSize / 2; i <= gridSize / 2; i += gridSize / gridDiv) {
                positions.push(i, 0, -gridSize / 2, i, 0, gridSize / 2);
                positions.push(-gridSize / 2, 0, i, gridSize / 2, 0, i);
            }
            gridGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            scene.add(new THREE.LineSegments(gridGeo, gridMat));
            userObj = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 16), new THREE.MeshBasicMaterial({ color: 0x00ffff }));
            userObj.position.copy(user);
            scene.add(userObj);
            const arrowGeometry = new THREE.ConeGeometry(0.1, 0.3, 8);
            const arrowMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const userArrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
            userArrow.position.set(0, 0.3, 0);
            userArrow.rotation.x = Math.PI / 2;
            userObj.add(userArrow);
            face3DLines = new THREE.LineSegments(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({color: 0x00ff00}));
            scene.add(face3DLines);
            const maskUrl = 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/models/gltf/DamagedHelmet/glTF/DamagedHelmet.gltf';
            const loader = new THREE.GLTFLoader();
            loader.load(maskUrl, (gltf) => {
                mask = gltf.scene;
                mask.scale.set(1.5,1.5,1.5);
                mask.position.set(0,0,0);
                scene.add(mask);
            });
            cam.lookAt(user);
            ren.render(scene, cam);
        } catch (error) {
            logError(`3D init: ${error.message}`);
        }
    }
    function setupFaceDetection() {
        try {
            faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
            faceMesh.setOptions({maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
            faceMesh.onResults(onFaceMeshResults);
        } catch (error) {
            logError(`Face detection: ${error.message}`);
        }
    }
    async function setupObjectDetection() {
        try {
            objectDetector = await cocoSsd.load();
        } catch (error) {
            logError(`Object detection: ${error.message}`);
        }
    }
    function onFaceMeshResults(results) {
        try {
            userDetected = results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0;
            const canvas = $('#webcamCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (results.image) {
                ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
            }
            if (userDetected) {
                const landmarks = results.multiFaceLandmarks[0];
                drawConnectors(ctx, landmarks, FACEMESH_TESSELATION, {color: '#00ff00', lineWidth: 1});
                const positions = [];
                FACEMESH_TESSELATION.forEach(conn => {
                    const p1 = landmarks[conn[0]];
                    const p2 = landmarks[conn[1]];
                    positions.push(p1.x * 4 - 2, -p1.y * 4 + 2, p1.z * 4);
                    positions.push(p2.x * 4 - 2, -p2.y * 4 + 2, p2.z * 4);
                });
                face3DLines.geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                face3DLines.position.set(0,0,0);
                geometryDataSchema.faceGeometry.landmarks = landmarks.map(lm => ({x: lm.x, y: lm.y, z: lm.z}));
                geometryDataSchema.faceGeometry.vertices = landmarks.flatMap(lm => [lm.x, lm.y, lm.z]);
                const nose = landmarks[1];
                const left = landmarks[234];
                const right = landmarks[454];
                const center = {x: (left.x + right.x)/2, y: (left.y + right.y)/2, z: (left.z + right.z)/2};
                if (mask) {
                    mask.position.x = (center.x - 0.5) * 0.005;
                    mask.position.y = -(center.y - 0.5) * 0.005;
                    mask.position.z = -center.z * 0.01;
                    const dx = right.x - left.x;
                    const dy = right.y - left.y;
                    mask.rotation.y = Math.atan2(dy, dx) * -2;
                    mask.rotation.x = (center.y - 0.5) * -1.5;
                    lightSource.position.copy(mask.position);
                }
                const leftEye = landmarks[33], rightEye = landmarks[263];
                faceDirection = Math.atan2(rightEye.y - leftEye.y, rightEye.x - leftEye.x) * 180 / Math.PI;
            }
            updateThermalMap(results.image);
            updateStatusPanel();
        } catch (error) {
            logError(`Face results: ${error.message}`);
        }
    }
    function updateThermalMap(video) {
        try {
            if (!video) return;
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = 32;
            tempCanvas.height = 24;
            const ctx = tempCanvas.getContext('2d');
            ctx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);
            const imageData = ctx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            lightPoints.forEach(pt => scene.remove(pt));
            lightPoints = [];
            let count = 0;
            for (let y = 0; y < tempCanvas.height; y += 1) {
                for (let x = 0; x < tempCanvas.width; x += 1) {
                    if (count >= 100) break;
                    const i = (y * tempCanvas.width + x) * 4;
                    const r = imageData.data[i];
                    const g = imageData.data[i+1];
                    const b = imageData.data[i+2];
                    const lum = 0.299 * r + 0.587 * g + 0.114 * b;
                    if (lum > 50) {
                        const pos = new THREE.Vector3((x / tempCanvas.width - 0.5) * 10, (0.5 - y / tempCanvas.height) * 7.5, (lum / 255 * 2 - 1));
                        const mat = new THREE.PointsMaterial({size: 0.1, color: new THREE.Color().setHSL(lum / 255, 1, 0.5)});
                        const geo = new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute([pos.x, pos.y, pos.z], 3));
                        const pt = new THREE.Points(geo, mat);
                        scene.add(pt);
                        lightPoints.push(pt);
                        count++;
                    }
                }
                if (count >= 100) break;
            }
        } catch (error) {
            logError(`Thermal map: ${error.message}`);
        }
    }
    function onObjectDetectionResults(results) {
        try {
            if (results.detections) {
                let added = 0;
                results.detections.forEach(detection => {
                    if (added >= 10 || objects.length >= 100) return;
                    if (detection.categories[0].score > 0.5) {
                        addVoidObject(detection, detection.categories[0].categoryName);
                        added++;
                    }
                });
            }
        } catch (error) {
            logError(`Object results: ${error.message}`);
        }
    }
    function addVoidObject(detection, className) {
        if (objects.length >= 100) return;
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * 5 + 2;
        const pos = new THREE.Vector3(Math.sin(angle) * distance, Math.random() * 2, Math.cos(angle) * distance);
        const geometry = new THREE.SphereGeometry(0.5, 8, 6);
        const material = new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true });
        const obj = new THREE.Mesh(geometry, material);
        obj.position.copy(pos);
        obj.userData = { type: 'void', class: className };
        scene.add(obj);
        objects.push(obj);
        geometryDataSchema.environmentObjects.push({
            class: className,
            type: 'void',
            position: { x: pos.x, y: pos.y, z: pos.z }
        });
    }
    function detectArUco(video) {
        try {
            let src = cv.matFromImageData(video);
            let dst = new cv.Mat();
            cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY);
            let dictionary = new cv.Dictionary(cv.DICT_6X6_250);
            let parameters = new cv.DetectorParameters();
            let markerCorners = new cv.MatVector();
            let markerIds = new cv.Mat();
            cv.detectMarkers(dst, dictionary, markerCorners, markerIds, parameters);
            if (markerIds.rows > 0) {
                for (let i = 0; i < Math.min(markerIds.rows, 5); ++i) {
                    if (objects.length >= 100) break;
                    addVoidObject({}, 'planar');
                }
            }
            src.delete(); dst.delete(); markerCorners.delete(); markerIds.delete();
        } catch (error) {
            logError(`ArUco: ${error.message}`);
        }
    }
    function detectSphere(video) {
        try {
            let src = cv.matFromImageData(video);
            let hsv = new cv.Mat();
            cv.cvtColor(src, hsv, cv.COLOR_RGB2HSV);
            let low = new cv.Scalar(0, 100, 100);
            let high = new cv.Scalar(10, 255, 255);
            let mask = new cv.Mat();
            cv.inRange(hsv, low, high, mask);
            let contours = new cv.MatVector();
            let hierarchy = new cv.Mat();
            cv.findContours(mask, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
            for (let i = 0; i < Math.min(contours.size(), 5); ++i) {
                let cnt = contours.get(i);
                let area = cv.contourArea(cnt);
                if (area > 100) {
                    if (objects.length >= 100) break;
                    addVoidObject({}, 'sphere');
                }
            }
            src.delete(); hsv.delete(); mask.delete(); contours.delete(); hierarchy.delete();
        } catch (error) {
            logError(`Sphere detect: ${error.message}`);
        }
    }
    function setupServiceWorker() {
        try {
            if ('serviceWorker' in navigator) {
                const swCode = `
                self.addEventListener('message', async (event) => {
                    if (event.data.type === 'fuseTensors') {
                        const tf = await import('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs');
                        const tensor1 = tf.tensor(event.data.tensor1);
                        const tensor2 = tf.tensor(event.data.tensor2);
                        const fused = tensor1.add(tensor2);
                        event.ports[0].postMessage({result: fused.arraySync()});
                    }
                });
                `;
                const blob = new Blob([swCode], {type: 'application/javascript'});
                serviceWorkerUrl = URL.createObjectURL(blob);
                navigator.serviceWorker.register(serviceWorkerUrl).then(reg => {});
            }
        } catch (error) {
            logError(`SW: ${error.message}`);
        }
    }
    function fuseTensors(tensor1, tensor2) {
        if (navigator.serviceWorker.controller) {
            const channel = new MessageChannel();
            channel.port1.onmessage = (event) => {};
            navigator.serviceWorker.controller.postMessage({type: 'fuseTensors', tensor1, tensor2}, [channel.port2]);
        }
    }
    function setupEventListeners() {
        try {
            let lastTap = 0;
            $('#mirrorPopup').addEventListener('touchstart', (e) => {
                const now = new Date().getTime();
                if (now - lastTap < 300) {
                    togglePiP();
                }
                lastTap = now;
            }, {passive: true});
            function togglePiP() {
                const pip = $('#pip');
                pip.classList.toggle('fullscreen');
            }
            $('#pip').ondblclick = togglePiP;
            $('#mirrorBtn').addEventListener('click', () => {
                if ($('#mirrorPopup').style.display === 'block') {
                    closeMirror();
                } else {
                    openMirror();
                    startWebcam();
                }
            });
            $('#exportBtn').addEventListener('click', exportGeometryData);
            $('#resetBtn').addEventListener('click', resetScene);
            $('.mirror-close').addEventListener('click', closeMirror);
            $('#sceneClickArea').addEventListener('click', centerView);
            const mirrorHeader = $('.mirror-header');
            const mirrorPopup = $('#mirrorPopup');
            mirrorHeader.addEventListener('mousedown', startDrag);
            mirrorHeader.addEventListener('touchstart', startDrag);
            function startDrag(e) {
                e.preventDefault();
                mirrorDragging = true;
                const rect = mirrorPopup.getBoundingClientRect();
                mirrorOffset.x = (e.type === 'mousedown' ? e.clientX : e.touches[0].clientX) - rect.left;
                mirrorOffset.y = (e.type === 'mousedown' ? e.clientY : e.touches[0].clientY) - rect.top;
                document.addEventListener('mousemove', dragMirror);
                document.addEventListener('touchmove', dragMirror);
                document.addEventListener('mouseup', stopDrag);
                document.addEventListener('touchend', stopDrag);
            }
            function dragMirror(e) {
                if (!mirrorDragging) return;
                e.preventDefault();
                let clientX = (e.type === 'mousemove' ? e.clientX : e.touches[0].clientX);
                let clientY = (e.type === 'mousemove' ? e.clientY : e.touches[0].clientY);
                mirrorPopup.style.left = (clientX - mirrorOffset.x) + 'px';
                mirrorPopup.style.top = (clientY - mirrorOffset.y) + 'px';
                mirrorPopup.style.transform = 'none';
            }
            function stopDrag() {
                mirrorDragging = false;
                document.removeEventListener('mousemove', dragMirror);
                document.removeEventListener('touchmove', dragMirror);
                document.removeEventListener('mouseup', stopDrag);
                document.removeEventListener('touchend', stopDrag);
            }
            window.addEventListener('resize', () => {
                cam.aspect = window.innerWidth / window.innerHeight;
                cam.updateProjectionMatrix();
                ren.setSize(window.innerWidth, window.innerHeight);
            }, { passive: true });
            window.addEventListener('beforeunload', cleanup);
        } catch (error) {
            logError(`Events: ${error.message}`);
        }
    }
    function startWebcam() {
        try {
            if (stream) return;
            const status = $('#calibStatus');
            status.textContent = 'INITIALIZING CAMERA...';
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            isFrontCam = isMobile;
            navigator.mediaDevices.getUserMedia({
                video: {
                    facingMode: isFrontCam ? 'user' : 'environment',
                    width: { ideal: 320 },
                    height: { ideal: 240 }
                }
            }).then(s => {
                stream = s;
                const video = document.createElement('video');
                video.id = 'webcamVideo';
                video.srcObject = stream;
                video.autoplay = true;
                video.playsInline = true;
                video.style.display = 'none';
                document.body.appendChild(video);
                camera = new Camera(video, {
                    onFrame: async () => {
                        await faceMesh.send({ image: video });
                        const detections = await objectDetector.detect(video);
                        onObjectDetectionResults({detections});
                        detectArUco(video);
                        detectSphere(video);
                    },
                    width: 320,
                    height: 240
                });
                camera.start();
                pipVideo = $('#pip');
                pipVideo.srcObject = $('#webcamCanvas').captureStream(15);
                pipVideo.style.display = 'block';
                const canvas = $('#webcamCanvas');
                canvas.width = 240;
                canvas.height = 180;
                status.textContent = 'READY FOR 3D CAPTURE';
            }).catch(error => {
                status.textContent = 'CAMERA ACCESS DENIED';
                logError(`Webcam: ${error.message}`);
            });
        } catch (error) {
            logError(`Webcam start: ${error.message}`);
        }
    }
    function animate() {
        try {
            animationId = requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            if (userObj && userObj.children.length > 0) {
                userObj.children[0].rotation.y = -faceDirection * Math.PI / 180;
            }
            objects.forEach((obj, index) => {
                obj.rotation.y += deltaTime * 0.2;
                obj.position.y += Math.sin(Date.now() * 0.001 + index) * 0.005;
            });
            cam.lookAt(user);
            ren.render(scene, cam);
        } catch (error) {
            logError(`Animate: ${error.message}`);
        }
    }
    function openMirror() {
        $('#mirrorPopup').style.display = 'block';
    }
    function closeMirror() {
        $('#mirrorPopup').style.display = 'none';
    }
    function exportGeometryData() {
        try {
            geometryDataSchema.timestamp = new Date().toISOString();
            const dataStr = JSON.stringify(geometryDataSchema);
            const blob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'geometry_data.json';
            a.click();
            URL.revokeObjectURL(url);
        } catch (error) {
            logError(`Export: ${error.message}`);
        }
    }
    function resetScene() {
        try {
            objects.forEach(obj => scene.remove(obj));
            objects = [];
            geometryDataSchema.environmentObjects = [];
            lightPoints.forEach(pt => scene.remove(pt));
            lightPoints = [];
            updateStatusPanel();
            startWebcam();
        } catch (error) {
            logError(`Reset: ${error.message}`);
        }
    }
    function centerView() {
        cam.position.set(0, 0, cameraDistance);
        cam.lookAt(user);
    }
    function autoStartMirror() {
        openMirror();
        startWebcam();
    }
    function updateStatusPanel() {
        $('#objectCount').textContent = objects.length;
        $('#faceCount').textContent = userDetected ? 1 : 0;
        $('#dataPointCount').textContent = geometryDataSchema.faceGeometry.vertices.length / 3 + objects.length;
    }
    function cleanup() {
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
        }
        if (animationId) {
            cancelAnimationFrame(animationId);
        }
    }
    window.addEventListener('load', init);
</script>
</body>
</html>
