<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GalaxyCraft</title>
    <style>
      body { 
        margin: 0; 
        background-color: #000;
        overflow: hidden;
      }
      canvas { 
        display: block; 
      }
      #hud {
        position: absolute;
        top: 10px;
        right: 10px;
        color: #0ff;
        font-family: 'Courier New', monospace;
        font-size: 16px;
        text-shadow: 0 0 5px #0ff, 0 0 10px #0ff;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border: 1px solid #0ff;
        border-radius: 5px;
        box-shadow: 0 0 10px #0ff;
      }
      .hud-stat {
        margin: 5px 0;
      }
      #console {
        position: absolute;
        bottom: 60px;
        left: 10px;
        width: 300px;
        height: 100px;
        color: #0ff;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        background: rgba(0, 0, 0, 0.7);
        padding: 5px;
        border: 1px solid #0ff;
        overflow-y: auto;
        box-shadow: 0 0 10px #0ff;
      }
      #crosshair {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 20px;
        height: 20px;
        background: transparent;
        border: 2px solid #0ff;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
        box-shadow: 0 0 10px #0ff;
      }
      #controls {
        position: fixed;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 10px;
      }
      button {
        padding: 10px 20px;
        font-size: 16px;
        font-family: 'Courier New', monospace;
        background: rgba(0, 0, 0, 0.7);
        color: #0ff;
        border: 1px solid #0ff;
        border-radius: 5px;
        cursor: pointer;
        touch-action: manipulation;
        text-shadow: 0 0 5px #0ff;
        box-shadow: 0 0 10px #0ff;
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .glow {
        animation: glow 2s infinite alternate;
      }
      @keyframes glow {
        from {
          box-shadow: 0 0 5px #0ff, 0 0 10px #0ff;
          text-shadow: 0 0 5px #0ff, 0 0 10px #0ff;
        }
        to {
          box-shadow: 0 0 10px #0ff, 0 0 20px #0ff, 0 0 30px #0ff;
          text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
        }
      }
    </style>
  </head>
  <body>
    <div id="hud">
      <div class="hud-stat">WAVE: <span id="wave">1</span></div>
      <div class="hud-stat">ENEMIES: <span id="enemies">0</span></div>
      <div class="hud-stat">SCORE: <span id="score">0</span></div>
      <div class="hud-stat">HEALTH: <span id="health">100</span></div>
      <div class="hud-stat">SHIELD: <span id="shield">100</span></div>
      <div class="hud-stat">DRONES: <span id="drones">0/3</span></div>
    </div>
    <div id="console"></div>
    <div id="crosshair"></div>
    <div id="controls">
      <button id="boostBtn">Boost</button>
      <button id="fireBtn">Fire</button>
      <button id="destroyBtn">Destroy All</button>
      <button id="lightspeedBtn">Lightspeed</button>
      <button id="endGameBtn">End Game</button>
    </div>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from 'three';
      import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
      import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
      import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
      import { GlitchPass } from 'three/addons/postprocessing/GlitchPass.js';

      // Scene setup
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
      const renderer = new THREE.WebGLRenderer({ antialias: false });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Postprocessing
      const composer = new EffectComposer(renderer);
      const renderPass = new RenderPass(scene, camera);
      composer.addPass(renderPass);
      const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
      composer.addPass(bloomPass);
      const glitchPass = new GlitchPass();
      glitchPass.enabled = false;
      composer.addPass(glitchPass);

      // Camera position
      camera.position.z = 3;

      // Clock for 30 fps game loop
      const clock = new THREE.Clock();
      const fps = 30;
      const interval = 1 / fps;
      let delta = 0;

      // Track generation parameters - larger and longer
      const segmentLength = 20;
      const segmentCount = 15;
      const trackRadius = 5;
      const segments = [];
      let currentZ = 0;
      let wave = 1;

      // Player spaceship
      let spaceship = null;
      let playerPosition = new THREE.Vector3(0, 0, 0);
      let playerVelocity = new THREE.Vector3(0, 0, -0.2);
      let playerTilt = 0;
      let playerPitch = 0;
      let barrelRoll = 0;
      let turn360 = 0;

      // Game state
      let score = 0;
      let health = 100;
      let shield = 100;
      let dronesKilled = 0;
      let startTime = Date.now();
      let scoreTimeRatios = [];
      let lastRatioUpdate = Date.now();
      let autoPlay = false;
      let lastInputTime = Date.now();
      const waveElement = document.getElementById('wave');
      const enemiesElement = document.getElementById('enemies');
      const scoreElement = document.getElementById('score');
      const healthElement = document.getElementById('health');
      const shieldElement = document.getElementById('shield');
      const dronesElement = document.getElementById('drones');
      const consoleElement = document.getElementById('console');

      function logConsole(message) {
        consoleElement.innerHTML += `${message}<br>`;
        consoleElement.scrollTop = consoleElement.scrollHeight;
      }

      // Keyboard controls
      const keys = {
        w: false,
        a: false,
        s: false,
        d: false,
        up: false,
        left: false,
        down: false,
        right: false,
        e: false,
        q: false,
        z: false,
        x: false,
        c: false,
        shift: false,
        space: false,
        r: false,
        backtick: false,
        esc: false
      };
      window.addEventListener('keydown', (event) => {
        if (event.key === 'w' || event.key === 'W') keys.w = true;
        if (event.key === 'a' || event.key === 'A') keys.a = true;
        if (event.key === 's' || event.key === 'S') keys.s = true;
        if (event.key === 'd' || event.key === 'D') keys.d = true;
        if (event.key === 'ArrowUp') keys.up = true;
        if (event.key === 'ArrowLeft') keys.left = true;
        if (event.key === 'ArrowDown') keys.down = true;
        if (event.key === 'ArrowRight') keys.right = true;
        if (event.key === 'e' || event.key === 'E') keys.e = true;
        if (event.key === 'q' || event.key === 'Q') keys.q = true;
        if (event.key === 'z' || event.key === 'Z') keys.z = true;
        if (event.key === 'x' || event.key === 'X') keys.x = true;
        if (event.key === 'c' || event.key === 'C') keys.c = true;
        if (event.key === 'Shift') keys.shift = true;
        if (event.key === ' ') keys.space = true;
        if (event.key === 'r' || event.key === 'R') keys.r = true;
        if (event.key === '`') keys.backtick = true;
        if (event.key === 'Escape') keys.esc = true;
        lastInputTime = Date.now();
      });
      window.addEventListener('keyup', (event) => {
        if (event.key === 'w' || event.key === 'W') keys.w = false;
        if (event.key === 'a' || event.key === 'A') keys.a = false;
        if (event.key === 's' || event.key === 'S') keys.s = false;
        if (event.key === 'd' || event.key === 'D') keys.d = false;
        if (event.key === 'ArrowUp') keys.up = false;
        if (event.key === 'ArrowLeft') keys.left = false;
        if (event.key === 'ArrowDown') keys.down = false;
        if (event.key === 'ArrowRight') keys.right = false;
        if (event.key === 'e' || event.key === 'E') keys.e = false;
        if (event.key === 'q' || event.key === 'Q') keys.q = false;
        if (event.key === 'z' || event.key === 'Z') keys.z = false;
        if (event.key === 'x' || event.key === 'X') keys.x = false;
        if (event.key === 'c' || event.key === 'C') keys.c = false;
        if (event.key === 'Shift') keys.shift = false;
        if (event.key === ' ') keys.space = false;
        if (event.key === 'r' || event.key === 'R') keys.r = false;
        if (event.key === '`') keys.backtick = false;
        if (event.key === 'Escape') keys.esc = false;
      });

      // Button controls
      const boostBtn = document.getElementById('boostBtn');
      const fireBtn = document.getElementById('fireBtn');
      const destroyBtn = document.getElementById('destroyBtn');
      const lightspeedBtn = document.getElementById('lightspeedBtn');
      const endGameBtn = document.getElementById('endGameBtn');
      let isBoosting = false;
      boostBtn.addEventListener('mousedown', () => { isBoosting = true; lastInputTime = Date.now(); });
      boostBtn.addEventListener('mouseup', () => { isBoosting = false; });
      boostBtn.addEventListener('touchstart', () => { isBoosting = true; lastInputTime = Date.now(); });
      boostBtn.addEventListener('touchend', () => { isBoosting = false; });
      fireBtn.addEventListener('click', () => { fireProjectiles(); lastInputTime = Date.now(); });
      destroyBtn.addEventListener('click', () => { destroyAllDrones(); lastInputTime = Date.now(); });
      lightspeedBtn.addEventListener('click', () => { activateLightspeed(); lastInputTime = Date.now(); });
      endGameBtn.addEventListener('click', () => { endGame(); lastInputTime = Date.now(); });

      // Lightspeed state
      let isLightspeed = false;
      let lightspeedEndTime = 0;
      let lightspeedCooldownEnd = 0;

      // Destroy all state
      let canDestroyAll = true;

      // Tilt controls
      let tiltLR = 0;
      window.addEventListener('deviceorientation', (event) => {
        tiltLR = event.gamma ? event.gamma / 90 : 0;
        lastInputTime = Date.now();
      }, true);

      // Particle system for player trail
      const particlesGeometry = new THREE.BufferGeometry();
      const particleCount = 200;
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = 0;
        positions[i * 3 + 1] = 0;
        positions[i * 3 + 2] = 0;
        colors[i * 3] = 1;
        colors[i * 3 + 1] = 0;
        colors[i * 3 + 2] = 0;
      }
      particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      const particleMaterial = new THREE.PointsMaterial({
        size: 0.1,
        vertexColors: true,
        transparent: true,
        opacity: 0.8
      });
      const particles = new THREE.Points(particlesGeometry, particleMaterial);
      scene.add(particles);

      // Stars - more stars for better space feel
      const starGeometry = new THREE.BufferGeometry();
      const starCount = 2000;
      const starPositions = new Float32Array(starCount * 3);
      for (let i = 0; i < starCount; i++) {
        starPositions[i * 3] = (Math.random() - 0.5) * 2000;
        starPositions[i * 3 + 1] = (Math.random() - 0.5) * 2000;
        starPositions[i * 3 + 2] = (Math.random() - 0.5) * 2000;
      }
      starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
      const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5 });
      const stars = new THREE.Points(starGeometry, starMaterial);
      scene.add(stars);

      // Glowing stars
      const glowStarGeometry = new THREE.BufferGeometry();
      const glowStarCount = 100;
      const glowStarPositions = new Float32Array(glowStarCount * 3);
      for (let i = 0; i < glowStarCount; i++) {
        glowStarPositions[i * 3] = (Math.random() - 0.5) * 1500;
        glowStarPositions[i * 3 + 1] = (Math.random() - 0.5) * 1500;
        glowStarPositions[i * 3 + 2] = (Math.random() - 0.5) * 1500;
      }
      glowStarGeometry.setAttribute('position', new THREE.BufferAttribute(glowStarPositions, 3));
      const glowStarMaterial = new THREE.PointsMaterial({
        color: 0x00ffff,
        size: 2.0,
        transparent: true,
        opacity: 0.7
      });
      const glowStars = new THREE.Points(glowStarGeometry, glowStarMaterial);
      scene.add(glowStars);

      // Nebula effects
      const nebulaGeometry = new THREE.BufferGeometry();
      const nebulaCount = 20;
      const nebulaPositions = new Float32Array(nebulaCount * 3);
      const nebulaSizes = new Float32Array(nebulaCount);
      const nebulaColors = new Float32Array(nebulaCount * 3);
      for (let i = 0; i < nebulaCount; i++) {
        nebulaPositions[i * 3] = (Math.random() - 0.5) * 1000;
        nebulaPositions[i * 3 + 1] = (Math.random() - 0.5) * 1000;
        nebulaPositions[i * 3 + 2] = (Math.random() - 0.5) * 1000;
        nebulaSizes[i] = Math.random() * 50 + 20;
        
        const hue = Math.random();
        const color = new THREE.Color().setHSL(hue, 1, 0.5);
        nebulaColors[i * 3] = color.r;
        nebulaColors[i * 3 + 1] = color.g;
        nebulaColors[i * 3 + 2] = color.b;
      }
      nebulaGeometry.setAttribute('position', new THREE.BufferAttribute(nebulaPositions, 3));
      nebulaGeometry.setAttribute('size', new THREE.BufferAttribute(nebulaSizes, 1));
      nebulaGeometry.setAttribute('color', new THREE.BufferAttribute(nebulaColors, 3));
      const nebulaMaterial = new THREE.PointsMaterial({
        size: 1,
        vertexColors: true,
        transparent: true,
        opacity: 0.3,
        blending: THREE.AdditiveBlending
      });
      const nebulas = new THREE.Points(nebulaGeometry, nebulaMaterial);
      scene.add(nebulas);

      // Planets with rings
      const planets = [];
      for (let i = 0; i < 8; i++) {
        const planetGroup = new THREE.Group();
        const geometry = new THREE.IcosahedronGeometry(Math.random() * 8 + 3, 3);
        const material = new THREE.MeshBasicMaterial({ 
          color: new THREE.Color().setHSL(Math.random(), 1, 0.5),
          wireframe: true
        });
        const planet = new THREE.Mesh(geometry, material);
        planetGroup.add(planet);
        if (Math.random() > 0.3) {
          const ringGeometry = new THREE.TorusGeometry(Math.random() * 3 + 8, 0.5, 4, 16);
          const ringMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x00ffff,
            wireframe: true,
            transparent: true,
            opacity: 0.7
          });
          const ring = new THREE.Mesh(ringGeometry, ringMaterial);
          ring.rotation.x = Math.PI / 2;
          planetGroup.add(ring);
        }
        planetGroup.position.set(
          (Math.random() - 0.5) * 500,
          (Math.random() - 0.5) * 500,
          (Math.random() - 0.5) * 1000 - 500
        );
        scene.add(planetGroup);
        planets.push(planetGroup);
      }

      // Drone swarms - make them more visible
      const drones = [];
      function createDrone() {
        const droneGroup = new THREE.Group();
        const coreGeometry = new THREE.IcosahedronGeometry(0.5, 1);
        const coreMaterial = new THREE.MeshBasicMaterial({ 
          color: 0xff0000,
          wireframe: true
        });
        const core = new THREE.Mesh(coreGeometry, coreMaterial);
        droneGroup.add(core);
        for (let i = 0; i < 4; i++) {
          const spikeGeometry = new THREE.ConeGeometry(0.2, 0.6, 4);
          const spike = new THREE.Mesh(spikeGeometry, coreMaterial);
          spike.position.set(
            Math.random() * 0.6 - 0.3,
            Math.random() * 0.6 - 0.3,
            Math.random() * 0.6 - 0.3
          );
          spike.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);
          droneGroup.add(spike);
        }
        return droneGroup;
      }
      function spawnDrone() {
        const drone = createDrone();
        drone.position.set(
          (Math.random() - 0.5) * trackRadius * 2,
          (Math.random() - 0.5) * trackRadius * 2,
          playerPosition.z - 30 - Math.random() * 20
        );
        scene.add(drone);
        drones.push(drone);
        enemiesElement.textContent = drones.length;
      }

      // Projectiles and missiles - make them more visible
      const projectiles = [];
      const missileGeometry = new THREE.SphereGeometry(0.2, 8, 8);
      const missileMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
      let lastAutoFire = 0;
      function fireProjectiles(manual = false) {
        for (let i = -1; i <= 1; i++) {
          const projectile = new THREE.Mesh(missileGeometry, missileMaterial);
          projectile.position.copy(playerPosition);
          projectile.velocity = new THREE.Vector3(i * 0.05, 0, -0.5);
          scene.add(projectile);
          projectiles.push(projectile);
        }
        if (drones.length > 0) {
          const missile = new THREE.Mesh(missileGeometry, missileMaterial);
          missile.position.copy(playerPosition);
          missile.target = drones.reduce((closest, drone) => {
            const dist = drone.position.distanceTo(playerPosition);
            return !closest || dist < closest.dist ? { drone, dist } : closest;
          }, null).drone;
          missile.velocity = new THREE.Vector3(0, 0, -0.7);
          scene.add(missile);
          projectiles.push(missile);
        }
        if (manual) logConsole('Fired multishot and missile!');
      }

      // Destroy all drones
      function destroyAllDrones() {
        if (!canDestroyAll) return;
        drones.forEach(drone => {
          score += 10;
          dronesKilled++;
          scoreElement.textContent = score;
          scene.remove(drone);
          logConsole('Drone destroyed!');
        });
        drones.length = 0;
        enemiesElement.textContent = drones.length;
        canDestroyAll = false;
        destroyBtn.disabled = true;
      }

      // Lightspeed
      function activateLightspeed() {
        const now = Date.now();
        if (now < lightspeedCooldownEnd) return;
        isLightspeed = true;
        lightspeedEndTime = now + 10000;
        lightspeedCooldownEnd = now + 20000;
        lightspeedBtn.disabled = true;
        particleMaterial.size = 0.3;
        glitchPass.enabled = true;
        logConsole('Lightspeed activated!');
      }

      // End game
      function endGame() {
        const timePlayed = (Date.now() - startTime) / 1000;
        const finalRatio = (score / timePlayed) || 0;
        scoreTimeRatios.push(finalRatio);
        const medianRatio = scoreTimeRatios.length ? scoreTimeRatios.sort((a, b) => a - b)[Math.floor(scoreTimeRatios.length / 2)] : 0;
        const highScores = JSON.parse(localStorage.getItem('galaxyCraftScores') || '[]');
        highScores.push({ score, time: timePlayed, ratio: medianRatio });
        highScores.sort((a, b) => b.score - a.score);
        highScores.splice(5); // Keep top 5
        localStorage.setItem('galaxyCraftScores', JSON.stringify(highScores));
        let scoreText = `Game Over!\nDrones Killed: ${dronesKilled}\nTime Played: ${timePlayed.toFixed(2)}s\nFinal Score: ${score}\nMedian Score/Time Ratio: ${medianRatio.toFixed(2)}\n\nHigh Scores:\n`;
        highScores.forEach((s, i) => {
          scoreText += `${i + 1}. Score: ${s.score}, Time: ${s.time.toFixed(2)}s, Ratio: ${s.ratio.toFixed(2)}\n`;
        });
        alert(scoreText);
        score = 0;
        dronesKilled = 0;
        health = 100;
        shield = 100;
        scoreTimeRatios = [];
        startTime = Date.now();
        wave = 1;
        scoreElement.textContent = score;
        healthElement.textContent = health;
        shieldElement.textContent = shield;
        waveElement.textContent = wave;
        canDestroyAll = true;
        destroyBtn.disabled = false;
        logConsole('Game reset!');
      }

      // Track segment types
      const segmentTypes = [
        () => createStraightSegment(),
        () => createCurveSegment(1),
        () => createCurveSegment(-1)
      ];

      function createStraightSegment() {
        const shape = new THREE.Shape();
        const sides = 8; // More sides for smoother tunnel
        const radius = trackRadius;
        for (let i = 0; i < sides; i++) {
          const angle = (i / sides) * Math.PI * 2;
          shape.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
        }
        shape.closePath();
        const extrudeSettings = { depth: segmentLength, bevelEnabled: false };
        const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        const material = new THREE.MeshBasicMaterial({ 
          color: 0x00ffff, 
          side: THREE.DoubleSide,
          wireframe: true,
          transparent: true,
          opacity: 0.7
        });
        const segment = new THREE.Mesh(geometry, material);
        segment.rotation.x = Math.PI / 2;
        return segment;
      }

      function createCurveSegment(direction) {
        const path = new THREE.CatmullRomCurve3([
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(direction * trackRadius * 2, 0, segmentLength / 2),
          new THREE.Vector3(0, 0, segmentLength)
        ]);
        const geometry = new THREE.TubeGeometry(path, 50, trackRadius, 24, false);
        const material = new THREE.MeshBasicMaterial({ 
          color: 0xff00ff, 
          side: THREE.DoubleSide,
          wireframe: true,
          transparent: true,
          opacity: 0.7
        });
        const segment = new THREE.Mesh(geometry, material);
        return segment;
      }

      // Initialize track
      function initTrack() {
        for (let i = 0; i < segmentCount; i++) {
          spawnSegment();
        }
        logConsole('Wave 1 started!');
      }

      function spawnSegment() {
        const segmentType = segmentTypes[Math.floor(Math.random() * segmentTypes.length)];
        const segment = segmentType();
        segment.position.z = currentZ - segmentLength * segments.length;
        scene.add(segment);
        segments.push(segment);
        currentZ -= segmentLength;

        if (segments.length > segmentCount) {
          const oldSegment = segments.shift();
          scene.remove(oldSegment);
          oldSegment.geometry.dispose();
          oldSegment.material.dispose();
        }
        wave++;
        waveElement.textContent = wave;
        canDestroyAll = true;
        destroyBtn.disabled = false;
        logConsole(`Wave ${wave} started!`);
      }

      // Load spaceship - make it more visible
      function loadSpaceship() {
        spaceship = new THREE.Group();
        const bodyGeometry = new THREE.ConeGeometry(0.5, 1.5, 8);
        const bodyMaterial = new THREE.MeshBasicMaterial({ 
          color: 0x00ffff,
          wireframe: true
        });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.rotation.x = Math.PI / 2;
        spaceship.add(body);

        const wingGeometry = new THREE.CylinderGeometry(0.1, 0.3, 1.2, 4);
        const wing1 = new THREE.Mesh(wingGeometry, bodyMaterial);
        wing1.position.set(0.6, 0, 0);
        wing1.rotation.z = Math.PI / 2;
        spaceship.add(wing1);
        const wing2 = wing1.clone();
        wing2.position.set(-0.6, 0, 0);
        spaceship.add(wing2);

        const cockpitGeometry = new THREE.SphereGeometry(0.3, 8, 8);
        const cockpit = new THREE.Mesh(cockpitGeometry, bodyMaterial);
        cockpit.position.set(0, 0.2, 0.6);
        spaceship.add(cockpit);

        // Add engine glow
        const engineGlowGeometry = new THREE.SphereGeometry(0.2, 8, 8);
        const engineGlowMaterial = new THREE.MeshBasicMaterial({
          color: 0xff0000,
          transparent: true,
          opacity: 0.7
        });
        const engineGlow = new THREE.Mesh(engineGlowGeometry, engineGlowMaterial);
        engineGlow.position.set(0, 0, -0.8);
        spaceship.add(engineGlow);

        scene.add(spaceship);
      }

      // Rainbow effect with neon colors
      let hue = 0;
      function updateRainbowEffect() {
        hue = (hue + 0.01) % 1;
        const color = new THREE.Color().setHSL(hue, 1, 0.5);
        
        // Update HUD colors
        document.getElementById('hud').style.color = `hsl(${hue * 360}, 100%, 50%)`;
        document.getElementById('hud').style.borderColor = `hsl(${hue * 360}, 100%, 50%)`;
        document.getElementById('hud').style.boxShadow = `0 0 10px hsl(${hue * 360}, 100%, 50%)`;
        
        document.getElementById('console').style.color = `hsl(${hue * 360}, 100%, 50%)`;
        document.getElementById('console').style.borderColor = `hsl(${hue * 360}, 100%, 50%)`;
        document.getElementById('console').style.boxShadow = `0 0 10px hsl(${hue * 360}, 100%, 50%)`;
        
        document.getElementById('crosshair').style.borderColor = `hsl(${hue * 360}, 100%, 50%)`;
        document.getElementById('crosshair').style.boxShadow = `0 0 10px hsl(${hue * 360}, 100%, 50%)`;
        
        const buttons = document.querySelectorAll('button');
        buttons.forEach(btn => {
          btn.style.color = `hsl(${hue * 360}, 100%, 50%)`;
          btn.style.borderColor = `hsl(${hue * 360}, 100%, 50%)`;
          btn.style.boxShadow = `0 0 10px hsl(${hue * 360}, 100%, 50%)`;
        });

        // Update track and ship colors
        segments.forEach(segment => {
          segment.material.color.set(color);
        });
        if (spaceship) {
          spaceship.children.forEach(child => {
            if (child.material) {
              child.material.color.set(color);
            }
          });
        }
        const colors = particlesGeometry.attributes.color.array;
        for (let i = 0; i < particleCount; i++) {
          const particleHue = (hue + i / particleCount) % 1;
          const particleColor = new THREE.Color().setHSL(particleHue, 1, 0.5);
          colors[i * 3] = particleColor.r;
          colors[i * 3 + 1] = particleColor.g;
          colors[i * 3 + 2] = particleColor.b;
        }
        particlesGeometry.attributes.color.needsUpdate = true;
        projectiles.forEach(projectile => {
          projectile.material.color.set(color);
        });
      }

      // Update particles
      function updateParticles() {
        const positions = particlesGeometry.attributes.position.array;
        for (let i = 0; i < particleCount; i++) {
          positions[i * 3] += (Math.random() - 0.5) * 0.1;
          positions[i * 3 + 1] += (Math.random() - 0.5) * 0.1;
          positions[i * 3 + 2] -= isLightspeed ? 0.4 : 0.2;
          if (positions[i * 3 + 2] < playerPosition.z - 5) {
            positions[i * 3] = playerPosition.x;
            positions[i * 3 + 1] = playerPosition.y;
            positions[i * 3 + 2] = playerPosition.z;
          }
        }
        particlesGeometry.attributes.position.needsUpdate = true;
      }

      // Update drones
      function updateDrones() {
        const spawnChance = 0.03 + (wave - 1) * 0.005;
        if (Math.random() < spawnChance) {
          spawnDrone();
        }
        const toRemove = [];
        drones.forEach((drone, index) => {
          // Make drones follow the track path
          const segmentIndex = Math.floor((playerPosition.z - drone.position.z) / segmentLength);
          if (segmentIndex >= 0 && segmentIndex < segments.length) {
            const segment = segments[segmentIndex];
            const targetPos = new THREE.Vector3(
              segment.position.x,
              segment.position.y,
              drone.position.z
            );
            drone.position.lerp(targetPos, 0.01);
          }
          
          drone.position.x += (Math.random() - 0.5) * 0.05;
          drone.position.y += (Math.random() - 0.5) * 0.05;
          drone.rotation.y += 0.1;

          const screenPos = drone.position.clone().project(camera);
          const screenX = (screenPos.x + 1) * window.innerWidth / 2;
          const screenY = (-screenPos.y + 1) * window.innerHeight / 2;
          const centerX = window.innerWidth / 2;
          const centerY = window.innerHeight / 2;
          const distance = Math.sqrt((screenX - centerX) ** 2 + (screenY - centerY) ** 2);

          if (distance < 25) {
            toRemove.push(index);
            score += 10;
            dronesKilled++;
            scoreElement.textContent = score;
            logConsole('Drone destroyed!');
            camera.position.x += (Math.random() - 0.5) * 0.2; // Screen shake
            camera.position.y += (Math.random() - 0.5) * 0.2;
          }

          if (drone.position.z > playerPosition.z + 10) {
            toRemove.push(index);
          }

          if (drone.position.distanceTo(playerPosition) < 1) {
            health = Math.max(0, health - (shield > 0 ? 0 : 5));
            shield = Math.max(0, shield - 5);
            healthElement.textContent = health;
            shieldElement.textContent = shield;
            if (health <= 0) {
              endGame();
            }
          }
        });

        toRemove.reverse().forEach(index => {
          scene.remove(drones[index]);
          drones.splice(index, 1);
        });
        enemiesElement.textContent = drones.length;
      }

      // Update projectiles
      function updateProjectiles() {
        const toRemove = [];
        projectiles.forEach((projectile, index) => {
          if (projectile.target) {
            const direction = new THREE.Vector3().subVectors(projectile.target.position, projectile.position).normalize().multiplyScalar(0.1);
            projectile.velocity.add(direction);
            projectile.velocity.clampLength(0, 0.7);
          }
          projectile.position.add(projectile.velocity);
          projectile.rotation.x += 0.1;
          projectile.rotation.y += 0.1;

          if (projectile.position.z < playerPosition.z - 50) {
            toRemove.push(index);
          }

          drones.forEach((drone, droneIndex) => {
            if (projectile.position.distanceTo(drone.position) < 1) {
              toRemove.push(index);
              scene.remove(drones[droneIndex]);
              drones.splice(droneIndex, 1);
              score += 10;
              dronesKilled++;
              scoreElement.textContent = score;
              logConsole('Drone destroyed by missile!');
            }
          });
        });

        toRemove.reverse().forEach(index => {
          scene.remove(projectiles[index]);
          projectiles.splice(index, 1);
        });
      }

      // Update track
      function updateTrack() {
        if (playerPosition.z < segments[segments.length - 1].position.z + segmentLength * 0.5) {
          spawnSegment();
        }
      }

      // Update lightspeed
      function updateLightspeed() {
        const now = Date.now();
        if (isLightspeed && now > lightspeedEndTime) {
          isLightspeed = false;
          particleMaterial.size = 0.1;
          glitchPass.enabled = false;
          logConsole('Lightspeed ended!');
        }
        if (now > lightspeedCooldownEnd) {
          lightspeedBtn.disabled = false;
        }
      }

      // Update auto play
      function updateAutoPlay() {
        if (Date.now() - lastInputTime > 10000) {
          if (!autoPlay) {
            autoPlay = true;
            logConsole('Auto play activated!');
          }
          if (Math.random() < 0.1) {
            playerVelocity.x += (Math.random() - 0.5) * 0.01;
            playerVelocity.y += (Math.random() - 0.5) * 0.01;
          }
          if (Math.random() < 0.05) {
            fireProjectiles();
          }
          if (Math.random() < 0.01) {
            activateLightspeed();
          }
        } else {
          if (autoPlay) {
            autoPlay = false;
            logConsole('Auto play deactivated!');
          }
        }
      }

      // Update score/time ratio
      function updateScoreTimeRatio() {
        const now = Date.now();
        if (now - lastRatioUpdate > 5000) {
          const timePlayed = (now - startTime) / 1000;
          const ratio = (score / timePlayed) || 0;
          scoreTimeRatios.push(ratio);
          lastRatioUpdate = now;
        }
      }

      // Initialize game
      loadSpaceship();
      initTrack();

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        delta += clock.getDelta();
        if (delta > interval) {
          updateGame();
          delta = delta % interval;
        }
        composer.render();
      }

      function updateGame() {
        // Update player position
        const speed = isLightspeed ? 0.4 : (isBoosting ? 0.3 : 0.2);
        const turnSpeed = isLightspeed ? 0.02 : 0.04;
        playerVelocity.z = -speed;
        playerVelocity.x += (keys.a || keys.left) ? -turnSpeed : 0;
        playerVelocity.x += (keys.d || keys.right) ? turnSpeed : 0;
        playerVelocity.y += (keys.s || keys.down) ? -turnSpeed : 0;
        playerVelocity.y += (keys.w || keys.up) ? turnSpeed : 0;
        playerVelocity.x += tiltLR * turnSpeed;
        playerVelocity.multiplyScalar(0.98);
        playerPosition.add(playerVelocity);

        // Update player tilt and pitch
        playerTilt = THREE.MathUtils.lerp(playerTilt, playerVelocity.x * 2, 0.1);
        playerPitch = THREE.MathUtils.lerp(playerPitch, playerVelocity.y * 2, 0.1);
        if (keys.q) barrelRoll += 0.1;
        if (keys.e) barrelRoll -= 0.1;
        if (keys.z) turn360 += 0.05;
        if (keys.x) turn360 -= 0.05;
        if (keys.c) {
          barrelRoll = 0;
          turn360 = 0;
        }

        // Update spaceship rotation
        if (spaceship) {
          spaceship.position.copy(playerPosition);
          spaceship.rotation.set(playerPitch, playerTilt, barrelRoll + turn360);
        }

        // Update camera position
        camera.position.x = THREE.MathUtils.lerp(camera.position.x, playerPosition.x, 0.1);
        camera.position.y = THREE.MathUtils.lerp(camera.position.y, playerPosition.y + 1, 0.1);
        camera.position.z = playerPosition.z + 3;
        camera.lookAt(playerPosition.x, playerPosition.y, playerPosition.z - 5);

        // Update game elements
        updateParticles();
        updateDrones();
        updateProjectiles();
        updateTrack();
        updateLightspeed();
        updateAutoPlay();
        updateScoreTimeRatio();
        updateRainbowEffect();

        // Auto fire
        const now = Date.now();
        if (now - lastAutoFire > 1000 && autoPlay) {
          fireProjectiles();
          lastAutoFire = now;
        }

        // Update HUD
        dronesElement.textContent = `${dronesKilled}/3`;
      }

      // Handle window resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      });

      // Start animation
      animate();
    </script>
  </body>
</html>